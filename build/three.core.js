/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '176';

/**
 * Represents mouse buttons and interaction types in context of controls.
 *
 * @type {ConstantsMouse}
 * @constant
 */
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };

/**
 * Represents touch interaction types in context of controls.
 *
 * @type {ConstantsTouch}
 * @constant
 */
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };

/**
 * Disables face culling.
 *
 * @type {number}
 * @constant
 */
const CullFaceNone = 0;

/**
 * Culls back faces.
 *
 * @type {number}
 * @constant
 */
const CullFaceBack = 1;

/**
 * Culls front faces.
 *
 * @type {number}
 * @constant
 */
const CullFaceFront = 2;

/**
 * Culls both front and back faces.
 *
 * @type {number}
 * @constant
 */
const CullFaceFrontBack = 3;

/**
 * Gives unfiltered shadow maps - fastest, but lowest quality.
 *
 * @type {number}
 * @constant
 */
const BasicShadowMap = 0;

/**
 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
 *
 * @type {number}
 * @constant
 */
const PCFShadowMap = 1;

/**
 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
 * better soft shadows especially when using low-resolution shadow maps.
 *
 * @type {number}
 * @constant
 */
const PCFSoftShadowMap = 2;

/**
 * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
 * When using VSMShadowMap all shadow receivers will also cast shadows.
 *
 * @type {number}
 * @constant
 */
const VSMShadowMap = 3;

/**
 * Only front faces are rendered.
 *
 * @type {number}
 * @constant
 */
const FrontSide = 0;

/**
 * Only back faces are rendered.
 *
 * @type {number}
 * @constant
 */
const BackSide = 1;

/**
 * Both front and back faces are rendered.
 *
 * @type {number}
 * @constant
 */
const DoubleSide = 2;

/**
 * No blending is performed which effectively disables
 * alpha transparency.
 *
 * @type {number}
 * @constant
 */
const NoBlending = 0;

/**
 * The default blending.
 *
 * @type {number}
 * @constant
 */
const NormalBlending = 1;

/**
 * Represents additive blending.
 *
 * @type {number}
 * @constant
 */
const AdditiveBlending = 2;

/**
 * Represents subtractive blending.
 *
 * @type {number}
 * @constant
 */
const SubtractiveBlending = 3;

/**
 * Represents multiply blending.
 *
 * @type {number}
 * @constant
 */
const MultiplyBlending = 4;

/**
 * Represents custom blending.
 *
 * @type {number}
 * @constant
 */
const CustomBlending = 5;

/**
 * A `source + destination` blending equation.
 *
 * @type {number}
 * @constant
 */
const AddEquation = 100;

/**
 * A `source - destination` blending equation.
 *
 * @type {number}
 * @constant
 */
const SubtractEquation = 101;

/**
 * A `destination - source` blending equation.
 *
 * @type {number}
 * @constant
 */
const ReverseSubtractEquation = 102;

/**
 * A blend equation that uses the minimum of source and destination.
 *
 * @type {number}
 * @constant
 */
const MinEquation = 103;

/**
 * A blend equation that uses the maximum of source and destination.
 *
 * @type {number}
 * @constant
 */
const MaxEquation = 104;

/**
 * Multiplies all colors by `0`.
 *
 * @type {number}
 * @constant
 */
const ZeroFactor = 200;

/**
 * Multiplies all colors by `1`.
 *
 * @type {number}
 * @constant
 */
const OneFactor = 201;

/**
 * Multiplies all colors by the source colors.
 *
 * @type {number}
 * @constant
 */
const SrcColorFactor = 202;

/**
 * Multiplies all colors by `1` minus each source color.
 *
 * @type {number}
 * @constant
 */
const OneMinusSrcColorFactor = 203;

/**
 * Multiplies all colors by the source alpha value.
 *
 * @type {number}
 * @constant
 */
const SrcAlphaFactor = 204;

/**
 * Multiplies all colors by 1 minus the source alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusSrcAlphaFactor = 205;

/**
 * Multiplies all colors by the destination alpha value.
 *
 * @type {number}
 * @constant
 */
const DstAlphaFactor = 206;

/**
 * Multiplies all colors by `1` minus the destination alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusDstAlphaFactor = 207;

/**
 * Multiplies all colors by the destination color.
 *
 * @type {number}
 * @constant
 */
const DstColorFactor = 208;

/**
 * Multiplies all colors by `1` minus each destination color.
 *
 * @type {number}
 * @constant
 */
const OneMinusDstColorFactor = 209;

/**
 * Multiplies the RGB colors by the smaller of either the source alpha
 * value or the value of `1` minus the destination alpha value. The alpha
 * value is multiplied by `1`.
 *
 * @type {number}
 * @constant
 */
const SrcAlphaSaturateFactor = 210;

/**
 * Multiplies all colors by a constant color.
 *
 * @type {number}
 * @constant
 */
const ConstantColorFactor = 211;

/**
 * Multiplies all colors by `1` minus a constant color.
 *
 * @type {number}
 * @constant
 */
const OneMinusConstantColorFactor = 212;

/**
 * Multiplies all colors by a constant alpha value.
 *
 * @type {number}
 * @constant
 */
const ConstantAlphaFactor = 213;

/**
 * Multiplies all colors by 1 minus a constant alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusConstantAlphaFactor = 214;

/**
 * Never pass.
 *
 * @type {number}
 * @constant
 */
const NeverDepth = 0;

/**
 * Always pass.
 *
 * @type {number}
 * @constant
 */
const AlwaysDepth = 1;

/**
 * Pass if the incoming value is less than the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const LessDepth = 2;

/**
 * Pass if the incoming value is less than or equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const LessEqualDepth = 3;

/**
 * Pass if the incoming value equals the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const EqualDepth = 4;

/**
 * Pass if the incoming value is greater than or equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const GreaterEqualDepth = 5;

/**
 * Pass if the incoming value is greater than the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const GreaterDepth = 6;

/**
 * Pass if the incoming value is not equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const NotEqualDepth = 7;

/**
 * Multiplies the environment map color with the surface color.
 *
 * @type {number}
 * @constant
 */
const MultiplyOperation = 0;

/**
 * Uses reflectivity to blend between the two colors.
 *
 * @type {number}
 * @constant
 */
const MixOperation = 1;

/**
 * Adds the two colors.
 *
 * @type {number}
 * @constant
 */
const AddOperation = 2;

/**
 * No tone mapping is applied.
 *
 * @type {number}
 * @constant
 */
const NoToneMapping = 0;

/**
 * Linear tone mapping.
 *
 * @type {number}
 * @constant
 */
const LinearToneMapping = 1;

/**
 * Reinhard tone mapping.
 *
 * @type {number}
 * @constant
 */
const ReinhardToneMapping = 2;

/**
 * Cineon tone mapping.
 *
 * @type {number}
 * @constant
 */
const CineonToneMapping = 3;

/**
 * ACES Filmic tone mapping.
 *
 * @type {number}
 * @constant
 */
const ACESFilmicToneMapping = 4;

/**
 * Custom tone mapping.
 *
 * Expects a custom implementation by modifying shader code of the material's fragment shader.
 *
 * @type {number}
 * @constant
 */
const CustomToneMapping = 5;

/**
 * AgX tone mapping.
 *
 * @type {number}
 * @constant
 */
const AgXToneMapping = 6;

/**
 * Neutral tone mapping.
 *
 * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
 *
 * @type {number}
 * @constant
 */
const NeutralToneMapping = 7;

/**
 * The skinned mesh shares the same world space as the skeleton.
 *
 * @type {string}
 * @constant
 */
const AttachedBindMode = 'attached';

/**
 * The skinned mesh does not share the same world space as the skeleton.
 * This is useful when a skeleton is shared across multiple skinned meshes.
 *
 * @type {string}
 * @constant
 */
const DetachedBindMode = 'detached';

/**
 * Maps textures using the geometry's UV coordinates.
 *
 * @type {number}
 * @constant
 */
const UVMapping = 300;

/**
 * Reflection mapping for cube textures.
 *
 * @type {number}
 * @constant
 */
const CubeReflectionMapping = 301;

/**
 * Refraction mapping for cube textures.
 *
 * @type {number}
 * @constant
 */
const CubeRefractionMapping = 302;

/**
 * Reflection mapping for equirectangular textures.
 *
 * @type {number}
 * @constant
 */
const EquirectangularReflectionMapping = 303;

/**
 * Refraction mapping for equirectangular textures.
 *
 * @type {number}
 * @constant
 */
const EquirectangularRefractionMapping = 304;

/**
 * Reflection mapping for PMREM textures.
 *
 * @type {number}
 * @constant
 */
const CubeUVReflectionMapping = 306;

/**
 * The texture will simply repeat to infinity.
 *
 * @type {number}
 * @constant
 */
const RepeatWrapping = 1000;

/**
 * The last pixel of the texture stretches to the edge of the mesh.
 *
 * @type {number}
 * @constant
 */
const ClampToEdgeWrapping = 1001;

/**
 * The texture will repeats to infinity, mirroring on each repeat.
 *
 * @type {number}
 * @constant
 */
const MirroredRepeatWrapping = 1002;

/**
 * Returns the value of the texture element that is nearest (in Manhattan distance)
 * to the specified texture coordinates.
 *
 * @type {number}
 * @constant
 */
const NearestFilter = 1003;

/**
 * Chooses the mipmap that most closely matches the size of the pixel being textured
 * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
 * to produce a texture value.
 *
 * @type {number}
 * @constant
 */
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004; // legacy

/**
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and
 * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
 * The final texture value is a weighted average of those two values.
 *
 * @type {number}
 * @constant
 */
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005; // legacy

/**
 * Returns the weighted average of the four texture elements that are closest to the specified
 * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
 * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
 *
 * @type {number}
 * @constant
 */
const LinearFilter = 1006;

/**
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
 * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
 * center of the pixel) to produce a texture value.
 *
 * @type {number}
 * @constant
 */
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007; // legacy

/**
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
 * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
 * is a weighted average of those two values.
 *
 * @type {number}
 * @constant
 */
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008; // legacy

/**
 * An unsigned byte data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedByteType = 1009;

/**
 * A byte data type for textures.
 *
 * @type {number}
 * @constant
 */
const ByteType = 1010;

/**
 * A short data type for textures.
 *
 * @type {number}
 * @constant
 */
const ShortType = 1011;

/**
 * An unsigned short data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShortType = 1012;

/**
 * An int data type for textures.
 *
 * @type {number}
 * @constant
 */
const IntType = 1013;

/**
 * An unsigned int data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedIntType = 1014;

/**
 * A float data type for textures.
 *
 * @type {number}
 * @constant
 */
const FloatType = 1015;

/**
 * A half float data type for textures.
 *
 * @type {number}
 * @constant
 */
const HalfFloatType = 1016;

/**
 * An unsigned short 4_4_4_4 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShort4444Type = 1017;

/**
 * An unsigned short 5_5_5_1 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShort5551Type = 1018;

/**
 * An unsigned int 24_8 data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedInt248Type = 1020;

/**
 * An unsigned int 5_9_9_9 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedInt5999Type = 35902;

/**
 * Discards the red, green and blue components and reads just the alpha component.
 *
 * @type {number}
 * @constant
 */
const AlphaFormat = 1021;

/**
 * Discards the alpha component and reads the red, green and blue component.
 *
 * @type {number}
 * @constant
 */
const RGBFormat = 1022;

/**
 * Reads the red, green, blue and alpha components.
 *
 * @type {number}
 * @constant
 */
const RGBAFormat = 1023;

/**
 * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
 *
 * @type {number}
 * @constant
 */
const DepthFormat = 1026;

/**
 * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
 * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
 *
 * @type {number}
 * @constant
 */
const DepthStencilFormat = 1027;

/**
 * Discards the green, blue and alpha components and reads just the red component.
 *
 * @type {number}
 * @constant
 */
const RedFormat = 1028;

/**
 * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RedIntegerFormat = 1029;

/**
 * Discards the alpha, and blue components and reads the red, and green components.
 *
 * @type {number}
 * @constant
 */
const RGFormat = 1030;

/**
 * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RGIntegerFormat = 1031;

/**
 * Discards the alpha component and reads the red, green and blue component. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RGBIntegerFormat = 1032;

/**
 * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RGBAIntegerFormat = 1033;

/**
 * A DXT1-compressed image in an RGB image format.
 *
 * @type {number}
 * @constant
 */
const RGB_S3TC_DXT1_Format = 33776;

/**
 * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT1_Format = 33777;

/**
 * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT3_Format = 33778;

/**
 * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
 * compression in how the alpha compression is done.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT5_Format = 33779;

/**
 * PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGB_PVRTC_4BPPV1_Format = 35840;

/**
 * PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGB_PVRTC_2BPPV1_Format = 35841;

/**
 * PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGBA_PVRTC_4BPPV1_Format = 35842;

/**
 * PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGBA_PVRTC_2BPPV1_Format = 35843;

/**
 * ETC1 RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_ETC1_Format = 36196;

/**
 * ETC2 RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_ETC2_Format = 37492;

/**
 * ETC2 RGBA format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ETC2_EAC_Format = 37496;

/**
 * ASTC RGBA 4x4 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_4x4_Format = 37808;

/**
 * ASTC RGBA 5x4 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_5x4_Format = 37809;

/**
 * ASTC RGBA 5x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_5x5_Format = 37810;

/**
 * ASTC RGBA 6x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_6x5_Format = 37811;

/**
 * ASTC RGBA 6x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_6x6_Format = 37812;

/**
 * ASTC RGBA 8x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x5_Format = 37813;

/**
 * ASTC RGBA 8x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x6_Format = 37814;

/**
 * ASTC RGBA 8x8 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x8_Format = 37815;

/**
 * ASTC RGBA 10x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x5_Format = 37816;

/**
 * ASTC RGBA 10x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x6_Format = 37817;

/**
 * ASTC RGBA 10x8 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x8_Format = 37818;

/**
 * ASTC RGBA 10x10 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x10_Format = 37819;

/**
 * ASTC RGBA 12x10 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_12x10_Format = 37820;

/**
 * ASTC RGBA 12x12 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_12x12_Format = 37821;

/**
 * BPTC RGBA format.
 *
 * @type {number}
 * @constant
 */
const RGBA_BPTC_Format = 36492;

/**
 * BPTC Signed RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_BPTC_SIGNED_Format = 36494;

/**
 * BPTC Unsigned RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_BPTC_UNSIGNED_Format = 36495;

/**
 * RGTC1 Red format.
 *
 * @type {number}
 * @constant
 */
const RED_RGTC1_Format = 36283;

/**
 * RGTC1 Signed Red format.
 *
 * @type {number}
 * @constant
 */
const SIGNED_RED_RGTC1_Format = 36284;

/**
 * RGTC2 Red Green format.
 *
 * @type {number}
 * @constant
 */
const RED_GREEN_RGTC2_Format = 36285;

/**
 * RGTC2 Signed Red Green format.
 *
 * @type {number}
 * @constant
 */
const SIGNED_RED_GREEN_RGTC2_Format = 36286;

/**
 * Animations are played once.
 *
 * @type {number}
 * @constant
 */
const LoopOnce = 2200;

/**
 * Animations are played with a chosen number of repetitions, each time jumping from
 * the end of the clip directly to its beginning.
 *
 * @type {number}
 * @constant
 */
const LoopRepeat = 2201;

/**
 * Animations are played with a chosen number of repetitions, alternately playing forward
 * and backward.
 *
 * @type {number}
 * @constant
 */
const LoopPingPong = 2202;

/**
 * Discrete interpolation mode for keyframe tracks.
 *
 * @type {number}
 * @constant
 */
const InterpolateDiscrete = 2300;

/**
 * Linear interpolation mode for keyframe tracks.
 *
 * @type {number}
 * @constant
 */
const InterpolateLinear = 2301;

/**
 * Smooth interpolation mode for keyframe tracks.
 *
 * @type {number}
 * @constant
 */
const InterpolateSmooth = 2302;

/**
 * Zero curvature ending for animations.
 *
 * @type {number}
 * @constant
 */
const ZeroCurvatureEnding = 2400;

/**
 * Zero slope ending for animations.
 *
 * @type {number}
 * @constant
 */
const ZeroSlopeEnding = 2401;

/**
 * Wrap around ending for animations.
 *
 * @type {number}
 * @constant
 */
const WrapAroundEnding = 2402;

/**
 * Default animation blend mode.
 *
 * @type {number}
 * @constant
 */
const NormalAnimationBlendMode = 2500;

/**
 * Additive animation blend mode. Can be used to layer motions on top of
 * each other to build complex performances from smaller re-usable assets.
 *
 * @type {number}
 * @constant
 */
const AdditiveAnimationBlendMode = 2501;

/**
 * For every three vertices draw a single triangle.
 *
 * @type {number}
 * @constant
 */
const TrianglesDrawMode = 0;

/**
 * For each vertex draw a triangle from the last three vertices.
 *
 * @type {number}
 * @constant
 */
const TriangleStripDrawMode = 1;

/**
 * For each vertex draw a triangle from the first vertex and the last two vertices.
 *
 * @type {number}
 * @constant
 */
const TriangleFanDrawMode = 2;

/**
 * Basic depth packing.
 *
 * @type {number}
 * @constant
 */
const BasicDepthPacking = 3200;

/**
 * A depth value is packed into 32 bit RGBA.
 *
 * @type {number}
 * @constant
 */
const RGBADepthPacking = 3201;

/**
 * A depth value is packed into 24 bit RGB.
 *
 * @type {number}
 * @constant
 */
const RGBDepthPacking = 3202;

/**
 * A depth value is packed into 16 bit RG.
 *
 * @type {number}
 * @constant
 */
const RGDepthPacking = 3203;

/**
 * Normal information is relative to the underlying surface.
 *
 * @type {number}
 * @constant
 */
const TangentSpaceNormalMap = 0;

/**
 * Normal information is relative to the object orientation.
 *
 * @type {number}
 * @constant
 */
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

/**
 * No color space.
 *
 * @type {string}
 * @constant
 */
const NoColorSpace = '';

/**
 * sRGB color space.
 *
 * @type {string}
 * @constant
 */
const SRGBColorSpace = 'srgb';

/**
 * sRGB-linear color space.
 *
 * @type {string}
 * @constant
 */
const LinearSRGBColorSpace = 'srgb-linear';

/**
 * Linear transfer function.
 *
 * @type {string}
 * @constant
 */
const LinearTransfer = 'linear';

/**
 * sRGB transfer function.
 *
 * @type {string}
 * @constant
 */
const SRGBTransfer = 'srgb';

/**
 * Sets the stencil buffer value to `0`.
 *
 * @type {number}
 * @constant
 */
const ZeroStencilOp = 0;

/**
 * Keeps the current value.
 *
 * @type {number}
 * @constant
 */
const KeepStencilOp = 7680;

/**
 * Sets the stencil buffer value to the specified reference value.
 *
 * @type {number}
 * @constant
 */
const ReplaceStencilOp = 7681;

/**
 * Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
 *
 * @type {number}
 * @constant
 */
const IncrementStencilOp = 7682;

/**
 * Decrements the current stencil buffer value. Clamps to `0`.
 *
 * @type {number}
 * @constant
 */
const DecrementStencilOp = 7683;

/**
 * Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing
 * the maximum representable unsigned value.
 *
 * @type {number}
 * @constant
 */
const IncrementWrapStencilOp = 34055;

/**
 * Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable
 * unsigned value when decrementing a stencil buffer value of `0`.
 *
 * @type {number}
 * @constant
 */
const DecrementWrapStencilOp = 34056;

/**
 * Inverts the current stencil buffer value bitwise.
 *
 * @type {number}
 * @constant
 */
const InvertStencilOp = 5386;

/**
 * Will never return true.
 *
 * @type {number}
 * @constant
 */
const NeverStencilFunc = 512;

/**
 * Will return true if the stencil reference value is less than the current stencil value.
 *
 * @type {number}
 * @constant
 */
const LessStencilFunc = 513;

/**
 * Will return true if the stencil reference value is equal to the current stencil value.
 *
 * @type {number}
 * @constant
 */
const EqualStencilFunc = 514;

/**
 * Will return true if the stencil reference value is less than or equal to the current stencil value.
 *
 * @type {number}
 * @constant
 */
const LessEqualStencilFunc = 515;

/**
 * Will return true if the stencil reference value is greater than the current stencil value.
 *
 * @type {number}
 * @constant
 */
const GreaterStencilFunc = 516;

/**
 * Will return true if the stencil reference value is not equal to the current stencil value.
 *
 * @type {number}
 * @constant
 */
const NotEqualStencilFunc = 517;

/**
 * Will return true if the stencil reference value is greater than or equal to the current stencil value.
 *
 * @type {number}
 * @constant
 */
const GreaterEqualStencilFunc = 518;

/**
 * Will always return true.
 *
 * @type {number}
 * @constant
 */
const AlwaysStencilFunc = 519;

/**
 * Never pass.
 *
 * @type {number}
 * @constant
 */
const NeverCompare = 512;

/**
 * Pass if the incoming value is less than the texture value.
 *
 * @type {number}
 * @constant
 */
const LessCompare = 513;

/**
 * Pass if the incoming value equals the texture value.
 *
 * @type {number}
 * @constant
 */
const EqualCompare = 514;

/**
 * Pass if the incoming value is less than or equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const LessEqualCompare = 515;

/**
 * Pass if the incoming value is greater than the texture value.
 *
 * @type {number}
 * @constant
 */
const GreaterCompare = 516;

/**
 * Pass if the incoming value is not equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const NotEqualCompare = 517;

/**
 * Pass if the incoming value is greater than or equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const GreaterEqualCompare = 518;

/**
 * Always pass.
 *
 * @type {number}
 * @constant
 */
const AlwaysCompare = 519;

/**
 * The contents are intended to be specified once by the application, and used many
 * times as the source for drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const StaticDrawUsage = 35044;

/**
 * The contents are intended to be respecified repeatedly by the application, and
 * used many times as the source for drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const DynamicDrawUsage = 35048;

/**
 * The contents are intended to be specified once by the application, and used at most
 * a few times as the source for drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const StreamDrawUsage = 35040;

/**
 * The contents are intended to be specified once by reading data from the 3D API, and queried
 * many times by the application.
 *
 * @type {number}
 * @constant
 */
const StaticReadUsage = 35045;

/**
 * The contents are intended to be respecified repeatedly by reading data from the 3D API, and queried
 * many times by the application.
 *
 * @type {number}
 * @constant
 */
const DynamicReadUsage = 35049;

/**
 * The contents are intended to be specified once by reading data from the 3D API, and queried at most
 * a few times by the application
 *
 * @type {number}
 * @constant
 */
const StreamReadUsage = 35041;

/**
 * The contents are intended to be specified once by reading data from the 3D API, and used many times as
 * the source for WebGL drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const StaticCopyUsage = 35046;

/**
 * The contents are intended to be respecified repeatedly by reading data from the 3D API, and used many times
 * as the source for WebGL drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const DynamicCopyUsage = 35050;

/**
 * The contents are intended to be specified once by reading data from the 3D API, and used at most a few times
 * as the source for WebGL drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const StreamCopyUsage = 35042;

/**
 * GLSL 1 shader code.
 *
 * @type {string}
 * @constant
 */
const GLSL1 = '100';

/**
 * GLSL 3 shader code.
 *
 * @type {string}
 * @constant
 */
const GLSL3 = '300 es';

/**
 * WebGL coordinate system.
 *
 * @type {number}
 * @constant
 */
const WebGLCoordinateSystem = 2000;

/**
 * WebGPU coordinate system.
 *
 * @type {number}
 * @constant
 */
const WebGPUCoordinateSystem = 2001;

/**
 * Represents the different timestamp query types.
 *
 * @type {ConstantsTimestampQuery}
 * @constant
 */
const TimestampQuery = {
	COMPUTE: 'compute',
	RENDER: 'render'
};

/**
 * Represents mouse buttons and interaction types in context of controls.
 *
 * @type {ConstantsInterpolationSamplingType}
 * @constant
 */
const InterpolationSamplingType = {
	PERSPECTIVE: 'perspective',
	LINEAR: 'linear',
	FLAT: 'flat'
};

/**
 * Represents the different interpolation sampling modes.
 *
 * @type {ConstantsInterpolationSamplingMode}
 * @constant
 */
const InterpolationSamplingMode = {
	NORMAL: 'normal',
	CENTROID: 'centroid',
	SAMPLE: 'sample',
	FLAT_FIRST: 'flat first',
	FLAT_EITHER: 'flat either'
};

/**
 * This type represents mouse buttons and interaction types in context of controls.
 *
 * @typedef {Object} ConstantsMouse
 * @property {number} MIDDLE - The left mouse button.
 * @property {number} LEFT - The middle mouse button.
 * @property {number} RIGHT - The right mouse button.
 * @property {number} ROTATE - A rotate interaction.
 * @property {number} DOLLY - A dolly interaction.
 * @property {number} PAN - A pan interaction.
 **/

/**
 * This type represents touch interaction types in context of controls.
 *
 * @typedef {Object} ConstantsTouch
 * @property {number} ROTATE - A rotate interaction.
 * @property {number} PAN - A pan interaction.
 * @property {number} DOLLY_PAN - The dolly-pan interaction.
 * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
 **/

/**
 * This type represents the different timestamp query types.
 *
 * @typedef {Object} ConstantsTimestampQuery
 * @property {string} COMPUTE - A `compute` timestamp query.
 * @property {string} RENDER - A `render` timestamp query.
 **/

/**
 * Represents the different interpolation sampling types.
 *
 * @typedef {Object} ConstantsInterpolationSamplingType
 * @property {string} PERSPECTIVE - Perspective-correct interpolation.
 * @property {string} LINEAR - Linear interpolation.
 * @property {string} FLAT - Flat interpolation.
 */

/**
 * Represents the different interpolation sampling modes.
 *
 * @typedef {Object} ConstantsInterpolationSamplingMode
 * @property {string} NORMAL - Normal sampling mode.
 * @property {string} CENTROID - Centroid sampling mode.
 * @property {string} SAMPLE - Sample-specific sampling mode.
 * @property {string} FLAT_FIRST - Flat interpolation using the first vertex.
 * @property {string} FLAT_EITHER - Flat interpolation using either vertex.
 */

/**
 * This modules allows to dispatch event objects on custom JavaScript objects.
 *
 * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}
 *
 * Code Example:
 * ```js
 * class Car extends EventDispatcher {
 * 	start() {
 *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
 *	}
 *};
 *
 * // Using events with the custom object
 * const car = new Car();
 * car.addEventListener( 'start', function ( event ) {
 * 	alert( event.message );
 * } );
 *
 * car.start();
 * ```
 */
class EventDispatcher {

	/**
	 * Adds the given event listener to the given event type.
	 *
	 * @param {string} type - The type of event to listen to.
	 * @param {Function} listener - The function that gets called when the event is fired.
	 */
	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === -1 ) {

			listeners[ type ].push( listener );

		}

	}

	/**
	 * Returns `true` if the given event listener has been added to the given event type.
	 *
	 * @param {string} type - The type of event.
	 * @param {Function} listener - The listener to check.
	 * @return {boolean} Whether the given event listener has been added to the given event type.
	 */
	hasEventListener( type, listener ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return false;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

	}

	/**
	 * Removes the given event listener from the given event type.
	 *
	 * @param {string} type - The type of event.
	 * @param {Function} listener - The listener to remove.
	 */
	removeEventListener( type, listener ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return;

		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== -1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	/**
	 * Dispatches an event object.
	 *
	 * @param {Object} event - The event that gets fired.
	 */
	dispatchEvent( event ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return;

		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

/**
 * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
 * (universally unique identifier).
 *
 * @return {string} The UUID.
 */
function generateUUID() {

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

/**
 * Clamps the given value between min and max.
 *
 * @param {number} value - The value to clamp.
 * @param {number} min - The min value.
 * @param {number} max - The max value.
 * @return {number} The clamped value.
 */
function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

/**
 * Computes the Euclidean modulo of the given parameters that
 * is `( ( n % m ) + m ) % m`.
 *
 * @param {number} n - The first parameter.
 * @param {number} m - The second parameter.
 * @return {number} The Euclidean modulo.
 */
function euclideanModulo( n, m ) {

	// https://en.wikipedia.org/wiki/Modulo_operation

	return ( ( n % m ) + m ) % m;

}

/**
 * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
 * for the given value.
 *
 * @param {number} x - The value to be mapped.
 * @param {number} a1 - Minimum value for range A.
 * @param {number} a2 - Maximum value for range A.
 * @param {number} b1 - Minimum value for range B.
 * @param {number} b2 - Maximum value for range B.
 * @return {number} The mapped value.
 */
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

/**
 * Returns the percentage in the closed interval `[0, 1]` of the given value
 * between the start and end point.
 *
 * @param {number} x - The start point
 * @param {number} y - The end point.
 * @param {number} value - A value between start and end.
 * @return {number} The interpolation factor.
 */
function inverseLerp( x, y, value ) {

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

/**
 * Returns a value linearly interpolated from two known points based on the given interval -
 * `t = 0` will return `x` and `t = 1` will return `y`.
 *
 * @param {number} x - The start point
 * @param {number} y - The end point.
 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
 * @return {number} The interpolated value.
 */
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

/**
 * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
 * time to maintain frame rate independent movement. For details, see
 * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
 *
 * @param {number} x - The current point.
 * @param {number} y - The target point.
 * @param {number} lambda - A higher lambda value will make the movement more sudden,
 * and a lower value will make the movement more gradual.
 * @param {number} dt - Delta time in seconds.
 * @return {number} The interpolated value.
 */
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

/**
 * Returns a value that alternates between `0` and the given `length` parameter.
 *
 * @param {number} x - The value to pingpong.
 * @param {number} [length=1] - The positive value the function will pingpong to.
 * @return {number} The alternated value.
 */
function pingpong( x, length = 1 ) {

	// https://www.desmos.com/calculator/vcsjnyz7x4

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

/**
 * Returns a value in the range `[0,1]` that represents the percentage that `x` has
 * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
 * the `min` and `max`.
 *
 * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
 *
 * @param {number} x - The value to evaluate based on its position between min and max.
 * @param {number} min - The min value. Any x value below min will be `0`.
 * @param {number} max - The max value. Any x value above max will be `1`.
 * @return {number} The alternated value.
 */
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

/**
 * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
 * that has zero 1st and 2nd order derivatives at x=0 and x=1.
 *
 * @param {number} x - The value to evaluate based on its position between min and max.
 * @param {number} min - The min value. Any x value below min will be `0`.
 * @param {number} max - The max value. Any x value above max will be `1`.
 * @return {number} The alternated value.
 */
function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

/**
 * Returns a random integer from `<low, high>` interval.
 *
 * @param {number} low - The lower value boundary.
 * @param {number} high - The upper value boundary
 * @return {number} A random integer.
 */
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

/**
 * Returns a random float from `<low, high>` interval.
 *
 * @param {number} low - The lower value boundary.
 * @param {number} high - The upper value boundary
 * @return {number} A random float.
 */
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

/**
 * Returns a random integer from `<-range/2, range/2>` interval.
 *
 * @param {number} range - Defines the value range.
 * @return {number} A random float.
 */
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

/**
 * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
 *
 * @param {number} [s] - The integer seed.
 * @return {number} A random float.
 */
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

/**
 * Converts degrees to radians.
 *
 * @param {number} degrees - A value in degrees.
 * @return {number} The converted value in radians.
 */
function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

/**
 * Converts radians to degrees.
 *
 * @param {number} radians - A value in radians.
 * @return {number} The converted value in degrees.
 */
function radToDeg( radians ) {

	return radians * RAD2DEG;

}

/**
 * Returns `true` if the given number is a power of two.
 *
 * @param {number} value - The value to check.
 * @return {boolean} Whether the given number is a power of two or not.
 */
function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

/**
 * Returns the smallest power of two that is greater than or equal to the given number.
 *
 * @param {number} value - The value to find a POT for.
 * @return {number} The smallest power of two that is greater than or equal to the given number.
 */
function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

/**
 * Returns the largest power of two that is less than or equal to the given number.
 *
 * @param {number} value - The value to find a POT for.
 * @return {number} The largest power of two that is less than or equal to the given number.
 */
function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

/**
 * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
 * defined by the given angles and order.
 *
 * Rotations are applied to the axes in the order specified by order:
 * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
 *
 * @param {Quaternion} q - The quaternion to set.
 * @param {number} a - The rotation applied to the first axis, in radians.
 * @param {number} b - The rotation applied to the second axis, in radians.
 * @param {number} c - The rotation applied to the third axis, in radians.
 * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
 */
function setQuaternionFromProperEuler( q, a, b, c, order ) {

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

/**
 * Denormalizes the given value according to the given typed array.
 *
 * @param {number} value - The value to denormalize.
 * @param {TypedArray} array - The typed array that defines the data type of the value.
 * @return {number} The denormalize (float) value in the range `[0,1]`.
 */
function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return value / 4294967295.0;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int32Array:

			return Math.max( value / 2147483647.0, -1 );

		case Int16Array:

			return Math.max( value / 32767.0, -1 );

		case Int8Array:

			return Math.max( value / 127.0, -1 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

/**
 * Normalizes the given value according to the given typed array.
 *
 * @param {number} value - The float value in the range `[0,1]` to normalize.
 * @param {TypedArray} array - The typed array that defines the data type of the value.
 * @return {number} The normalize value.
 */
function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return Math.round( value * 4294967295.0 );

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int32Array:

			return Math.round( value * 2147483647.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

/**
 * @class
 * @classdesc A collection of math utility functions.
 * @hideconstructor
 */
const MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	/**
	 * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
	 * (universally unique identifier).
	 *
	 * @static
	 * @method
	 * @return {string} The UUID.
	 */
	generateUUID: generateUUID,
	/**
	 * Clamps the given value between min and max.
	 *
	 * @static
	 * @method
	 * @param {number} value - The value to clamp.
	 * @param {number} min - The min value.
	 * @param {number} max - The max value.
	 * @return {number} The clamped value.
	 */
	clamp: clamp,
	/**
	 * Computes the Euclidean modulo of the given parameters that
	 * is `( ( n % m ) + m ) % m`.
	 *
	 * @static
	 * @method
	 * @param {number} n - The first parameter.
	 * @param {number} m - The second parameter.
	 * @return {number} The Euclidean modulo.
	 */
	euclideanModulo: euclideanModulo,
	/**
	 * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
	 * for the given value.
	 *
	 * @static
	 * @method
	 * @param {number} x - The value to be mapped.
	 * @param {number} a1 - Minimum value for range A.
	 * @param {number} a2 - Maximum value for range A.
	 * @param {number} b1 - Minimum value for range B.
	 * @param {number} b2 - Maximum value for range B.
	 * @return {number} The mapped value.
	 */
	mapLinear: mapLinear,
	/**
	 * Returns the percentage in the closed interval `[0, 1]` of the given value
	 * between the start and end point.
	 *
	 * @static
	 * @method
	 * @param {number} x - The start point
	 * @param {number} y - The end point.
	 * @param {number} value - A value between start and end.
	 * @return {number} The interpolation factor.
	 */
	inverseLerp: inverseLerp,
	/**
	 * Returns a value linearly interpolated from two known points based on the given interval -
	 * `t = 0` will return `x` and `t = 1` will return `y`.
	 *
	 * @static
	 * @method
	 * @param {number} x - The start point
	 * @param {number} y - The end point.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {number} The interpolated value.
	 */
	lerp: lerp,
	/**
	 * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
	 * time to maintain frame rate independent movement. For details, see
	 * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
	 *
	 * @static
	 * @method
	 * @param {number} x - The current point.
	 * @param {number} y - The target point.
	 * @param {number} lambda - A higher lambda value will make the movement more sudden,
	 * and a lower value will make the movement more gradual.
	 * @param {number} dt - Delta time in seconds.
	 * @return {number} The interpolated value.
	 */
	damp: damp,
	/**
	 * Returns a value that alternates between `0` and the given `length` parameter.
	 *
	 * @static
	 * @method
	 * @param {number} x - The value to pingpong.
	 * @param {number} [length=1] - The positive value the function will pingpong to.
	 * @return {number} The alternated value.
	 */
	pingpong: pingpong,
	/**
	 * Returns a value in the range `[0,1]` that represents the percentage that `x` has
	 * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
	 * the `min` and `max`.
	 *
	 * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
	 *
	 * @static
	 * @method
	 * @param {number} x - The value to evaluate based on its position between min and max.
	 * @param {number} min - The min value. Any x value below min will be `0`.
	 * @param {number} max - The max value. Any x value above max will be `1`.
	 * @return {number} The alternated value.
	 */
	smoothstep: smoothstep,
	/**
	 * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
	 * that has zero 1st and 2nd order derivatives at x=0 and x=1.
	 *
	 * @static
	 * @method
	 * @param {number} x - The value to evaluate based on its position between min and max.
	 * @param {number} min - The min value. Any x value below min will be `0`.
	 * @param {number} max - The max value. Any x value above max will be `1`.
	 * @return {number} The alternated value.
	 */
	smootherstep: smootherstep,
	/**
	 * Returns a random integer from `<low, high>` interval.
	 *
	 * @static
	 * @method
	 * @param {number} low - The lower value boundary.
	 * @param {number} high - The upper value boundary
	 * @return {number} A random integer.
	 */
	randInt: randInt,
	/**
	 * Returns a random float from `<low, high>` interval.
	 *
	 * @static
	 * @method
	 * @param {number} low - The lower value boundary.
	 * @param {number} high - The upper value boundary
	 * @return {number} A random float.
	 */
	randFloat: randFloat,
	/**
	 * Returns a random integer from `<-range/2, range/2>` interval.
	 *
	 * @static
	 * @method
	 * @param {number} range - Defines the value range.
	 * @return {number} A random float.
	 */
	randFloatSpread: randFloatSpread,
	/**
	 * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
	 *
	 * @static
	 * @method
	 * @param {number} [s] - The integer seed.
	 * @return {number} A random float.
	 */
	seededRandom: seededRandom,
	/**
	 * Converts degrees to radians.
	 *
	 * @static
	 * @method
	 * @param {number} degrees - A value in degrees.
	 * @return {number} The converted value in radians.
	 */
	degToRad: degToRad,
	/**
	 * Converts radians to degrees.
	 *
	 * @static
	 * @method
	 * @param {number} radians - A value in radians.
	 * @return {number} The converted value in degrees.
	 */
	radToDeg: radToDeg,
	/**
	 * Returns `true` if the given number is a power of two.
	 *
	 * @static
	 * @method
	 * @param {number} value - The value to check.
	 * @return {boolean} Whether the given number is a power of two or not.
	 */
	isPowerOfTwo: isPowerOfTwo,
	/**
	 * Returns the smallest power of two that is greater than or equal to the given number.
	 *
	 * @static
	 * @method
	 * @param {number} value - The value to find a POT for.
	 * @return {number} The smallest power of two that is greater than or equal to the given number.
	 */
	ceilPowerOfTwo: ceilPowerOfTwo,
	/**
	 * Returns the largest power of two that is less than or equal to the given number.
	 *
	 * @static
	 * @method
	 * @param {number} value - The value to find a POT for.
	 * @return {number} The largest power of two that is less than or equal to the given number.
	 */
	floorPowerOfTwo: floorPowerOfTwo,
	/**
	 * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
	 * defined by the given angles and order.
	 *
	 * Rotations are applied to the axes in the order specified by order:
	 * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
	 *
	 * @static
	 * @method
	 * @param {Quaternion} q - The quaternion to set.
	 * @param {number} a - The rotation applied to the first axis, in radians.
	 * @param {number} b - The rotation applied to the second axis, in radians.
	 * @param {number} c - The rotation applied to the third axis, in radians.
	 * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
	 */
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	/**
	 * Normalizes the given value according to the given typed array.
	 *
	 * @static
	 * @method
	 * @param {number} value - The float value in the range `[0,1]` to normalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The normalize value.
	 */
	normalize: normalize,
	/**
	 * Denormalizes the given value according to the given typed array.
	 *
	 * @static
	 * @method
	 * @param {number} value - The value to denormalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The denormalize (float) value in the range `[0,1]`.
	 */
	denormalize: denormalize
};

/**
 * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
 * (labeled x and y), which can be used to represent a number of things, such as:
 *
 * - A point in 2D space (i.e. a position on a plane).
 * - A direction and length across a plane. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
 * and the direction is also measured from `(0, 0)` towards `(x, y)`.
 * - Any arbitrary ordered pair of numbers.
 *
 * There are other things a 2D vector can be used to represent, such as
 * momentum vectors, complex numbers and so on, however these are the most
 * common uses in three.js.
 *
 * Iterating through a vector instance will yield its components `(x, y)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector2( 0, 1 );
 *
 * //no arguments; will be initialised to (0, 0)
 * const b = new THREE.Vector2( );
 *
 * const d = a.distanceTo( b );
 * ```
 */
class Vector2 {

	/**
	 * Constructs a new 2D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 */
	constructor( x = 0, y = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector2.prototype.isVector2 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

	}

	/**
	 * Alias for {@link Vector2#x}.
	 *
	 * @type {number}
	 */
	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	/**
	 * Alias for {@link Vector2#y}.
	 *
	 * @type {number}
	 */
	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @return {Vector2} A reference to this vector.
	 */
	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector2} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	 * @param {number} value - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector2} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to copy.
	 * @return {Vector2} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to add.
	 * @return {Vector2} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector2} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector2} a - The first vector.
	 * @param {Vector2} b - The second vector.
	 * @return {Vector2} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector2} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector2} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector2} v - The vector to subtract.
	 * @return {Vector2} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector2} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector2} a - The first vector.
	 * @param {Vector2} b - The second vector.
	 * @return {Vector2} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to multiply.
	 * @return {Vector2} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector2} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector2} v - The vector to divide.
	 * @return {Vector2} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector2} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * Multiplies this vector (with an implicit 1 as the 3rd component) by
	 * the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to apply.
	 * @return {Vector2} A reference to this vector.
	 */
	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	/**
	 * If this vector's x or y value is greater than the given vector's x or y
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector2} v - The vector.
	 * @return {Vector2} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	/**
	 * If this vector's x or y value is less than the given vector's x or y
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector2} v - The vector.
	 * @return {Vector2} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	/**
	 * If this vector's x or y value is greater than the max vector's x or y
	 * value, it is replaced by the corresponding value.
	 * If this vector's x or y value is less than the min vector's x or y value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector2} min - The minimum x and y values.
	 * @param {Vector2} max - The maximum x and y values in the desired range.
	 * @return {Vector2} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );

		return this;

	}

	/**
	 * If this vector's x or y values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x or y values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector2} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector2} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x and y = -y.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	/**
	 * Calculates the cross product of the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to compute the cross product with.
	 * @return {number} The result of the cross product.
	 */
	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Computes the angle in radians of this vector with respect to the positive x-axis.
	 *
	 * @return {number} The angle in radians.
	 */
	angle() {

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	/**
	 * Returns the angle between the given vector and this instance in radians.
	 *
	 * @param {Vector2} v - The vector to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, -1, 1 ) );

	}

	/**
	 * Computes the distance from the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	/**
	 * Computes the squared distance from the given vector to this instance.
	 * If you are just comparing the distance with another distance, you should compare
	 * the distance squared instead as it is slightly more efficient to calculate.
	 *
	 * @param {Vector2} v - The vector to compute the squared distance to.
	 * @return {number} The squared distance.
	 */
	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	/**
	 * Computes the Manhattan distance from the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to compute the Manhattan distance to.
	 * @return {number} The Manhattan distance.
	 */
	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector2} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector2} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector2} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector2} v1 - The first vector.
	 * @param {Vector2} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector2} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector2} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]` and y
	 * value to be `array[ offset + 1 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector2} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector2} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	/**
	 * Rotates this vector around the given center by the given angle.
	 *
	 * @param {Vector2} center - The point around which to rotate.
	 * @param {number} angle - The angle to rotate, in radians.
	 * @return {Vector2} A reference to this vector.
	 */
	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

/**
 * Represents a 3x3 matrix.
 *
 * A Note on Row-Major and Column-Major Ordering:
 *
 * The constructor and {@link Matrix3#set} method take arguments in
 * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
 * This means that calling:
 * ```js
 * const m = new THREE.Matrix();
 * m.set( 11, 12, 13,
 *        21, 22, 23,
 *        31, 32, 33 );
 * ```
 * will result in the elements array containing:
 * ```js
 * m.elements = [ 11, 21, 31,
 *                12, 22, 32,
 *                13, 23, 33 ];
 * ```
 * and internally all calculations are performed using column-major ordering.
 * However, as the actual ordering makes no difference mathematically and
 * most people are used to thinking about matrices in row-major order, the
 * three.js documentation shows matrices in row-major order. Just bear in
 * mind that if you are reading the source code, you'll have to take the
 * transpose of any matrices outlined here to make sense of the calculations.
 */
class Matrix3 {

	/**
	 * Constructs a new 3x3 matrix. The arguments are supposed to be
	 * in row-major order. If no arguments are provided, the constructor
	 * initializes the matrix as an identity matrix.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 */
	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Matrix3.prototype.isMatrix3 = true;

		/**
		 * A column-major list of matrix values.
		 *
		 * @type {Array<number>}
		 */
		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

		}

	}

	/**
	 * Sets the elements of the matrix.The arguments are supposed to be
	 * in row-major order.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @return {Matrix3} A reference to this matrix.
	 */
	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	/**
	 * Sets this matrix to the 3x3 identity matrix.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Copies the values of the given matrix to this instance.
	 *
	 * @param {Matrix3} m - The matrix to copy.
	 * @return {Matrix3} A reference to this matrix.
	 */
	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	/**
	 * Extracts the basis of this matrix into the three axis vectors provided.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	/**
	 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	/**
	 * Post-multiplies this matrix by the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to multiply with.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	/**
	 * Pre-multiplies this matrix by the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to multiply with.
	 * @return {Matrix3} A reference to this matrix.
	 */
	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	/**
	 * Multiples the given 3x3 matrices and stores the result
	 * in this matrix.
	 *
	 * @param {Matrix3} a - The first matrix.
	 * @param {Matrix3} b - The second matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	/**
	 * Multiplies every component of the matrix by the given scalar.
	 *
	 * @param {number} s - The scalar.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	/**
	 * Computes and returns the determinant of this matrix.
	 *
	 * @return {number} The determinant.
	 */
	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	/**
	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
	 * You can not invert with a determinant of zero. If you attempt this, the method produces
	 * a zero matrix instead.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	/**
	 * Transposes this matrix in place.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	/**
	 * Computes the normal matrix which is the inverse transpose of the upper
	 * left 3x3 portion of the given 4x4 matrix.
	 *
	 * @param {Matrix4} matrix4 - The 4x4 matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	/**
	 * Transposes this matrix into the supplied array, and returns itself unchanged.
	 *
	 * @param {Array<number>} r - An array to store the transposed matrix elements.
	 * @return {Matrix3} A reference to this matrix.
	 */
	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	/**
	 * Sets the UV transform matrix from offset, repeat, rotation, and center.
	 *
	 * @param {number} tx - Offset x.
	 * @param {number} ty - Offset y.
	 * @param {number} sx - Repeat x.
	 * @param {number} sy - Repeat y.
	 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
	 * @param {number} cx - Center x of rotation.
	 * @param {number} cy - Center y of rotation
	 * @return {Matrix3} A reference to this matrix.
	 */
	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	/**
	 * Scales this matrix with the given scalar values.
	 *
	 * @param {number} sx - The amount to scale in the X axis.
	 * @param {number} sy - The amount to scale in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	/**
	 * Rotates this matrix by the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix3} A reference to this matrix.
	 */
	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	/**
	 * Translates this matrix by the given scalar values.
	 *
	 * @param {number} tx - The amount to translate in the X axis.
	 * @param {number} ty - The amount to translate in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	/**
	 * Sets this matrix as a 2D translation transform.
	 *
	 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
	 * @param {number} y - The amount to translate in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeTranslation( x, y ) {

		if ( x.isVector2 ) {

			this.set(

				1, 0, x.x,
				0, 1, x.y,
				0, 0, 1

			);

		} else {

			this.set(

				1, 0, x,
				0, 1, y,
				0, 0, 1

			);

		}

		return this;

	}

	/**
	 * Sets this matrix as a 2D rotational transformation.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a 2D scale transform.
	 *
	 * @param {number} x - The amount to scale in the X axis.
	 * @param {number} y - The amount to scale in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Returns `true` if this matrix is equal with the given one.
	 *
	 * @param {Matrix3} matrix - The matrix to test for equality.
	 * @return {boolean} Whether this matrix is equal with the given one.
	 */
	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	/**
	 * Sets the elements of the matrix from the given array.
	 *
	 * @param {Array<number>} array - The matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Matrix3} A reference to this matrix.
	 */
	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	/**
	 * Writes the elements of this matrix to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The matrix elements in column-major order.
	 */
	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	/**
	 * Returns a matrix with copied values from this instance.
	 *
	 * @return {Matrix3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

const _cache = {};

function warnOnce( message ) {

	if ( message in _cache ) return;

	_cache[ message ] = true;

	console.warn( message );

}

function probeAsync( gl, sync, interval ) {

	return new Promise( function ( resolve, reject ) {

		function probe() {

			switch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {

				case gl.WAIT_FAILED:
					reject();
					break;

				case gl.TIMEOUT_EXPIRED:
					setTimeout( probe, interval );
					break;

				default:
					resolve();

			}

		}

		setTimeout( probe, interval );

	} );

}

function toNormalizedProjectionMatrix( projectionMatrix ) {

	const m = projectionMatrix.elements;

	// Convert [-1, 1] to [0, 1] projection matrix
	m[ 2 ] = 0.5 * m[ 2 ] + 0.5 * m[ 3 ];
	m[ 6 ] = 0.5 * m[ 6 ] + 0.5 * m[ 7 ];
	m[ 10 ] = 0.5 * m[ 10 ] + 0.5 * m[ 11 ];
	m[ 14 ] = 0.5 * m[ 14 ] + 0.5 * m[ 15 ];

}

function toReversedProjectionMatrix( projectionMatrix ) {

	const m = projectionMatrix.elements;
	const isPerspectiveMatrix = m[ 11 ] === -1;

	// Reverse [0, 1] projection matrix
	if ( isPerspectiveMatrix ) {

		m[ 10 ] = - m[ 10 ] - 1;
		m[ 14 ] = - m[ 14 ];

	} else {

		m[ 10 ] = - m[ 10 ];
		m[ 14 ] = - m[ 14 ] + 1;

	}

}

const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
	0.4123908, 0.3575843, 0.1804808,
	0.2126390, 0.7151687, 0.0721923,
	0.0193308, 0.1191948, 0.9505322
);

const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
	3.2409699, -1.5373832, -0.4986108,
	-0.9692436, 1.8759675, 0.0415551,
	0.0556301, -0.203977, 1.0569715
);

function createColorManagement() {

	const ColorManagement = {

		enabled: true,

		workingColorSpace: LinearSRGBColorSpace,

		/**
		 * Implementations of supported color spaces.
		 *
		 * Required:
		 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
		 *	- whitePoint: reference white [ x y ]
		 *	- transfer: transfer function (pre-defined)
		 *	- toXYZ: Matrix3 RGB to XYZ transform
		 *	- fromXYZ: Matrix3 XYZ to RGB transform
		 *	- luminanceCoefficients: RGB luminance coefficients
		 *
		 * Optional:
		 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
		 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
		 *
		 * Reference:
		 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
		 */
		spaces: {},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

				color.r = SRGBToLinear( color.r );
				color.g = SRGBToLinear( color.g );
				color.b = SRGBToLinear( color.b );

			}

			if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

				color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
				color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

			}

			if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

				color.r = LinearToSRGB( color.r );
				color.g = LinearToSRGB( color.g );
				color.b = LinearToSRGB( color.b );

			}

			return color;

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

		getPrimaries: function ( colorSpace ) {

			return this.spaces[ colorSpace ].primaries;

		},

		getTransfer: function ( colorSpace ) {

			if ( colorSpace === NoColorSpace ) return LinearTransfer;

			return this.spaces[ colorSpace ].transfer;

		},

		getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

			return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

		},

		define: function ( colorSpaces ) {

			Object.assign( this.spaces, colorSpaces );

		},

		// Internal APIs

		_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

			return targetMatrix
				.copy( this.spaces[ sourceColorSpace ].toXYZ )
				.multiply( this.spaces[ targetColorSpace ].fromXYZ );

		},

		_getDrawingBufferColorSpace: function ( colorSpace ) {

			return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

		},

		_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

			return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

		}

	};

	/******************************************************************************
	 * sRGB definitions
	 */

	const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
	const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
	const D65 = [ 0.3127, 0.3290 ];

	ColorManagement.define( {

		[ LinearSRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: LinearTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

		[ SRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: SRGBTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

	} );

	return ColorManagement;

}

const ColorManagement = /*@__PURE__*/ createColorManagement();

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

let _canvas;

/**
 * A class containing utility functions for images.
 *
 * @hideconstructor
 */
class ImageUtils {

	/**
	 * Returns a data URI containing a representation of the given image.
	 *
	 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
	 * @param {string} [type='image/png'] - Indicates the image format.
	 * @return {string} The data URI.
	 */
	static getDataURL( image, type = 'image/png' ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement === 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		return canvas.toDataURL( type );

	}

	/**
	 * Converts the given sRGB image data to linear color space.
	 *
	 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
	 * @return {HTMLCanvasElement|Object} The converted image.
	 */
	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

let _sourceId = 0;

/**
 * Represents the data source of a texture.
 *
 * The main purpose of this class is to decouple the data definition from the texture
 * definition so the same data can be used with multiple texture instances.
 */
class Source {

	/**
	 * Constructs a new video texture.
	 *
	 * @param {any} [data=null] - The data definition of a texture.
	 */
	constructor( data = null ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSource = true;

		/**
		 * The ID of the source.
		 *
		 * @name Source#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

		/**
		 * The UUID of the source.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The data definition of a texture.
		 *
		 * @type {any}
		 */
		this.data = data;

		/**
		 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
		 * provides more control on how texture data should be processed. When `dataReady` is set
		 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
		 * the data into the GPU memory.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.dataReady = true;

		/**
		 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

	}

	/**
	 * When the property is set to `true`, the engine allocates the memory
	 * for the texture (if necessary) and triggers the actual texture upload
	 * to the GPU next time the source is used.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Serializes the source into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized source.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let _textureId = 0;

/**
 * Base class for all textures.
 *
 * Note: After the initial use of a texture, its dimensions, format, and type
 * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
 *
 * @augments EventDispatcher
 */
class Texture extends EventDispatcher {

	/**
	 * Constructs a new texture.
	 *
	 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space.
	 */
	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isTexture = true;

		/**
		 * The ID of the texture.
		 *
		 * @name Texture#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _textureId ++ } );

		/**
		 * The UUID of the material.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the material.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The data definition of a texture. A reference to the data source can be
		 * shared across textures. This is often useful in context of spritesheets
		 * where multiple textures render the same data but with different texture
		 * transformations.
		 *
		 * @type {Source}
		 */
		this.source = new Source( image );

		/**
		 * An array holding user-defined mipmaps.
		 *
		 * @type {Array<Object>}
		 */
		this.mipmaps = [];

		/**
		 * How the texture is applied to the object. The value `UVMapping`
		 * is the default, where texture or uv coordinates are used to apply the map.
		 *
		 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
		 * @default UVMapping
		*/
		this.mapping = mapping;

		/**
		 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
		 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.channel = 0;

		/**
		 * This defines how the texture is wrapped horizontally and corresponds to
		 * *U* in UV mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapS = wrapS;

		/**
		 * This defines how the texture is wrapped horizontally and corresponds to
		 * *V* in UV mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapT = wrapT;

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default LinearFilter
		 */
		this.magFilter = magFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default LinearMipmapLinearFilter
		 */
		this.minFilter = minFilter;

		/**
		 * The number of samples taken along the axis through the pixel that has the
		 * highest density of texels. By default, this value is `1`. A higher value
		 * gives a less blurry result than a basic mipmap, at the cost of more
		 * texture samples being used.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.anisotropy = anisotropy;

		/**
		 * The format of the texture.
		 *
		 * @type {number}
		 * @default RGBAFormat
		 */
		this.format = format;

		/**
		 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
		 * defines how the texture data is going to be stored on the GPU.
		 *
		 * This property allows to overwrite the default format.
		 *
		 * @type {?string}
		 * @default null
		 */
		this.internalFormat = null;

		/**
		 * The data type of the texture.
		 *
		 * @type {number}
		 * @default UnsignedByteType
		 */
		this.type = type;

		/**
		 * How much a single repetition of the texture is offset from the beginning,
		 * in each direction U and V. Typical range is `0.0` to `1.0`.
		 *
		 * @type {Vector2}
		 * @default (0,0)
		 */
		this.offset = new Vector2( 0, 0 );

		/**
		 * How many times the texture is repeated across the surface, in each
		 * direction U and V. If repeat is set greater than `1` in either direction,
		 * the corresponding wrap parameter should also be set to `RepeatWrapping`
		 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.repeat = new Vector2( 1, 1 );

		/**
		 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
		 * to the center of the texture. Default is `(0, 0)`, the lower left.
		 *
		 * @type {Vector2}
		 * @default (0,0)
		 */
		this.center = new Vector2( 0, 0 );

		/**
		 * How much the texture is rotated around the center point, in radians.
		 * Positive values are counter-clockwise.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.rotation = 0;

		/**
		 * Whether to update the texture's uv-transformation {@link Texture#matrix}
		 * from the properties {@link Texture#offset}, {@link Texture#repeat},
		 * {@link Texture#rotation}, and {@link Texture#center}.
		 *
		 * Set this to `false` if you are specifying the uv-transform matrix directly.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixAutoUpdate = true;

		/**
		 * The uv-transformation matrix of the texture.
		 *
		 * @type {Matrix3}
		 */
		this.matrix = new Matrix3();

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Set this to `false` if you are creating mipmaps manually.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.generateMipmaps = true;

		/**
		 * If set to `true`, the alpha channel, if present, is multiplied into the
		 * color channels when the texture is uploaded to the GPU.
		 *
		 * Note that this property has no effect when using `ImageBitmap`. You need to
		 * configure premultiply alpha on bitmap creation instead.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.premultiplyAlpha = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Note that this property has no effect when using `ImageBitmap`. You need to
		 * configure the flip on bitmap creation instead.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.flipY = true;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
		 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
		 *
		 * @type {number}
		 * @default 4
		 */
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		/**
		 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
		 *
		 * @type {string}
		 * @default NoColorSpace
		 */
		this.colorSpace = colorSpace;

		/**
		 * An object that can be used to store custom data about the texture. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

		/**
		 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

		/**
		 * A callback function, called when the texture is updated (e.g., when
		 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
		 *
		 * @type {?Function}
		 * @default null
		 */
		this.onUpdate = null;

		/**
		 * An optional back reference to the textures render target.
		 *
		 * @type {?(RenderTarget|WebGLRenderTarget)}
		 * @default null
		 */
		this.renderTarget = null;

		/**
		 * Indicates whether a texture belongs to a render target or not.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isRenderTargetTexture = false;

		/**
		 * Indicates if a texture should be handled like a texture array.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isTextureArray = false;

		/**
		 * Indicates whether this texture should be processed by `PMREMGenerator` or not
		 * (only relevant for render target textures).
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.pmremVersion = 0;

	}

	/**
	 * The image object holding the texture data.
	 *
	 * @type {?Object}
	 */
	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	/**
	 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
	 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
	 */
	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	/**
	 * Returns a new texture with copied values from this instance.
	 *
	 * @return {Texture} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given texture to this instance.
	 *
	 * @param {Texture} source - The texture to copy.
	 * @return {Texture} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;
		this.channel = source.channel;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;

		this.renderTarget = source.renderTarget;
		this.isRenderTargetTexture = source.isRenderTargetTexture;
		this.isTextureArray = source.isTextureArray;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	/**
	 * Serializes the texture into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized texture.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.6,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,
			channel: this.channel,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Texture#dispose
	 */
	dispose() {

		/**
		 * Fires when the texture has been disposed of.
		 *
		 * @event Texture#dispose
		 * @type {Object}
		 */
		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Transforms the given uv vector with the textures uv transformation matrix.
	 *
	 * @param {Vector2} uv - The uv vector.
	 * @return {Vector2} The transformed uv vector.
	 */
	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	/**
	 * Setting this property to `true` indicates the engine the texture
	 * must be updated in the next render. This triggers a texture upload
	 * to the GPU and ensures correct texture parameter configuration.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

	/**
	 * Setting this property to `true` indicates the engine the PMREM
	 * must be regenerated.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsPMREMUpdate( value ) {

		if ( value === true ) {

			this.pmremVersion ++;

		}

	}

}

/**
 * The default image for all textures.
 *
 * @static
 * @type {?Image}
 * @default null
 */
Texture.DEFAULT_IMAGE = null;

/**
 * The default mapping for all textures.
 *
 * @static
 * @type {number}
 * @default UVMapping
 */
Texture.DEFAULT_MAPPING = UVMapping;

/**
 * The default anisotropy value for all textures.
 *
 * @static
 * @type {number}
 * @default 1
 */
Texture.DEFAULT_ANISOTROPY = 1;

/**
 * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
 * (labeled x, y, z and w), which can be used to represent a number of things, such as:
 *
 * - A point in 4D space.
 * - A direction and length in 4D space. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
 * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
 * - Any arbitrary ordered quadruplet of numbers.
 *
 * There are other things a 4D vector can be used to represent, however these
 * are the most common uses in *three.js*.
 *
 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector4( 0, 1, 0, 0 );
 *
 * //no arguments; will be initialised to (0, 0, 0, 1)
 * const b = new THREE.Vector4( );
 *
 * const d = a.dot( b );
 * ```
 */
class Vector4 {

	/**
	 * Constructs a new 4D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 * @param {number} [z=0] - The z value of this vector.
	 * @param {number} [w=1] - The w value of this vector.
	 */
	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector4.prototype.isVector4 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

		/**
		 * The z value of this vector.
		 *
		 * @type {number}
		 */
		this.z = z;

		/**
		 * The w value of this vector.
		 *
		 * @type {number}
		 */
		this.w = w;

	}

	/**
	 * Alias for {@link Vector4#z}.
	 *
	 * @type {number}
	 */
	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	/**
	 * Alias for {@link Vector4#w}.
	 *
	 * @type {number}
	 */
	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @param {number} z - The value of the z component.
	 * @param {number} w - The value of the w component.
	 * @return {Vector4} A reference to this vector.
	 */
	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector4} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Sets the vector's z component to the given value
	 *
	 * @param {number} z - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setZ( z ) {

		this.z = z;

		return this;

	}

	/**
	 * Sets the vector's w component to the given value
	 *
	 * @param {number} w - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setW( w ) {

		this.w = w;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
	 * `2` equals to z, `3` equals to w.
	 * @param {number} value - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
	 * `2` equals to z, `3` equals to w.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector4} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector3|Vector4} v - The vector to copy.
	 * @return {Vector4} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector4} v - The vector to add.
	 * @return {Vector4} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector4} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector4} a - The first vector.
	 * @param {Vector4} b - The second vector.
	 * @return {Vector4} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector4} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector4} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector4} v - The vector to subtract.
	 * @return {Vector4} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector4} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector4} a - The first vector.
	 * @param {Vector4} b - The second vector.
	 * @return {Vector4} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector4} v - The vector to multiply.
	 * @return {Vector4} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector4} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	/**
	 * Multiplies this vector with the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector4} v - The vector to divide.
	 * @return {Vector4} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		this.w /= v.w;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector4} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * Sets the x, y and z components of this
	 * vector to the quaternion's axis and w to the angle.
	 *
	 * @param {Quaternion} q - The Quaternion to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	/**
	 * Sets the x, y and z components of this
	 * vector to the axis of rotation and w to the angle.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	/**
	 * Sets the vector components to the position elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];
		this.w = e[ 15 ];

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector4} v - The vector.
	 * @return {Vector4} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector4} v - The vector.
	 * @return {Vector4} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
	 * value, it is replaced by the corresponding value.
	 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector4} min - The minimum x, y and z values.
	 * @param {Vector4} max - The maximum x, y and z values in the desired range.
	 * @return {Vector4} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );
		this.z = clamp( this.z, min.z, max.z );
		this.w = clamp( this.w, min.w, max.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x, y, z or w values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector4} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );
		this.z = clamp( this.z, minVal, maxVal );
		this.w = clamp( this.w, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector4} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );
		this.w = Math.trunc( this.w );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector4} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector4} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector4} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector4} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector4} v1 - The first vector.
	 * @param {Vector4} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector4} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector4} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
	 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector4} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector4} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/**
 * A render target is a buffer where the video card draws pixels for a scene
 * that is being rendered in the background. It is used in different effects,
 * such as applying postprocessing to a rendered image before displaying it
 * on the screen.
 *
 * @augments EventDispatcher
 */
class RenderTarget extends EventDispatcher {

	/**
	 * Render target options.
	 *
	 * @typedef {Object} RenderTarget~Options
	 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
	 * @property {number} [magFilter=LinearFilter] - The mag filter.
	 * @property {number} [minFilter=LinearFilter] - The min filter.
	 * @property {number} [format=RGBAFormat] - The texture format.
	 * @property {number} [type=UnsignedByteType] - The texture type.
	 * @property {?string} [internalFormat=null] - The texture's internal format.
	 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	 * @property {number} [anisotropy=1] - The texture's anisotropy value.
	 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
	 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
	 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
	 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
	 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
	 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
	 * @property {number} [samples=0] - The MSAA samples count.
	 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
	 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
	 */

	/**
	 * Constructs a new render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, options = {} ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isRenderTarget = true;

		/**
		 * The width of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.width = width;

		/**
		 * The height of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.height = height;

		/**
		 * The depth of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.depth = options.depth ? options.depth : 1;

		/**
		 * A rectangular area inside the render target's viewport. Fragments that are
		 * outside the area will be discarded.
		 *
		 * @type {Vector4}
		 * @default (0,0,width,height)
		 */
		this.scissor = new Vector4( 0, 0, width, height );

		/**
		 * Indicates whether the scissor test should be enabled when rendering into
		 * this render target or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.scissorTest = false;

		/**
		 * A rectangular area representing the render target's viewport.
		 *
		 * @type {Vector4}
		 * @default (0,0,width,height)
		 */
		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: this.depth };

		options = Object.assign( {
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1,
			multiview: false
		}, options );

		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		texture.flipY = false;
		texture.generateMipmaps = options.generateMipmaps;
		texture.internalFormat = options.internalFormat;

		/**
		 * An array of textures. Each color attachment is represented as a separate texture.
		 * Has at least a single entry for the default color attachment.
		 *
		 * @type {Array<Texture>}
		 */
		this.textures = [];

		const count = options.count;
		for ( let i = 0; i < count; i ++ ) {

			this.textures[ i ] = texture.clone();
			this.textures[ i ].isRenderTargetTexture = true;
			this.textures[ i ].renderTarget = this;

		}

		/**
		 * Whether to allocate a depth buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthBuffer = options.depthBuffer;

		/**
		 * Whether to allocate a stencil buffer or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.stencilBuffer = options.stencilBuffer;

		/**
		 * Whether to resolve the depth buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.resolveDepthBuffer = options.resolveDepthBuffer;

		/**
		 * Whether to resolve the stencil buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.resolveStencilBuffer = options.resolveStencilBuffer;

		this._depthTexture = null;
		this.depthTexture = options.depthTexture;

		/**
		 * The number of MSAA samples.
		 *
		 * A value of `0` disables MSAA.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.samples = options.samples;

		/**
		 * Whether to this target is used in multiview rendering.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.multiview = options.multiview;

	}

	/**
	 * The texture representing the default color attachment.
	 *
	 * @type {Texture}
	 */
	get texture() {

		return this.textures[ 0 ];

	}

	set texture( value ) {

		this.textures[ 0 ] = value;

	}

	set depthTexture( current ) {

		if ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;
		if ( current !== null ) current.renderTarget = this;

		this._depthTexture = current;

	}

	/**
	 * Instead of saving the depth in a renderbuffer, a texture
	 * can be used instead which is useful for further processing
	 * e.g. in context of post-processing.
	 *
	 * @type {?DepthTexture}
	 * @default null
	 */
	get depthTexture() {

		return this._depthTexture;

	}

	/**
	 * Sets the size of this render target.
	 *
	 * @param {number} width - The width.
	 * @param {number} height - The height.
	 * @param {number} [depth=1] - The depth.
	 */
	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

				this.textures[ i ].image.width = width;
				this.textures[ i ].image.height = height;
				this.textures[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	/**
	 * Returns a new render target with copied values from this instance.
	 *
	 * @return {RenderTarget} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the settings of the given render target. This is a structural copy so
	 * no resources are shared between render targets after the copy. That includes
	 * all MRT textures and the depth texture.
	 *
	 * @param {RenderTarget} source - The render target to copy.
	 * @return {RenderTarget} A reference to this instance.
	 */
	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.scissor.copy( source.scissor );
		this.scissorTest = source.scissorTest;

		this.viewport.copy( source.viewport );

		this.textures.length = 0;

		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

			this.textures[ i ] = source.textures[ i ].clone();
			this.textures[ i ].isRenderTargetTexture = true;
			this.textures[ i ].renderTarget = this;

			// ensure image object is not shared, see #20328

			const image = Object.assign( {}, source.textures[ i ].image );
			this.textures[ i ].source = new Source( image );

		}

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires RenderTarget#dispose
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

/**
 * A render target used in context of {@link WebGLRenderer}.
 *
 * @augments RenderTarget
 */
class WebGLRenderTarget extends RenderTarget {

	/**
	 * Constructs a new 3D render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, options = {} ) {

		super( width, height, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLRenderTarget = true;

	}

}

/**
 * Creates an array of textures directly from raw buffer data.
 *
 * @augments Texture
 */
class DataArrayTexture extends Texture {

	/**
	 * Constructs a new data array texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDataArrayTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
		 */
		this.image = { data, width, height, depth };

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.magFilter = NearestFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.minFilter = NearestFilter;

		/**
		 * This defines how the texture is wrapped in the depth and corresponds to
		 * *W* in UVW mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapR = ClampToEdgeWrapping;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

		/**
		 * A set of all layers which need to be updated in the texture.
		 *
		 * @type {Set<number>}
		 */
		this.layerUpdates = new Set();

	}

	/**
	 * Describes that a specific layer of the texture needs to be updated.
	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
	 * entire data texture array is sent to the GPU. Marking specific
	 * layers will only transmit subsets of all mipmaps associated with a
	 * specific depth in the array which is often much more performant.
	 *
	 * @param {number} layerIndex - The layer index that should be updated.
	 */
	addLayerUpdate( layerIndex ) {

		this.layerUpdates.add( layerIndex );

	}

	/**
	 * Resets the layer updates registry.
	 */
	clearLayerUpdates() {

		this.layerUpdates.clear();

	}

}

/**
 * An array render target used in context of {@link WebGLRenderer}.
 *
 * @augments WebGLRenderTarget
 */
class WebGLArrayRenderTarget extends WebGLRenderTarget {

	/**
	 * Constructs a new array render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {number} [depth=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLArrayRenderTarget = true;

		this.depth = depth;

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {DataArrayTexture}
		 */
		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

/**
 * Creates a three-dimensional texture from raw data, with parameters to
 * divide it into width, height, and depth.
 *
 * @augments Texture
 */
class Data3DTexture extends Texture {

	/**
	 * Constructs a new data array texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in Data3DTexture directly.
		//
		//	const texture = new THREE.Data3DTexture( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isData3DTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
		 */
		this.image = { data, width, height, depth };

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.magFilter = NearestFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.minFilter = NearestFilter;

		/**
		 * This defines how the texture is wrapped in the depth and corresponds to
		 * *W* in UVW mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapR = ClampToEdgeWrapping;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

	}

}

/**
 * A 3D render target used in context of {@link WebGLRenderer}.
 *
 * @augments WebGLRenderTarget
 */
class WebGL3DRenderTarget extends WebGLRenderTarget {

	/**
	 * Constructs a new 3D render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {number} [depth=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGL3DRenderTarget = true;

		this.depth = depth;

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {Data3DTexture}
		 */
		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

/**
 * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
 *
 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
 * the corresponding order.
 *
 * Note that three.js expects Quaternions to be normalized.
 * ```js
 * const quaternion = new THREE.Quaternion();
 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
 *
 * const vector = new THREE.Vector3( 1, 0, 0 );
 * vector.applyQuaternion( quaternion );
 * ```
 */
class Quaternion {

	/**
	 * Constructs a new quaternion.
	 *
	 * @param {number} [x=0] - The x value of this quaternion.
	 * @param {number} [y=0] - The y value of this quaternion.
	 * @param {number} [z=0] - The z value of this quaternion.
	 * @param {number} [w=1] - The w value of this quaternion.
	 */
	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	/**
	 * Interpolates between two quaternions via SLERP. This implementation assumes the
	 * quaternion data are managed  in flat arrays.
	 *
	 * @param {Array<number>} dst - The destination array.
	 * @param {number} dstOffset - An offset into the destination array.
	 * @param {Array<number>} src0 - The source array of the first quaternion.
	 * @param {number} srcOffset0 - An offset into the first source array.
	 * @param {Array<number>} src1 -  The source array of the second quaternion.
	 * @param {number} srcOffset1 - An offset into the second source array.
	 * @param {number} t - The interpolation factor in the range `[0,1]`.
	 * @see {@link Quaternion#slerp}
	 */
	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : -1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	/**
	 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
	 * in flat arrays.
	 *
	 * @param {Array<number>} dst - The destination array.
	 * @param {number} dstOffset - An offset into the destination array.
	 * @param {Array<number>} src0 - The source array of the first quaternion.
	 * @param {number} srcOffset0 - An offset into the first source array.
	 * @param {Array<number>} src1 -  The source array of the second quaternion.
	 * @param {number} srcOffset1 - An offset into the second source array.
	 * @return {Array<number>} The destination array.
	 * @see {@link Quaternion#multiplyQuaternions}.
	 */
	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	/**
	 * The x value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	/**
	 * The y value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	/**
	 * The z value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	/**
	 * The w value of this quaternion.
	 *
	 * @type {number}
	 * @default 1
	 */
	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	/**
	 * Sets the quaternion components.
	 *
	 * @param {number} x - The x value of this quaternion.
	 * @param {number} y - The y value of this quaternion.
	 * @param {number} z - The z value of this quaternion.
	 * @param {number} w - The w value of this quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Returns a new quaternion with copied values from this instance.
	 *
	 * @return {Quaternion} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	/**
	 * Copies the values of the given quaternion to this instance.
	 *
	 * @param {Quaternion} quaternion - The quaternion to copy.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the rotation specified by the given
	 * Euler angles.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromEuler( euler, update = true ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the given axis and angle.
	 *
	 * @param {Vector3} axis - The normalized axis.
	 * @param {number} angle - The angle in radians.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the given rotation matrix.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion to the rotation required to rotate the direction vector
	 * `vFrom` to the direction vector `vTo`.
	 *
	 * @param {Vector3} vFrom - The first (normalized) direction vector.
	 * @param {Vector3} vTo - The second (normalized) direction vector.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	/**
	 * Returns the angle between this quaternion and the given one in radians.
	 *
	 * @param {Quaternion} q - The quaternion to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );

	}

	/**
	 * Rotates this quaternion by a given angular step to the given quaternion.
	 * The method ensures that the final quaternion will not overshoot `q`.
	 *
	 * @param {Quaternion} q - The target quaternion.
	 * @param {number} step - The angular step in radians.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	/**
	 * Sets this quaternion to the identity quaternion; that is, to the
	 * quaternion that represents "no rotation".
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	/**
	 * Inverts this quaternion via {@link Quaternion#conjugate}. The
	 * quaternion is assumed to have unit length.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	invert() {

		return this.conjugate();

	}

	/**
	 * Returns the rotational conjugate of this quaternion. The conjugate of a
	 * quaternion represents the same rotation in the opposite direction about
	 * the rotational axis.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	conjugate() {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Calculates the dot product of this quaternion and the given one.
	 *
	 * @param {Quaternion} v - The quaternion to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	/**
	 * Computes the squared Euclidean length (straight-line length) of this quaternion,
	 * considered as a 4 dimensional vector. This can be useful if you are comparing the
	 * lengths of two quaternions, as this is a slightly more efficient calculation than
	 * {@link Quaternion#length}.
	 *
	 * @return {number} The squared Euclidean length.
	 */
	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	/**
	 * Computes the Euclidean length (straight-line length) of this quaternion,
	 * considered as a 4 dimensional vector.
	 *
	 * @return {number} The Euclidean length.
	 */
	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	/**
	 * Normalizes this quaternion - that is, calculated the quaternion that performs
	 * the same rotation as this one, but has a length equal to `1`.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	/**
	 * Multiplies this quaternion by the given one.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	/**
	 * Pre-multiplies this quaternion by the given one.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	/**
	 * Multiplies the given quaternions and stores the result in this instance.
	 *
	 * @param {Quaternion} a - The first quaternion.
	 * @param {Quaternion} b - The second quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Performs a spherical linear interpolation between quaternions.
	 *
	 * @param {Quaternion} qb - The target quaternion.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize(); // normalize calls _onChangeCallback()

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	/**
	 * Performs a spherical linear interpolation between the given quaternions
	 * and stores the result in this quaternion.
	 *
	 * @param {Quaternion} qa - The source quaternion.
	 * @param {Quaternion} qb - The target quaternion.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	/**
	 * Sets this quaternion to a uniformly random, normalized quaternion.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	random() {

		// Ken Shoemake
		// Uniform random rotations
		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();

		const x0 = Math.random();
		const r1 = Math.sqrt( 1 - x0 );
		const r2 = Math.sqrt( x0 );

		return this.set(
			r1 * Math.sin( theta1 ),
			r1 * Math.cos( theta1 ),
			r2 * Math.sin( theta2 ),
			r2 * Math.cos( theta2 ),
		);

	}

	/**
	 * Returns `true` if this quaternion is equal with the given one.
	 *
	 * @param {Quaternion} quaternion - The quaternion to test for equality.
	 * @return {boolean} Whether this quaternion is equal with the given one.
	 */
	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	/**
	 * Sets this quaternion's components from the given array.
	 *
	 * @param {Array<number>} array - An array holding the quaternion component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	/**
	 * Writes the components of this quaternion to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The quaternion components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	/**
	 * Sets the components of this quaternion from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
	 * @param {number} index - The index into the attribute.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		this._onChangeCallback();

		return this;

	}

	/**
	 * This methods defines the serialization result of this class. Returns the
	 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
	 *
	 * @return {Array<number>} The serialized quaternion.
	 */
	toJSON() {

		return this.toArray();

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

/**
 * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
 * (labeled x, y and z), which can be used to represent a number of things, such as:
 *
 * - A point in 3D space.
 * - A direction and length in 3D space. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
 * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
 * - Any arbitrary ordered triplet of numbers.
 *
 * There are other things a 3D vector can be used to represent, such as
 * momentum vectors and so on, however these are the most
 * common uses in three.js.
 *
 * Iterating through a vector instance will yield its components `(x, y, z)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector3( 0, 1, 0 );
 *
 * //no arguments; will be initialised to (0, 0, 0)
 * const b = new THREE.Vector3( );
 *
 * const d = a.distanceTo( b );
 * ```
 */
class Vector3 {

	/**
	 * Constructs a new 3D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 * @param {number} [z=0] - The z value of this vector.
	 */
	constructor( x = 0, y = 0, z = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector3.prototype.isVector3 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

		/**
		 * The z value of this vector.
		 *
		 * @type {number}
		 */
		this.z = z;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @param {number} z - The value of the z component.
	 * @return {Vector3} A reference to this vector.
	 */
	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector3} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Sets the vector's z component to the given value
	 *
	 * @param {number} z - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setZ( z ) {

		this.z = z;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	 * @param {number} value - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector3} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to copy.
	 * @return {Vector3} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to add.
	 * @return {Vector3} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector3} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector3|Vector4} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector3} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector3} v - The vector to subtract.
	 * @return {Vector3} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector3} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to multiply.
	 * @return {Vector3} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector3} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	/**
	 * Multiplies the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	/**
	 * Applies the given Euler rotation to this vector.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @return {Vector3} A reference to this vector.
	 */
	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	/**
	 * Applies a rotation specified by an axis and an angle to this vector.
	 *
	 * @param {Vector3} axis - A normalized vector representing the rotation axis.
	 * @param {number} angle - The angle in radians.
	 * @return {Vector3} A reference to this vector.
	 */
	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	/**
	 * Multiplies this vector with the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	/**
	 * Multiplies this vector by the given normal matrix and normalizes
	 * the result.
	 *
	 * @param {Matrix3} m - The normal matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	/**
	 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
	 * divides by perspective.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {Vector3} A reference to this vector.
	 */
	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	/**
	 * Applies the given Quaternion to this vector.
	 *
	 * @param {Quaternion} q - The Quaternion.
	 * @return {Vector3} A reference to this vector.
	 */
	applyQuaternion( q ) {

		// quaternion q is assumed to have unit length

		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// t = 2 * cross( q.xyz, v );
		const tx = 2 * ( qy * vz - qz * vy );
		const ty = 2 * ( qz * vx - qx * vz );
		const tz = 2 * ( qx * vy - qy * vx );

		// v + q.w * t + cross( q.xyz, t );
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;

		return this;

	}

	/**
	 * Projects this vector from world space into the camera's normalized
	 * device coordinate (NDC) space.
	 *
	 * @param {Camera} camera - The camera.
	 * @return {Vector3} A reference to this vector.
	 */
	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	/**
	 * Unprojects this vector from the camera's normalized device coordinate (NDC)
	 * space into world space.
	 *
	 * @param {Camera} camera - The camera.
	 * @return {Vector3} A reference to this vector.
	 */
	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	/**
	 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
	 * subset of the given 4x4 matrix and then normalizes the result.
	 *
	 * @param {Matrix4} m - The matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector3} v - The vector to divide.
	 * @return {Vector3} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector3} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * If this vector's x, y or z value is greater than the given vector's x, y or z
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector3} v - The vector.
	 * @return {Vector3} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	/**
	 * If this vector's x, y or z value is less than the given vector's x, y or z
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector3} v - The vector.
	 * @return {Vector3} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	/**
	 * If this vector's x, y or z value is greater than the max vector's x, y or z
	 * value, it is replaced by the corresponding value.
	 * If this vector's x, y or z value is less than the min vector's x, y or z value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector3} min - The minimum x, y and z values.
	 * @param {Vector3} max - The maximum x, y and z values in the desired range.
	 * @return {Vector3} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );
		this.z = clamp( this.z, min.z, max.z );

		return this;

	}

	/**
	 * If this vector's x, y or z values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x, y or z values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector3} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );
		this.z = clamp( this.z, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector3} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector3} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector3} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector3} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector3} v1 - The first vector.
	 * @param {Vector3} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector3} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	/**
	 * Calculates the cross product of the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to compute the cross product with.
	 * @return {Vector3} The result of the cross product.
	 */
	cross( v ) {

		return this.crossVectors( this, v );

	}

	/**
	 * Calculates the cross product of the given vectors and stores the result
	 * in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	/**
	 * Projects this vector onto the given one.
	 *
	 * @param {Vector3} v - The vector to project to.
	 * @return {Vector3} A reference to this vector.
	 */
	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	/**
	 * Projects this vector onto a plane by subtracting this
	 * vector projected onto the plane's normal from this vector.
	 *
	 * @param {Vector3} planeNormal - The plane normal.
	 * @return {Vector3} A reference to this vector.
	 */
	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	/**
	 * Reflects this vector off a plane orthogonal to the given normal vector.
	 *
	 * @param {Vector3} normal - The (normalized) normal vector.
	 * @return {Vector3} A reference to this vector.
	 */
	reflect( normal ) {

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}
	/**
	 * Returns the angle between the given vector and this instance in radians.
	 *
	 * @param {Vector3} v - The vector to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, -1, 1 ) );

	}

	/**
	 * Computes the distance from the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	/**
	 * Computes the squared distance from the given vector to this instance.
	 * If you are just comparing the distance with another distance, you should compare
	 * the distance squared instead as it is slightly more efficient to calculate.
	 *
	 * @param {Vector3} v - The vector to compute the squared distance to.
	 * @return {number} The squared distance.
	 */
	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	/**
	 * Computes the Manhattan distance from the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to compute the Manhattan distance to.
	 * @return {number} The Manhattan distance.
	 */
	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	/**
	 * Sets the vector components from the given spherical coordinates.
	 *
	 * @param {Spherical} s - The spherical coordinates.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	/**
	 * Sets the vector components from the given spherical coordinates.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} phi - The phi angle in radians.
	 * @param {number} theta - The theta angle in radians.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	/**
	 * Sets the vector components from the given cylindrical coordinates.
	 *
	 * @param {Cylindrical} c - The cylindrical coordinates.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	/**
	 * Sets the vector components from the given cylindrical coordinates.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} theta - The theta angle in radians.
	 * @param {number} y - The y value.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	/**
	 * Sets the vector components to the position elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	/**
	 * Sets the vector components to the scale elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	/**
	 * Sets the vector components from the specified matrix column.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @param {number} index - The column index.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	/**
	 * Sets the vector components from the specified matrix column.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @param {number} index - The column index.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	/**
	 * Sets the vector components from the given Euler angles.
	 *
	 * @param {Euler} e - The Euler angles to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	/**
	 * Sets the vector components from the RGB components of the
	 * given color.
	 *
	 * @param {Color} c - The color to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromColor( c ) {

		this.x = c.r;
		this.y = c.g;
		this.z = c.b;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector3} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
	 * and z value to be `array[ offset + 2 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector3} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector3} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	/**
	 * Sets this vector to a uniformly random point on a unit sphere.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	randomDirection() {

		// https://mathworld.wolfram.com/SpherePointPicking.html

		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c = Math.sqrt( 1 - u * u );

		this.x = c * Math.cos( theta );
		this.y = u;
		this.z = c * Math.sin( theta );

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

/**
 * Represents an axis-aligned bounding box (AABB) in 3D space.
 */
class Box3 {

	/**
	 * Constructs a new bounding box.
	 *
	 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
	 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
	 */
	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBox3 = true;

		/**
		 * The lower boundary of the box.
		 *
		 * @type {Vector3}
		 */
		this.min = min;

		/**
		 * The upper boundary of the box.
		 *
		 * @type {Vector3}
		 */
		this.max = max;

	}

	/**
	 * Sets the lower and upper boundaries of this box.
	 * Please note that this method only copies the values from the given objects.
	 *
	 * @param {Vector3} min - The lower boundary of the box.
	 * @param {Vector3} max - The upper boundary of the box.
	 * @return {Box3} A reference to this bounding box.
	 */
	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given array.
	 *
	 * @param {Array<number>} array - An array holding 3D position data.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromArray( array ) {

		this.makeEmpty();

		for ( let i = 0, il = array.length; i < il; i += 3 ) {

			this.expandByPoint( _vector$b.fromArray( array, i ) );

		}

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromBufferAttribute( attribute ) {

		this.makeEmpty();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

		}

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given array.
	 *
	 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	/**
	 * Centers this box on the given center vector and sets this box's width, height and
	 * depth to the given size values.
	 *
	 * @param {Vector3} center - The center of the box.
	 * @param {Vector3} size - The x, y and z dimensions of the box.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	/**
	 * Computes the world-axis-aligned bounding box for the given 3D object
	 * (including its children), accounting for the object's, and children's,
	 * world transforms. The function may result in a larger box than strictly necessary.
	 *
	 * @param {Object3D} object - The 3D object to compute the bounding box for.
	 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
	 * world-axis-aligned bounding box at the expense of more computation.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	/**
	 * Returns a new box with copied values from this instance.
	 *
	 * @return {Box3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given box to this instance.
	 *
	 * @param {Box3} box - The box to copy.
	 * @return {Box3} A reference to this bounding box.
	 */
	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	/**
	 * Makes this box empty which means in encloses a zero space in 3D.
	 *
	 * @return {Box3} A reference to this bounding box.
	 */
	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	/**
	 * Returns true if this box includes zero points within its bounds.
	 * Note that a box with equal lower and upper bounds still includes one
	 * point, the one both bounds share.
	 *
	 * @return {boolean} Whether this box is empty or not.
	 */
	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	/**
	 * Returns the center point of this box.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The center point.
	 */
	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	/**
	 * Returns the dimensions of this box.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The size.
	 */
	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	/**
	 * Expands the boundaries of this box to include the given point.
	 *
	 * @param {Vector3} point - The point that should be included by the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	/**
	 * Expands this box equilaterally by the given vector. The width of this
	 * box will be expanded by the x component of the vector in both
	 * directions. The height of this box will be expanded by the y component of
	 * the vector in both directions. The depth of this box will be
	 * expanded by the z component of the vector in both directions.
	 *
	 * @param {Vector3} vector - The vector that should expand the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	/**
	 * Expands each dimension of the box by the given scalar. If negative, the
	 * dimensions of the box will be contracted.
	 *
	 * @param {number} scalar - The scalar value that should expand the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	/**
	 * Expands the boundaries of this box to include the given 3D object and
	 * its children, accounting for the object's, and children's, world
	 * transforms. The function may result in a larger box than strictly
	 * necessary (unless the precise parameter is set to true).
	 *
	 * @param {Object3D} object - The 3D object that should expand the bounding box.
	 * @param {boolean} precise - If set to `true`, the method expands the bounding box
	 * as little as necessary at the expense of more computation.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			const positionAttribute = geometry.getAttribute( 'position' );

			// precise AABB computation based on vertex data requires at least a position attribute.
			// instancing isn't supported so far and uses the normal (conservative) code path.

			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					if ( object.isMesh === true ) {

						object.getVertexPosition( i, _vector$b );

					} else {

						_vector$b.fromBufferAttribute( positionAttribute, i );

					}

					_vector$b.applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( object.boundingBox !== undefined ) {

					// object-level bounding box

					if ( object.boundingBox === null ) {

						object.computeBoundingBox();

					}

					_box$4.copy( object.boundingBox );


				} else {

					// geometry-level bounding box

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );

				}

				_box$4.applyMatrix4( object.matrixWorld );

				this.union( _box$4 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	/**
	 * Returns `true` if the given point lies within or on the boundaries of this box.
	 *
	 * @param {Vector3} point - The point to test.
	 * @return {boolean} Whether the bounding box contains the given point or not.
	 */
	containsPoint( point ) {

		return point.x >= this.min.x && point.x <= this.max.x &&
			point.y >= this.min.y && point.y <= this.max.y &&
			point.z >= this.min.z && point.z <= this.max.z;

	}

	/**
	 * Returns `true` if this bounding box includes the entirety of the given bounding box.
	 * If this box and the given one are identical, this function also returns `true`.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the bounding box contains the given bounding box or not.
	 */
	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	/**
	 * Returns a point as a proportion of this box's width, height and depth.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} A point as a proportion of this box's width, height and depth.
	 */
	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	/**
	 * Returns `true` if the given bounding box intersects with this bounding box.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with this bounding box.
	 */
	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
			box.max.y >= this.min.y && box.min.y <= this.max.y &&
			box.max.z >= this.min.z && box.min.z <= this.max.z;

	}

	/**
	 * Returns `true` if the given bounding sphere intersects with this bounding box.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
	 */
	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	/**
	 * Returns `true` if the given plane intersects with this bounding box.
	 *
	 * @param {Plane} plane - The plane to test.
	 * @return {boolean} Whether the given plane intersects with this bounding box.
	 */
	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	/**
	 * Returns `true` if the given triangle intersects with this bounding box.
	 *
	 * @param {Triangle} triangle - The triangle to test.
	 * @return {boolean} Whether the given triangle intersects with this bounding box.
	 */
	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	/**
	 * Clamps the given point within the bounds of this box.
	 *
	 * @param {Vector3} point - The point to clamp.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The clamped point.
	 */
	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	/**
	 * Returns the euclidean distance from any edge of this box to the specified point. If
	 * the given point lies inside of this box, the distance will be `0`.
	 *
	 * @param {Vector3} point - The point to compute the distance to.
	 * @return {number} The euclidean distance.
	 */
	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	/**
	 * Returns a bounding sphere that encloses this bounding box.
	 *
	 * @param {Sphere} target - The target sphere that is used to store the method's result.
	 * @return {Sphere} The bounding sphere that encloses this bounding box.
	 */
	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	/**
	 * Computes the intersection of this bounding box and the given one, setting the upper
	 * bound of this box to the lesser of the two boxes' upper bounds and the
	 * lower bound of this box to the greater of the two boxes' lower bounds. If
	 * there's no overlap, makes this box empty.
	 *
	 * @param {Box3} box - The bounding box to intersect with.
	 * @return {Box3} A reference to this bounding box.
	 */
	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	/**
	 * Computes the union of this box and another and the given one, setting the upper
	 * bound of this box to the greater of the two boxes' upper bounds and the
	 * lower bound of this box to the lesser of the two boxes' lower bounds.
	 *
	 * @param {Box3} box - The bounding box that will be unioned with this instance.
	 * @return {Box3} A reference to this bounding box.
	 */
	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	/**
	 * Transforms this bounding box by the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @return {Box3} A reference to this bounding box.
	 */
	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	/**
	 * Adds the given offset to both the upper and lower bounds of this bounding box,
	 * effectively moving it in 3D space.
	 *
	 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	/**
	 * Returns `true` if this bounding box is equal with the given one.
	 *
	 * @param {Box3} box - The box to test for equality.
	 * @return {boolean} Whether this bounding box is equal with the given one.
	 */
	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$4 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$3 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

/**
 * An analytical 3D sphere defined by a center and radius. This class is mainly
 * used as a Bounding Sphere for 3D objects.
 */
class Sphere {

	/**
	 * Constructs a new sphere.
	 *
	 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
	 * @param {number} [radius=-1] - The radius of the sphere.
	 */
	constructor( center = new Vector3(), radius = -1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSphere = true;

		/**
		 * The center of the sphere
		 *
		 * @type {Vector3}
		 */
		this.center = center;

		/**
		 * The radius of the sphere.
		 *
		 * @type {number}
		 */
		this.radius = radius;

	}

	/**
	 * Sets the sphere's components by copying the given values.
	 *
	 * @param {Vector3} center - The center.
	 * @param {number} radius - The radius.
	 * @return {Sphere} A reference to this sphere.
	 */
	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	/**
	 * Computes the minimum bounding sphere for list of points.
	 * If the optional center point is given, it is used as the sphere's
	 * center. Otherwise, the center of the axis-aligned bounding box
	 * encompassing the points is calculated.
	 *
	 * @param {Array<Vector3>} points - A list of points in 3D space.
	 * @param {Vector3} [optionalCenter] - The center of the sphere.
	 * @return {Sphere} A reference to this sphere.
	 */
	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$3.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	/**
	 * Copies the values of the given sphere to this instance.
	 *
	 * @param {Sphere} sphere - The sphere to copy.
	 * @return {Sphere} A reference to this sphere.
	 */
	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	/**
	 * Returns `true` if the sphere is empty (the radius set to a negative number).
	 *
	 * Spheres with a radius of `0` contain only their center point and are not
	 * considered to be empty.
	 *
	 * @return {boolean} Whether this sphere is empty or not.
	 */
	isEmpty() {

		return ( this.radius < 0 );

	}

	/**
	 * Makes this sphere empty which means in encloses a zero space in 3D.
	 *
	 * @return {Sphere} A reference to this sphere.
	 */
	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = -1;

		return this;

	}

	/**
	 * Returns `true` if this sphere contains the given point inclusive of
	 * the surface of the sphere.
	 *
	 * @param {Vector3} point - The point to check.
	 * @return {boolean} Whether this sphere contains the given point or not.
	 */
	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	/**
	 * Returns the closest distance from the boundary of the sphere to the
	 * given point. If the sphere contains the point, the distance will
	 * be negative.
	 *
	 * @param {Vector3} point - The point to compute the distance to.
	 * @return {number} The distance to the point.
	 */
	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	/**
	 * Returns `true` if this sphere intersects with the given one.
	 *
	 * @param {Sphere} sphere - The sphere to test.
	 * @return {boolean} Whether this sphere intersects with the given one or not.
	 */
	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	/**
	 * Returns `true` if this sphere intersects with the given box.
	 *
	 * @param {Box3} box - The box to test.
	 * @return {boolean} Whether this sphere intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	/**
	 * Returns `true` if this sphere intersects with the given plane.
	 *
	 * @param {Plane} plane - The plane to test.
	 * @return {boolean} Whether this sphere intersects with the given plane or not.
	 */
	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	/**
	 * Clamps a point within the sphere. If the point is outside the sphere, it
	 * will clamp it to the closest point on the edge of the sphere. Points
	 * already inside the sphere will not be affected.
	 *
	 * @param {Vector3} point - The plane to clamp.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The clamped point.
	 */
	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	/**
	 * Returns a bounding box that encloses this sphere.
	 *
	 * @param {Box3} target - The target box that is used to store the method's result.
	 * @return {Box3} The bounding box that encloses this sphere.
	 */
	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	/**
	 * Transforms this sphere with the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @return {Sphere} A reference to this sphere.
	 */
	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	/**
	 * Translates the sphere's center by the given offset.
	 *
	 * @param {Vector3} offset - The offset.
	 * @return {Sphere} A reference to this sphere.
	 */
	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	/**
	 * Expands the boundaries of this sphere to include the given point.
	 *
	 * @param {Vector3} point - The point to include.
	 * @return {Sphere} A reference to this sphere.
	 */
	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	/**
	 * Expands this sphere to enclose both the original sphere and the given sphere.
	 *
	 * @param {Sphere} sphere - The sphere to include.
	 * @return {Sphere} A reference to this sphere.
	 */
	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	/**
	 * Returns `true` if this sphere is equal with the given one.
	 *
	 * @param {Sphere} sphere - The sphere to test for equality.
	 * @return {boolean} Whether this bounding sphere is equal with the given one.
	 */
	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	/**
	 * Returns a new sphere with copied values from this instance.
	 *
	 * @return {Sphere} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

/**
 * A ray that emits from an origin in a certain direction. The class is used by
 * {@link Raycaster} to assist with raycasting. Raycasting is used for
 * mouse picking (working out what objects in the 3D space the mouse is over)
 * amongst other things.
 */
class Ray {

	/**
	 * Constructs a new ray.
	 *
	 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
	 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
	 */
	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

		/**
		 * The origin of the ray.
		 *
		 * @type {Vector3}
		 */
		this.origin = origin;

		/**
		 * The (normalized) direction of the ray.
		 *
		 * @type {Vector3}
		 */
		this.direction = direction;

	}

	/**
	 * Sets the ray's components by copying the given values.
	 *
	 * @param {Vector3} origin - The origin.
	 * @param {Vector3} direction - The direction.
	 * @return {Ray} A reference to this ray.
	 */
	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	/**
	 * Copies the values of the given ray to this instance.
	 *
	 * @param {Ray} ray - The ray to copy.
	 * @return {Ray} A reference to this ray.
	 */
	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	/**
	 * Returns a vector that is located at a given distance along this ray.
	 *
	 * @param {number} t - The distance along the ray to retrieve a position for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} A position on the ray.
	 */
	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	/**
	 * Adjusts the direction of the ray to point at the given vector in world space.
	 *
	 * @param {Vector3} v - The target position.
	 * @return {Ray} A reference to this ray.
	 */
	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	/**
	 * Shift the origin of this ray along its direction by the given distance.
	 *
	 * @param {number} t - The distance along the ray to interpolate.
	 * @return {Ray} A reference to this ray.
	 */
	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	/**
	 * Returns the point along this ray that is closest to the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The closest point on this ray.
	 */
	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	/**
	 * Returns the distance of the closest approach between this ray and the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	/**
	 * Returns the squared distance of the closest approach between this ray and the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to compute the distance to.
	 * @return {number} The squared distance.
	 */
	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	/**
	 * Returns the squared distance between this ray and the given line segment.
	 *
	 * @param {Vector3} v0 - The start point of the line segment.
	 * @param {Vector3} v1 - The end point of the line segment.
	 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
	 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
	 * @return {number} The squared distance.
	 */
	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	/**
	 * Intersects this ray with the given sphere, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Sphere} sphere - The sphere to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given sphere.
	 *
	 * @param {Sphere} sphere - The sphere to intersect.
	 * @return {boolean} Whether this ray intersects with the given sphere or not.
	 */
	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	/**
	 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
	 * does not intersect with the plane.
	 *
	 * @param {Plane} plane - The plane to compute the distance to.
	 * @return {?number} Whether this ray intersects with the given sphere or not.
	 */
	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	/**
	 * Intersects this ray with the given plane, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Plane} plane - The plane to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given plane.
	 *
	 * @param {Plane} plane - The plane to intersect.
	 * @return {boolean} Whether this ray intersects with the given plane or not.
	 */
	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	/**
	 * Intersects this ray with the given bounding box, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given box.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @return {boolean} Whether this ray intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	/**
	 * Intersects this ray with the given triangle, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Vector3} a - The first vertex of the triangle.
	 * @param {Vector3} b - The second vertex of the triangle.
	 * @param {Vector3} c - The third vertex of the triangle.
	 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = -1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	/**
	 * Transforms this ray with the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix4 - The transformation matrix.
	 * @return {Ray} A reference to this ray.
	 */
	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	/**
	 * Returns `true` if this ray is equal with the given one.
	 *
	 * @param {Ray} ray - The ray to test for equality.
	 * @return {boolean} Whether this ray is equal with the given one.
	 */
	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	/**
	 * Returns a new ray with copied values from this instance.
	 *
	 * @return {Ray} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Represents a 4x4 matrix.
 *
 * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
 * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}
 *
 * This allows a 3D vector representing a point in 3D space to undergo
 * transformations such as translation, rotation, shear, scale, reflection,
 * orthogonal or perspective projection and so on, by being multiplied by the
 * matrix. This is known as `applying` the matrix to the vector.
 *
 * A Note on Row-Major and Column-Major Ordering:
 *
 * The constructor and {@link Matrix3#set} method take arguments in
 * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
 * This means that calling:
 * ```js
 * const m = new THREE.Matrix4();
 * m.set( 11, 12, 13, 14,
 *        21, 22, 23, 24,
 *        31, 32, 33, 34,
 *        41, 42, 43, 44 );
 * ```
 * will result in the elements array containing:
 * ```js
 * m.elements = [ 11, 21, 31, 41,
 *                12, 22, 32, 42,
 *                13, 23, 33, 43,
 *                14, 24, 34, 44 ];
 * ```
 * and internally all calculations are performed using column-major ordering.
 * However, as the actual ordering makes no difference mathematically and
 * most people are used to thinking about matrices in row-major order, the
 * three.js documentation shows matrices in row-major order. Just bear in
 * mind that if you are reading the source code, you'll have to take the
 * transpose of any matrices outlined here to make sense of the calculations.
 */
class Matrix4 {

	/**
	 * Constructs a new 4x4 matrix. The arguments are supposed to be
	 * in row-major order. If no arguments are provided, the constructor
	 * initializes the matrix as an identity matrix.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n14] - 1-4 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n24] - 2-4 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @param {number} [n34] - 3-4 matrix element.
	 * @param {number} [n41] - 4-1 matrix element.
	 * @param {number} [n42] - 4-2 matrix element.
	 * @param {number} [n43] - 4-3 matrix element.
	 * @param {number} [n44] - 4-4 matrix element.
	 */
	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Matrix4.prototype.isMatrix4 = true;

		/**
		 * A column-major list of matrix values.
		 *
		 * @type {Array<number>}
		 */
		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

		}

	}

	/**
	 * Sets the elements of the matrix.The arguments are supposed to be
	 * in row-major order.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n14] - 1-4 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n24] - 2-4 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @param {number} [n34] - 3-4 matrix element.
	 * @param {number} [n41] - 4-1 matrix element.
	 * @param {number} [n42] - 4-2 matrix element.
	 * @param {number} [n43] - 4-3 matrix element.
	 * @param {number} [n44] - 4-4 matrix element.
	 * @return {Matrix4} A reference to this matrix.
	 */
	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	/**
	 * Sets this matrix to the 4x4 identity matrix.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Returns a matrix with copied values from this instance.
	 *
	 * @return {Matrix4} A clone of this instance.
	 */
	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	/**
	 * Copies the values of the given matrix to this instance.
	 *
	 * @param {Matrix4} m - The matrix to copy.
	 * @return {Matrix4} A reference to this matrix.
	 */
	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	/**
	 * Copies the translation component of the given matrix
	 * into this matrix's translation component.
	 *
	 * @param {Matrix4} m - The matrix to copy the translation component.
	 * @return {Matrix4} A reference to this matrix.
	 */
	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	/**
	 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Extracts the basis of this matrix into the three axis vectors provided.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	/**
	 * Sets the given basis vectors to this matrix.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	/**
	 * Extracts the rotation component of the given matrix
	 * into this matrix's rotation component.
	 *
	 * Note: This method does not support reflection matrices.
	 *
	 * @param {Matrix4} m - The matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	extractRotation( m ) {

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
	 * the rotation specified by the given Euler angles. The rest of
	 * the matrix is set to the identity. Depending on the {@link Euler#order},
	 * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
	 * for a complete list.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Sets the rotation component of this matrix to the rotation specified by
	 * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
	 * The rest of the matrix is set to the identity.
	 *
	 * @param {Quaternion} q - The Quaternion.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	/**
	 * Sets the rotation component of the transformation matrix, looking from `eye` towards
	 * `target`, and oriented by the up-direction.
	 *
	 * @param {Vector3} eye - The eye vector.
	 * @param {Vector3} target - The target vector.
	 * @param {Vector3} up - The up vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	/**
	 * Post-multiplies this matrix by the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The matrix to multiply with.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	/**
	 * Pre-multiplies this matrix by the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The matrix to multiply with.
	 * @return {Matrix4} A reference to this matrix.
	 */
	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	/**
	 * Multiples the given 4x4 matrices and stores the result
	 * in this matrix.
	 *
	 * @param {Matrix4} a - The first matrix.
	 * @param {Matrix4} b - The second matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	/**
	 * Multiplies every component of the matrix by the given scalar.
	 *
	 * @param {number} s - The scalar.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	/**
	 * Computes and returns the determinant of this matrix.
	 *
	 * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
	 *
	 * @return {number} The determinant.
	 */
	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	/**
	 * Transposes this matrix in place.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	/**
	 * Sets the position component for this matrix from the given vector,
	 * without affecting the rest of the matrix.
	 *
	 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
	 * @param {number} y - The y component of the vector.
	 * @param {number} z - The z component of the vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	/**
	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
	 * You can not invert with a determinant of zero. If you attempt this, the method produces
	 * a zero matrix instead.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	/**
	 * Multiplies the columns of this matrix by the given vector.
	 *
	 * @param {Vector3} v - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	/**
	 * Gets the maximum scale value of the three axes.
	 *
	 * @return {number} The maximum scale.
	 */
	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	/**
	 * Sets this matrix as a translation transform from the given vector.
	 *
	 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
	 * @param {number} y - The amount to translate in the Y axis.
	 * @param {number} z - The amount to translate in the z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeTranslation( x, y, z ) {

		if ( x.isVector3 ) {

			this.set(

				1, 0, 0, x.x,
				0, 1, 0, x.y,
				0, 0, 1, x.z,
				0, 0, 0, 1

			);

		} else {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

		}

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the X axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the Y axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the Z axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the given axis by
	 * the given angle.
	 *
	 * This is a somewhat controversial but mathematically sound alternative to
	 * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
	 *
	 * @param {Vector3} axis - The normalized rotation axis.
	 * @param {number} angle - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a scale transformation.
	 *
	 * @param {number} x - The amount to scale in the X axis.
	 * @param {number} y - The amount to scale in the Y axis.
	 * @param {number} z - The amount to scale in the Z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a shear transformation.
	 *
	 * @param {number} xy - The amount to shear X by Y.
	 * @param {number} xz - The amount to shear X by Z.
	 * @param {number} yx - The amount to shear Y by X.
	 * @param {number} yz - The amount to shear Y by Z.
	 * @param {number} zx - The amount to shear Z by X.
	 * @param {number} zy - The amount to shear Z by Y.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix to the transformation composed of the given position,
	 * rotation (Quaternion) and scale.
	 *
	 * @param {Vector3} position - The position vector.
	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
	 * @param {Vector3} scale - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Decomposes this matrix into its position, rotation and scale components
	 * and provides the result in the given objects.
	 *
	 * Note: Not all matrices are decomposable in this way. For example, if an
	 * object has a non-uniformly scaled parent, then the object's world matrix
	 * may not be decomposable, and this method may not be appropriate.
	 *
	 * @param {Vector3} position - The position vector.
	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
	 * @param {Vector3} scale - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	/**
	 * Creates a perspective projection matrix. This is used internally by
	 * {@link PerspectiveCamera#updateProjectionMatrix}.

	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	 * @param {number} near - The distance from the camera to the near plane.
	 * @param {number} far - The distance from the camera to the far plane.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			c = - ( far + near ) / ( far - near );
			d = ( -2 * far * near ) / ( far - near );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			c = - far / ( far - near );
			d = ( - far * near ) / ( far - near );

		} else {

			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

		return this;

	}

	/**
	 * Creates a orthographic projection matrix. This is used internally by
	 * {@link OrthographicCamera#updateProjectionMatrix}.

	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	 * @param {number} near - The distance from the camera to the near plane.
	 * @param {number} far - The distance from the camera to the far plane.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;

		let z, zInv;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			z = ( far + near ) * p;
			zInv = -2 * p;

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			z = near * p;
			zInv = -1 * p;

		} else {

			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Returns `true` if this matrix is equal with the given one.
	 *
	 * @param {Matrix4} matrix - The matrix to test for equality.
	 * @return {boolean} Whether this matrix is equal with the given one.
	 */
	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	/**
	 * Sets the elements of the matrix from the given array.
	 *
	 * @param {Array<number>} array - The matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Matrix4} A reference to this matrix.
	 */
	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	/**
	 * Writes the elements of this matrix to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The matrix elements in column-major order.
	 */
	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$2 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

/**
 * A class representing Euler angles.
 *
 * Euler angles describe a rotational transformation by rotating an object on
 * its various axes in specified amounts per axis, and a specified axis
 * order.
 *
 * Iterating through an instance will yield its components (x, y, z,
 * order) in the corresponding order.
 *
 * ```js
 * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
 * const b = new THREE.Vector3( 1, 0, 1 );
 * b.applyEuler(a);
 * ```
 */
class Euler {

	/**
	 * Constructs a new euler instance.
	 *
	 * @param {number} [x=0] - The angle of the x axis in radians.
	 * @param {number} [y=0] - The angle of the y axis in radians.
	 * @param {number} [z=0] - The angle of the z axis in radians.
	 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
	 */
	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	/**
	 * The angle of the x axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	/**
	 * The angle of the y axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	/**
	 * The angle of the z axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	/**
	 * A string representing the order that the rotations are applied.
	 *
	 * @type {string}
	 * @default 'XYZ'
	 */
	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	/**
	 * Sets the Euler components.
	 *
	 * @param {number} x - The angle of the x axis in radians.
	 * @param {number} y - The angle of the y axis in radians.
	 * @param {number} z - The angle of the z axis in radians.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Returns a new Euler instance with copied values from this instance.
	 *
	 * @return {Euler} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	/**
	 * Copies the values of the given Euler instance to this instance.
	 *
	 * @param {Euler} euler - The Euler instance to copy.
	 * @return {Euler} A reference to this Euler instance.
	 */
	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets the angles of this Euler instance from a pure rotation matrix.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromRotationMatrix( m, order = this._order, update = true ) {

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, -1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, -1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, -1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, -1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, -1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, -1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	/**
	 * Sets the angles of this Euler instance from a normalized quaternion.
	 *
	 * @param {Quaternion} q - A normalized Quaternion.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromQuaternion( q, order, update ) {

		_matrix$2.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$2, order, update );

	}

	/**
	 * Sets the angles of this Euler instance from the given vector.
	 *
	 * @param {Vector3} v - The vector.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	/**
	 * Resets the euler angle with a new order by creating a quaternion from this
	 * euler angle and then setting this euler angle with the quaternion and the
	 * new order.
	 *
	 * Warning: This discards revolution information.
	 *
	 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	reorder( newOrder ) {

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	/**
	 * Returns `true` if this Euler instance is equal with the given one.
	 *
	 * @param {Euler} euler - The Euler instance to test for equality.
	 * @return {boolean} Whether this Euler instance is equal with the given one.
	 */
	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	/**
	 * Sets this Euler instance's components to values from the given array. The first three
	 * entries of the array are assign to the x,y and z components. An optional fourth entry
	 * defines the Euler order.
	 *
	 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
	 * @return {Euler} A reference to this Euler instance.
	 */
	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	/**
	 * Writes the components of this Euler instance to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number,number,number,string>} The Euler components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

/**
 * The default Euler angle order.
 *
 * @static
 * @type {string}
 * @default 'XYZ'
 */
Euler.DEFAULT_ORDER = 'XYZ';

/**
 * A layers object assigns an 3D object to 1 or more of 32
 * layers numbered `0` to `31` - internally the layers are stored as a
 * bit mask], and by default all 3D objects are a member of layer `0`.
 *
 * This can be used to control visibility - an object must share a layer with
 * a camera to be visible when that camera's view is
 * rendered.
 *
 * All classes that inherit from {@link Object3D} have an `layers` property which
 * is an instance of this class.
 */
class Layers {

	/**
	 * Constructs a new layers instance, with membership
	 * initially set to layer `0`.
	 */
	constructor() {

		/**
		 * A bit mask storing which of the 32 layers this layers object is currently
		 * a member of.
		 *
		 * @type {number}
		 */
		this.mask = 1 | 0;

	}

	/**
	 * Sets membership to the given layer, and remove membership all other layers.
	 *
	 * @param {number} layer - The layer to set.
	 */
	set( layer ) {

		this.mask = ( 1 << layer | 0 ) >>> 0;

	}

	/**
	 * Adds membership of the given layer.
	 *
	 * @param {number} layer - The layer to enable.
	 */
	enable( layer ) {

		this.mask |= 1 << layer | 0;

	}

	/**
	 * Adds membership to all layers.
	 */
	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	/**
	 * Toggles the membership of the given layer.
	 *
	 * @param {number} layer - The layer to toggle.
	 */
	toggle( layer ) {

		this.mask ^= 1 << layer | 0;

	}

	/**
	 * Removes membership of the given layer.
	 *
	 * @param {number} layer - The layer to enable.
	 */
	disable( layer ) {

		this.mask &= ~ ( 1 << layer | 0 );

	}

	/**
	 * Removes the membership from all layers.
	 */
	disableAll() {

		this.mask = 0;

	}

	/**
	 * Returns `true` if this and the given layers object have at least one
	 * layer in common.
	 *
	 * @param {Layers} layers - The layers to test.
	 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
	 */
	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	/**
	 * Returns `true` if the given layer is enabled.
	 *
	 * @param {number} layer - The layer to test.
	 * @return {boolean } Whether the given layer is enabled or not.
	 */
	isEnabled( layer ) {

		return ( this.mask & ( 1 << layer | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

/**
 * Fires when the object has been added to its parent object.
 *
 * @event Object3D#added
 * @type {Object}
 */
const _addedEvent = { type: 'added' };

/**
 * Fires when the object has been removed from its parent object.
 *
 * @event Object3D#removed
 * @type {Object}
 */
const _removedEvent = { type: 'removed' };

/**
 * Fires when a new child object has been added.
 *
 * @event Object3D#childadded
 * @type {Object}
 */
const _childaddedEvent = { type: 'childadded', child: null };

/**
 * Fires when a new child object has been added.
 *
 * @event Object3D#childremoved
 * @type {Object}
 */
const _childremovedEvent = { type: 'childremoved', child: null };

/**
 * This is the base class for most objects in three.js and provides a set of
 * properties and methods for manipulating objects in 3D space.
 *
 * @augments EventDispatcher
 */
class Object3D extends EventDispatcher {

	/**
	 * Constructs a new 3D object.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isObject3D = true;

		/**
		 * The ID of the 3D object.
		 *
		 * @name Object3D#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		/**
		 * The UUID of the 3D object.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the 3D object.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'Object3D';

		/**
		 * A reference to the parent object.
		 *
		 * @type {?Object3D}
		 * @default null
		 */
		this.parent = null;

		/**
		 * An array holding the child 3D objects of this instance.
		 *
		 * @type {Array<Object3D>}
		 */
		this.children = [];

		/**
		 * Defines the `up` direction of the 3D object which influences
		 * the orientation via methods like {@link Object3D#lookAt}.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
		 *
		 * @type {Vector3}
		 */
		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			/**
			 * Represents the object's local position.
			 *
			 * @name Object3D#position
			 * @type {Vector3}
			 * @default (0,0,0)
			 */
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			/**
			 * Represents the object's local rotation as Euler angles, in radians.
			 *
			 * @name Object3D#rotation
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			/**
			 * Represents the object's local rotation as Quaternions.
			 *
			 * @name Object3D#quaternion
			 * @type {Quaternion}
			 */
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			/**
			 * Represents the object's local scale.
			 *
			 * @name Object3D#scale
			 * @type {Vector3}
			 * @default (1,1,1)
			 */
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			/**
			 * Represents the object's model-view matrix.
			 *
			 * @name Object3D#modelViewMatrix
			 * @type {Matrix4}
			 */
			modelViewMatrix: {
				value: new Matrix4()
			},
			/**
			 * Represents the object's normal matrix.
			 *
			 * @name Object3D#normalMatrix
			 * @type {Matrix3}
			 */
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		/**
		 * Represents the object's transformation matrix in local space.
		 *
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();

		/**
		 * Represents the object's transformation matrix in world space.
		 * If the 3D object has no parent, then it's identical to the local transformation matrix
		 *
		 * @type {Matrix4}
		 */
		this.matrixWorld = new Matrix4();

		/**
		 * When set to `true`, the engine automatically computes the local matrix from position,
		 * rotation and scale every frame.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

		/**
		 * When set to `true`, the engine automatically computes the world matrix from the current local
		 * matrix and the object's transformation hierarchy.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

		/**
		 * When set to `true`, it calculates the world matrix in that frame and resets this property
		 * to `false`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.matrixWorldNeedsUpdate = false;

		/**
		 * The layer membership of the 3D object. The 3D object is only visible if it has
		 * at least one layer in common with the camera in use. This property can also be
		 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
		 *
		 * @type {Layers}
		 */
		this.layers = new Layers();

		/**
		 * When set to `true`, the 3D object gets rendered.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.visible = true;

		/**
		 * When set to `true`, the 3D object gets rendered into shadow maps.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.castShadow = false;

		/**
		 * When set to `true`, the 3D object is affected by shadows in the scene.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.receiveShadow = false;

		/**
		 * When set to `true`, the 3D object is honored by view frustum culling.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.frustumCulled = true;

		/**
		 * This value allows the default rendering order of scene graph objects to be
		 * overridden although opaque and transparent objects remain sorted independently.
		 * When this property is set for an instance of {@link Group},all descendants
		 * objects will be sorted and rendered together. Sorting is from lowest to highest
		 * render order.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.renderOrder = 0;

		/**
		 * An array holding the animation clips of the 3D object.
		 *
		 * @type {Array<AnimationClip>}
		 */
		this.animations = [];

		/**
		 * Custom depth material to be used when rendering to the depth map. Can only be used
		 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
		 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
		 * material for proper shadows.
		 *
		 * Only relevant in context of {@link WebGLRenderer}.
		 *
		 * @type {(Material|undefined)}
		 * @default undefined
		 */
		this.customDepthMaterial = undefined;

		/**
		 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
		 *
		 * Only relevant in context of {@link WebGLRenderer}.
		 *
		 * @type {(Material|undefined)}
		 * @default undefined
		 */
		this.customDistanceMaterial = undefined;

		/**
		 * An object that can be used to store custom data about the 3D object. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

	}

	/**
	 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {Camera} shadowCamera - The shadow camera.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} depthMaterial - The depth material.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	/**
	 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {Camera} shadowCamera - The shadow camera.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} depthMaterial - The depth material.
	 * @param {Object} group - The geometry group data.
	 */
	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	/**
	 * A callback that is executed immediately before a 3D object is rendered.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} material - The 3D object's material.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	/**
	 * A callback that is executed immediately after a 3D object is rendered.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} material - The 3D object's material.
	 * @param {Object} group - The geometry group data.
	 */
	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	/**
	 * Applies the given transformation matrix to the object and updates the object's position,
	 * rotation and scale.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 */
	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	/**
	 * Applies a rotation represented by given the quaternion to the 3D object.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Object3D} A reference to this instance.
	 */
	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	/**
	 * Sets the given rotation represented as an axis/angle couple to the 3D object.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 */
	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	/**
	 * Sets the given rotation represented as Euler angles to the 3D object.
	 *
	 * @param {Euler} euler - The Euler angles.
	 */
	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	/**
	 * Sets the given rotation represented as rotation matrix to the 3D object.
	 *
	 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
	 * a pure rotation matrix (i.e, unscaled).
	 */
	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	/**
	 * Sets the given rotation represented as a Quaternion to the 3D object.
	 *
	 * @param {Quaternion} q - The Quaternion
	 */
	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	/**
	 * Rotates the 3D object along an axis in local space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	/**
	 * Rotates the 3D object along an axis in world space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	/**
	 * Rotates the 3D object around its X axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	/**
	 * Rotates the 3D object around its Y axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	/**
	 * Rotates the 3D object around its Z axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	/**
	 * Translate the 3D object by a distance along the given axis in local space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	/**
	 * Translate the 3D object by a distance along its X-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	/**
	 * Translate the 3D object by a distance along its Y-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	/**
	 * Translate the 3D object by a distance along its Z-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	/**
	 * Converts the given vector from this 3D object's local space to world space.
	 *
	 * @param {Vector3} vector - The vector to convert.
	 * @return {Vector3} The converted vector.
	 */
	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	/**
	 * Converts the given vector from this 3D object's word space to local space.
	 *
	 * @param {Vector3} vector - The vector to convert.
	 * @return {Vector3} The converted vector.
	 */
	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	/**
	 * Rotates the object to face a point in world space.
	 *
	 * This method does not support objects having non-uniformly-scaled parent(s).
	 *
	 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
	 * @param {number} [y] - The y coordinate in world space.
	 * @param {number} [z] - The z coordinate in world space.
	 */
	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	/**
	 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
	 * objects may be added. Any current parent on an object passed in here will be
	 * removed, since an object can have at most one parent.
	 *
	 * @fires Object3D#added
	 * @fires Object3D#childadded
	 * @param {Object3D} object - The 3D object to add.
	 * @return {Object3D} A reference to this instance.
	 */
	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	/**
	 * Removes the given 3D object as child from this 3D object.
	 * An arbitrary number of objects may be removed.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @param {Object3D} object - The 3D object to remove.
	 * @return {Object3D} A reference to this instance.
	 */
	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== -1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

			_childremovedEvent.child = object;
			this.dispatchEvent( _childremovedEvent );
			_childremovedEvent.child = null;

		}

		return this;

	}

	/**
	 * Removes this 3D object from its current parent.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @return {Object3D} A reference to this instance.
	 */
	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	/**
	 * Removes all child objects.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @return {Object3D} A reference to this instance.
	 */
	clear() {

		return this.remove( ... this.children );

	}

	/**
	 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
	 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
	 *
	 * @fires Object3D#added
	 * @fires Object3D#childadded
	 * @param {Object3D} object - The 3D object to attach.
	 * @return {Object3D} A reference to this instance.
	 */
	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		object.removeFromParent();
		object.parent = this;
		this.children.push( object );

		object.updateWorldMatrix( false, true );

		object.dispatchEvent( _addedEvent );

		_childaddedEvent.child = object;
		this.dispatchEvent( _childaddedEvent );
		_childaddedEvent.child = null;

		return this;

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching ID.
	 *
	 * @param {number} id - The id.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching name.
	 *
	 * @param {string} name - The name.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching property value.
	 *
	 * @param {string} name - The name of the property.
	 * @param {any} value - The value.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns all 3D objects with a matching property value.
	 *
	 * @param {string} name - The name of the property.
	 * @param {any} value - The value.
	 * @param {Array<Object3D>} result - The method stores the result in this array.
	 * @return {Array<Object3D>} The found 3D objects.
	 */
	getObjectsByProperty( name, value, result = [] ) {

		if ( this[ name ] === value ) result.push( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].getObjectsByProperty( name, value, result );

		}

		return result;

	}

	/**
	 * Returns a vector representing the position of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's position in world space.
	 */
	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	/**
	 * Returns a Quaternion representing the position of the 3D object in world space.
	 *
	 * @param {Quaternion} target - The target Quaternion the result is stored to.
	 * @return {Quaternion} The 3D object's rotation in world space.
	 */
	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	/**
	 * Returns a vector representing the scale of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's scale in world space.
	 */
	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	/**
	 * Returns a vector representing the ("look") direction of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's direction in world space.
	 */
	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	/**
	 * Abstract method to get intersections between a casted ray and this
	 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
	 * implement this method in order to use raycasting.
	 *
	 * @abstract
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - An array holding the result of the method.
	 */
	raycast( /* raycaster, intersects */ ) {}

	/**
	 * Executes the callback on this 3D object and all descendants.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	/**
	 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
	 * Descendants of invisible 3D objects are not traversed.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	/**
	 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	/**
	 * Updates the transformation matrix in local space by computing it from the current
	 * position, rotation and scale values.
	 */
	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	/**
	 * Updates the transformation matrix in world space of this 3D objects and its descendants.
	 *
	 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
	 * local space. The computation of the local and world matrix can be controlled with the
	 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
	 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
	 *
	 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
	 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
	 */
	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.matrixWorldAutoUpdate === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// make sure descendants are updated if required

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			child.updateMatrixWorld( force );

		}

	}

	/**
	 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
	 * update of ancestor and descendant nodes.
	 *
	 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
	 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
	 */
	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldAutoUpdate === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

		}

		// make sure descendants are updated

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				child.updateWorldMatrix( false, true );

			}

		}

	}

	/**
	 * Serializes the 3D object into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized 3D object.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.6,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		if ( this.isBatchedMesh ) {

			object.type = 'BatchedMesh';
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;

			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;

			object.geometryInfo = this._geometryInfo.map( info => ( {
				...info,
				boundingBox: info.boundingBox ? {
					min: info.boundingBox.min.toArray(),
					max: info.boundingBox.max.toArray()
				} : undefined,
				boundingSphere: info.boundingSphere ? {
					radius: info.boundingSphere.radius,
					center: info.boundingSphere.center.toArray()
				} : undefined
			} ) );
			object.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );

			object.availableInstanceIds = this._availableInstanceIds.slice();
			object.availableGeometryIds = this._availableGeometryIds.slice();

			object.nextIndexStart = this._nextIndexStart;
			object.nextVertexStart = this._nextVertexStart;
			object.geometryCount = this._geometryCount;

			object.maxInstanceCount = this._maxInstanceCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;

			object.geometryInitialized = this._geometryInitialized;

			object.matricesTexture = this._matricesTexture.toJSON( meta );

			object.indirectTexture = this._indirectTexture.toJSON( meta );

			if ( this._colorsTexture !== null ) {

				object.colorsTexture = this._colorsTexture.toJSON( meta );

			}

			if ( this.boundingSphere !== null ) {

				object.boundingSphere = {
					center: this.boundingSphere.center.toArray(),
					radius: this.boundingSphere.radius
				};

			}

			if ( this.boundingBox !== null ) {

				object.boundingBox = {
					min: this.boundingBox.min.toArray(),
					max: this.boundingBox.max.toArray()
				};

			}

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	/**
	 * Returns a new 3D object with copied values from this instance.
	 *
	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
	 * @return {Object3D} A clone of this instance.
	 */
	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	/**
	 * Copies the values of the given 3D object to this instance.
	 *
	 * @param {Object3D} source - The 3D object to copy.
	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
	 * @return {Object3D} A reference to this instance.
	 */
	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.animations = source.animations.slice();

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

/**
 * The default up direction for objects, also used as the default
 * position for {@link DirectionalLight} and {@link HemisphereLight}.
 *
 * @static
 * @type {Vector3}
 * @default (0,1,0)
 */
Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );

/**
 * The default setting for {@link Object3D#matrixAutoUpdate} for
 * newly created 3D objects.
 *
 * @static
 * @type {boolean}
 * @default true
 */
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

/**
 * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
 * newly created 3D objects.
 *
 * @static
 * @type {boolean}
 * @default true
 */
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$2 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

const _v40 = /*@__PURE__*/ new Vector4();
const _v41 = /*@__PURE__*/ new Vector4();
const _v42 = /*@__PURE__*/ new Vector4();

/**
 * A geometric triangle as defined by three vectors representing its three corners.
 */
class Triangle {

	/**
	 * Constructs a new triangle.
	 *
	 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
	 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
	 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
	 */
	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		/**
		 * The first corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.a = a;

		/**
		 * The second corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.b = b;

		/**
		 * The third corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.c = c;

	}

	/**
	 * Computes the normal vector of a triangle.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's normal.
	 */
	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	/**
	 * Computes a barycentric coordinates from the given vector.
	 * Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The barycentric coordinates for the given point
	 */
	static getBarycoord( point, a, b, c, target ) {

		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			target.set( 0, 0, 0 );
			return null;

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	/**
	 * Returns `true` if the given point, when projected onto the plane of the
	 * triangle, lies within the triangle.
	 *
	 * @param {Vector3} point - The point in 3D space to test.
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @return {boolean} Whether the given point, when projected onto the plane of the
	 * triangle, lies within the triangle or not.
	 */
	static containsPoint( point, a, b, c ) {

		// if the triangle is degenerate then we can't contain a point
		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

			return false;

		}

		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

	}

	/**
	 * Computes the value barycentrically interpolated for the given point on the
	 * triangle. Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - Position of interpolated point.
	 * @param {Vector3} p1 - The first corner of the triangle.
	 * @param {Vector3} p2 - The second corner of the triangle.
	 * @param {Vector3} p3 - The third corner of the triangle.
	 * @param {Vector3} v1 - Value to interpolate of first vertex.
	 * @param {Vector3} v2 - Value to interpolate of second vertex.
	 * @param {Vector3} v3 - Value to interpolate of third vertex.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The interpolated value.
	 */
	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

			target.x = 0;
			target.y = 0;
			if ( 'z' in target ) target.z = 0;
			if ( 'w' in target ) target.w = 0;
			return null;

		}

		target.setScalar( 0 );
		target.addScaledVector( v1, _v3$2.x );
		target.addScaledVector( v2, _v3$2.y );
		target.addScaledVector( v3, _v3$2.z );

		return target;

	}

	/**
	 * Computes the value barycentrically interpolated for the given attribute and indices.
	 *
	 * @param {BufferAttribute} attr - The attribute to interpolate.
	 * @param {number} i1 - Index of first vertex.
	 * @param {number} i2 - Index of second vertex.
	 * @param {number} i3 - Index of third vertex.
	 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The interpolated attribute value.
	 */
	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

		_v40.setScalar( 0 );
		_v41.setScalar( 0 );
		_v42.setScalar( 0 );

		_v40.fromBufferAttribute( attr, i1 );
		_v41.fromBufferAttribute( attr, i2 );
		_v42.fromBufferAttribute( attr, i3 );

		target.setScalar( 0 );
		target.addScaledVector( _v40, barycoord.x );
		target.addScaledVector( _v41, barycoord.y );
		target.addScaledVector( _v42, barycoord.z );

		return target;

	}

	/**
	 * Returns `true` if the triangle is oriented towards the given direction.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} direction - The (normalized) direction vector.
	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
	 */
	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	/**
	 * Sets the triangle's vertices by copying the given values.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	/**
	 * Sets the triangle's vertices by copying the given array values.
	 *
	 * @param {Array<Vector3>} points - An array with 3D points.
	 * @param {number} i0 - The array index representing the first corner of the triangle.
	 * @param {number} i1 - The array index representing the second corner of the triangle.
	 * @param {number} i2 - The array index representing the third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	/**
	 * Sets the triangle's vertices by copying the given attribute values.
	 *
	 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
	 * @param {number} i0 - The attribute index representing the first corner of the triangle.
	 * @param {number} i1 - The attribute index representing the second corner of the triangle.
	 * @param {number} i2 - The attribute index representing the third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	/**
	 * Returns a new triangle with copied values from this instance.
	 *
	 * @return {Triangle} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given triangle to this instance.
	 *
	 * @param {Triangle} triangle - The triangle to copy.
	 * @return {Triangle} A reference to this triangle.
	 */
	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	/**
	 * Computes the area of the triangle.
	 *
	 * @return {number} The triangle's area.
	 */
	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	/**
	 * Computes the midpoint of the triangle.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's midpoint.
	 */
	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	/**
	 * Computes the normal of the triangle.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's normal.
	 */
	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	/**
	 * Computes a plane the triangle lies within.
	 *
	 * @param {Plane} target - The target vector that is used to store the method's result.
	 * @return {Plane} The plane the triangle lies within.
	 */
	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	/**
	 * Computes a barycentric coordinates from the given vector.
	 * Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The barycentric coordinates for the given point
	 */
	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	/**
	 * Computes the value barycentrically interpolated for the given point on the
	 * triangle. Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - Position of interpolated point.
	 * @param {Vector3} v1 - Value to interpolate of first vertex.
	 * @param {Vector3} v2 - Value to interpolate of second vertex.
	 * @param {Vector3} v3 - Value to interpolate of third vertex.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The interpolated value.
	 */
	getInterpolation( point, v1, v2, v3, target ) {

		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

	}

	/**
	 * Returns `true` if the given point, when projected onto the plane of the
	 * triangle, lies within the triangle.
	 *
	 * @param {Vector3} point - The point in 3D space to test.
	 * @return {boolean} Whether the given point, when projected onto the plane of the
	 * triangle, lies within the triangle or not.
	 */
	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	/**
	 * Returns `true` if the triangle is oriented towards the given direction.
	 *
	 * @param {Vector3} direction - The (normalized) direction vector.
	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
	 */
	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	/**
	 * Returns `true` if this triangle intersects with the given box.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @return {boolean} Whether this triangle intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	/**
	 * Returns the closest point on the triangle to the given point.
	 *
	 * @param {Vector3} p - The point to compute the closest point for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The closest point on the triangle.
	 */
	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	/**
	 * Returns `true` if this triangle is equal with the given one.
	 *
	 * @param {Triangle} triangle - The triangle to test for equality.
	 * @return {boolean} Whether this triangle is equal with the given one.
	 */
	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

/**
 * A Color instance is represented by RGB components in the linear <i>working
 * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
 * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
 * strings) are converted to the working color space automatically.
 *
 * ```js
 * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
 * const color = new THREE.Color().setHex( 0x112233 );
 * ```
 * Source color spaces may be specified explicitly, to ensure correct conversions.
 * ```js
 * // assumed already LinearSRGBColorSpace; no conversion
 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
 *
 * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
 * ```
 * If THREE.ColorManagement is disabled, no conversions occur. For details,
 * see <i>Color management</i>. Iterating through a Color instance will yield
 * its components (r, g, b) in the corresponding order. A Color can be initialised
 * in any of the following ways:
 * ```js
 * //empty constructor - will default white
 * const color1 = new THREE.Color();
 *
 * //Hexadecimal color (recommended)
 * const color2 = new THREE.Color( 0xff0000 );
 *
 * //RGB string
 * const color3 = new THREE.Color("rgb(255, 0, 0)");
 * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
 *
 * //X11 color name - all 140 color names are supported.
 * //Note the lack of CamelCase in the name
 * const color5 = new THREE.Color( 'skyblue' );
 * //HSL string
 * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
 *
 * //Separate RGB values between 0 and 1
 * const color7 = new THREE.Color( 1, 0, 0 );
 * ```
 */
class Color {

	/**
	 * Constructs a new color.
	 *
	 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
	 * and that method is used throughout the rest of the documentation.
	 *
	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	 * @param {number} [g] - The green component.
	 * @param {number} [b] - The blue component.
	 */
	constructor( r, g, b ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isColor = true;

		/**
		 * The red component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.r = 1;

		/**
		 * The green component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.g = 1;

		/**
		 * The blue component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.b = 1;

		return this.set( r, g, b );

	}

	/**
	 * Sets the colors's components from the given values.
	 *
	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	 * @param {number} [g] - The green component.
	 * @param {number} [b] - The blue component.
	 * @return {Color} A reference to this color.
	 */
	set( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string

			const value = r;

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

		} else {

			this.setRGB( r, g, b );

		}

		return this;

	}

	/**
	 * Sets the colors's components to the given scalar value.
	 *
	 * @param {number} scalar - The scalar value.
	 * @return {Color} A reference to this color.
	 */
	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	/**
	 * Sets this color from a hexadecimal value.
	 *
	 * @param {number} hex - The hexadecimal value.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from RGB values.
	 *
	 * @param {number} r - Red channel value between `0.0` and `1.0`.
	 * @param {number} g - Green channel value between `0.0` and `1.0`.
	 * @param {number} b - Blue channel value between `0.0` and `1.0`.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from RGB values.
	 *
	 * @param {number} h - Hue value between `0.0` and `1.0`.
	 * @param {number} s - Saturation value between `0.0` and `1.0`.
	 * @param {number} l - Lightness value between `0.0` and `1.0`.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
	 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
	 * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
	 * all 140 color names are supported).
	 *
	 * @param {string} style - Color as a CSS-style string.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
							colorSpace
						);

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
							colorSpace
						);

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setHSL(
							parseFloat( color[ 1 ] ) / 360,
							parseFloat( color[ 2 ] ) / 100,
							parseFloat( color[ 3 ] ) / 100,
							colorSpace
						);

					}

					break;

				default:

					console.warn( 'THREE.Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				return this.setRGB(
					parseInt( hex.charAt( 0 ), 16 ) / 15,
					parseInt( hex.charAt( 1 ), 16 ) / 15,
					parseInt( hex.charAt( 2 ), 16 ) / 15,
					colorSpace
				);

			} else if ( size === 6 ) {

				// #ff0000
				return this.setHex( parseInt( hex, 16 ), colorSpace );

			} else {

				console.warn( 'THREE.Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	/**
	 * Sets this color from a color name. Faster than {@link Color#setStyle} if
	 * you don't need the other CSS-style formats.
	 *
	 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
	 * ```js
	 * Color.NAMES.aliceblue // returns 0xF0F8FF
	 * ```
	 *
	 * @param {string} style - The color name.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	/**
	 * Returns a new color with copied values from this instance.
	 *
	 * @return {Color} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	/**
	 * Copies the values of the given color to this instance.
	 *
	 * @param {Color} color - The color to copy.
	 * @return {Color} A reference to this color.
	 */
	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	/**
	 * Copies the given color into this color, and then converts this color from
	 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 *
	 * @param {Color} color - The color to copy/convert.
	 * @return {Color} A reference to this color.
	 */
	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	/**
	 * Copies the given color into this color, and then converts this color from
	 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 *
	 * @param {Color} color - The color to copy/convert.
	 * @return {Color} A reference to this color.
	 */
	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	/**
	 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 *
	 * @return {Color} A reference to this color.
	 */
	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	/**
	 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 *
	 * @return {Color} A reference to this color.
	 */
	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	/**
	 * Returns the hexadecimal value of this color.
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {number} The hexadecimal value.
	 */
	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

	}

	/**
	 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {string} The hexadecimal value as a string.
	 */
	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

	}

	/**
	 * Converts the colors RGB values into the HSL format and stores them into the
	 * given target object.
	 *
	 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
	 */
	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	/**
	 * Returns the RGB values of this color and stores them into the given target object.
	 *
	 * @param {Color} target - The target color that is used to store the method's result.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} The RGB representation of this color.
	 */
	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;

		return target;

	}

	/**
	 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {string} The CSS representation of this color.
	 */
	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

	}

	/**
	 * Adds the given HSL values to this color's values.
	 * Internally, this converts the color's RGB values to HSL, adds HSL
	 * and then converts the color back to RGB.
	 *
	 * @param {number} h - Hue value between `0.0` and `1.0`.
	 * @param {number} s - Saturation value between `0.0` and `1.0`.
	 * @param {number} l - Lightness value between `0.0` and `1.0`.
	 * @return {Color} A reference to this color.
	 */
	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

	}

	/**
	 * Adds the RGB values of the given color to the RGB values of this color.
	 *
	 * @param {Color} color - The color to add.
	 * @return {Color} A reference to this color.
	 */
	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	/**
	 * Adds the RGB values of the given colors and stores the result in this instance.
	 *
	 * @param {Color} color1 - The first color.
	 * @param {Color} color2 - The second color.
	 * @return {Color} A reference to this color.
	 */
	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	/**
	 * Adds the given scalar value to the RGB values of this color.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Color} A reference to this color.
	 */
	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	/**
	 * Subtracts the RGB values of the given color from the RGB values of this color.
	 *
	 * @param {Color} color - The color to subtract.
	 * @return {Color} A reference to this color.
	 */
	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	/**
	 * Multiplies the RGB values of the given color with the RGB values of this color.
	 *
	 * @param {Color} color - The color to multiply.
	 * @return {Color} A reference to this color.
	 */
	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	/**
	 * Multiplies the given scalar value with the RGB values of this color.
	 *
	 * @param {number} s - The scalar to multiply.
	 * @return {Color} A reference to this color.
	 */
	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	/**
	 * Linearly interpolates this color's RGB values toward the RGB values of the
	 * given color. The alpha argument can be thought of as the ratio between
	 * the two colors, where `0.0` is this color and `1.0` is the first argument.
	 *
	 * @param {Color} color - The color to converge on.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given colors and stores the result in this instance.
	 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
	 * is the first and `1.0` is the second color.
	 *
	 * @param {Color} color1 - The first color.
	 * @param {Color} color2 - The second color.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates this color's HSL values toward the HSL values of the
	 * given color. It differs from {@link Color#lerp} by not interpolating straight
	 * from one color to the other, but instead going through all the hues in between
	 * those two colors. The alpha argument can be thought of as the ratio between
	 * the two colors, where 0.0 is this color and 1.0 is the first argument.
	 *
	 * @param {Color} color - The color to converge on.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	/**
	 * Sets the color's RGB components from the given 3D vector.
	 *
	 * @param {Vector3} v - The vector to set.
	 * @return {Color} A reference to this color.
	 */
	setFromVector3( v ) {

		this.r = v.x;
		this.g = v.y;
		this.b = v.z;

		return this;

	}

	/**
	 * Transforms this color with the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix.
	 * @return {Color} A reference to this color.
	 */
	applyMatrix3( m ) {

		const r = this.r, g = this.g, b = this.b;
		const e = m.elements;

		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

		return this;

	}

	/**
	 * Returns `true` if this color is equal with the given one.
	 *
	 * @param {Color} c - The color to test for equality.
	 * @return {boolean} Whether this bounding color is equal with the given one.
	 */
	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	/**
	 * Sets this color's RGB components from the given array.
	 *
	 * @param {Array<number>} array - An array holding the RGB values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Color} A reference to this color.
	 */
	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	/**
	 * Writes the RGB components of this color to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the color components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The color components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	/**
	 * Sets the components of this color from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
	 * @param {number} index - The index into the attribute.
	 * @return {Color} A reference to this color.
	 */
	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	/**
	 * This methods defines the serialization result of this class. Returns the color
	 * as a hexadecimal value.
	 *
	 * @return {number} The hexadecimal value.
	 */
	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color = /*@__PURE__*/ new Color();

/**
 * A dictionary with X11 color names.
 *
 * Note that multiple words such as Dark Orange become the string 'darkorange'.
 *
 * @static
 * @type {Object}
 */
Color.NAMES = _colorKeywords;

let _materialId = 0;

/**
 * Abstract base class for materials.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * @abstract
 * @augments EventDispatcher
 */
class Material extends EventDispatcher {

	/**
	 * Constructs a new material.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMaterial = true;

		/**
		 * The ID of the material.
		 *
		 * @name Material#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _materialId ++ } );

		/**
		 * The UUID of the material.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the material.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'Material';

		/**
		 * Defines the blending type of the material.
		 *
		 * It must be set to `CustomBlending` if custom blending properties like
		 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
		 * should have any effect.
		 *
		 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
		 * @default NormalBlending
		 */
		this.blending = NormalBlending;

		/**
		 * Defines which side of faces will be rendered - front, back or both.
		 *
		 * @type {(FrontSide|BackSide|DoubleSide)}
		 * @default FrontSide
		 */
		this.side = FrontSide;

		/**
		 * If set to `true`, vertex colors should be used.
		 *
		 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
		 * four (RGBA) component color buffer attribute is used.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.vertexColors = false;

		/**
		 * Defines how transparent the material is.
		 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
		 *
		 * If the {@link Material#transparent} is not set to `true`,
		 * the material will remain fully opaque and this value will only affect its color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.opacity = 1;

		/**
		 * Defines whether this material is transparent. This has an effect on
		 * rendering as transparent objects need special treatment and are rendered
		 * after non-transparent objects.
		 *
		 * When set to true, the extent to which the material is transparent is
		 * controlled by {@link Material#opacity}.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.transparent = false;

		/**
		 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
		 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
		 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
		 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.alphaHash = false;

		/**
		 * Defines the blending source factor.
		 *
		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default SrcAlphaFactor
		 */
		this.blendSrc = SrcAlphaFactor;

		/**
		 * Defines the blending destination factor.
		 *
		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default OneMinusSrcAlphaFactor
		 */
		this.blendDst = OneMinusSrcAlphaFactor;

		/**
		 * Defines the blending equation.
		 *
		 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		 * @default AddEquation
		 */
		this.blendEquation = AddEquation;

		/**
		 * Defines the blending source alpha factor.
		 *
		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default null
		 */
		this.blendSrcAlpha = null;

		/**
		 * Defines the blending destination alpha factor.
		 *
		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default null
		 */
		this.blendDstAlpha = null;

		/**
		 * Defines the blending equation of the alpha channel.
		 *
		 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		 * @default null
		 */
		this.blendEquationAlpha = null;

		/**
		 * Represents the RGB values of the constant blend color.
		 *
		 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.blendColor = new Color( 0, 0, 0 );

		/**
		 * Represents the alpha value of the constant blend color.
		 *
		 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.blendAlpha = 0;

		/**
		 * Defines the depth function.
		 *
		 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
		 * @default LessEqualDepth
		 */
		this.depthFunc = LessEqualDepth;

		/**
		 * Whether to have depth test enabled when rendering this material.
		 * When the depth test is disabled, the depth write will also be implicitly disabled.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthTest = true;

		/**
		 * Whether rendering this material has any effect on the depth buffer.
		 *
		 * When drawing 2D overlays it can be useful to disable the depth writing in
		 * order to layer several things together without creating z-index artifacts.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthWrite = true;

		/**
		 * The bit mask to use when writing to the stencil buffer.
		 *
		 * @type {number}
		 * @default 0xff
		 */
		this.stencilWriteMask = 0xff;

		/**
		 * The stencil comparison function to use.
		 *
		 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
		 * @default AlwaysStencilFunc
		 */
		this.stencilFunc = AlwaysStencilFunc;

		/**
		 * The value to use when performing stencil comparisons or stencil operations.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.stencilRef = 0;

		/**
		 * The bit mask to use when comparing against the stencil buffer.
		 *
		 * @type {number}
		 * @default 0xff
		 */
		this.stencilFuncMask = 0xff;

		/**
		 * Which stencil operation to perform when the comparison function returns `false`.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilFail = KeepStencilOp;

		/**
		 * Which stencil operation to perform when the comparison function returns
		 * `true` but the depth test fails.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilZFail = KeepStencilOp;

		/**
		 * Which stencil operation to perform when the comparison function returns
		 * `true` and the depth test passes.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilZPass = KeepStencilOp;

		/**
		 * Whether stencil operations are performed against the stencil buffer. In
		 * order to perform writes or comparisons against the stencil buffer this
		 * value must be `true`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.stencilWrite = false;

		/**
		 * User-defined clipping planes specified as THREE.Plane objects in world
		 * space. These planes apply to the objects this material is attached to.
		 * Points in space whose signed distance to the plane is negative are clipped
		 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
		 * be `true`.
		 *
		 * @type {?Array<Plane>}
		 * @default null
		 */
		this.clippingPlanes = null;

		/**
		 * Changes the behavior of clipping planes so that only their intersection is
		 * clipped, rather than their union.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipIntersection = false;

		/**
		 * Defines whether to clip shadows according to the clipping planes specified
		 * on this material.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipShadows = false;

		/**
		 * Defines which side of faces cast shadows. If `null`, the side casting shadows
		 * is determined as follows:
		 *
		 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
		 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
		 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
		 *
		 * @type {?(FrontSide|BackSide|DoubleSide)}
		 * @default null
		 */
		this.shadowSide = null;

		/**
		 * Whether to render the material's color.
		 *
		 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
		 * objects that occlude other objects.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.colorWrite = true;

		/**
		 * Override the renderer's default precision for this material.
		 *
		 * @type {?('highp'|'mediump'|'lowp')}
		 * @default null
		 */
		this.precision = null;

		/**
		 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
		 * be offset after it is interpolated from the depth values of the appropriate vertices.
		 * The offset is added before the depth test is performed and before the value is written
		 * into the depth buffer.
		 *
		 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
		 * rendering solids with highlighted edges.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.polygonOffset = false;

		/**
		 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.polygonOffsetFactor = 0;

		/**
		 * Is multiplied by an implementation-specific value to create a constant depth offset.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.polygonOffsetUnits = 0;

		/**
		 * Whether to apply dithering to the color to remove the appearance of banding.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.dithering = false;

		/**
		 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
		 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
		 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.alphaToCoverage = false;

		/**
		 * Whether to premultiply the alpha (transparency) value.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.premultipliedAlpha = false;

		/**
		 * Whether double-sided, transparent objects should be rendered with a single pass or not.
		 *
		 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
		 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
		 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
		 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
		 * disable the two pass rendering to avoid performance issues.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.forceSinglePass = false;

		/**
		 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.allowOverride = true;

		/**
		 * Defines whether 3D objects using this material are visible.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.visible = true;

		/**
		 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
		 *
		 * It is ignored when rendering to a render target or using post processing or when using
		 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.toneMapped = true;

		/**
		 * An object that can be used to store custom data about the Material. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

		/**
		 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

		this._alphaTest = 0;

	}

	/**
	 * Sets the alpha value to be used when running an alpha test. The material
	 * will not be rendered if the opacity is lower than this value.
	 *
	 * @type {number}
	 * @readonly
	 * @default 0
	 */
	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	/**
	 * An optional callback that is executed immediately before the material is used to render a 3D object.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {Scene} scene - The scene.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Object3D} object - The 3D object.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	/**
	 * An optional callback that is executed immediately before the shader
	 * program is compiled. This function is called with the shader source code
	 * as a parameter. Useful for the modification of built-in materials.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}. The
	 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
	 * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
	 *
	 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
	 * @param {WebGLRenderer} renderer - A reference to the renderer.
	 */
	onBeforeCompile( /* shaderobject, renderer */ ) {}

	/**
	 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
	 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
	 * shader or recompile the shader for this material as needed.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @return {string} The custom program cache key.
	 */
	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	/**
	 * This method can be used to set default values from parameter objects.
	 * It is a generic implementation so it can be used with different types
	 * of materials.
	 *
	 * @param {Object} [values] - The material values to set.
	 */
	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	/**
	 * Serializes the material into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized material.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.6,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors === true ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = true;

		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
		if ( this.depthTest === false ) data.depthTest = this.depthTest;
		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaHash === true ) data.alphaHash = true;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

		if ( this.wireframe === true ) data.wireframe = true;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	/**
	 * Returns a new material with copied values from this instance.
	 *
	 * @return {Material} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given material to this instance.
	 *
	 * @param {Material} source - The material to copy.
	 * @return {Material} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy( source.blendColor );
		this.blendAlpha = source.blendAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Material#dispose
	 */
	dispose() {

		/**
		 * Fires when the material has been disposed of.
		 *
		 * @event Material#dispose
		 * @type {Object}
		 */
		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Setting this property to `true` indicates the engine the material
	 * needs to be recompiled.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

/**
 * A material for drawing geometries in a simple shaded (flat or wireframe) way.
 *
 * This material is not affected by lights.
 *
 * @augments Material
 */
class MeshBasicMaterial extends Material {

	/**
	 * Constructs a new mesh basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // emissive

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Specular map used by the material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * How to combine the result of the surface's color with the environment map, if any.
		 *
		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		 * blend between the two colors.
		 *
		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
		 * @default MultiplyOperation
		 */
		this.combine = MultiplyOperation;

		/**
		 * How much the environment map affects the surface.
		 * The valid range is between `0` (no reflections) and `1` (full reflections).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.reflectivity = 1;

		/**
		 * The index of refraction (IOR) of air (approximately 1) divided by the
		 * index of refraction of the material. It is used with environment mapping
		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		 * The refraction ratio should not exceed `1`.
		 *
		 * @type {number}
		 * @default 0.98
		 */
		this.refractionRatio = 0.98;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < -27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < -14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= -8388609; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

/**
 * Returns a half precision floating point value (FP16) from the given single
 * precision floating point value (FP32).
 *
 * @param {number} val - A single precision floating point value.
 * @return {number} The FP16 value.
 */
function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp( val, -65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

/**
 * Returns a single precision floating point value (FP32) from the given half
 * precision floating point value (FP16).
 *
 * @param {number} val - A half precision floating point value.
 * @return {number} The FP32 value.
 */
function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

/**
 * A class containing utility functions for data.
 *
 * @hideconstructor
 */
class DataUtils {

	/**
	 * Returns a half precision floating point value (FP16) from the given single
	 * precision floating point value (FP32).
	 *
	 * @param {number} val - A single precision floating point value.
	 * @return {number} The FP16 value.
	 */
	static toHalfFloat( val ) {

		return toHalfFloat( val );

	}

	/**
	 * Returns a single precision floating point value (FP32) from the given half
	 * precision floating point value (FP16).
	 *
	 * @param {number} val - A half precision floating point value.
	 * @return {number} The FP32 value.
	 */
	static fromHalfFloat( val ) {

		return fromHalfFloat( val );

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

let _id$2 = 0;

/**
 * This class stores data for an attribute (such as vertex positions, face
 * indices, normals, colors, UVs, and any custom attributes ) associated with
 * a geometry, which allows for more efficient passing of data to the GPU.
 *
 * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
 * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
 */
class BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {TypedArray} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBufferAttribute = true;

		/**
		 * The ID of the buffer attribute.
		 *
		 * @name BufferAttribute#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

		/**
		 * The name of the buffer attribute.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The array holding the attribute data. It should have `itemSize * numVertices`
		 * elements, where `numVertices` is the number of vertices in the associated geometry.
		 *
		 * @type {TypedArray}
		 */
		this.array = array;

		/**
		 * The number of values of the array that should be associated with a particular vertex.
		 * For instance, if this attribute is storing a 3-component vector (such as a position,
		 * normal, or color), then the value should be `3`.
		 *
		 * @type {number}
		 */
		this.itemSize = itemSize;

		/**
		 * Represents the number of items this buffer attribute stores. It is internally computed
		 * by dividing the `array` length by the `itemSize`.
		 *
		 * @type {number}
		 * @readonly
		 */
		this.count = array !== undefined ? array.length / itemSize : 0;

		/**
		 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
		 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
		 * and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
		 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
		 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
		 *
		 * @type {boolean}
		 */
		this.normalized = normalized;

		/**
		 * Defines the intended usage pattern of the data store for optimization purposes.
		 *
		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		 * instantiate a new one and set the desired usage before the next render.
		 *
		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		 * @default StaticDrawUsage
		 */
		this.usage = StaticDrawUsage;

		/**
		 * This can be used to only update some components of stored vectors (for example, just the
		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		 *
		 * @type {Array<Object>}
		 */
		this.updateRanges = [];

		/**
		 * Configures the bound GPU type for use in shaders.
		 *
		 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
		 * For lower precision float types, use `Float16BufferAttribute`.
		 *
		 * @type {(FloatType|IntType)}
		 * @default FloatType
		 */
		this.gpuType = FloatType;

		/**
		 * A version number, incremented every time the `needsUpdate` is set to `true`.
		 *
		 * @type {number}
		 */
		this.version = 0;

	}

	/**
	 * A callback function that is executed after the renderer has transferred the attribute
	 * array data to the GPU.
	 */
	onUploadCallback() {}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Sets the usage of this buffer attribute.
	 *
	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	 * @return {BufferAttribute} A reference to this buffer attribute.
	 */
	setUsage( value ) {

		this.usage = value;

		return this;

	}

	/**
	 * Adds a range of data in the data array to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	/**
	 * Copies the values of the given buffer attribute to this instance.
	 *
	 * @param {BufferAttribute} source - The buffer attribute to copy.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;
		this.gpuType = source.gpuType;

		return this;

	}

	/**
	 * Copies a vector from the given buffer attribute to this one. The start
	 * and destination position in the attribute buffers are represented by the
	 * given indices.
	 *
	 * @param {number} index1 - The destination index into this buffer attribute.
	 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
	 * @param {number} index2 - The source index into the given buffer attribute.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	/**
	 * Copies the given array data into this buffer attribute.
	 *
	 * @param {(TypedArray|Array)} array - The array to copy.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	/**
	 * Applies the given 3x3 matrix to the given attribute. Works with
	 * item size `2` and `3`.
	 *
	 * @param {Matrix3} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix3} m - The normal matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3` and with direction vectors.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Sets the given array data in the buffer attribute.
	 *
	 * @param {(TypedArray|Array)} value - The array data to set.
	 * @param {number} [offset=0] - The offset in this buffer attribute's array.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	/**
	 * Returns the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @return {number} The returned value.
	 */
	getComponent( index, component ) {

		let value = this.array[ index * this.itemSize + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	/**
	 * Sets the given value to the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @param {number} value - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.array[ index * this.itemSize + component ] = value;

		return this;

	}

	/**
	 * Returns the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The x component.
	 */
	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	/**
	 * Sets the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	/**
	 * Returns the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The y component.
	 */
	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	/**
	 * Sets the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} y - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	/**
	 * Returns the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The z component.
	 */
	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	/**
	 * Sets the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} z - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	/**
	 * Returns the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The w component.
	 */
	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	/**
	 * Sets the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} w - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	/**
	 * Sets the x and y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	/**
	 * Sets the x, y and z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	/**
	 * Sets the x, y, z and w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @param {number} w - The value for the w component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	/**
	 * Sets the given callback function that is executed after the Renderer has transferred
	 * the attribute array data to the GPU. Can be used to perform clean-up operations after
	 * the upload when attribute data are not needed anymore on the CPU side.
	 *
	 * @param {Function} callback - The `onUpload()` callback.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	/**
	 * Returns a new buffer attribute with copied values from this instance.
	 *
	 * @return {BufferAttribute} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	/**
	 * Serializes the buffer attribute into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized buffer attribute.
	 */
	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

		return data;

	}

}

/**
 * Convenient class that can be used when creating a `Int8` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Int8BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `UInt8` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint8BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `UInt8Clamped` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint8ClampedBufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `Int16` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Int16BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `UInt16` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint16BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `Int32` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Int32BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `UInt32` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint32BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `Float16` buffer attribute with
 * a plain `Array` instance.
 *
 * This class automatically converts to and from FP16 since `Float16Array` is not
 * natively supported in JavaScript.
 *
 * @augments BufferAttribute
 */
class Float16BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

		this.isFloat16BufferAttribute = true;

	}

	getX( index ) {

		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = toHalfFloat( x );

		return this;

	}

	getY( index ) {

		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

		return this;

	}

	getZ( index ) {

		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

		return this;

	}

	getW( index ) {

		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );
		this.array[ index + 3 ] = toHalfFloat( w );

		return this;

	}

}

/**
 * Convenient class that can be used when creating a `Float32` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Float32BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$2 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

/**
 * A representation of mesh, line, or point geometry. Includes vertex
 * positions, face indices, normals, colors, UVs, and custom attributes
 * within buffers, reducing the cost of passing all this data to the GPU.
 *
 * ```js
 * const geometry = new THREE.BufferGeometry();
 * // create a simple square shape. We duplicate the top left and bottom right
 * // vertices because each vertex needs to appear once per triangle.
 * const vertices = new Float32Array( [
 * 	-1.0, -1.0,  1.0, // v0
 * 	 1.0, -1.0,  1.0, // v1
 * 	 1.0,  1.0,  1.0, // v2
 *
 * 	 1.0,  1.0,  1.0, // v3
 * 	-1.0,  1.0,  1.0, // v4
 * 	-1.0, -1.0,  1.0  // v5
 * ] );
 * // itemSize = 3 because there are 3 values (components) per vertex
 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * ```
 *
 * @augments EventDispatcher
 */
class BufferGeometry extends EventDispatcher {

	/**
	 * Constructs a new geometry.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBufferGeometry = true;

		/**
		 * The ID of the geometry.
		 *
		 * @name BufferGeometry#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		/**
		 * The UUID of the geometry.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the geometry.
		 *
		 * @type {string}
		 */
		this.name = '';
		this.type = 'BufferGeometry';

		/**
		 * Allows for vertices to be re-used across multiple triangles; this is
		 * called using "indexed triangles". Each triangle is associated with the
		 * indices of three vertices. This attribute therefore stores the index of
		 * each vertex for each triangular face. If this attribute is not set, the
		 * renderer assumes that each three contiguous positions represent a single triangle.
		 *
		 * @type {?BufferAttribute}
		 * @default null
		 */
		this.index = null;

		/**
		 * A (storage) buffer attribute which was generated with a compute shader and
		 * now defines indirect draw calls.
		 *
		 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
		 *
		 * @type {?BufferAttribute}
		 * @default null
		 */
		this.indirect = null;

		/**
		 * This dictionary has as id the name of the attribute to be set and as value
		 * the buffer attribute to set it to. Rather than accessing this property directly,
		 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
		 *
		 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
		 */
		this.attributes = {};

		/**
		 * This dictionary holds the morph targets of the geometry.
		 *
		 * Note: Once the geometry has been rendered, the morph attribute data cannot
		 * be changed. You will have to call `dispose()?, and create a new geometry instance.
		 *
		 * @type {Object}
		 */
		this.morphAttributes = {};

		/**
		 * Used to control the morph target behavior; when set to `true`, the morph
		 * target data is treated as relative offsets, rather than as absolute
		 * positions/normals.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.morphTargetsRelative = false;

		/**
		 * Split the geometry into groups, each of which will be rendered in a
		 * separate draw call. This allows an array of materials to be used with the geometry.
		 *
		 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
		 *
		 * Every vertex and index must belong to exactly one group — groups must not share vertices or
		 * indices, and must not leave vertices or indices unused.
		 *
		 * @type {Array<Object>}
		 */
		this.groups = [];

		/**
		 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
		 *
		 * @type {Box3}
		 * @default null
		 */
		this.boundingBox = null;

		/**
		 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
		 *
		 * @type {Sphere}
		 * @default null
		 */
		this.boundingSphere = null;

		/**
		 * Determines the part of the geometry to render. This should not be set directly,
		 * instead use `setDrawRange()`.
		 *
		 * @type {{start:number,count:number}}
		 */
		this.drawRange = { start: 0, count: Infinity };

		/**
		 * An object that can be used to store custom data about the geometry.
		 * It should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

	}

	/**
	 * Returns the index of this geometry.
	 *
	 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
	 */
	getIndex() {

		return this.index;

	}

	/**
	 * Sets the given index to this geometry.
	 *
	 * @param {Array<number>|BufferAttribute} index - The index to set.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	/**
	 * Sets the given indirect attribute to this geometry.
	 *
	 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setIndirect( indirect ) {

		this.indirect = indirect;

		return this;

	}

	/**
	 * Returns the indirect attribute of this geometry.
	 *
	 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
	 */
	getIndirect() {

		return this.indirect;

	}

	/**
	 * Returns the buffer attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
	 * Returns `undefined` if not attribute has been found.
	 */
	getAttribute( name ) {

		return this.attributes[ name ];

	}

	/**
	 * Sets the given attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	/**
	 * Deletes the attribute for the given name.
	 *
	 * @param {string} name - The attribute name to delete.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	/**
	 * Returns `true` if this geometry has an attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @return {boolean} Whether this geometry has an attribute for the given name or not.
	 */
	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	/**
	 * Adds a group to this geometry.
	 *
	 * @param {number} start - The first element in this draw call. That is the first
	 * vertex for non-indexed geometry, otherwise the first triangle index.
	 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
	 * @param {number} [materialIndex=0] - The material array index to use.
	 */
	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	/**
	 * Clears all groups.
	 */
	clearGroups() {

		this.groups = [];

	}

	/**
	 * Sets the draw range for this geometry.
	 *
	 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
	 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
	 * For indexed BufferGeometry, `count` is the number of indices to render.
	 */
	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	/**
	 * Applies the given 4x4 transformation matrix to the geometry.
	 *
	 * @param {Matrix4} matrix - The matrix to apply.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	/**
	 * Applies the rotation represented by the Quaternion to the geometry.
	 *
	 * @param {Quaternion} q - The Quaternion to apply.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Rotates the geometry about the X axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Rotates the geometry about the Y axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Rotates the geometry about the Z axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Translates the geometry. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#position} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} x - The x offset.
	 * @param {number} y - The y offset.
	 * @param {number} z - The z offset.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Scales the geometry. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#scale} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} x - The x scale.
	 * @param {number} y - The y scale.
	 * @param {number} z - The z scale.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	/**
	 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
	 * real-time mesh rotation.
	 *
	 * @param {Vector3} vector - The target point.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	/**
	 * Center the geometry based on its bounding box.
	 *
	 * @return {BufferGeometry} A reference to this instance.
	 */
	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	/**
	 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
	 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
	 * set to `0`.
	 *
	 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
	 * data from the array. The length of the array must match the vertex count.
	 *
	 * @param {Array<Vector2>|Array<Vector3>} points - The points.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setFromPoints( points ) {

		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute === undefined ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		} else {

			const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

			for ( let i = 0; i < l; i ++ ) {

				const point = points[ i ];
				positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

			}

			if ( points.length > positionAttribute.count ) {

				console.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

			}

			positionAttribute.needsUpdate = true;

		}

		return this;

	}

	/**
	 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
	 * The bounding box is not computed by the engine; it must be computed by your app.
	 * You may need to recompute the bounding box if the geometry vertices are modified.
	 */
	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	/**
	 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
	 * You may need to recompute the bounding sphere if the geometry vertices are modified.
	 */
	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$8 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	/**
	 * Calculates and adds a tangent attribute to this geometry.
	 *
	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
	 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
	 */
	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

		}

		const tangentAttribute = this.getAttribute( 'tangent' );

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			uvA.fromBufferAttribute( uvAttribute, a );
			uvB.fromBufferAttribute( uvAttribute, b );
			uvC.fromBufferAttribute( uvAttribute, c );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: index.count
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					index.getX( j + 0 ),
					index.getX( j + 1 ),
					index.getX( j + 2 )
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromBufferAttribute( normalAttribute, v );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? -1 : 1.0;

			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( index.getX( j + 0 ) );
				handleVertex( index.getX( j + 1 ) );
				handleVertex( index.getX( j + 2 ) );

			}

		}

	}

	/**
	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
	 * each vertex normal to be the average of the face normals of the faces that share that vertex.
	 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
	 * to be the same as the face normal.
	 */
	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	/**
	 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
	 * correct lighting on the geometry surfaces.
	 */
	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	/**
	 * Return a new non-index version of this indexed geometry. If the geometry
	 * is already non-indexed, the method is a NOOP.
	 *
	 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
	 */
	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	/**
	 * Serializes the geometry into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized geometry.
	 */
	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	/**
	 * Returns a new geometry with copied values from this instance.
	 *
	 * @return {BufferGeometry} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given geometry to this instance.
	 *
	 * @param {BufferGeometry} source - The geometry to copy.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires BufferGeometry#dispose
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$6 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

/**
 * Class representing triangular polygon mesh based objects.
 *
 * ```js
 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * scene.add( mesh );
 * ```
 *
 * @augments Object3D
 */
class Mesh extends Object3D {

	/**
	 * Constructs a new mesh.
	 *
	 * @param {BufferGeometry} [geometry] - The mesh geometry.
	 * @param {Material|Array<Material>} [material] - The mesh material.
	 */
	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMesh = true;

		this.type = 'Mesh';

		/**
		 * The mesh geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The mesh material.
		 *
		 * @type {Material|Array<Material>}
		 * @default MeshBasicMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	/**
	 * Returns the local-space position of the vertex at the given index, taking into
	 * account the current animation state of both morph targets and skinning.
	 *
	 * @param {number} index - The vertex index.
	 * @param {Vector3} target - The target object that is used to store the method's result.
	 * @return {Vector3} The vertex position in local space.
	 */
	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		return target;

	}

	/**
	 * Computes intersection points between a casted ray and this line.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$6.copy( geometry.boundingSphere );
		_sphere$6.applyMatrix4( matrixWorld );

		// check distance from ray origin to bounding sphere

		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		// convert ray to local space of mesh

		_inverseMatrix$3.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		// test with bounding box in local space

		if ( geometry.boundingBox !== null ) {

			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$3 );

	}

	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

		let intersection;

		const geometry = this.geometry;
		const material = this.material;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		const barycoord = new Vector3();
		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

		if ( uv ) {

			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

		}

		if ( uv1 ) {

			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

		}

		if ( normal ) {

			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

			if ( intersection.normal.dot( ray.direction ) > 0 ) {

				intersection.normal.multiplyScalar( -1 );

			}

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;
		intersection.barycoord = barycoord;

	}

	return intersection;

}

/**
 * A geometry class for a rectangular cuboid with a given width, height, and depth.
 * On creation, the cuboid is centred on the origin, with each edge parallel to one
 * of the axes.
 *
 * ```js
 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 * const cube = new THREE.Mesh( geometry, material );
 * scene.add( cube );
 * ```
 *
 * @augments BufferGeometry
 */
class BoxGeometry extends BufferGeometry {

	/**
	 * Constructs a new box geometry.
	 *
	 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
	 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
	 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
	 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
	 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
	 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
	 */
	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {BoxGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

// Uniform Utilities

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				if ( property.isRenderTargetTexture ) {

					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
					dst[ u ][ p ] = null;

				} else {

					dst[ u ][ p ] = property.clone();

				}

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

function getUnlitUniformColorSpace( renderer ) {

	const currentRenderTarget = renderer.getRenderTarget();

	if ( currentRenderTarget === null ) {

		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
		return renderer.outputColorSpace;

	}

	// https://github.com/mrdoob/three.js/issues/27868
	if ( currentRenderTarget.isXRRenderTarget === true ) {

		return currentRenderTarget.texture.colorSpace;

	}

	return ColorManagement.workingColorSpace;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * A material rendered with custom shaders. A shader is a small program written in GLSL.
 * that runs on the GPU. You may want to use a custom shader if you need to implement an
 * effect not included with any of the built-in materials.
 *
 * There are the following notes to bear in mind when using a `ShaderMaterial`:
 *
 * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
 * - Built in attributes and uniforms are passed to the shaders along with your code. If
 * you don't want that, use {@link RawShaderMaterial} instead.
 * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
 * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
 * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
 *   - The loop has to be [normalized]{@link https://en.wikipedia.org/wiki/Normalized_loop}.
 *   - The loop variable has to be *i*.
 *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
 * value of *i* for the given iteration and can be used in preprocessor
 * statements.
 *
 * ```js
 * const material = new THREE.ShaderMaterial( {
 * 	uniforms: {
 * 		time: { value: 1.0 },
 * 		resolution: { value: new THREE.Vector2() }
 * 	},
 * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
 * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
 * } );
 * ```
 *
 * @augments Material
 */
class ShaderMaterial extends Material {

	/**
	 * Constructs a new shader material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		/**
		 * Defines custom constants using `#define` directives within the GLSL code
		 * for both the vertex shader and the fragment shader; each key/value pair
		 * yields another directive.
		 * ```js
		 * defines: {
		 * 	FOO: 15,
		 * 	BAR: true
		 * }
		 * ```
		 * Yields the lines:
		 * ```
		 * #define FOO 15
		 * #define BAR true
		 * ```
		 *
		 * @type {Object}
		 */
		this.defines = {};

		/**
		 * An object of the form:
		 * ```js
		 * {
		 * 	"uniform1": { value: 1.0 },
		 * 	"uniform2": { value: 2 }
		 * }
		 * ```
		 * specifying the uniforms to be passed to the shader code; keys are uniform
		 * names, values are definitions of the form
		 * ```
		 * {
		 * 	value: 1.0
		 * }
		 * ```
		 * where `value` is the value of the uniform. Names must match the name of
		 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
		 * on every frame, so updating the value of the uniform will immediately
		 * update the value available to the GLSL code.
		 *
		 * @type {Object}
		 */
		this.uniforms = {};

		/**
		 * An array holding uniforms groups for configuring UBOs.
		 *
		 * @type {Array<UniformsGroup>}
		 */
		this.uniformsGroups = [];

		/**
		 * Vertex shader GLSL code. This is the actual code for the shader.
		 *
		 * @type {string}
		 */
		this.vertexShader = default_vertex;

		/**
		 * Fragment shader GLSL code. This is the actual code for the shader.
		 *
		 * @type {string}
		 */
		this.fragmentShader = default_fragment;

		/**
		 * Controls line thickness or lines.
		 *
		 * WebGL and WebGPU ignore this setting and always render line primitives with a
		 * width of one pixel.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.linewidth = 1;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * WebGL and WebGPU ignore this property and always render
		 * 1 pixel wide lines.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Define whether the material color is affected by global fog settings; `true`
		 * to pass fog uniforms to the shader.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.fog = false;

		/**
		 * Defines whether this material uses lighting; `true` to pass uniform data
		 * related to lighting to this shader.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.lights = false;

		/**
		 * Defines whether this material supports clipping; `true` to let the renderer
		 * pass the clippingPlanes uniform.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipping = false;

		/**
		 * Overwritten and set to `true` by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.forceSinglePass = true;

		/**
		 * This object allows to enable certain WebGL 2 extensions.
		 *
		 * - clipCullDistance: set to `true` to use vertex shader clipping
		 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
		 *
		 * @type {{clipCullDistance:false,multiDraw:false}}
		 */
		this.extensions = {
			clipCullDistance: false, // set to use vertex shader clipping
			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
		};

		/**
		 * When the rendered geometry doesn't include these attributes but the
		 * material does, these default values will be passed to the shaders. This
		 * avoids errors when buffer data is missing.
		 *
		 * - color: [ 1, 1, 1 ]
		 * - uv: [ 0, 0 ]
		 * - uv1: [ 0, 0 ]
		 *
		 * @type {Object}
		 */
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv1': [ 0, 0 ]
		};

		/**
		 * If set, this calls [gl.bindAttribLocation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation}
		 * to bind a generic vertex index to an attribute variable.
		 *
		 * @type {string|undefined}
		 * @default undefined
		 */
		this.index0AttributeName = undefined;

		/**
		 * Can be used to force a uniform update while changing uniforms in
		 * {@link Object3D#onBeforeRender}.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.uniformsNeedUpdate = false;

		/**
		 * Defines the GLSL version of custom shader code.
		 *
		 * @type {?(GLSL1|GLSL3)}
		 * @default null
		 */
		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		data.lights = this.lights;
		data.clipping = this.clipping;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

/**
 * Abstract base class for cameras. This class should always be inherited
 * when you build a new camera.
 *
 * @abstract
 * @augments Object3D
 */
class Camera extends Object3D {

	/**
	 * Constructs a new camera.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCamera = true;

		this.type = 'Camera';

		/**
		 * The inverse of the camera's world matrix.
		 *
		 * @type {Matrix4}
		 */
		this.matrixWorldInverse = new Matrix4();

		/**
		 * The camera's projection matrix.
		 *
		 * @type {Matrix4}
		 */
		this.projectionMatrix = new Matrix4();

		/**
		 * The inverse of the camera's projection matrix.
		 *
		 * @type {Matrix4}
		 */
		this.projectionMatrixInverse = new Matrix4();

		/**
		 * The coordinate system in which the camera is used.
		 *
		 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		 */
		this.coordinateSystem = WebGLCoordinateSystem;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		this.coordinateSystem = source.coordinateSystem;

		return this;

	}

	/**
	 * Returns a vector representing the ("look") direction of the 3D object in world space.
	 *
	 * This method is overwritten since cameras have a different forward vector compared to other
	 * 3D objects. A camera looks down its local, negative z-axis by default.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's direction in world space.
	 */
	getWorldDirection( target ) {

		return super.getWorldDirection( target ).negate();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _v3$1 = /*@__PURE__*/ new Vector3();
const _minTarget = /*@__PURE__*/ new Vector2();
const _maxTarget = /*@__PURE__*/ new Vector2();

/**
 * Camera that uses [perspective projection]{@link https://en.wikipedia.org/wiki/Perspective_(graphical)}.
 *
 * This projection mode is designed to mimic the way the human eye sees. It
 * is the most common projection mode used for rendering a 3D scene.
 *
 * ```js
 * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
 * scene.add( camera );
 * ```
 *
 * @augments Camera
 */
class PerspectiveCamera extends Camera {

	/**
	 * Constructs a new perspective camera.
	 *
	 * @param {number} [fov=50] - The vertical field of view.
	 * @param {number} [aspect=1] - The aspect ratio.
	 * @param {number} [near=0.1] - The camera's near plane.
	 * @param {number} [far=2000] - The camera's far plane.
	 */
	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		/**
		 * The vertical field of view, from bottom to top of view,
		 * in degrees.
		 *
		 * @type {number}
		 * @default 50
		 */
		this.fov = fov;

		/**
		 * The zoom factor of the camera.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.zoom = 1;

		/**
		 * The camera's near plane. The valid range is greater than `0`
		 * and less than the current value of {@link PerspectiveCamera#far}.
		 *
		 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
		 * valid value for a perspective camera's near plane.
		 *
		 * @type {number}
		 * @default 0.1
		 */
		this.near = near;

		/**
		 * The camera's far plane. Must be greater than the
		 * current value of {@link PerspectiveCamera#near}.
		 *
		 * @type {number}
		 * @default 2000
		 */
		this.far = far;

		/**
		 * Object distance used for stereoscopy and depth-of-field effects. This
		 * parameter does not influence the projection matrix unless a
		 * {@link StereoCamera} is being used.
		 *
		 * @type {number}
		 * @default 10
		 */
		this.focus = 10;

		/**
		 * The aspect ratio, usually the canvas width / canvas height.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aspect = aspect;

		/**
		 * Represents the frustum window specification. This property should not be edited
		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		 *
		 * @type {?Object}
		 * @default null
		 */
		this.view = null;

		/**
		 * Film size used for the larger axis. Default is `35` (millimeters). This
		 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
		 * is set to a nonzero value.
		 *
		 * @type {number}
		 * @default 35
		 */
		this.filmGauge = 35;

		/**
		 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.filmOffset = 0;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
	 * {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The computed focal length.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	/**
	 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
	 *
	 * @return {number} The effective FOV.
	 */
	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	/**
	 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The film width.
	 */
	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	/**
	 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The film width.
	 */
	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 *
	 * @param {number} distance - The viewing distance.
	 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
	 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
	 */
	getViewBounds( distance, minTarget, maxTarget ) {

		_v3$1.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

	}

	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 *
	 * @param {number} distance - The viewing distance.
	 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
	 * @returns {Vector2} The view size.
	 */
	getViewSize( distance, target ) {

		this.getViewBounds( distance, _minTarget, _maxTarget );

		return target.subVectors( _maxTarget, _minTarget );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *```
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *```
	 * then for each monitor you would call it like this:
	 *```js
	 * const w = 1920;
	 * const h = 1080;
	 * const fullWidth = w * 3;
	 * const fullHeight = h * 2;
	 *
	 * // --A--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 * // --B--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 * // --C--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 * // --D--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 * // --E--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 * // --F--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 * ```
	 *
	 * Note there is no reason monitors have to be the same size or in a grid.
	 *
	 * @param {number} fullWidth - The full width of multiview setup.
	 * @param {number} fullHeight - The full height of multiview setup.
	 * @param {number} x - The horizontal offset of the subcamera.
	 * @param {number} y - The vertical offset of the subcamera.
	 * @param {number} width - The width of subcamera.
	 * @param {number} height - The height of subcamera.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	/**
	 * Removes the view offset from the projection matrix.
	 */
	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	/**
	 * Updates the camera's projection matrix. Must be called after any change of
	 * camera properties.
	 */
	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = -90; // negative fov is not an error
const aspect = 1;

/**
 * A special type of camera that is positioned in 3D space to render its surroundings into a
 * cube render target. The render target can then be used as an environment map for rendering
 * realtime reflections in your scene.
 *
 * ```js
 * // Create cube render target
 * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
 *
 * // Create cube camera
 * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
 * scene.add( cubeCamera );
 *
 * // Create car
 * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
 * const car = new THREE.Mesh( carGeometry, chromeMaterial );
 * scene.add( car );
 *
 * // Update the render target cube
 * car.visible = false;
 * cubeCamera.position.copy( car.position );
 * cubeCamera.update( renderer, scene );
 *
 * // Render the scene
 * car.visible = true;
 * renderer.render( scene, camera );
 * ```
 *
 * @augments Object3D
 */
class CubeCamera extends Object3D {

	/**
	 * Constructs a new cube camera.
	 *
	 * @param {number} near - The camera's near plane.
	 * @param {number} far - The camera's far plane.
	 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
	 */
	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		/**
		 * A reference to the cube render target.
		 *
		 * @type {WebGLCubeRenderTarget}
		 */
		this.renderTarget = renderTarget;

		/**
		 * The current active coordinate system.
		 *
		 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		 * @default null
		 */
		this.coordinateSystem = null;

		/**
		 * The current active mipmap level
		 *
		 * @type {number}
		 * @default 0
		 */
		this.activeMipmapLevel = 0;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		this.add( cameraNZ );

	}

	/**
	 * Must be called when the coordinate system of the cube camera is changed.
	 */
	updateCoordinateSystem() {

		const coordinateSystem = this.coordinateSystem;

		const cameras = this.children.concat();

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

		for ( const camera of cameras ) this.remove( camera );

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			cameraPX.up.set( 0, 1, 0 );
			cameraPX.lookAt( 1, 0, 0 );

			cameraNX.up.set( 0, 1, 0 );
			cameraNX.lookAt( -1, 0, 0 );

			cameraPY.up.set( 0, 0, -1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, 1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, 1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			cameraPX.up.set( 0, -1, 0 );
			cameraPX.lookAt( -1, 0, 0 );

			cameraNX.up.set( 0, -1, 0 );
			cameraNX.lookAt( 1, 0, 0 );

			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, -1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, -1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, -1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else {

			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

		}

		for ( const camera of cameras ) {

			this.add( camera );

			camera.updateMatrixWorld();

		}

	}

	/**
	 * Calling this method will render the given scene with the given renderer
	 * into the cube render target of the camera.
	 *
	 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
	 * @param {Scene} scene - The scene to render.
	 */
	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const { renderTarget, activeMipmapLevel } = this;

		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

			this.coordinateSystem = renderer.coordinateSystem;

			this.updateCoordinateSystem();

		}

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

		const currentXrEnabled = renderer.xr.enabled;

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
		renderer.render( scene, cameraPZ );

		// mipmaps are generated during the last call of render()
		// at this point, all sides of the cube render target are defined

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

/**
 * Creates a cube texture made up of six images.
 *
 * ```js
 * const loader = new THREE.CubeTextureLoader();
 * loader.setPath( 'textures/cube/pisa/' );
 *
 * const textureCube = loader.load( [
 * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
 * ] );
 *
 * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
 * ```
 *
 * @augments Texture
 */
class CubeTexture extends Texture {

	/**
	 * Constructs a new cube texture.
	 *
	 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
	 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space value.
	 */
	constructor( images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCubeTexture = true;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

	}

	/**
	 * Alias for {@link CubeTexture#image}.
	 *
	 * @type {Array<Image>}
	 */
	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

/**
 * A cube render target used in context of {@link WebGLRenderer}.
 *
 * @augments WebGLRenderTarget
 */
class WebGLCubeRenderTarget extends WebGLRenderTarget {

	/**
	 * Constructs a new cube render target.
	 *
	 * @param {number} [size=1] - The size of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( size = 1, options = {} ) {

		super( size, size, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {DataArrayTexture}
		 */
		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	/**
	 * Converts the given equirectangular texture to a cube map.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {Texture} texture - The equirectangular texture.
	 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
	 */
	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.colorSpace = texture.colorSpace;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	/**
	 * Clears this cube render target.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
	 */
	clear( renderer, color = true, depth = true, stencil = true ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

/**
 * This is almost identical to an {@link Object3D}. Its purpose is to
 * make working with groups of objects syntactically clearer.
 *
 * ```js
 * // Create a group and add the two cubes.
 * // These cubes can now be rotated / scaled etc as a group.
 * const group = new THREE.Group();
 *
 * group.add( meshA );
 * group.add( meshB );
 *
 * scene.add( group );
 * ```
 *
 * @augments Object3D
 */
class Group extends Object3D {

	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

/**
 * Class for representing a XR controller with its
 * different coordinate systems.
 *
 * @private
 */
class WebXRController {

	/**
	 * Constructs a new XR controller.
	 */
	constructor() {

		/**
		 * A group representing the target ray space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._targetRay = null;

		/**
		 * A group representing the grip space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._grip = null;

		/**
		 * A group representing the hand space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._hand = null;

	}

	/**
	 * Returns a group representing the hand space of the XR controller.
	 *
	 * @return {Group} A group representing the hand space of the XR controller.
	 */
	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	/**
	 * Returns a group representing the target ray space of the XR controller.
	 *
	 * @return {Group} A group representing the target ray space of the XR controller.
	 */
	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	/**
	 * Returns a group representing the grip space of the XR controller.
	 *
	 * @return {Group} A group representing the grip space of the XR controller.
	 */
	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	/**
	 * Dispatches the given event to the groups representing
	 * the different coordinate spaces of the XR controller.
	 *
	 * @param {Object} event - The event to dispatch.
	 * @return {WebXRController} A reference to this instance.
	 */
	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	/**
	 * Connects the controller with the given XR input source.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @return {WebXRController} A reference to this instance.
	 */
	connect( inputSource ) {

		if ( inputSource && inputSource.hand ) {

			const hand = this._hand;

			if ( hand ) {

				for ( const inputjoint of inputSource.hand.values() ) {

					// Initialize hand with joints when connected
					this._getHandJoint( hand, inputjoint );

				}

			}

		}

		this.dispatchEvent( { type: 'connected', data: inputSource } );

		return this;

	}

	/**
	 * Disconnects the controller from the given XR input source.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @return {WebXRController} A reference to this instance.
	 */
	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	/**
	 * Updates the controller with the given input source, XR frame and reference space.
	 * This updates the transformations of the groups that represent the different
	 * coordinate systems of the controller.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @param {XRFrame} frame - The XR frame.
	 * @param {XRReferenceSpace} referenceSpace - The reference space.
	 * @return {WebXRController} A reference to this instance.
	 */
	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = this._getHandJoint( hand, inputjoint );

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.matrixWorldNeedsUpdate = true;
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
						grip.matrixWorldNeedsUpdate = true;

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if ( inputPose === null && gripPose !== null ) {

					inputPose = gripPose;

				}

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
					targetRay.matrixWorldNeedsUpdate = true;

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}


		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

	/**
	 * Returns a group representing the hand joint for the given input joint.
	 *
	 * @private
	 * @param {Group} hand - The group representing the hand space.
	 * @param {XRJointSpace} inputjoint - The hand joint data.
	 * @return {Group} A group representing the hand joint for the given input joint.
	 */
	_getHandJoint( hand, inputjoint ) {

		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[ inputjoint.jointName ] = joint;

			hand.add( joint );

		}

		return hand.joints[ inputjoint.jointName ];

	}

}

/**
 * This class can be used to define an exponential squared fog,
 * which gives a clear view near the camera and a faster than exponentially
 * densening fog farther from the camera.
 *
 * ```js
 * const scene = new THREE.Scene();
 * scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
 * ```
 */
class FogExp2 {

	/**
	 * Constructs a new fog.
	 *
	 * @param {number|Color} color - The fog's color.
	 * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
	 */
	constructor( color, density = 0.00025 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isFogExp2 = true;

		/**
		 * The name of the fog.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The fog's color.
		 *
		 * @type {Color}
		 */
		this.color = new Color( color );

		/**
		 *  Defines how fast the fog will grow dense.
		 *
		 * @type {number}
		 * @default 0.00025
		 */
		this.density = density;

	}

	/**
	 * Returns a new fog with copied values from this instance.
	 *
	 * @return {FogExp2} A clone of this instance.
	 */
	clone() {

		return new FogExp2( this.color, this.density );

	}

	/**
	 * Serializes the fog into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized fog
	 */
	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			name: this.name,
			color: this.color.getHex(),
			density: this.density
		};

	}

}

/**
 * This class can be used to define a linear fog that grows linearly denser
 * with the distance.
 *
 * ```js
 * const scene = new THREE.Scene();
 * scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );
 * ```
 */
class Fog {

	/**
	 * Constructs a new fog.
	 *
	 * @param {number|Color} color - The fog's color.
	 * @param {number} [near=1] - The minimum distance to start applying fog.
	 * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
	 */
	constructor( color, near = 1, far = 1000 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isFog = true;

		/**
		 * The name of the fog.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The fog's color.
		 *
		 * @type {Color}
		 */
		this.color = new Color( color );

		/**
		 * The minimum distance to start applying fog. Objects that are less than
		 * `near` units from the active camera won't be affected by fog.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.near = near;

		/**
		 * The maximum distance at which fog stops being calculated and applied.
		 * Objects that are more than `far` units away from the active camera won't
		 * be affected by fog.
		 *
		 * @type {number}
		 * @default 1000
		 */
		this.far = far;

	}

	/**
	 * Returns a new fog with copied values from this instance.
	 *
	 * @return {Fog} A clone of this instance.
	 */
	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	/**
	 * Serializes the fog into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized fog
	 */
	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			name: this.name,
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

/**
 * Scenes allow you to set up what is to be rendered and where by three.js.
 * This is where you place 3D objects like meshes, lines or lights.
 *
 * @augments Object3D
 */
class Scene extends Object3D {

	/**
	 * Constructs a new scene.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isScene = true;

		this.type = 'Scene';

		/**
		 * Defines the background of the scene. Valid inputs are:
		 *
		 * - A color for defining a uniform colored background.
		 * - A texture for defining a (flat) textured background.
		 * - Cube textures or equirectangular textures for defining a skybox.
		 *
		 * @type {?(Color|Texture)}
		 * @default null
		 */
		this.background = null;

		/**
		 * Sets the environment map for all physical materials in the scene. However,
		 * it's not possible to overwrite an existing texture assigned to the `envMap`
		 * material property.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.environment = null;

		/**
		 * A fog instance defining the type of fog that affects everything
		 * rendered in the scene.
		 *
		 * @type {?(Fog|FogExp2)}
		 * @default null
		 */
		this.fog = null;

		/**
		 * Sets the blurriness of the background. Only influences environment maps
		 * assigned to {@link Scene#background}. Valid input is a float between `0`
		 * and `1`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.backgroundBlurriness = 0;

		/**
		 * Attenuates the color of the background. Only applies to background textures.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.backgroundIntensity = 1;

		/**
		 * The rotation of the background in radians. Only influences environment maps
		 * assigned to {@link Scene#background}.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.backgroundRotation = new Euler();

		/**
		 * Attenuates the color of the environment. Only influences environment maps
		 * assigned to {@link Scene#environment}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.environmentIntensity = 1;

		/**
		 * The rotation of the environment map in radians. Only influences physical materials
		 * in the scene when {@link Scene#environment} is used.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.environmentRotation = new Euler();

		/**
		 * Forces everything in the scene to be rendered with the defined material. It is possible
		 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
		 *
		 * @type {?Material}
		 * @default null
		 */
		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy( source.backgroundRotation );

		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy( source.environmentRotation );

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();

		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();

		return data;

	}

}

/**
 * "Interleaved" means that multiple attributes, possibly of different types,
 * (e.g., position, normal, uv, color) are packed into a single array buffer.
 *
 * An introduction into interleaved arrays can be found here: [Interleaved array basics]{@link https://blog.tojicode.com/2011/05/interleaved-array-basics.html}
 */
class InterleavedBuffer {

	/**
	 * Constructs a new interleaved buffer.
	 *
	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
	 * @param {number} stride - The number of typed-array elements per vertex.
	 */
	constructor( array, stride ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInterleavedBuffer = true;

		/**
		 * A typed array with a shared buffer storing attribute data.
		 *
		 * @type {TypedArray}
		 */
		this.array = array;

		/**
		 * The number of typed-array elements per vertex.
		 *
		 * @type {number}
		 */
		this.stride = stride;

		/**
		 * The total number of elements in the array
		 *
		 * @type {number}
		 * @readonly
		 */
		this.count = array !== undefined ? array.length / stride : 0;

		/**
		 * Defines the intended usage pattern of the data store for optimization purposes.
		 *
		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		 * instantiate a new one and set the desired usage before the next render.
		 *
		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		 * @default StaticDrawUsage
		 */
		this.usage = StaticDrawUsage;

		/**
		 * This can be used to only update some components of stored vectors (for example, just the
		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		 *
		 * @type {Array<Object>}
		 */
		this.updateRanges = [];

		/**
		 * A version number, incremented every time the `needsUpdate` is set to `true`.
		 *
		 * @type {number}
		 */
		this.version = 0;

		/**
		 * The UUID of the interleaved buffer.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

	}

	/**
	 * A callback function that is executed after the renderer has transferred the attribute array
	 * data to the GPU.
	 */
	onUploadCallback() {}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Sets the usage of this interleaved buffer.
	 *
	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	 * @return {InterleavedBuffer} A reference to this interleaved buffer.
	 */
	setUsage( value ) {

		this.usage = value;

		return this;

	}

	/**
	 * Adds a range of data in the data array to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	/**
	 * Copies the values of the given interleaved buffer to this instance.
	 *
	 * @param {InterleavedBuffer} source - The interleaved buffer to copy.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	/**
	 * Copies a vector from the given interleaved buffer to this one. The start
	 * and destination position in the attribute buffers are represented by the
	 * given indices.
	 *
	 * @param {number} index1 - The destination index into this interleaved buffer.
	 * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
	 * @param {number} index2 - The source index into the given interleaved buffer.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	copyAt( index1, interleavedBuffer, index2 ) {

		index1 *= this.stride;
		index2 *= interleavedBuffer.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = interleavedBuffer.array[ index2 + i ];

		}

		return this;

	}

	/**
	 * Sets the given array data in the interleaved buffer.
	 *
	 * @param {(TypedArray|Array)} value - The array data to set.
	 * @param {number} [offset=0] - The offset in this interleaved buffer's array.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	/**
	 * Returns a new interleaved buffer with copied values from this instance.
	 *
	 * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
	 * @return {InterleavedBuffer} A clone of this instance.
	 */
	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	/**
	 * Sets the given callback function that is executed after the Renderer has transferred
	 * the array data to the GPU. Can be used to perform clean-up operations after
	 * the upload when data are not needed anymore on the CPU side.
	 *
	 * @param {Function} callback - The `onUpload()` callback.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	/**
	 * Serializes the interleaved buffer into JSON.
	 *
	 * @param {Object} [data] - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized interleaved buffer.
	 */
	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$7 = /*@__PURE__*/ new Vector3();

/**
 * An alternative version of a buffer attribute with interleaved data. Interleaved
 * attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with
 * different offsets into the buffer.
 */
class InterleavedBufferAttribute {

	/**
	 * Constructs a new interleaved buffer attribute.
	 *
	 * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
	 * @param {number} itemSize - The item size.
	 * @param {number} offset - The attribute offset into the buffer.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInterleavedBufferAttribute = true;

		/**
		 * The name of the buffer attribute.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The buffer holding the interleaved data.
		 *
		 * @type {InterleavedBuffer}
		 */
		this.data = interleavedBuffer;

		/**
		 * The item size, see {@link BufferAttribute#itemSize}.
		 *
		 * @type {number}
		 */
		this.itemSize = itemSize;

		/**
		 * The attribute offset into the buffer.
		 *
		 * @type {number}
		 */
		this.offset = offset;

		/**
		 * Whether the data are normalized or not, see {@link BufferAttribute#normalized}
		 *
		 * @type {InterleavedBuffer}
		 */
		this.normalized = normalized;

	}

	/**
	 * The item count of this buffer attribute.
	 *
	 * @type {number}
	 * @readonly
	 */
	get count() {

		return this.data.count;

	}

	/**
	 * The array holding the interleaved buffer attribute data.
	 *
	 * @type {TypedArray}
	 */
	get array() {

		return this.data.array;

	}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyMatrix4( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix3} m - The normal matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyNormalMatrix( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3` and with direction vectors.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.transformDirection( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Returns the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @return {number} The returned value.
	 */
	getComponent( index, component ) {

		let value = this.array[ index * this.data.stride + this.offset + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	/**
	 * Sets the given value to the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @param {number} value - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.data.array[ index * this.data.stride + this.offset + component ] = value;

		return this;

	}

	/**
	 * Sets the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	/**
	 * Sets the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} y - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	/**
	 * Sets the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} z - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	/**
	 * Sets the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} w - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	/**
	 * Returns the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The x component.
	 */
	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	/**
	 * Returns the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The y component.
	 */
	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	/**
	 * Returns the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The z component.
	 */
	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	/**
	 * Returns the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The w component.
	 */
	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	/**
	 * Sets the x and y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	/**
	 * Sets the x, y and z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	/**
	 * Sets the x, y, z and w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @param {number} w - The value for the w component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	/**
	 * Returns a new buffer attribute with copied values from this instance.
	 *
	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	 *
	 * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
	 * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
	 */
	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	/**
	 * Serializes the buffer attribute into JSON.
	 *
	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	 *
	 * @param {Object} [data] - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized buffer attribute.
	 */
	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

/**
 * A material for rendering instances of {@link Sprite}.
 *
 * ```js
 * const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
 * const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );
 *
 * const sprite = new THREE.Sprite( material );
 * sprite.scale.set(200, 200, 1)
 * scene.add( sprite );
 * ```
 *
 * @augments Material
 */
class SpriteMaterial extends Material {

	/**
	 * Constructs a new sprite material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The rotation of the sprite in radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.rotation = 0;

		/**
		 * Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sizeAttenuation = true;

		/**
		 * Overwritten since sprite materials are transparent
		 * by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.transparent = true;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

/**
 * A sprite is a plane that always faces towards the camera, generally with a
 * partially transparent texture applied.
 *
 * Sprites do not cast shadows, setting {@link Object3D#castShadow} to `true` will
 * have no effect.
 *
 * ```js
 * const map = new THREE.TextureLoader().load( 'sprite.png' );
 * const material = new THREE.SpriteMaterial( { map: map } );
 *
 * const sprite = new THREE.Sprite( material );
 * scene.add( sprite );
 * ```
 *
 * @augments Object3D
 */
class Sprite extends Object3D {

	/**
	 * Constructs a new sprite.
	 *
	 * @param {SpriteMaterial} [material] - The sprite material.
	 */
	constructor( material = new SpriteMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSprite = true;

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				-0.5, -0.5, 0, 0, 0,
				0.5, -0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				-0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		/**
		 * The sprite geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = _geometry;

		/**
		 * The sprite material.
		 *
		 * @type {SpriteMaterial}
		 */
		this.material = material;

		/**
		 * The sprite's anchor point, and the point around which the sprite rotates.
		 * A value of `(0.5, 0.5)` corresponds to the midpoint of the sprite. A value
		 * of `(0, 0)` corresponds to the lower left corner of the sprite.
		 *
		 * @type {Vector2}
		 * @default (0.5,0.5)
		 */
		this.center = new Vector2( 0.5, 0.5 );

	}

	/**
	 * Computes intersection points between a casted ray and this sprite.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( -0.5, -0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, -0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( -0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

/**
 * A component for providing a basic Level of Detail (LOD) mechanism.
 *
 * Every LOD level is associated with an object, and rendering can be switched
 * between them at the distances specified. Typically you would create, say,
 * three meshes, one for far away (low detail), one for mid range (medium
 * detail) and one for close up (high detail).
 *
 * ```js
 * const lod = new THREE.LOD();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 *
 * //Create spheres with 3 levels of detail and create new LOD levels for them
 * for( let i = 0; i < 3; i++ ) {
 *
 * 	const geometry = new THREE.IcosahedronGeometry( 10, 3 - i );
 * 	const mesh = new THREE.Mesh( geometry, material );
 * 	lod.addLevel( mesh, i * 75 );
 *
 * }
 *
 * scene.add( lod );
 * ```
 *
 * @augments Object3D
 */
class LOD extends Object3D {

	/**
	 * Constructs a new LOD.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLOD = true;

		/**
		 * The current LOD index.
		 *
		 * @private
		 * @type {number}
		 * @default 0
		 */
		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			/**
			 * This array holds the LOD levels.
			 *
			 * @name LOD#levels
			 * @type {Array<{object:Object3D,distance:number,hysteresis:number}>}
			 */
			levels: {
				enumerable: true,
				value: []
			}
		} );

		/**
		 * Whether the LOD object is updated automatically by the renderer per frame
		 * or not. If set to `false`, you have to call {@link LOD#update} in the
		 * render loop by yourself.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance, level.hysteresis );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	/**
	 * Adds a mesh that will display at a certain distance and greater. Typically
	 * the further away the distance, the lower the detail on the mesh.
	 *
	 * @param {Object3D} object - The 3D object to display at this level.
	 * @param {number} [distance=0] - The distance at which to display this level of detail.
	 * @param {number} [hysteresis=0] - Threshold used to avoid flickering at LOD boundaries, as a fraction of distance.
	 * @return {LOD} A reference to this instance.
	 */
	addLevel( object, distance = 0, hysteresis = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );

		this.add( object );

		return this;

	}

	/**
	 * Removes an existing level, based on the distance from the camera.
	 * Returns `true` when the level has been removed. Otherwise `false`.
	 *
	 * @param {number} distance - Distance of the level to remove.
	 * @return {boolean} Whether the level has been removed or not.
	 */
	removeLevel( distance ) {

		const levels = this.levels;

		for ( let i = 0; i < levels.length; i ++ ) {

			if ( levels[ i ].distance === distance ) {

				const removedElements = levels.splice( i, 1 );
				this.remove( removedElements[ 0 ].object );

				return true;

			}

		}

		return false;

	}

	/**
	 * Returns the currently active LOD level index.
	 *
	 * @return {number} The current active LOD level index.
	 */
	getCurrentLevel() {

		return this._currentLevel;

	}

	/**
	 * Returns a reference to the first 3D object that is greater than
	 * the given distance.
	 *
	 * @param {number} distance - The LOD distance.
	 * @return {Object3D|null} The found 3D object. `null` if no 3D object has been found.
	 */
	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance < levelDistance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	/**
	 * Computes intersection points between a casted ray and this LOD.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	/**
	 * Updates the LOD by computing which LOD level should be visible according
	 * to the current distance of the given camera.
	 *
	 * @param {Camera} camera - The camera the scene is rendered with.
	 */
	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance >= levelDistance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance,
				hysteresis: level.hysteresis
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector3 = /*@__PURE__*/ new Vector3();
const _matrix4 = /*@__PURE__*/ new Matrix4();
const _vertex = /*@__PURE__*/ new Vector3();

const _sphere$5 = /*@__PURE__*/ new Sphere();
const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();

/**
 * A mesh that has a {@link Skeleton} that can then be used to animate the
 * vertices of the geometry with skinning/skeleton animation.
 *
 * Next to a valid skeleton, the skinned mesh requires skin indices and weights
 * as buffer attributes in its geometry. These attribute define which bones affect a single
 * vertex to a certain extend.
 *
 * Typically skinned meshes are not created manually but loaders like {@link GLTFLoader}
 * or {@link FBXLoader } import respective models.
 *
 * @augments Mesh
 */
class SkinnedMesh extends Mesh {

	/**
	 * Constructs a new skinned mesh.
	 *
	 * @param {BufferGeometry} [geometry] - The mesh geometry.
	 * @param {Material|Array<Material>} [material] - The mesh material.
	 */
	constructor( geometry, material ) {

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		/**
		 * `AttachedBindMode` means the skinned mesh shares the same world space as the skeleton.
		 * This is not true when using `DetachedBindMode` which is useful when sharing a skeleton
		 * across multiple skinned meshes.
		 *
		 * @type {(AttachedBindMode|DetachedBindMode)}
		 * @default AttachedBindMode
		 */
		this.bindMode = AttachedBindMode;

		/**
		 * The base matrix that is used for the bound bone transforms.
		 *
		 * @type {Matrix4}
		 */
		this.bindMatrix = new Matrix4();

		/**
		 * The base matrix that is used for resetting the bound bone transforms.
		 *
		 * @type {Matrix4}
		 */
		this.bindMatrixInverse = new Matrix4();

		/**
		 * The bounding box of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingBox}.
		 *
		 * @type {?Box3}
		 * @default null
		 */
		this.boundingBox = null;

		/**
		 * The bounding sphere of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingSphere}.
		 *
		 * @type {?Sphere}
		 * @default null
		 */
		this.boundingSphere = null;

	}

	/**
	 * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
	 * The bounding box is not automatically computed by the engine; this method must be called by your app.
	 * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
	 * the current animation state.
	 */
	computeBoundingBox() {

		const geometry = this.geometry;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingBox.expandByPoint( _vertex );

		}

	}

	/**
	 * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
	 * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
	 * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
	 * per frame in order to reflect the current animation state.
	 */
	computeBoundingSphere() {

		const geometry = this.geometry;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingSphere.expandByPoint( _vertex );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	raycast( raycaster, intersects ) {

		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$5.copy( this.boundingSphere );
		_sphere$5.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$5 ) === false ) return;

		// convert ray to local space of skinned mesh

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// test with bounding box in local space

		if ( this.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$2 );

	}

	getVertexPosition( index, target ) {

		super.getVertexPosition( index, target );

		this.applyBoneTransform( index, target );

		return target;

	}

	/**
	 * Binds the given skeleton to the skinned mesh.
	 *
	 * @param {Skeleton} skeleton - The skeleton to bind.
	 * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
	 * the skinned mesh's world matrix will be used instead.
	 */
	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	/**
	 * This method sets the skinned mesh in the rest pose).
	 */
	pose() {

		this.skeleton.pose();

	}

	/**
	 * Normalizes the skin weights which are defined as a buffer attribute
	 * in the skinned mesh's geometry.
	 */
	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === AttachedBindMode ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === DetachedBindMode ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	/**
	 * Applies the bone transform associated with the given index to the given
	 * vertex position. Returns the updated vector.
	 *
	 * @param {number} index - The vertex index.
	 * @param {Vector3} target - The target object that is used to store the method's result.
	 * the skinned mesh's world matrix will be used instead.
	 * @return {Vector3} The updated vertex position.
	 */
	applyBoneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

/**
 * A bone which is part of a {@link Skeleton}. The skeleton in turn is used by
 * the {@link SkinnedMesh}.
 *
 * ```js
 * const root = new THREE.Bone();
 * const child = new THREE.Bone();
 *
 * root.add( child );
 * child.position.y = 5;
 * ```
 *
 * @augments Object3D
 */
class Bone extends Object3D {

	/**
	 * Constructs a new bone.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBone = true;

		this.type = 'Bone';

	}

}

/**
 * Creates a texture directly from raw buffer data.
 *
 * The interpretation of the data depends on type and format: If the type is
 * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
 * texel data. If the format is `RGBAFormat`, data needs four values for
 * one texel; Red, Green, Blue and Alpha (typically the opacity).
 *
 * @augments Texture
 */
class DataTexture extends Texture {

	/**
	 * Constructs a new data texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=NearestFilter] - The mag filter value.
	 * @param {number} [minFilter=NearestFilter] - The min filter value.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space.
	 */
	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDataTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number}}
		 */
		this.image = { data: data, width: width, height: height };

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

/**
 * Class for representing the armatures in `three.js`. The skeleton
 * is defined by a hierarchy of bones.
 *
 * ```js
 * const bones = [];
 *
 * const shoulder = new THREE.Bone();
 * const elbow = new THREE.Bone();
 * const hand = new THREE.Bone();
 *
 * shoulder.add( elbow );
 * elbow.add( hand );
 *
 * bones.push( shoulder , elbow, hand);
 *
 * shoulder.position.y = -5;
 * elbow.position.y = 0;
 * hand.position.y = 5;
 *
 * const armSkeleton = new THREE.Skeleton( bones );
 * ```
 */
class Skeleton {

	/**
	 * Constructs a new skeleton.
	 *
	 * @param {Array<Bone>} [bones] - An array of bones.
	 * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
	 * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
	 */
	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		/**
		 * An array of bones defining the skeleton.
		 *
		 * @type {Array<Bone>}
		 */
		this.bones = bones.slice( 0 );

		/**
		 * An array of bone inverse matrices.
		 *
		 * @type {Array<Matrix4>}
		 */
		this.boneInverses = boneInverses;

		/**
		 * An array buffer holding the bone data.
		 * Input data for {@link Skeleton#boneTexture}.
		 *
		 * @type {?Float32Array}
		 * @default null
		 */
		this.boneMatrices = null;

		/**
		 * A texture holding the bone data for use
		 * in the vertex shader.
		 *
		 * @type {?DataTexture}
		 * @default null
		 */
		this.boneTexture = null;

		this.init();

	}

	/**
	 * Initializes the skeleton. This method gets automatically called by the constructor
	 * but depending on how the skeleton is created it might be necessary to call this method
	 * manually.
	 */
	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	/**
	 * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
	 * and fills it with new matrices.
	 */
	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	/**
	 * Resets the skeleton to the base pose.
	 */
	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	/**
	 * Resets the skeleton to the base pose.
	 */
	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	/**
	 * Returns a new skeleton with copied values from this instance.
	 *
	 * @return {Skeleton} A clone of this instance.
	 */
	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	/**
	 * Computes a data texture for passing bone data to the vertex shader.
	 *
	 * @return {Skeleton} A reference of this instance.
	 */
	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;

		return this;

	}

	/**
	 * Searches through the skeleton's bone array and returns the first with a
	 * matching name.
	 *
	 * @param {string} name - The name of the bone.
	 * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
	 */
	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	/**
	 * Setups the skeleton by the given JSON and bones.
	 *
	 * @param {Object} json - The skeleton as serialized JSON.
	 * @param {Object<string, Bone>} bones - An array of bones.
	 * @return {Skeleton} A reference of this instance.
	 */
	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	/**
	 * Serializes the skeleton into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized skeleton.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

/**
 * An instanced version of a buffer attribute.
 *
 * @augments BufferAttribute
 */
class InstancedBufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new instanced buffer attribute.
	 *
	 * @param {TypedArray} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
	 */
	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		super( array, itemSize, normalized );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInstancedBufferAttribute = true;

		/**
		 * Defines how often a value of this buffer attribute should be repeated. A
		 * value of one means that each value of the instanced attribute is used for
		 * a single instance. A value of two means that each value is used for two
		 * consecutive instances (and so on).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _box3 = /*@__PURE__*/ new Box3();
const _identity = /*@__PURE__*/ new Matrix4();
const _mesh$1 = /*@__PURE__*/ new Mesh();
const _sphere$4 = /*@__PURE__*/ new Sphere();

/**
 * A special version of a mesh with instanced rendering support. Use
 * this class if you have to render a large number of objects with the same
 * geometry and material(s) but with different world transformations. The usage
 * of 'InstancedMesh' will help you to reduce the number of draw calls and thus
 * improve the overall rendering performance in your application.
 *
 * @augments Mesh
 */
class InstancedMesh extends Mesh {

	/**
	 * Constructs a new instanced mesh.
	 *
	 * @param {BufferGeometry} [geometry] - The mesh geometry.
	 * @param {Material|Array<Material>} [material] - The mesh material.
	 * @param {number} count - The number of instances.
	 */
	constructor( geometry, material, count ) {

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInstancedMesh = true;

		/**
		 * Represents the local transformation of all instances. You have to set its
		 * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data
		 * via {@link InstancedMesh#setMatrixAt}.
		 *
		 * @type {InstancedBufferAttribute}
		 */
		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );

		/**
		 * Represents the color of all instances. You have to set its
		 * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data
		 * via {@link InstancedMesh#setColorAt}.
		 *
		 * @type {?InstancedBufferAttribute}
		 * @default null
		 */
		this.instanceColor = null;

		/**
		 * Represents the morph target weights of all instances. You have to set its
		 * {@link Texture#needsUpdate} flag to true if you modify instanced data
		 * via {@link InstancedMesh#setMorphAt}.
		 *
		 * @type {?DataTexture}
		 * @default null
		 */
		this.morphTexture = null;

		/**
		 * The number of instances.
		 *
		 * @type {number}
		 */
		this.count = count;

		/**
		 * The bounding box of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingBox}.
		 *
		 * @type {?Box3}
		 * @default null
		 */
		this.boundingBox = null;

		/**
		 * The bounding sphere of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingSphere}.
		 *
		 * @type {?Sphere}
		 * @default null
		 */
		this.boundingSphere = null;

		for ( let i = 0; i < count; i ++ ) {

			this.setMatrixAt( i, _identity );

		}

	}

	/**
	 * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
	 * The bounding box is not automatically computed by the engine; this method must be called by your app.
	 * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
	 */
	computeBoundingBox() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		this.boundingBox.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

			this.boundingBox.union( _box3 );

		}

	}

	/**
	 * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
	 * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
	 */
	computeBoundingSphere() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		this.boundingSphere.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

			this.boundingSphere.union( _sphere$4 );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	/**
	 * Gets the color of the defined instance.
	 *
	 * @param {number} index - The instance index.
	 * @param {Color} color - The target object that is used to store the method's result.
	 */
	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	/**
	 * Gets the local transformation matrix of the defined instance.
	 *
	 * @param {number} index - The instance index.
	 * @param {Matrix4} matrix - The target object that is used to store the method's result.
	 */
	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	/**
	 * Gets the morph target weights of the defined instance.
	 *
	 * @param {number} index - The instance index.
	 * @param {Mesh} object - The target object that is used to store the method's result.
	 */
	getMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const array = this.morphTexture.source.data.data;

		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			objectInfluences[ i ] = array[ dataIndex + i ];

		}

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh$1.geometry = this.geometry;
		_mesh$1.material = this.material;

		if ( _mesh$1.material === undefined ) return;

		// test with bounding sphere first

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$4.copy( this.boundingSphere );
		_sphere$4.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		// now test each instance

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh$1.matrixWorld = _instanceWorldMatrix;

			_mesh$1.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	/**
	 * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
	 * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
	 *
	 * @param {number} index - The instance index.
	 * @param {Color} color - The instance color.
	 */
	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	/**
	 * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
	 * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
	 *
	 * @param {number} index - The instance index.
	 * @param {Matrix4} matrix - The local transformation.
	 */
	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	/**
	 * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
	 * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
	 *
	 * @param {number} index - The instance index.
	 * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
	 * of a single instance.
	 */
	setMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

		if ( this.morphTexture === null ) {

			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

		}

		const array = this.morphTexture.source.data.data;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			morphInfluencesSum += objectInfluences[ i ];

		}

		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		const dataIndex = len * index;

		array[ dataIndex ] = morphBaseInfluence;

		array.set( objectInfluences, dataIndex + 1 );

	}

	updateMorphTargets() {

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		if ( this.morphTexture !== null ) {

			this.morphTexture.dispose();
			this.morphTexture = null;

		}

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

/**
 * A two dimensional surface that extends infinitely in 3D space, represented
 * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}
 * by a unit length normal vector and a constant.
 */
class Plane {

	/**
	 * Constructs a new plane.
	 *
	 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
	 * @param {number} [constant=0] - The signed distance from the origin to the plane.
	 */
	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPlane = true;

		/**
		 * A unit length vector defining the normal of the plane.
		 *
		 * @type {Vector3}
		 */
		this.normal = normal;

		/**
		 * The signed distance from the origin to the plane.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.constant = constant;

	}

	/**
	 * Sets the plane components by copying the given values.
	 *
	 * @param {Vector3} normal - The normal.
	 * @param {number} constant - The constant.
	 * @return {Plane} A reference to this plane.
	 */
	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	/**
	 * Sets the plane components by defining `x`, `y`, `z` as the
	 * plane normal and `w` as the constant.
	 *
	 * @param {number} x - The value for the normal's x component.
	 * @param {number} y - The value for the normal's y component.
	 * @param {number} z - The value for the normal's z component.
	 * @param {number} w - The constant value.
	 * @return {Plane} A reference to this plane.
	 */
	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	/**
	 * Sets the plane from the given normal and coplanar point (that is a point
	 * that lies onto the plane).
	 *
	 * @param {Vector3} normal - The normal.
	 * @param {Vector3} point - A coplanar point.
	 * @return {Plane} A reference to this plane.
	 */
	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	/**
	 * Sets the plane from three coplanar points. The winding order is
	 * assumed to be counter-clockwise, and determines the direction of
	 * the plane normal.
	 *
	 * @param {Vector3} a - The first coplanar point.
	 * @param {Vector3} b - The second coplanar point.
	 * @param {Vector3} c - The third coplanar point.
	 * @return {Plane} A reference to this plane.
	 */
	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	/**
	 * Copies the values of the given plane to this instance.
	 *
	 * @param {Plane} plane - The plane to copy.
	 * @return {Plane} A reference to this plane.
	 */
	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	/**
	 * Normalizes the plane normal and adjusts the constant accordingly.
	 *
	 * @return {Plane} A reference to this plane.
	 */
	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	/**
	 * Negates both the plane normal and the constant.
	 *
	 * @return {Plane} A reference to this plane.
	 */
	negate() {

		this.constant *= -1;
		this.normal.negate();

		return this;

	}

	/**
	 * Returns the signed distance from the given point to this plane.
	 *
	 * @param {Vector3} point - The point to compute the distance for.
	 * @return {number} The signed distance.
	 */
	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	/**
	 * Returns the signed distance from the given sphere to this plane.
	 *
	 * @param {Sphere} sphere - The sphere to compute the distance for.
	 * @return {number} The signed distance.
	 */
	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	/**
	 * Projects a the given point onto the plane.
	 *
	 * @param {Vector3} point - The point to project.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The projected point on the plane.
	 */
	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	/**
	 * Returns the intersection point of the passed line and the plane. Returns
	 * `null` if the line does not intersect. Returns the line's starting point if
	 * the line is coplanar with the plane.
	 *
	 * @param {Line3} line - The line to compute the intersection for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	/**
	 * Returns `true` if the given line segment intersects with (passes through) the plane.
	 *
	 * @param {Line3} line - The line to test.
	 * @return {boolean} Whether the given line segment intersects with the plane or not.
	 */
	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	/**
	 * Returns `true` if the given bounding box intersects with the plane.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with the plane or not.
	 */
	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	/**
	 * Returns `true` if the given bounding sphere intersects with the plane.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
	 */
	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	/**
	 * Returns a coplanar vector to the plane, by calculating the
	 * projection of the normal at the origin onto the plane.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The coplanar point.
	 */
	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	/**
	 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
	 *
	 * The optional normal matrix can be pre-computed like so:
	 * ```js
	 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	 * ```
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
	 * @return {Plane} A reference to this plane.
	 */
	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	/**
	 * Translates the plane by the distance defined by the given offset vector.
	 * Note that this only affects the plane constant and will not affect the normal vector.
	 *
	 * @param {Vector3} offset - The offset vector.
	 * @return {Plane} A reference to this plane.
	 */
	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	/**
	 * Returns `true` if this plane is equal with the given one.
	 *
	 * @param {Plane} plane - The plane to test for equality.
	 * @return {boolean} Whether this plane is equal with the given one.
	 */
	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	/**
	 * Returns a new plane with copied values from this instance.
	 *
	 * @return {Plane} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$3 = /*@__PURE__*/ new Sphere();
const _vector$6 = /*@__PURE__*/ new Vector3();

/**
 * Frustums are used to determine what is inside the camera's field of view.
 * They help speed up the rendering process - objects which lie outside a camera's
 * frustum can safely be excluded from rendering.
 *
 * This class is mainly intended for use internally by a renderer.
 */
class Frustum {

	/**
	 * Constructs a new frustum.
	 *
	 * @param {Plane} [p0] - The first plane that encloses the frustum.
	 * @param {Plane} [p1] - The second plane that encloses the frustum.
	 * @param {Plane} [p2] - The third plane that encloses the frustum.
	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
	 */
	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		/**
		 * This array holds the planes that enclose the frustum.
		 *
		 * @type {Array<Plane>}
		 */
		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	/**
	 * Sets the frustum planes by copying the given planes.
	 *
	 * @param {Plane} [p0] - The first plane that encloses the frustum.
	 * @param {Plane} [p1] - The second plane that encloses the frustum.
	 * @param {Plane} [p2] - The third plane that encloses the frustum.
	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
	 * @return {Frustum} A reference to this frustum.
	 */
	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	/**
	 * Copies the values of the given frustum to this instance.
	 *
	 * @param {Frustum} frustum - The frustum to copy.
	 * @return {Frustum} A reference to this frustum.
	 */
	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	/**
	 * Sets the frustum planes from the given projection matrix.
	 *
	 * @param {Matrix4} m - The projection matrix.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
	 * @return {Frustum} A reference to this frustum.
	 */
	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

		} else {

			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

		}

		return this;

	}

	/**
	 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
	 *
	 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
	 *
	 * @param {Object3D} object - The 3D object to test.
	 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
	 */
	intersectsObject( object ) {

		if ( object.boundingSphere !== undefined ) {

			if ( object.boundingSphere === null ) object.computeBoundingSphere();

			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

		} else {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		}

		return this.intersectsSphere( _sphere$3 );

	}

	/**
	 * Returns `true` if the given sprite is intersecting this frustum.
	 *
	 * @param {Sprite} sprite - The sprite to test.
	 * @return {boolean} Whether the sprite is intersecting this frustum or not.
	 */
	intersectsSprite( sprite ) {

		_sphere$3.center.set( 0, 0, 0 );
		_sphere$3.radius = 0.7071067811865476;
		_sphere$3.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$3 );

	}

	/**
	 * Returns `true` if the given bounding sphere is intersecting this frustum.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
	 */
	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns `true` if the given bounding box is intersecting this frustum.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
	 */
	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns `true` if the given point lies within the frustum.
	 *
	 * @param {Vector3} point - The point to test.
	 * @return {boolean} Whether the point lies within this frustum or not.
	 */
	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns a new frustum with copied values from this instance.
	 *
	 * @return {Frustum} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
const _frustum$1 = /*@__PURE__*/ new Frustum();

/**
 * FrustumArray is used to determine if an object is visible in at least one camera
 * from an array of cameras. This is particularly useful for multi-view renderers.
*/
class FrustumArray {

	/**
	 * Constructs a new frustum array.
	 *
	 */
	constructor() {

		/**
		 * The coordinate system to use.
		 *
		 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
		 * @default WebGLCoordinateSystem
		 */
		this.coordinateSystem = WebGLCoordinateSystem;

	}

	/**
	 * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
	 * from the camera array.
	 *
	 * @param {Object3D} object - The 3D object to test.
	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	 * @return {boolean} Whether the 3D object is visible in any camera.
	 */
	intersectsObject( object, cameraArray ) {

		if ( ! cameraArray.isArrayCamera || cameraArray.cameras.length === 0 ) {

			return false;

		}

		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

			const camera = cameraArray.cameras[ i ];

			_projScreenMatrix$2.multiplyMatrices(
				camera.projectionMatrix,
				camera.matrixWorldInverse
			);

			_frustum$1.setFromProjectionMatrix(
				_projScreenMatrix$2,
				this.coordinateSystem
			);

			if ( _frustum$1.intersectsObject( object ) ) {

				return true; // Object is visible in at least one camera

			}

		}

		return false; // Not visible in any camera

	}

	/**
	 * Returns `true` if the given sprite is intersecting any frustum
	 * from the camera array.
	 *
	 * @param {Sprite} sprite - The sprite to test.
	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	 * @return {boolean} Whether the sprite is visible in any camera.
	 */
	intersectsSprite( sprite, cameraArray ) {

		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

			return false;

		}

		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

			const camera = cameraArray.cameras[ i ];

			_projScreenMatrix$2.multiplyMatrices(
				camera.projectionMatrix,
				camera.matrixWorldInverse
			);

			_frustum$1.setFromProjectionMatrix(
				_projScreenMatrix$2,
				this.coordinateSystem
			);

			if ( _frustum$1.intersectsSprite( sprite ) ) {

				return true; // Sprite is visible in at least one camera

			}

		}

		return false; // Not visible in any camera

	}

	/**
	 * Returns `true` if the given bounding sphere is intersecting any frustum
	 * from the camera array.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	 * @return {boolean} Whether the sphere is visible in any camera.
	 */
	intersectsSphere( sphere, cameraArray ) {

		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

			return false;

		}

		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

			const camera = cameraArray.cameras[ i ];

			_projScreenMatrix$2.multiplyMatrices(
				camera.projectionMatrix,
				camera.matrixWorldInverse
			);

			_frustum$1.setFromProjectionMatrix(
				_projScreenMatrix$2,
				this.coordinateSystem
			);

			if ( _frustum$1.intersectsSphere( sphere ) ) {

				return true; // Sphere is visible in at least one camera

			}

		}

		return false; // Not visible in any camera

	}

	/**
	 * Returns `true` if the given bounding box is intersecting any frustum
	 * from the camera array.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	 * @return {boolean} Whether the box is visible in any camera.
	 */
	intersectsBox( box, cameraArray ) {

		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

			return false;

		}

		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

			const camera = cameraArray.cameras[ i ];

			_projScreenMatrix$2.multiplyMatrices(
				camera.projectionMatrix,
				camera.matrixWorldInverse
			);

			_frustum$1.setFromProjectionMatrix(
				_projScreenMatrix$2,
				this.coordinateSystem
			);

			if ( _frustum$1.intersectsBox( box ) ) {

				return true; // Box is visible in at least one camera

			}

		}

		return false; // Not visible in any camera

	}

	/**
	 * Returns `true` if the given point lies within any frustum
	 * from the camera array.
	 *
	 * @param {Vector3} point - The point to test.
	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
	 * @return {boolean} Whether the point is visible in any camera.
	 */
	containsPoint( point, cameraArray ) {

		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

			return false;

		}

		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

			const camera = cameraArray.cameras[ i ];

			_projScreenMatrix$2.multiplyMatrices(
				camera.projectionMatrix,
				camera.matrixWorldInverse
			);

			_frustum$1.setFromProjectionMatrix(
				_projScreenMatrix$2,
				this.coordinateSystem
			);

			if ( _frustum$1.containsPoint( point ) ) {

				return true; // Point is visible in at least one camera

			}

		}

		return false; // Not visible in any camera

	}

	/**
	 * Returns a new frustum array with copied values from this instance.
	 *
	 * @return {FrustumArray} A clone of this instance.
	 */
	clone() {

		return new FrustumArray();

	}

}

function ascIdSort( a, b ) {

	return a - b;

}

function sortOpaque( a, b ) {

	return a.z - b.z;

}

function sortTransparent( a, b ) {

	return b.z - a.z;

}

class MultiDrawRenderList {

	constructor() {

		this.index = 0;
		this.pool = [];
		this.list = [];

	}

	push( start, count, z, index ) {

		const pool = this.pool;
		const list = this.list;
		if ( this.index >= pool.length ) {

			pool.push( {

				start: -1,
				count: -1,
				z: -1,
				index: -1,

			} );

		}

		const item = pool[ this.index ];
		list.push( item );
		this.index ++;

		item.start = start;
		item.count = count;
		item.z = z;
		item.index = index;

	}

	reset() {

		this.list.length = 0;
		this.index = 0;

	}

}

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );
const _frustum = /*@__PURE__*/ new Frustum();
const _frustumArray = /*@__PURE__*/ new FrustumArray();
const _box$1 = /*@__PURE__*/ new Box3();
const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$5 = /*@__PURE__*/ new Vector3();
const _forward = /*@__PURE__*/ new Vector3();
const _temp = /*@__PURE__*/ new Vector3();
const _renderList = /*@__PURE__*/ new MultiDrawRenderList();
const _mesh = /*@__PURE__*/ new Mesh();
const _batchIntersects = [];

// copies data from attribute "src" into "target" starting at "targetOffset"
function copyAttributeData( src, target, targetOffset = 0 ) {

	const itemSize = target.itemSize;
	if ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {

		// use the component getters and setters if the array data cannot
		// be copied directly
		const vertexCount = src.count;
		for ( let i = 0; i < vertexCount; i ++ ) {

			for ( let c = 0; c < itemSize; c ++ ) {

				target.setComponent( i + targetOffset, c, src.getComponent( i, c ) );

			}

		}

	} else {

		// faster copy approach using typed array set function
		target.array.set( src.array, targetOffset * itemSize );

	}

	target.needsUpdate = true;

}

// safely copies array contents to a potentially smaller array
function copyArrayContents( src, target ) {

	if ( src.constructor !== target.constructor ) {

		// if arrays are of a different type (eg due to index size increasing) then data must be per-element copied
		const len = Math.min( src.length, target.length );
		for ( let i = 0; i < len; i ++ ) {

			target[ i ] = src[ i ];

		}

	} else {

		// if the arrays use the same data layout we can use a fast block copy
		const len = Math.min( src.length, target.length );
		target.set( new src.constructor( src.buffer, 0, len ) );

	}

}

/**
 * A special version of a mesh with multi draw batch rendering support. Use
 * this class if you have to render a large number of objects with the same
 * material but with different geometries or world transformations. The usage of
 * `BatchedMesh` will help you to reduce the number of draw calls and thus improve the overall
 * rendering performance in your application.
 *
 * ```js
 * const box = new THREE.BoxGeometry( 1, 1, 1 );
 * const sphere = new THREE.SphereGeometry( 1, 12, 12 );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 *
 * // initialize and add geometries into the batched mesh
 * const batchedMesh = new BatchedMesh( 10, 5000, 10000, material );
 * const boxGeometryId = batchedMesh.addGeometry( box );
 * const sphereGeometryId = batchedMesh.addGeometry( sphere );
 *
 * // create instances of those geometries
 * const boxInstancedId1 = batchedMesh.addInstance( boxGeometryId );
 * const boxInstancedId2 = batchedMesh.addInstance( boxGeometryId );
 *
 * const sphereInstancedId1 = batchedMesh.addInstance( sphereGeometryId );
 * const sphereInstancedId2 = batchedMesh.addInstance( sphereGeometryId );
 *
 * // position the geometries
 * batchedMesh.setMatrixAt( boxInstancedId1, boxMatrix1 );
 * batchedMesh.setMatrixAt( boxInstancedId2, boxMatrix2 );
 *
 * batchedMesh.setMatrixAt( sphereInstancedId1, sphereMatrix1 );
 * batchedMesh.setMatrixAt( sphereInstancedId2, sphereMatrix2 );
 *
 * scene.add( batchedMesh );
 * ```
 *
 * @augments Mesh
 */
class BatchedMesh extends Mesh {

	/**
	 * Constructs a new batched mesh.
	 *
	 * @param {number} maxInstanceCount - The maximum number of individual instances planned to be added and rendered.
	 * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries.
	 * @param {number} [maxIndexCount=maxVertexCount*2] - The maximum number of indices to be used by all unique geometries
	 * @param {Material|Array<Material>} [material] - The mesh material.
	 */
	constructor( maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {

		super( new BufferGeometry(), material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBatchedMesh = true;

		/**
		 * When set ot `true`, the individual objects of a batch are frustum culled.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.perObjectFrustumCulled = true;

		/**
		 * When set to `true`, the individual objects of a batch are sorted to improve overdraw-related artifacts.
		 * If the material is marked as "transparent" objects are rendered back to front and if not then they are
		 * rendered front to back.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sortObjects = true;

		/**
		 * The bounding box of the batched mesh. Can be computed via {@link BatchedMesh#computeBoundingBox}.
		 *
		 * @type {?Box3}
		 * @default null
		 */
		this.boundingBox = null;

		/**
		 * The bounding sphere of the batched mesh. Can be computed via {@link BatchedMesh#computeBoundingSphere}.
		 *
		 * @type {?Sphere}
		 * @default null
		 */
		this.boundingSphere = null;

		/**
		 * Takes a sort a function that is run before render. The function takes a list of instances to
		 * sort and a camera. The objects in the list include a "z" field to perform a depth-ordered
		 * sort with.
		 *
		 * @type {?Function}
		 * @default null
		 */
		this.customSort = null;

		// stores visible, active, and geometry id per instance and reserved buffer ranges for geometries
		this._instanceInfo = [];
		this._geometryInfo = [];

		// instance, geometry ids that have been set as inactive, and are available to be overwritten
		this._availableInstanceIds = [];
		this._availableGeometryIds = [];

		// used to track where the next point is that geometry should be inserted
		this._nextIndexStart = 0;
		this._nextVertexStart = 0;
		this._geometryCount = 0;

		// flags
		this._visibilityChanged = true;
		this._geometryInitialized = false;

		// cached user options
		this._maxInstanceCount = maxInstanceCount;
		this._maxVertexCount = maxVertexCount;
		this._maxIndexCount = maxIndexCount;

		// buffers for multi draw
		this._multiDrawCounts = new Int32Array( maxInstanceCount );
		this._multiDrawStarts = new Int32Array( maxInstanceCount );
		this._multiDrawCount = 0;
		this._multiDrawInstances = null;

		// Local matrix per geometry by using data texture
		this._matricesTexture = null;
		this._indirectTexture = null;
		this._colorsTexture = null;

		this._initMatricesTexture();
		this._initIndirectTexture();

	}

	/**
	 * The maximum number of individual instances that can be stored in the batch.
	 *
	 * @type {number}
	 * @readonly
	 */
	get maxInstanceCount() {

		return this._maxInstanceCount;

	}

	/**
	 * The instance count.
	 *
	 * @type {number}
	 * @readonly
	 */
	get instanceCount() {

		return this._instanceInfo.length - this._availableInstanceIds.length;

	}

	/**
	 * The number of unused vertices.
	 *
	 * @type {number}
	 * @readonly
	 */
	get unusedVertexCount() {

		return this._maxVertexCount - this._nextVertexStart;

	}

	/**
	 * The number of unused indices.
	 *
	 * @type {number}
	 * @readonly
	 */
	get unusedIndexCount() {

		return this._maxIndexCount - this._nextIndexStart;

	}

	_initMatricesTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

		let size = Math.sqrt( this._maxInstanceCount * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		const matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );

		this._matricesTexture = matricesTexture;

	}

	_initIndirectTexture() {

		let size = Math.sqrt( this._maxInstanceCount );
		size = Math.ceil( size );

		const indirectArray = new Uint32Array( size * size );
		const indirectTexture = new DataTexture( indirectArray, size, size, RedIntegerFormat, UnsignedIntType );

		this._indirectTexture = indirectTexture;

	}

	_initColorsTexture() {

		let size = Math.sqrt( this._maxInstanceCount );
		size = Math.ceil( size );

		// 4 floats per RGBA pixel initialized to white
		const colorsArray = new Float32Array( size * size * 4 ).fill( 1 );
		const colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );
		colorsTexture.colorSpace = ColorManagement.workingColorSpace;

		this._colorsTexture = colorsTexture;

	}

	_initializeGeometry( reference ) {

		const geometry = this.geometry;
		const maxVertexCount = this._maxVertexCount;
		const maxIndexCount = this._maxIndexCount;
		if ( this._geometryInitialized === false ) {

			for ( const attributeName in reference.attributes ) {

				const srcAttribute = reference.getAttribute( attributeName );
				const { array, itemSize, normalized } = srcAttribute;

				const dstArray = new array.constructor( maxVertexCount * itemSize );
				const dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );

				geometry.setAttribute( attributeName, dstAttribute );

			}

			if ( reference.getIndex() !== null ) {

				// Reserve last u16 index for primitive restart.
				const indexArray = maxVertexCount > 65535
					? new Uint32Array( maxIndexCount )
					: new Uint16Array( maxIndexCount );

				geometry.setIndex( new BufferAttribute( indexArray, 1 ) );

			}

			this._geometryInitialized = true;

		}

	}

	// Make sure the geometry is compatible with the existing combined geometry attributes
	_validateGeometry( geometry ) {

		// check to ensure the geometries are using consistent attributes and indices
		const batchGeometry = this.geometry;
		if ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {

			throw new Error( 'THREE.BatchedMesh: All geometries must consistently have "index".' );

		}

		for ( const attributeName in batchGeometry.attributes ) {

			if ( ! geometry.hasAttribute( attributeName ) ) {

				throw new Error( `THREE.BatchedMesh: Added geometry missing "${ attributeName }". All geometries must have consistent attributes.` );

			}

			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			if ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {

				throw new Error( 'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );

			}

		}

	}

	/**
	 * Validates the instance defined by the given ID.
	 *
	 * @param {number} instanceId - The instance to validate.
	 */
	validateInstanceId( instanceId ) {

		const instanceInfo = this._instanceInfo;
		if ( instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[ instanceId ].active === false ) {

			throw new Error( `THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.` );

		}

	}

	/**
	 * Validates the geometry defined by the given ID.
	 *
	 * @param {number} geometryId - The geometry to validate.
	 */
	validateGeometryId( geometryId ) {

		const geometryInfoList = this._geometryInfo;
		if ( geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {

			throw new Error( `THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.` );

		}

	}

	/**
	 * Takes a sort a function that is run before render. The function takes a list of instances to
	 * sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.
	 *
	 * @param {Function} func - The custom sort function.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	setCustomSort( func ) {

		this.customSort = func;
		return this;

	}

	/**
	 * Computes the bounding box, updating {@link BatchedMesh#boundingBox}.
	 * Bounding boxes aren't computed by default. They need to be explicitly computed,
	 * otherwise they are `null`.
	 */
	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const boundingBox = this.boundingBox;
		const instanceInfo = this._instanceInfo;

		boundingBox.makeEmpty();
		for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

			if ( instanceInfo[ i ].active === false ) continue;

			const geometryId = instanceInfo[ i ].geometryIndex;
			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingBoxAt( geometryId, _box$1 ).applyMatrix4( _matrix$1 );
			boundingBox.union( _box$1 );

		}

	}

	/**
	 * Computes the bounding sphere, updating {@link BatchedMesh#boundingSphere}.
	 * Bounding spheres aren't computed by default. They need to be explicitly computed,
	 * otherwise they are `null`.
	 */
	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const boundingSphere = this.boundingSphere;
		const instanceInfo = this._instanceInfo;

		boundingSphere.makeEmpty();
		for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

			if ( instanceInfo[ i ].active === false ) continue;

			const geometryId = instanceInfo[ i ].geometryIndex;
			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );
			boundingSphere.union( _sphere$2 );

		}

	}

	/**
	 * Adds a new instance to the batch using the geometry of the given ID and returns
	 * a new id referring to the new instance to be used by other functions.
	 *
	 * @param {number} geometryId - The ID of a previously added geometry via {@link BatchedMesh#addGeometry}.
	 * @return {number} The instance ID.
	 */
	addInstance( geometryId ) {

		const atCapacity = this._instanceInfo.length >= this.maxInstanceCount;

		// ensure we're not over geometry
		if ( atCapacity && this._availableInstanceIds.length === 0 ) {

			throw new Error( 'THREE.BatchedMesh: Maximum item count reached.' );

		}

		const instanceInfo = {
			visible: true,
			active: true,
			geometryIndex: geometryId,
		};

		let drawId = null;

		// Prioritize using previously freed instance ids
		if ( this._availableInstanceIds.length > 0 ) {

			this._availableInstanceIds.sort( ascIdSort );

			drawId = this._availableInstanceIds.shift();
			this._instanceInfo[ drawId ] = instanceInfo;

		} else {

			drawId = this._instanceInfo.length;
			this._instanceInfo.push( instanceInfo );

		}

		const matricesTexture = this._matricesTexture;
		_matrix$1.identity().toArray( matricesTexture.image.data, drawId * 16 );
		matricesTexture.needsUpdate = true;

		const colorsTexture = this._colorsTexture;
		if ( colorsTexture ) {

			_whiteColor.toArray( colorsTexture.image.data, drawId * 4 );
			colorsTexture.needsUpdate = true;

		}

		this._visibilityChanged = true;
		return drawId;

	}

	/**
	 * Adds the given geometry to the batch and returns the associated
	 * geometry id referring to it to be used in other functions.
	 *
	 * @param {BufferGeometry} geometry - The geometry to add.
	 * @param {number} [reservedVertexCount=-1] - Optional parameter specifying the amount of
	 * vertex buffer space to reserve for the added geometry. This is necessary if it is planned
	 * to set a new geometry at this index at a later time that is larger than the original geometry.
	 * Defaults to the length of the given geometry vertex buffer.
	 * @param {number} [reservedIndexCount=-1] - Optional parameter specifying the amount of index
	 * buffer space to reserve for the added geometry. This is necessary if it is planned to set a
	 * new geometry at this index at a later time that is larger than the original geometry. Defaults to
	 * the length of the given geometry index buffer.
	 * @return {number} The geometry ID.
	 */
	addGeometry( geometry, reservedVertexCount = -1, reservedIndexCount = -1 ) {

		this._initializeGeometry( geometry );

		this._validateGeometry( geometry );

		const geometryInfo = {
			// geometry information
			vertexStart: -1,
			vertexCount: -1,
			reservedVertexCount: -1,

			indexStart: -1,
			indexCount: -1,
			reservedIndexCount: -1,

			// draw range information
			start: -1,
			count: -1,

			// state
			boundingBox: null,
			boundingSphere: null,
			active: true,
		};

		const geometryInfoList = this._geometryInfo;
		geometryInfo.vertexStart = this._nextVertexStart;
		geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute( 'position' ).count : reservedVertexCount;

		const index = geometry.getIndex();
		const hasIndex = index !== null;
		if ( hasIndex ) {

			geometryInfo.indexStart = this._nextIndexStart;
			geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;

		}

		if (
			geometryInfo.indexStart !== -1 &&
			geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||
			geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount
		) {

			throw new Error( 'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.' );

		}

		// update id
		let geometryId;
		if ( this._availableGeometryIds.length > 0 ) {

			this._availableGeometryIds.sort( ascIdSort );

			geometryId = this._availableGeometryIds.shift();
			geometryInfoList[ geometryId ] = geometryInfo;


		} else {

			geometryId = this._geometryCount;
			this._geometryCount ++;
			geometryInfoList.push( geometryInfo );

		}

		// update the geometry
		this.setGeometryAt( geometryId, geometry );

		// increment the next geometry position
		this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;
		this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;

		return geometryId;

	}

	/**
	 * Replaces the geometry at the given ID with the provided geometry. Throws an error if there
	 * is not enough space reserved for geometry. Calling this will change all instances that are
	 * rendering that geometry.
	 *
	 * @param {number} geometryId - The ID of the geometry that should be replaced with the given geometry.
	 * @param {BufferGeometry} geometry - The new geometry.
	 * @return {number} The geometry ID.
	 */
	setGeometryAt( geometryId, geometry ) {

		if ( geometryId >= this._geometryCount ) {

			throw new Error( 'THREE.BatchedMesh: Maximum geometry count reached.' );

		}

		this._validateGeometry( geometry );

		const batchGeometry = this.geometry;
		const hasIndex = batchGeometry.getIndex() !== null;
		const dstIndex = batchGeometry.getIndex();
		const srcIndex = geometry.getIndex();
		const geometryInfo = this._geometryInfo[ geometryId ];
		if (
			hasIndex &&
			srcIndex.count > geometryInfo.reservedIndexCount ||
			geometry.attributes.position.count > geometryInfo.reservedVertexCount
		) {

			throw new Error( 'THREE.BatchedMesh: Reserved space not large enough for provided geometry.' );

		}

		// copy geometry buffer data over
		const vertexStart = geometryInfo.vertexStart;
		const reservedVertexCount = geometryInfo.reservedVertexCount;
		geometryInfo.vertexCount = geometry.getAttribute( 'position' ).count;

		for ( const attributeName in batchGeometry.attributes ) {

			// copy attribute data
			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			copyAttributeData( srcAttribute, dstAttribute, vertexStart );

			// fill the rest in with zeroes
			const itemSize = srcAttribute.itemSize;
			for ( let i = srcAttribute.count, l = reservedVertexCount; i < l; i ++ ) {

				const index = vertexStart + i;
				for ( let c = 0; c < itemSize; c ++ ) {

					dstAttribute.setComponent( index, c, 0 );

				}

			}

			dstAttribute.needsUpdate = true;
			dstAttribute.addUpdateRange( vertexStart * itemSize, reservedVertexCount * itemSize );

		}

		// copy index
		if ( hasIndex ) {

			const indexStart = geometryInfo.indexStart;
			const reservedIndexCount = geometryInfo.reservedIndexCount;
			geometryInfo.indexCount = geometry.getIndex().count;

			// copy index data over
			for ( let i = 0; i < srcIndex.count; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );

			}

			// fill the rest in with zeroes
			for ( let i = srcIndex.count, l = reservedIndexCount; i < l; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart );

			}

			dstIndex.needsUpdate = true;
			dstIndex.addUpdateRange( indexStart, geometryInfo.reservedIndexCount );

		}

		// update the draw range
		geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;
		geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;

		// store the bounding boxes
		geometryInfo.boundingBox = null;
		if ( geometry.boundingBox !== null ) {

			geometryInfo.boundingBox = geometry.boundingBox.clone();

		}

		geometryInfo.boundingSphere = null;
		if ( geometry.boundingSphere !== null ) {

			geometryInfo.boundingSphere = geometry.boundingSphere.clone();

		}

		this._visibilityChanged = true;
		return geometryId;

	}

	/**
	 * Deletes the geometry defined by the given ID from this batch. Any instances referencing
	 * this geometry will also be removed as a side effect.
	 *
	 * @param {number} geometryId - The ID of the geometry to remove from the batch.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	deleteGeometry( geometryId ) {

		const geometryInfoList = this._geometryInfo;
		if ( geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {

			return this;

		}

		// delete any instances associated with this geometry
		const instanceInfo = this._instanceInfo;
		for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

			if ( instanceInfo[ i ].active && instanceInfo[ i ].geometryIndex === geometryId ) {

				this.deleteInstance( i );

			}

		}

		geometryInfoList[ geometryId ].active = false;
		this._availableGeometryIds.push( geometryId );
		this._visibilityChanged = true;

		return this;

	}

	/**
	 * Deletes an existing instance from the batch using the given ID.
	 *
	 * @param {number} instanceId - The ID of the instance to remove from the batch.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	deleteInstance( instanceId ) {

		this.validateInstanceId( instanceId );

		this._instanceInfo[ instanceId ].active = false;
		this._availableInstanceIds.push( instanceId );
		this._visibilityChanged = true;

		return this;

	}

	/**
	 * Repacks the sub geometries in [name] to remove any unused space remaining from
	 * previously deleted geometry, freeing up space to add new geometry.
	 *
	 * @param {number} instanceId - The ID of the instance to remove from the batch.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	optimize() {

		// track the next indices to copy data to
		let nextVertexStart = 0;
		let nextIndexStart = 0;

		// Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest
		// in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.
		const geometryInfoList = this._geometryInfo;
		const indices = geometryInfoList
			.map( ( e, i ) => i )
			.sort( ( a, b ) => {

				return geometryInfoList[ a ].vertexStart - geometryInfoList[ b ].vertexStart;

			} );

		const geometry = this.geometry;
		for ( let i = 0, l = geometryInfoList.length; i < l; i ++ ) {

			// if a geometry range is inactive then don't copy anything
			const index = indices[ i ];
			const geometryInfo = geometryInfoList[ index ];
			if ( geometryInfo.active === false ) {

				continue;

			}

			// if a geometry contains an index buffer then shift it, as well
			if ( geometry.index !== null ) {

				if ( geometryInfo.indexStart !== nextIndexStart ) {

					const { indexStart, vertexStart, reservedIndexCount } = geometryInfo;
					const index = geometry.index;
					const array = index.array;

					// shift the index pointers based on how the vertex data will shift
					// adjusting the index must happen first so the original vertex start value is available
					const elementDelta = nextVertexStart - vertexStart;
					for ( let j = indexStart; j < indexStart + reservedIndexCount; j ++ ) {

						array[ j ] = array[ j ] + elementDelta;

					}

					index.array.copyWithin( nextIndexStart, indexStart, indexStart + reservedIndexCount );
					index.addUpdateRange( nextIndexStart, reservedIndexCount );

					geometryInfo.indexStart = nextIndexStart;

				}

				nextIndexStart += geometryInfo.reservedIndexCount;

			}

			// if a geometry needs to be moved then copy attribute data to overwrite unused space
			if ( geometryInfo.vertexStart !== nextVertexStart ) {

				const { vertexStart, reservedVertexCount } = geometryInfo;
				const attributes = geometry.attributes;
				for ( const key in attributes ) {

					const attribute = attributes[ key ];
					const { array, itemSize } = attribute;
					array.copyWithin( nextVertexStart * itemSize, vertexStart * itemSize, ( vertexStart + reservedVertexCount ) * itemSize );
					attribute.addUpdateRange( nextVertexStart * itemSize, reservedVertexCount * itemSize );

				}

				geometryInfo.vertexStart = nextVertexStart;

			}

			nextVertexStart += geometryInfo.reservedVertexCount;
			geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;

			// step the next geometry points to the shifted position
			this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;
			this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;

		}

		return this;

	}

	/**
	 * Returns the bounding box for the given geometry.
	 *
	 * @param {number} geometryId - The ID of the geometry to return the bounding box for.
	 * @param {Box3} target - The target object that is used to store the method's result.
	 * @return {Box3|null} The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.
	 */
	getBoundingBoxAt( geometryId, target ) {

		if ( geometryId >= this._geometryCount ) {

			return null;

		}

		// compute bounding box
		const geometry = this.geometry;
		const geometryInfo = this._geometryInfo[ geometryId ];
		if ( geometryInfo.boundingBox === null ) {

			const box = new Box3();
			const index = geometry.index;
			const position = geometry.attributes.position;
			for ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				box.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );

			}

			geometryInfo.boundingBox = box;

		}

		target.copy( geometryInfo.boundingBox );
		return target;

	}

	/**
	 * Returns the bounding sphere for the given geometry.
	 *
	 * @param {number} geometryId - The ID of the geometry to return the bounding sphere for.
	 * @param {Sphere} target - The target object that is used to store the method's result.
	 * @return {Sphere|null} The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.
	 */
	getBoundingSphereAt( geometryId, target ) {

		if ( geometryId >= this._geometryCount ) {

			return null;

		}

		// compute bounding sphere
		const geometry = this.geometry;
		const geometryInfo = this._geometryInfo[ geometryId ];
		if ( geometryInfo.boundingSphere === null ) {

			const sphere = new Sphere();
			this.getBoundingBoxAt( geometryId, _box$1 );
			_box$1.getCenter( sphere.center );

			const index = geometry.index;
			const position = geometry.attributes.position;

			let maxRadiusSq = 0;
			for ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				_vector$5.fromBufferAttribute( position, iv );
				maxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );

			}

			sphere.radius = Math.sqrt( maxRadiusSq );
			geometryInfo.boundingSphere = sphere;

		}

		target.copy( geometryInfo.boundingSphere );
		return target;

	}

	/**
	 * Sets the given local transformation matrix to the defined instance.
	 * Negatively scaled matrices are not supported.
	 *
	 * @param {number} instanceId - The ID of an instance to set the matrix of.
	 * @param {Matrix4} matrix - A 4x4 matrix representing the local transformation of a single instance.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	setMatrixAt( instanceId, matrix ) {

		this.validateInstanceId( instanceId );

		const matricesTexture = this._matricesTexture;
		const matricesArray = this._matricesTexture.image.data;
		matrix.toArray( matricesArray, instanceId * 16 );
		matricesTexture.needsUpdate = true;

		return this;

	}

	/**
	 * Returns the local transformation matrix of the defined instance.
	 *
	 * @param {number} instanceId - The ID of an instance to get the matrix of.
	 * @param {Matrix4} matrix - The target object that is used to store the method's result.
	 * @return {Matrix4} The instance's local transformation matrix.
	 */
	getMatrixAt( instanceId, matrix ) {

		this.validateInstanceId( instanceId );
		return matrix.fromArray( this._matricesTexture.image.data, instanceId * 16 );

	}

	/**
	 * Sets the given color to the defined instance.
	 *
	 * @param {number} instanceId - The ID of an instance to set the color of.
	 * @param {Color} color - The color to set the instance to.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	setColorAt( instanceId, color ) {

		this.validateInstanceId( instanceId );

		if ( this._colorsTexture === null ) {

			this._initColorsTexture();

		}

		color.toArray( this._colorsTexture.image.data, instanceId * 4 );
		this._colorsTexture.needsUpdate = true;

		return this;

	}

	/**
	 * Returns the color of the defined instance.
	 *
	 * @param {number} instanceId - The ID of an instance to get the color of.
	 * @param {Color} color - The target object that is used to store the method's result.
	 * @return {Color} The instance's color.
	 */
	getColorAt( instanceId, color ) {

		this.validateInstanceId( instanceId );
		return color.fromArray( this._colorsTexture.image.data, instanceId * 4 );

	}

	/**
	 * Sets the visibility of the instance.
	 *
	 * @param {number} instanceId - The id of the instance to set the visibility of.
	 * @param {boolean} visible - Whether the instance is visible or not.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	setVisibleAt( instanceId, visible ) {

		this.validateInstanceId( instanceId );

		if ( this._instanceInfo[ instanceId ].visible === visible ) {

			return this;

		}

		this._instanceInfo[ instanceId ].visible = visible;
		this._visibilityChanged = true;

		return this;

	}

	/**
	 * Returns the visibility state of the defined instance.
	 *
	 * @param {number} instanceId - The ID of an instance to get the visibility state of.
	 * @return {boolean} Whether the instance is visible or not.
	 */
	getVisibleAt( instanceId ) {

		this.validateInstanceId( instanceId );

		return this._instanceInfo[ instanceId ].visible;

	}

	/**
	 * Sets the geometry ID of the instance at the given index.
	 *
	 * @param {number} instanceId - The ID of the instance to set the geometry ID of.
	 * @param {number} geometryId - The geometry ID to be use by the instance.
	 * @return {BatchedMesh} A reference to this batched mesh.
	 */
	setGeometryIdAt( instanceId, geometryId ) {

		this.validateInstanceId( instanceId );
		this.validateGeometryId( geometryId );

		this._instanceInfo[ instanceId ].geometryIndex = geometryId;

		return this;

	}

	/**
	 * Returns the geometry ID of the defined instance.
	 *
	 * @param {number} instanceId - The ID of an instance to get the geometry ID of.
	 * @return {number} The instance's geometry ID.
	 */
	getGeometryIdAt( instanceId ) {

		this.validateInstanceId( instanceId );

		return this._instanceInfo[ instanceId ].geometryIndex;

	}

	/**
	 * Get the range representing the subset of triangles related to the attached geometry,
	 * indicating the starting offset and count, or `null` if invalid.
	 *
	 * @param {number} geometryId - The id of the geometry to get the range of.
	 * @param {Object} [target] - The target object that is used to store the method's result.
	 * @return {{
	 * 	vertexStart:number,vertexCount:number,reservedVertexCount:number,
	 * 	indexStart:number,indexCount:number,reservedIndexCount:number,
	 * 	start:number,count:number
	 * }} The result object with range data.
	 */
	getGeometryRangeAt( geometryId, target = {} ) {

		this.validateGeometryId( geometryId );

		const geometryInfo = this._geometryInfo[ geometryId ];
		target.vertexStart = geometryInfo.vertexStart;
		target.vertexCount = geometryInfo.vertexCount;
		target.reservedVertexCount = geometryInfo.reservedVertexCount;

		target.indexStart = geometryInfo.indexStart;
		target.indexCount = geometryInfo.indexCount;
		target.reservedIndexCount = geometryInfo.reservedIndexCount;

		target.start = geometryInfo.start;
		target.count = geometryInfo.count;

		return target;

	}

	/**
	 * Resizes the necessary buffers to support the provided number of instances.
	 * If the provided arguments shrink the number of instances but there are not enough
	 * unused Ids at the end of the list then an error is thrown.
	 *
	 * @param {number} maxInstanceCount - The max number of individual instances that can be added and rendered by the batch.
	*/
	setInstanceCount( maxInstanceCount ) {

		// shrink the available instances as much as possible
		const availableInstanceIds = this._availableInstanceIds;
		const instanceInfo = this._instanceInfo;
		availableInstanceIds.sort( ascIdSort );
		while ( availableInstanceIds[ availableInstanceIds.length - 1 ] === instanceInfo.length ) {

			instanceInfo.pop();
			availableInstanceIds.pop();

		}

		// throw an error if it can't be shrunk to the desired size
		if ( maxInstanceCount < instanceInfo.length ) {

			throw new Error( `BatchedMesh: Instance ids outside the range ${ maxInstanceCount } are being used. Cannot shrink instance count.` );

		}

		// copy the multi draw counts
		const multiDrawCounts = new Int32Array( maxInstanceCount );
		const multiDrawStarts = new Int32Array( maxInstanceCount );
		copyArrayContents( this._multiDrawCounts, multiDrawCounts );
		copyArrayContents( this._multiDrawStarts, multiDrawStarts );

		this._multiDrawCounts = multiDrawCounts;
		this._multiDrawStarts = multiDrawStarts;
		this._maxInstanceCount = maxInstanceCount;

		// update texture data for instance sampling
		const indirectTexture = this._indirectTexture;
		const matricesTexture = this._matricesTexture;
		const colorsTexture = this._colorsTexture;

		indirectTexture.dispose();
		this._initIndirectTexture();
		copyArrayContents( indirectTexture.image.data, this._indirectTexture.image.data );

		matricesTexture.dispose();
		this._initMatricesTexture();
		copyArrayContents( matricesTexture.image.data, this._matricesTexture.image.data );

		if ( colorsTexture ) {

			colorsTexture.dispose();
			this._initColorsTexture();
			copyArrayContents( colorsTexture.image.data, this._colorsTexture.image.data );

		}

	}

	/**
	 * Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
	 * If the provided arguments shrink the geometry buffers but there is not enough unused space at the
	 * end of the geometry attributes then an error is thrown.
	 *
	 * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries to resize to.
	 * @param {number} maxIndexCount - The maximum number of indices to be used by all unique geometries to resize to.
	*/
	setGeometrySize( maxVertexCount, maxIndexCount ) {

		// Check if we can shrink to the requested vertex attribute size
		const validRanges = [ ...this._geometryInfo ].filter( info => info.active );
		const requiredVertexLength = Math.max( ...validRanges.map( range => range.vertexStart + range.reservedVertexCount ) );
		if ( requiredVertexLength > maxVertexCount ) {

			throw new Error( `BatchedMesh: Geometry vertex values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );

		}

		// Check if we can shrink to the requested index attribute size
		if ( this.geometry.index ) {

			const requiredIndexLength = Math.max( ...validRanges.map( range => range.indexStart + range.reservedIndexCount ) );
			if ( requiredIndexLength > maxIndexCount ) {

				throw new Error( `BatchedMesh: Geometry index values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );

			}

		}

		//

		// dispose of the previous geometry
		const oldGeometry = this.geometry;
		oldGeometry.dispose();

		// recreate the geometry needed based on the previous variant
		this._maxVertexCount = maxVertexCount;
		this._maxIndexCount = maxIndexCount;

		if ( this._geometryInitialized ) {

			this._geometryInitialized = false;
			this.geometry = new BufferGeometry();
			this._initializeGeometry( oldGeometry );

		}

		// copy data from the previous geometry
		const geometry = this.geometry;
		if ( oldGeometry.index ) {

			copyArrayContents( oldGeometry.index.array, geometry.index.array );

		}

		for ( const key in oldGeometry.attributes ) {

			copyArrayContents( oldGeometry.attributes[ key ].array, geometry.attributes[ key ].array );

		}

	}

	raycast( raycaster, intersects ) {

		const instanceInfo = this._instanceInfo;
		const geometryInfoList = this._geometryInfo;
		const matrixWorld = this.matrixWorld;
		const batchGeometry = this.geometry;

		// iterate over each geometry
		_mesh.material = this.material;
		_mesh.geometry.index = batchGeometry.index;
		_mesh.geometry.attributes = batchGeometry.attributes;
		if ( _mesh.geometry.boundingBox === null ) {

			_mesh.geometry.boundingBox = new Box3();

		}

		if ( _mesh.geometry.boundingSphere === null ) {

			_mesh.geometry.boundingSphere = new Sphere();

		}

		for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

			if ( ! instanceInfo[ i ].visible || ! instanceInfo[ i ].active ) {

				continue;

			}

			const geometryId = instanceInfo[ i ].geometryIndex;
			const geometryInfo = geometryInfoList[ geometryId ];
			_mesh.geometry.setDrawRange( geometryInfo.start, geometryInfo.count );

			// get the intersects
			this.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );
			this.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );
			this.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );
			_mesh.raycast( raycaster, _batchIntersects );

			// add batch id to the intersects
			for ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {

				const intersect = _batchIntersects[ j ];
				intersect.object = this;
				intersect.batchId = i;
				intersects.push( intersect );

			}

			_batchIntersects.length = 0;

		}

		_mesh.material = null;
		_mesh.geometry.index = null;
		_mesh.geometry.attributes = {};
		_mesh.geometry.setDrawRange( 0, Infinity );

	}

	copy( source ) {

		super.copy( source );

		this.geometry = source.geometry.clone();
		this.perObjectFrustumCulled = source.perObjectFrustumCulled;
		this.sortObjects = source.sortObjects;
		this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
		this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;

		this._geometryInfo = source._geometryInfo.map( info => ( {
			...info,

			boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,
			boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,
		} ) );
		this._instanceInfo = source._instanceInfo.map( info => ( { ...info } ) );

		this._availableInstanceIds = source._availableInstanceIds.slice();
		this._availableGeometryIds = source._availableGeometryIds.slice();

		this._nextIndexStart = source._nextIndexStart;
		this._nextVertexStart = source._nextVertexStart;
		this._geometryCount = source._geometryCount;

		this._maxInstanceCount = source._maxInstanceCount;
		this._maxVertexCount = source._maxVertexCount;
		this._maxIndexCount = source._maxIndexCount;

		this._geometryInitialized = source._geometryInitialized;
		this._multiDrawCounts = source._multiDrawCounts.slice();
		this._multiDrawStarts = source._multiDrawStarts.slice();

		this._indirectTexture = source._indirectTexture.clone();
		this._indirectTexture.image.data = this._indirectTexture.image.data.slice();

		this._matricesTexture = source._matricesTexture.clone();
		this._matricesTexture.image.data = this._matricesTexture.image.data.slice();

		if ( this._colorsTexture !== null ) {

			this._colorsTexture = source._colorsTexture.clone();
			this._colorsTexture.image.data = this._colorsTexture.image.data.slice();

		}

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		// Assuming the geometry is not shared with other meshes
		this.geometry.dispose();

		this._matricesTexture.dispose();
		this._matricesTexture = null;

		this._indirectTexture.dispose();
		this._indirectTexture = null;

		if ( this._colorsTexture !== null ) {

			this._colorsTexture.dispose();
			this._colorsTexture = null;

		}

	}

	onBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {

		// if visibility has not changed and frustum culling and object sorting is not required
		// then skip iterating over all items
		if ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {

			return;

		}

		// the indexed version of the multi draw function requires specifying the start
		// offset in bytes.
		const index = geometry.getIndex();
		const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;

		const instanceInfo = this._instanceInfo;
		const multiDrawStarts = this._multiDrawStarts;
		const multiDrawCounts = this._multiDrawCounts;
		const geometryInfoList = this._geometryInfo;
		const perObjectFrustumCulled = this.perObjectFrustumCulled;
		const indirectTexture = this._indirectTexture;
		const indirectArray = indirectTexture.image.data;

		const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
		// prepare the frustum in the local frame
		if ( perObjectFrustumCulled && ! camera.isArrayCamera ) {

			_matrix$1
				.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )
				.multiply( this.matrixWorld );
			_frustum.setFromProjectionMatrix(
				_matrix$1,
				renderer.coordinateSystem
			);

		}

		let multiDrawCount = 0;
		if ( this.sortObjects ) {

			// get the camera position in the local frame
			_matrix$1.copy( this.matrixWorld ).invert();
			_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _matrix$1 );
			_forward.set( 0, 0, -1 ).transformDirection( camera.matrixWorld ).transformDirection( _matrix$1 );

			for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

				if ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {

					const geometryId = instanceInfo[ i ].geometryIndex;

					// get the bounds in world space
					this.getMatrixAt( i, _matrix$1 );
					this.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						culled = ! frustum.intersectsSphere( _sphere$2, camera );

					}

					if ( ! culled ) {

						// get the distance from camera used for sorting
						const geometryInfo = geometryInfoList[ geometryId ];
						const z = _temp.subVectors( _sphere$2.center, _vector$5 ).dot( _forward );
						_renderList.push( geometryInfo.start, geometryInfo.count, z, i );

					}

				}

			}

			// Sort the draw ranges and prep for rendering
			const list = _renderList.list;
			const customSort = this.customSort;
			if ( customSort === null ) {

				list.sort( material.transparent ? sortTransparent : sortOpaque );

			} else {

				customSort.call( this, list, camera );

			}

			for ( let i = 0, l = list.length; i < l; i ++ ) {

				const item = list[ i ];
				multiDrawStarts[ multiDrawCount ] = item.start * bytesPerElement;
				multiDrawCounts[ multiDrawCount ] = item.count;
				indirectArray[ multiDrawCount ] = item.index;
				multiDrawCount ++;

			}

			_renderList.reset();

		} else {

			for ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {

				if ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {

					const geometryId = instanceInfo[ i ].geometryIndex;

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						// get the bounds in world space
						this.getMatrixAt( i, _matrix$1 );
						this.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );
						culled = ! frustum.intersectsSphere( _sphere$2, camera );

					}

					if ( ! culled ) {

						const geometryInfo = geometryInfoList[ geometryId ];
						multiDrawStarts[ multiDrawCount ] = geometryInfo.start * bytesPerElement;
						multiDrawCounts[ multiDrawCount ] = geometryInfo.count;
						indirectArray[ multiDrawCount ] = i;
						multiDrawCount ++;

					}

				}

			}

		}

		indirectTexture.needsUpdate = true;
		this._multiDrawCount = multiDrawCount;
		this._visibilityChanged = false;

	}

	onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {

		this.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );

	}

}

/**
 * A material for rendering line primitives.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * ```js
 * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
 * ```
 *
 * @augments Material
 */
class LineBasicMaterial extends Material {

	/**
	 * Constructs a new line basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * Sets the color of the lines using data from a texture. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * Controls line thickness or lines.
		 *
		 * Can only be used with {@link SVGRenderer}. WebGL and WebGPU
		 * ignore this setting and always render line primitives with a
		 * width of one pixel.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.linewidth = 1;

		/**
		 * Defines appearance of line ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('butt'|'round'|'square')}
		 * @default 'round'
		 */
		this.linecap = 'round';

		/**
		 * Defines appearance of line joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.linejoin = 'round';

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vStart = /*@__PURE__*/ new Vector3();
const _vEnd = /*@__PURE__*/ new Vector3();

const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

/**
 * A continuous line. The line are rendered by connecting consecutive
 * vertices with straight lines.
 *
 * ```js
 * const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 *
 * const points = [];
 * points.push( new THREE.Vector3( - 10, 0, 0 ) );
 * points.push( new THREE.Vector3( 0, 10, 0 ) );
 * points.push( new THREE.Vector3( 10, 0, 0 ) );
 *
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const line = new THREE.Line( geometry, material );
 * scene.add( line );
 * ```
 *
 * @augments Object3D
 */
class Line extends Object3D {

	/**
	 * Constructs a new line.
	 *
	 * @param {BufferGeometry} [geometry] - The line geometry.
	 * @param {Material|Array<Material>} [material] - The line material.
	 */
	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLine = true;

		this.type = 'Line';

		/**
		 * The line geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The line material.
		 *
		 * @type {Material|Array<Material>}
		 * @default LineBasicMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Computes an array of distance values which are necessary for rendering dashed lines.
	 * For each vertex in the geometry, the method calculates the cumulative length from the
	 * current point to the very beginning of the line.
	 *
	 * @return {Line} A reference to this line.
	 */
	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
				_vEnd.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	/**
	 * Computes intersection points between a casted ray and this line.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, i );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const a = index.getX( end - 1 );
				const b = index.getX( start );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, end - 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1, i );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start, end - 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		}

	}

	/**
	 * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function checkIntersection( object, raycaster, ray, thresholdSq, a, b, i ) {

	const positionAttribute = object.geometry.attributes.position;

	_vStart.fromBufferAttribute( positionAttribute, a );
	_vEnd.fromBufferAttribute( positionAttribute, b );

	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

	if ( distSq > thresholdSq ) return;

	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

	if ( distance < raycaster.near || distance > raycaster.far ) return;

	return {

		distance: distance,
		// What do we want? intersection point on the ray or on the segment??
		// point: raycaster.ray.at( distance ),
		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
		index: i,
		face: null,
		faceIndex: null,
		barycoord: null,
		object: object

	};

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

/**
 * A series of lines drawn between pairs of vertices.
 *
 * @augments Line
 */
class LineSegments extends Line {

	/**
	 * Constructs a new line segments.
	 *
	 * @param {BufferGeometry} [geometry] - The line geometry.
	 * @param {Material|Array<Material>} [material] - The line material.
	 */
	constructor( geometry, material ) {

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

/**
 * A continuous line. This is nearly the same as {@link Line} the only difference
 * is that the last vertex is connected with the first vertex in order to close
 * the line to form a loop.
 *
 * @augments Line
 */
class LineLoop extends Line {

	/**
	 * Constructs a new line loop.
	 *
	 * @param {BufferGeometry} [geometry] - The line geometry.
	 * @param {Material|Array<Material>} [material] - The line material.
	 */
	constructor( geometry, material ) {

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

/**
 * A material for rendering point primitives.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * ```js
 * const vertices = [];
 *
 * for ( let i = 0; i < 10000; i ++ ) {
 * 	const x = THREE.MathUtils.randFloatSpread( 2000 );
 * 	const y = THREE.MathUtils.randFloatSpread( 2000 );
 * 	const z = THREE.MathUtils.randFloatSpread( 2000 );
 *
 * 	vertices.push( x, y, z );
 * }
 *
 * const geometry = new THREE.BufferGeometry();
 * geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
 * const material = new THREE.PointsMaterial( { color: 0x888888 } );
 * const points = new THREE.Points( geometry, material );
 * scene.add( points );
 * ```
 *
 * @augments Material
 */
class PointsMaterial extends Material {

	/**
	 * Constructs a new points material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * Defines the size of the points in pixels.
		 *
		 * Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.size = 1;

		/**
		 * Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sizeAttenuation = true;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

/**
 * A class for displaying points or point clouds.
 *
 * @augments Object3D
 */
class Points extends Object3D {

	/**
	 * Constructs a new point cloud.
	 *
	 * @param {BufferGeometry} [geometry] - The points geometry.
	 * @param {Material|Array<Material>} [material] - The points material.
	 */
	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPoints = true;

		this.type = 'Points';

		/**
		 * The points geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The line material.
		 *
		 * @type {Material|Array<Material>}
		 * @default PointsMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Computes intersection points between a casted ray and this point cloud.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	/**
	 * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			faceIndex: null,
			barycoord: null,
			object: object

		} );

	}

}

/**
 * A texture for use with a video.
 *
 * ```js
 * // assuming you have created a HTML video element with id="video"
 * const video = document.getElementById( 'video' );
 * const texture = new THREE.VideoTexture( video );
 * ```
 *
 * Note: After the initial use of a texture, its dimensions, format, and type
 * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
 *
 * @augments Texture
 */
class VideoTexture extends Texture {

	/**
	 * Constructs a new video texture.
	 *
	 * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 */
	constructor( video, mapping, wrapS, wrapT, magFilter = LinearFilter, minFilter = LinearFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isVideoTexture = true;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	/**
	 * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
	 * to `true` every time a new frame is available.
	 *
	 * Only relevant if `requestVideoFrameCallback` is not supported in the browser.
	 */
	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

/**
 * This class can be used as an alternative way to define video data. Instead of using
 * an instance of `HTMLVideoElement` like with `VideoTexture`, `VideoFrameTexture` expects each frame is
 * defined manually via {@link VideoFrameTexture#setFrame}. A typical use case for this module is when
 * video frames are decoded with the WebCodecs API.
 *
 * ```js
 * const texture = new THREE.VideoFrameTexture();
 * texture.setFrame( frame );
 * ```
 *
 * @augments VideoTexture
 */
class VideoFrameTexture extends VideoTexture {

	/**
	 * Constructs a new video frame texture.
	 *
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 */
	constructor( mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( {}, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isVideoFrameTexture = true;

	}

	/**
	 * This method overwritten with an empty implementation since
	 * this type of texture is updated via `setFrame()`.
	 */
	update() {}

	clone() {

		return new this.constructor().copy( this ); // restoring Texture.clone()

	}

	/**
	 * Sets the current frame of the video. This will automatically update the texture
	 * so the data can be used for rendering.
	 *
	 * @param {VideoFrame} frame - The video frame.
	 */
	setFrame( frame ) {

		this.image = frame;
		this.needsUpdate = true;

	}

}

/**
 * This class can only be used in combination with `copyFramebufferToTexture()` methods
 * of renderers. It extracts the contents of the current bound framebuffer and provides it
 * as a texture for further usage.
 *
 * ```js
 * const pixelRatio = window.devicePixelRatio;
 * const textureSize = 128 * pixelRatio;
 *
 * const frameTexture = new FramebufferTexture( textureSize, textureSize );
 *
 * // calculate start position for copying part of the frame data
 * const vector = new Vector2();
 * vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
 * vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );
 *
 * renderer.render( scene, camera );
 *
 * // copy part of the rendered frame into the framebuffer texture
 * renderer.copyFramebufferToTexture( frameTexture, vector );
 * ```
 *
 * @augments Texture
 */
class FramebufferTexture extends Texture {

	/**
	 * Constructs a new framebuffer texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 */
	constructor( width, height ) {

		super( { width, height } );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isFramebufferTexture = true;

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default to disable filtering.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.magFilter = NearestFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default to disable filtering.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.minFilter = NearestFilter;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

/**
 * Creates a texture based on data in compressed form.
 *
 * These texture are usually loaded with {@link CompressedTextureLoader}.
 *
 * @augments Texture
 */
class CompressedTexture extends Texture {

	/**
	 * Constructs a new compressed texture.
	 *
	 * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
	 * the data and dimensions.
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space.
	 */
	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCompressedTexture = true;

		/**
		 * The image property of a compressed texture just defines its dimensions.
		 *
		 * @type {{width:number,height:number}}
		 */
		this.image = { width: width, height: height };

		/**
		 * This array holds for all mipmaps (including the bases mip) the data and dimensions.
		 *
		 * @type {Array<Object>}
		 */
		this.mipmaps = mipmaps;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default since it is not possible to
		 * flip compressed textures.
		 *
		 * @type {boolean}
		 * @default false
		 * @readonly
		 */
		this.flipY = false;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default since it is not
		 * possible to generate mipmaps for compressed data. Mipmaps
		 * must be embedded in the compressed texture file.
		 *
		 * @type {boolean}
		 * @default false
		 * @readonly
		 */
		this.generateMipmaps = false;

	}

}

/**
 * Creates a texture 2D array based on data in compressed form.
 *
 * These texture are usually loaded with {@link CompressedTextureLoader}.
 *
 * @augments CompressedTexture
 */
class CompressedArrayTexture extends CompressedTexture {

	/**
	 * Constructs a new compressed array texture.
	 *
	 * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
	 * the data and dimensions.
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} depth - The depth of the texture.
	 * @param {number} [format=RGBAFormat] - The min filter value.
	 * @param {number} [type=UnsignedByteType] - The min filter value.
	 */
	constructor( mipmaps, width, height, depth, format, type ) {

		super( mipmaps, width, height, format, type );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCompressedArrayTexture = true;

		/**
		 * The image property of a compressed texture just defines its dimensions.
		 *
		 * @name CompressedArrayTexture#image
		 * @type {{width:number,height:number,depth:number}}
		 */
		this.image.depth = depth;

		/**
		 * This defines how the texture is wrapped in the depth and corresponds to
		 * *W* in UVW mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapR = ClampToEdgeWrapping;

		/**
		 * A set of all layers which need to be updated in the texture.
		 *
		 * @type {Set<number>}
		 */
		this.layerUpdates = new Set();

	}

	/**
	 * Describes that a specific layer of the texture needs to be updated.
	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
	 * entire compressed texture array is sent to the GPU. Marking specific
	 * layers will only transmit subsets of all mipmaps associated with a
	 * specific depth in the array which is often much more performant.
	 *
	 * @param {number} layerIndex - The layer index that should be updated.
	 */
	addLayerUpdate( layerIndex ) {

		this.layerUpdates.add( layerIndex );

	}

	/**
	 * Resets the layer updates registry.
	 */
	clearLayerUpdates() {

		this.layerUpdates.clear();

	}

}

/**
 * Creates a cube texture based on data in compressed form.
 *
 * These texture are usually loaded with {@link CompressedTextureLoader}.
 *
 * @augments CompressedTexture
 */
class CompressedCubeTexture extends CompressedTexture {

	/**
	 * Constructs a new compressed texture.
	 *
	 * @param {Array<CompressedTexture>} images - An array of compressed textures.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 */
	constructor( images, format, type ) {

		super( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCompressedCubeTexture = true;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCubeTexture = true;

		this.image = images;

	}

}

/**
 * Creates a texture from a canvas element.
 *
 * This is almost the same as the base texture class, except that it sets {@link Texture#needsUpdate}
 * to `true` immediately since a canvas can directly be used for rendering.
 *
 * @augments Texture
 */
class CanvasTexture extends Texture {

	/**
	 * Constructs a new texture.
	 *
	 * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 */
	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCanvasTexture = true;

		this.needsUpdate = true;

	}

}

/**
 * This class can be used to automatically save the depth information of a
 * rendering into a texture.
 *
 * @augments Texture
 */
class DepthTexture extends Texture {

	/**
	 * Constructs a new depth texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} [type=UnsignedIntType] - The texture type.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearFilter] - The min filter value.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {number} [format=DepthFormat] - The texture format.
	 */
	constructor( width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat ) {

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDepthTexture = true;

		/**
		 * The image property of a depth texture just defines its dimensions.
		 *
		 * @type {{width:number,height:number}}
		 */
		this.image = { width: width, height: height };

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * Code corresponding to the depth compare function.
		 *
		 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
		 * @default null
		 */
		this.compareFunction = null;

	}


	copy( source ) {

		super.copy( source );

		this.source = new Source( Object.assign( {}, source.image ) ); // see #30540
		this.compareFunction = source.compareFunction;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

		return data;

	}

}

/**
 * Creates an array of depth textures.
 *
 * @augments DepthTexture
 */
class DepthArrayTexture extends DepthTexture {

	/**
	 * Constructs a new depth array texture.
	 *
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( width = 1, height = 1, depth = 1 ) {

		super( width, height );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDepthArrayTexture = true;

		/**
		 * The image definition of a depth texture.
		 *
		 * @type {{width:number,height:number,depth:number}}
		 */
		this.image = { width: width, height: height, depth: depth };

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * Code corresponding to the depth compare function.
		 *
		 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
		 * @default null
		 */
		this.compareFunction = null;

		/**
		 * A set of all layers which need to be updated in the texture.
		 *
		 * @type {Set<number>}
		 */
		this.layerUpdates = new Set();

	}

	/**
	 * Describes that a specific layer of the texture needs to be updated.
	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
	 * entire slice is sent to the GPU. Marking specific
	 * layers will only transmit subsets of all mipmaps associated with a
	 * specific depth in the array which is often much more performant.
	 *
	 * @param {number} layerIndex - The layer index that should be updated.
	 */
	addLayerUpdate( layerIndex ) {

		this.layerUpdates.add( layerIndex );

	}

	/**
	 * Resets the layer updates registry.
	 */
	clearLayerUpdates() {

		this.layerUpdates.clear();

	}

}

/**
 * A geometry class for representing a capsule.
 *
 * ```js
 * const geometry = new THREE.CapsuleGeometry( 1, 1, 4, 8, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 * const capsule = new THREE.Mesh( geometry, material );
 * scene.add( capsule );
 * ```
 *
 * @augments BufferGeometry
 */
class CapsuleGeometry extends BufferGeometry {

	/**
	 * Constructs a new capsule geometry.
	 *
	 * @param {number} [radius=1] - Radius of the capsule.
	 * @param {number} [height=1] - Height of the middle section.
	 * @param {number} [capSegments=4] - Number of curve segments used to build each cap.
	 * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule. Must be an integer >= 3.
	 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the middle section. Must be an integer >= 1.
	 */
	constructor( radius = 1, height = 1, capSegments = 4, radialSegments = 8, heightSegments = 1 ) {

		super();

		this.type = 'CapsuleGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			height: height,
			capSegments: capSegments,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
		};

		height = Math.max( 0, height );
		capSegments = Math.max( 1, Math.floor( capSegments ) );
		radialSegments = Math.max( 3, Math.floor( radialSegments ) );
		heightSegments = Math.max( 1, Math.floor( heightSegments ) );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const halfHeight = height / 2;
		const capArcLength = ( Math.PI / 2 ) * radius;
		const cylinderPartLength = height;
		const totalArcLength = 2 * capArcLength + cylinderPartLength;

		const numVerticalSegments = capSegments * 2 + heightSegments;
		const verticesPerRow = radialSegments + 1;

		const normal = new Vector3();
		const vertex = new Vector3();

		// generate vertices, normals, and uvs

		for ( let iy = 0; iy <= numVerticalSegments; iy ++ ) {

			let currentArcLength = 0;
			let profileY = 0;
			let profileRadius = 0;
			let normalYComponent = 0;

			if ( iy <= capSegments ) {

				// bottom cap
				const segmentProgress = iy / capSegments;
				const angle = ( segmentProgress * Math.PI ) / 2;
				profileY = - halfHeight - radius * Math.cos( angle );
				profileRadius = radius * Math.sin( angle );
				normalYComponent = - radius * Math.cos( angle );
				currentArcLength = segmentProgress * capArcLength;

			} else if ( iy <= capSegments + heightSegments ) {

				// middle section
				const segmentProgress = ( iy - capSegments ) / heightSegments;
				profileY = - halfHeight + segmentProgress * height;
				profileRadius = radius;
				normalYComponent = 0;
				currentArcLength = capArcLength + segmentProgress * cylinderPartLength;

			} else {

				// top cap
				const segmentProgress =
					( iy - capSegments - heightSegments ) / capSegments;
				const angle = ( segmentProgress * Math.PI ) / 2;
				profileY = halfHeight + radius * Math.sin( angle );
				profileRadius = radius * Math.cos( angle );
				normalYComponent = radius * Math.sin( angle );
				currentArcLength =
					capArcLength + cylinderPartLength + segmentProgress * capArcLength;

			}

			const v = Math.max( 0, Math.min( 1, currentArcLength / totalArcLength ) );


			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 ) {

				uOffset = 0.5 / radialSegments;

			} else if ( iy === numVerticalSegments ) {

				uOffset = -0.5 / radialSegments;

			}

			for ( let ix = 0; ix <= radialSegments; ix ++ ) {

				const u = ix / radialSegments;
				const theta = u * Math.PI * 2;

				const sinTheta = Math.sin( theta );
				const cosTheta = Math.cos( theta );

				// vertex

				vertex.x = - profileRadius * cosTheta;
				vertex.y = profileY;
				vertex.z = profileRadius * sinTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set(
					- profileRadius * cosTheta,
					normalYComponent,
					profileRadius * sinTheta
				);
				normal.normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, v );

			}

			if ( iy > 0 ) {

				const prevIndexRow = ( iy - 1 ) * verticesPerRow;
				for ( let ix = 0; ix < radialSegments; ix ++ ) {

					const i1 = prevIndexRow + ix;
					const i2 = prevIndexRow + ix + 1;
					const i3 = iy * verticesPerRow + ix;
					const i4 = iy * verticesPerRow + ix + 1;

					indices.push( i1, i2, i3 );
					indices.push( i2, i4, i3 );

				}

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {CapsuleGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.height, data.capSegments, data.radialSegments, data.heightSegments );

	}

}

/**
 * A simple shape of Euclidean geometry. It is constructed from a
 * number of triangular segments that are oriented around a central point and
 * extend as far out as a given radius. It is built counter-clockwise from a
 * start angle and a given central angle. It can also be used to create
 * regular polygons, where the number of segments determines the number of
 * sides.
 *
 * ```js
 * const geometry = new THREE.CircleGeometry( 5, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const circle = new THREE.Mesh( geometry, material );
 * scene.add( circle )
 * ```
 *
 * @augments BufferGeometry
 */
class CircleGeometry extends BufferGeometry {

	/**
	 * Constructs a new circle geometry.
	 *
	 * @param {number} [radius=1] - Radius of the circle.
	 * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
	 * @param {number} [thetaStart=0] - Start angle for first segment in radians.
	 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
	 * of the circular sector in radians. The default value results in a complete circle.
	 */
	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {CircleGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

/**
 * A geometry class for representing a cylinder.
 *
 * ```js
 * const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const cylinder = new THREE.Mesh( geometry, material );
 * scene.add( cylinder );
 * ```
 *
 * @augments BufferGeometry
 */
class CylinderGeometry extends BufferGeometry {

	/**
	 * Constructs a new cylinder geometry.
	 *
	 * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
	 * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
	 * @param {number} [height=1] - Height of the cylinder.
	 * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
	 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
	 * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
	 * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
	 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
	 * The default value results in a complete cylinder.
	 */
	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					if ( radiusTop > 0 || y !== 0 ) {

						indices.push( a, b, d );
						groupCount += 3;

					}

					if ( radiusBottom > 0 || y !== heightSegments - 1 ) {

						indices.push( b, c, d );
						groupCount += 3;

					}

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : -1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {CylinderGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

/**
 * A geometry class for representing a cone.
 *
 * ```js
 * const geometry = new THREE.ConeGeometry( 5, 20, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const cone = new THREE.Mesh(geometry, material );
 * scene.add( cone );
 * ```
 *
 * @augments CylinderGeometry
 */
class ConeGeometry extends CylinderGeometry {

	/**
	 * Constructs a new cone geometry.
	 *
	 * @param {number} [radius=1] - Radius of the cone base.
	 * @param {number} [height=1] - Height of the cone.
	 * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
	 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
	 * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
	 * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
	 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
	 * The default value results in a complete cone.
	 */
	constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {ConeGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

/**
 * A polyhedron is a solid in three dimensions with flat faces. This class
 * will take an array of vertices, project them onto a sphere, and then
 * divide them up to the desired level of detail.
 *
 * @augments BufferGeometry
 */
class PolyhedronGeometry extends BufferGeometry {

	/**
	 * Constructs a new polyhedron geometry.
	 *
	 * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
	 * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
	 * @param {number} [radius=1] - The radius of the shape.
	 * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
	 */
	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {PolyhedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

/**
 * A geometry class for representing a dodecahedron.
 *
 * ```js
 * const geometry = new THREE.DodecahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const dodecahedron = new THREE.Mesh( geometry, material );
 * scene.add( dodecahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 */
class DodecahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new dodecahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the dodecahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			-1, -1, -1,	-1, -1, 1,
			-1, 1, -1, -1, 1, 1,
			1, -1, -1, 1, -1, 1,
			1, 1, -1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {DodecahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = /*@__PURE__*/ new Vector3();
const _v1$1 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();
const _triangle = /*@__PURE__*/ new Triangle();

/**
 * Can be used as a helper object to view the edges of a geometry.
 *
 * ```js
 * const geometry = new THREE.BoxGeometry();
 * const edges = new THREE.EdgesGeometry( geometry );
 * const line = new THREE.LineSegments( edges );
 * scene.add( line );
 * ```
 *
 * Note: It is not yet possible to serialize/deserialize instances of this class.
 *
 * @augments BufferGeometry
 */
class EdgesGeometry extends BufferGeometry {

	/**
	 * Constructs a new edges geometry.
	 *
	 * @param {?BufferGeometry} [geometry=null] - The geometry.
	 * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
	 * between the face normals of the adjoining faces exceeds this value.
	 */
	constructor( geometry = null, thresholdAngle = 1 ) {

		super();

		this.type = 'EdgesGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

/**
 * An abstract base class for creating an analytic curve object that contains methods
 * for interpolation.
 *
 * @abstract
 */
class Curve {

	/**
	 * Constructs a new curve.
	 */
	constructor() {

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'Curve';

		/**
		 * This value determines the amount of divisions when calculating the
		 * cumulative segment lengths of a curve via {@link Curve#getLengths}. To ensure
		 * precision when using methods like {@link Curve#getSpacedPoints}, it is
		 * recommended to increase the value of this property if the curve is very large.
		 *
		 * @type {number}
		 * @default 200
		 */
		this.arcLengthDivisions = 200;

		/**
		 * Must be set to `true` if the curve parameters have changed.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsUpdate = false;

		/**
		 * An internal cache that holds precomputed curve length values.
		 *
		 * @private
		 * @type {?Array<number>}
		 * @default null
		 */
		this.cacheArcLengths = null;

	}

	/**
	 * This method returns a vector in 2D or 3D space (depending on the curve definition)
	 * for the given interpolation factor.
	 *
	 * @abstract
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
	 * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
	 */
	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );

	}

	/**
	 * This method returns a vector in 2D or 3D space (depending on the curve definition)
	 * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
	 * of the curve which equidistant samples.
	 *
	 * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
	 * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
	 */
	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	/**
	 * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
	 * the curve shape.
	 *
	 * @param {number} [divisions=5] - The number of divisions.
	 * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
	 */
	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	/**
	 * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
	 * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
	 * curve.
	 *
	 * @param {number} [divisions=5] - The number of divisions.
	 * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
	 */
	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	/**
	 * Returns the total arc length of the curve.
	 *
	 * @return {number} The length of the curve.
	 */
	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	/**
	 * Returns an array of cumulative segment lengths of the curve.
	 *
	 * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
	 * @return {Array<number>} An array holding the cumulative segment lengths.
	 */
	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	/**
	 * Update the cumulative segment distance cache. The method must be called
	 * every time curve parameters are changed. If an updated curve is part of a
	 * composed curve like {@link CurvePath}, this method must be called on the
	 * composed curve, too.
	 */
	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	/**
	 * Given an interpolation factor in the range `[0,1]`, this method returns an updated
	 * interpolation factor in the same range that can be ued to sample equidistant points
	 * from a curve.
	 *
	 * @param {number} u - The interpolation factor.
	 * @param {?number} distance - An optional distance on the curve.
	 * @return {number} The updated interpolation factor.
	 */
	getUtoTmapping( u, distance = null ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	/**
	 * Returns a unit vector tangent for the given interpolation factor.
	 * If the derived curve does not implement its tangent derivation,
	 * two points a small delta apart will be used to find its gradient
	 * which seems to give a reasonable approximation.
	 *
	 * @param {number} t - The interpolation factor.
	 * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
	 * @return {(Vector2|Vector3)} The tangent vector.
	 */
	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	/**
	 * Same as {@link Curve#getTangent} but with equidistant samples.
	 *
	 * @param {number} u - The interpolation factor.
	 * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
	 * @return {(Vector2|Vector3)} The tangent vector.
	 * @see {@link Curve#getPointAt}
	 */
	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	/**
	 * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
	 * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
	 *
	 * @param {number} segments - The number of segments.
	 * @param {boolean} [closed=false] - Whether the curve is closed or not.
	 * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
	 */
	computeFrenetFrames( segments, closed = false ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), -1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	/**
	 * Returns a new curve with copied values from this instance.
	 *
	 * @return {Curve} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given curve to this instance.
	 *
	 * @param {Curve} source - The curve to copy.
	 * @return {Curve} A reference to this curve.
	 */
	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	/**
	 * Serializes the curve into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized curve.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	/**
	 * Deserializes the curve from the given JSON.
	 *
	 * @param {Object} json - The JSON holding the serialized curve.
	 * @return {Curve} A reference to this curve.
	 */
	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

/**
 * A curve representing an ellipse.
 *
 * ```js
 * const curve = new THREE.EllipseCurve(
 * 	0, 0,
 * 	10, 10,
 * 	0, 2 * Math.PI,
 * 	false,
 * 	0
 * );
 *
 * const points = curve.getPoints( 50 );
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
 *
 * // Create the final object to add to the scene
 * const ellipse = new THREE.Line( geometry, material );
 * ```
 *
 * @augments Curve
 */
class EllipseCurve extends Curve {

	/**
	 * Constructs a new ellipse curve.
	 *
	 * @param {number} [aX=0] - The X center of the ellipse.
	 * @param {number} [aY=0] - The Y center of the ellipse.
	 * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
	 * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
	 * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
	 * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
	 * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
	 * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
	 */
	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isEllipseCurve = true;

		this.type = 'EllipseCurve';

		/**
		 * The X center of the ellipse.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.aX = aX;

		/**
		 * The Y center of the ellipse.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.aY = aY;

		/**
		 * The radius of the ellipse in the x direction.
		 * Setting the this value equal to the {@link EllipseCurve#yRadius} will result in a circle.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.xRadius = xRadius;

		/**
		 * The radius of the ellipse in the y direction.
		 * Setting the this value equal to the {@link EllipseCurve#xRadius} will result in a circle.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.yRadius = yRadius;

		/**
		 * The start angle of the curve in radians starting from the positive X axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.aStartAngle = aStartAngle;

		/**
		 * The end angle of the curve in radians starting from the positive X axis.
		 *
		 * @type {number}
		 * @default Math.PI*2
		 */
		this.aEndAngle = aEndAngle;

		/**
		 * Whether the ellipse is drawn clockwise or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.aClockwise = aClockwise;

		/**
		 * The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.aRotation = aRotation;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector2} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

/**
 * A curve representing an arc.
 *
 * @augments EllipseCurve
 */
class ArcCurve extends EllipseCurve {

	/**
	 * Constructs a new arc curve.
	 *
	 * @param {number} [aX=0] - The X center of the ellipse.
	 * @param {number} [aY=0] - The Y center of the ellipse.
	 * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
	 * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
	 * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
	 * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
	 */
	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isArcCurve = true;

		this.type = 'ArcCurve';

	}

}

function CubicPoly() {

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	* cusps and self-intersections in non-uniform catmull rom curves.
	* http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	*
	* curve.type accepts centripetal(default), chordal and catmullrom
	* curve.tension is used for catmullrom which defaults to 0.5
	*/

	/*
	Based on an optimized c++ solution in
	- http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	- http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = /*@__PURE__*/ new Vector3();
const px = /*@__PURE__*/ new CubicPoly();
const py = /*@__PURE__*/ new CubicPoly();
const pz = /*@__PURE__*/ new CubicPoly();

/**
 * A curve representing a Catmull-Rom spline.
 *
 * ```js
 * //Create a closed wavey loop
 * const curve = new THREE.CatmullRomCurve3( [
 * 	new THREE.Vector3( -10, 0, 10 ),
 * 	new THREE.Vector3( -5, 5, 5 ),
 * 	new THREE.Vector3( 0, 0, 0 ),
 * 	new THREE.Vector3( 5, -5, 5 ),
 * 	new THREE.Vector3( 10, 0, 10 )
 * ] );
 *
 * const points = curve.getPoints( 50 );
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
 *
 * // Create the final object to add to the scene
 * const curveObject = new THREE.Line( geometry, material );
 * ```
 *
 * @augments Curve
 */
class CatmullRomCurve3 extends Curve {

	/**
	 * Constructs a new Catmull-Rom curve.
	 *
	 * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
	 * @param {boolean} [closed=false] - Whether the curve is closed or not.
	 * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
	 * @param {number} [tension=0.5] - Tension of the curve.
	 */
	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCatmullRomCurve3 = true;

		this.type = 'CatmullRomCurve3';

		/**
		 * An array of 3D points defining the curve.
		 *
		 * @type {Array<Vector3>}
		 */
		this.points = points;

		/**
		 * Whether the curve is closed or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.closed = closed;

		/**
		 * The curve type.
		 *
		 * @type {('centripetal'|'chordal'|'catmullrom')}
		 * @default 'centripetal'
		 */
		this.curveType = curveType;

		/**
		 * Tension of the curve.
		 *
		 * @type {number}
		 * @default 0.5
		 */
		this.tension = tension;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector3} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

// Bezier Curves formulas obtained from: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

/**
 * Computes a point on a Catmull-Rom spline.
 *
 * @param {number} t - The interpolation factor.
 * @param {number} p0 - The first control point.
 * @param {number} p1 - The second control point.
 * @param {number} p2 - The third control point.
 * @param {number} p3 - The fourth control point.
 * @return {number} The calculated point on a Catmull-Rom spline.
 */
function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

/**
 * Computes a point on a Quadratic Bezier curve.
 *
 * @param {number} t - The interpolation factor.
 * @param {number} p0 - The first control point.
 * @param {number} p1 - The second control point.
 * @param {number} p2 - The third control point.
 * @return {number} The calculated point on a Quadratic Bezier curve.
 */
function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

/**
 * Computes a point on a Cubic Bezier curve.
 *
 * @param {number} t - The interpolation factor.
 * @param {number} p0 - The first control point.
 * @param {number} p1 - The second control point.
 * @param {number} p2 - The third control point.
 * @param {number} p3 - The fourth control point.
 * @return {number} The calculated point on a Cubic Bezier curve.
 */
function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

/**
 * A curve representing a 2D Cubic Bezier curve.
 *
 * ```js
 * const curve = new THREE.CubicBezierCurve(
 * 	new THREE.Vector2( - 0, 0 ),
 * 	new THREE.Vector2( - 5, 15 ),
 * 	new THREE.Vector2( 20, 15 ),
 * 	new THREE.Vector2( 10, 0 )
 * );
 *
 * const points = curve.getPoints( 50 );
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
 *
 * // Create the final object to add to the scene
 * const curveObject = new THREE.Line( geometry, material );
 * ```
 *
 * @augments Curve
 */
class CubicBezierCurve extends Curve {

	/**
	 * Constructs a new Cubic Bezier curve.
	 *
	 * @param {Vector2} [v0] - The start point.
	 * @param {Vector2} [v1] - The first control point.
	 * @param {Vector2} [v2] - The second control point.
	 * @param {Vector2} [v3] - The end point.
	 */
	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCubicBezierCurve = true;

		this.type = 'CubicBezierCurve';

		/**
		 * The start point.
		 *
		 * @type {Vector2}
		 */
		this.v0 = v0;

		/**
		 * The first control point.
		 *
		 * @type {Vector2}
		 */
		this.v1 = v1;

		/**
		 * The second control point.
		 *
		 * @type {Vector2}
		 */
		this.v2 = v2;

		/**
		 * The end point.
		 *
		 * @type {Vector2}
		 */
		this.v3 = v3;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector2} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

/**
 * A curve representing a 3D Cubic Bezier curve.
 *
 * @augments Curve
 */
class CubicBezierCurve3 extends Curve {

	/**
	 * Constructs a new Cubic Bezier curve.
	 *
	 * @param {Vector3} [v0] - The start point.
	 * @param {Vector3} [v1] - The first control point.
	 * @param {Vector3} [v2] - The second control point.
	 * @param {Vector3} [v3] - The end point.
	 */
	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCubicBezierCurve3 = true;

		this.type = 'CubicBezierCurve3';

		/**
		 * The start point.
		 *
		 * @type {Vector3}
		 */
		this.v0 = v0;

		/**
		 * The first control point.
		 *
		 * @type {Vector3}
		 */
		this.v1 = v1;

		/**
		 * The second control point.
		 *
		 * @type {Vector3}
		 */
		this.v2 = v2;

		/**
		 * The end point.
		 *
		 * @type {Vector3}
		 */
		this.v3 = v3;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector3} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

/**
 * A curve representing a 2D line segment.
 *
 * @augments Curve
 */
class LineCurve extends Curve {

	/**
	 * Constructs a new line curve.
	 *
	 * @param {Vector2} [v1] - The start point.
	 * @param {Vector2} [v2] - The end point.
	 */
	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineCurve = true;

		this.type = 'LineCurve';

		/**
		 * The start point.
		 *
		 * @type {Vector2}
		 */
		this.v1 = v1;

		/**
		 * The end point.
		 *
		 * @type {Vector2}
		 */
		this.v2 = v2;

	}

	/**
	 * Returns a point on the line.
	 *
	 * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
	 * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector2} The position on the line.
	 */
	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector2() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

/**
 * A curve representing a 3D line segment.
 *
 * @augments Curve
 */
class LineCurve3 extends Curve {

	/**
	 * Constructs a new line curve.
	 *
	 * @param {Vector3} [v1] - The start point.
	 * @param {Vector3} [v2] - The end point.
	 */
	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineCurve3 = true;

		this.type = 'LineCurve3';

		/**
		 * The start point.
		 *
		 * @type {Vector3}
		 */
		this.v1 = v1;

		/**
		 * The end point.
		 *
		 * @type {Vector2}
		 */
		this.v2 = v2;

	}

	/**
	 * Returns a point on the line.
	 *
	 * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
	 * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector3} The position on the line.
	 */
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

/**
 * A curve representing a 2D Quadratic Bezier curve.
 *
 * ```js
 * const curve = new THREE.QuadraticBezierCurve(
 * 	new THREE.Vector2( - 10, 0 ),
 * 	new THREE.Vector2( 20, 15 ),
 * 	new THREE.Vector2( 10, 0 )
 * )
 *
 * const points = curve.getPoints( 50 );
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
 *
 * // Create the final object to add to the scene
 * const curveObject = new THREE.Line( geometry, material );
 * ```
 *
 * @augments Curve
 */
class QuadraticBezierCurve extends Curve {

	/**
	 * Constructs a new Quadratic Bezier curve.
	 *
	 * @param {Vector2} [v0] - The start point.
	 * @param {Vector2} [v1] - The control point.
	 * @param {Vector2} [v2] - The end point.
	 */
	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isQuadraticBezierCurve = true;

		this.type = 'QuadraticBezierCurve';

		/**
		 * The start point.
		 *
		 * @type {Vector2}
		 */
		this.v0 = v0;

		/**
		 * The control point.
		 *
		 * @type {Vector2}
		 */
		this.v1 = v1;

		/**
		 * The end point.
		 *
		 * @type {Vector2}
		 */
		this.v2 = v2;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector2} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

/**
 * A curve representing a 3D Quadratic Bezier curve.
 *
 * @augments Curve
 */
class QuadraticBezierCurve3 extends Curve {

	/**
	 * Constructs a new Quadratic Bezier curve.
	 *
	 * @param {Vector3} [v0] - The start point.
	 * @param {Vector3} [v1] - The control point.
	 * @param {Vector3} [v2] - The end point.
	 */
	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isQuadraticBezierCurve3 = true;

		this.type = 'QuadraticBezierCurve3';

		/**
		 * The start point.
		 *
		 * @type {Vector3}
		 */
		this.v0 = v0;

		/**
		 * The control point.
		 *
		 * @type {Vector3}
		 */
		this.v1 = v1;

		/**
		 * The end point.
		 *
		 * @type {Vector3}
		 */
		this.v2 = v2;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector3} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

/**
 * A curve representing a 2D spline curve.
 *
 * ```js
 * // Create a sine-like wave
 * const curve = new THREE.SplineCurve( [
 * 	new THREE.Vector2( -10, 0 ),
 * 	new THREE.Vector2( -5, 5 ),
 * 	new THREE.Vector2( 0, 0 ),
 * 	new THREE.Vector2( 5, -5 ),
 * 	new THREE.Vector2( 10, 0 )
 * ] );
 *
 * const points = curve.getPoints( 50 );
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
 *
 * // Create the final object to add to the scene
 * const splineObject = new THREE.Line( geometry, material );
 * ```
 *
 * @augments Curve
 */
class SplineCurve extends Curve {

	/**
	 * Constructs a new 2D spline curve.
	 *
	 * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
	 */
	constructor( points = [] ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSplineCurve = true;

		this.type = 'SplineCurve';

		/**
		 * An array of 2D points defining the curve.
		 *
		 * @type {Array<Vector2>}
		 */
		this.points = points;

	}

	/**
	 * Returns a point on the curve.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
	 * @return {Vector2} The position on the curve.
	 */
	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**
 * A base class extending {@link Curve}. `CurvePath` is simply an
 * array of connected curves, but retains the API of a curve.
 *
 * @augments Curve
 */
class CurvePath extends Curve {

	/**
	 * Constructs a new curve path.
	 */
	constructor() {

		super();

		this.type = 'CurvePath';

		/**
		 * An array of curves defining the
		 * path.
		 *
		 * @type {Array<Curve>}
		 */
		this.curves = [];

		/**
		 * Whether the path should automatically be closed
		 * by a line curve.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.autoClose = false;

	}

	/**
	 * Adds a curve to this curve path.
	 *
	 * @param {Curve} curve - The curve to add.
	 */
	add( curve ) {

		this.curves.push( curve );

	}

	/**
	 * Adds a line curve to close the path.
	 *
	 * @return {CurvePath} A reference to this curve path.
	 */
	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			const lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';
			this.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );

		}

		return this;

	}

	/**
	 * This method returns a vector in 2D or 3D space (depending on the curve definitions)
	 * for the given interpolation factor.
	 *
	 * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
	 * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
	 * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
	 */
	getPoint( t, optionalTarget ) {

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	getLength() {

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	updateArcLengths() {

		// cacheLengths must be recalculated.

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	/**
	 * Returns list of cumulative curve lengths of the defined curves.
	 *
	 * @return {Array<number>} The curve lengths.
	 */
	getCurveLengths() {

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

/**
 * A 2D path representation. The class provides methods for creating paths
 * and contours of 2D shapes similar to the 2D Canvas API.
 *
 * ```js
 * const path = new THREE.Path();
 *
 * path.lineTo( 0, 0.8 );
 * path.quadraticCurveTo( 0, 1, 0.2, 1 );
 * path.lineTo( 1, 1 );
 *
 * const points = path.getPoints();
 *
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
 *
 * const line = new THREE.Line( geometry, material );
 * scene.add( line );
 * ```
 *
 * @augments CurvePath
 */
class Path extends CurvePath {

	/**
	 * Constructs a new path.
	 *
	 * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
	 */
	constructor( points ) {

		super();

		this.type = 'Path';

		/**
		 * The current offset of the path. Any new curve added will start here.
		 *
		 * @type {Vector2}
		 */
		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	/**
	 * Creates a path from the given list of points. The points are added
	 * to the path as instances of {@link LineCurve}.
	 *
	 * @param {Array<Vector2>} points - An array of 2D points.
	 * @return {Path} A reference to this path.
	 */
	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	/**
	 * Moves {@link Path#currentPoint} to the given point.
	 *
	 * @param {number} x - The x coordinate.
	 * @param {number} y - The y coordinate.
	 * @return {Path} A reference to this path.
	 */
	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	/**
	 * Adds an instance of {@link LineCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} x - The x coordinate of the end point.
	 * @param {number} y - The y coordinate of the end point.
	 * @return {Path} A reference to this path.
	 */
	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	/**
	 * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} aCPx - The x coordinate of the control point.
	 * @param {number} aCPy - The y coordinate of the control point.
	 * @param {number} aX - The x coordinate of the end point.
	 * @param {number} aY - The y coordinate of the end point.
	 * @return {Path} A reference to this path.
	 */
	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	/**
	 * Adds an instance of {@link CubicBezierCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} aCP1x - The x coordinate of the first control point.
	 * @param {number} aCP1y - The y coordinate of the first control point.
	 * @param {number} aCP2x - The x coordinate of the second control point.
	 * @param {number} aCP2y - The y coordinate of the second control point.
	 * @param {number} aX - The x coordinate of the end point.
	 * @param {number} aY - The y coordinate of the end point.
	 * @return {Path} A reference to this path.
	 */
	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	/**
	 * Adds an instance of {@link SplineCurve} to the path by connecting
	 * the current point with the given list of points.
	 *
	 * @param {Array<Vector2>} pts - An array of points in 2D space.
	 * @return {Path} A reference to this path.
	 */
	splineThru( pts ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	/**
	 * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
	 * to the current point.
	 *
	 * @param {number} aX - The x coordinate of the center of the arc offsetted from the previous curve.
	 * @param {number} aY - The y coordinate of the center of the arc offsetted from the previous curve.
	 * @param {number} aRadius - The radius of the arc.
	 * @param {number} aStartAngle - The start angle in radians.
	 * @param {number} aEndAngle - The end angle in radians.
	 * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
	 * @return {Path} A reference to this path.
	 */
	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	/**
	 * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
	 *
	 * @param {number} aX - The x coordinate of the center of the arc.
	 * @param {number} aY - The y coordinate of the center of the arc.
	 * @param {number} aRadius - The radius of the arc.
	 * @param {number} aStartAngle - The start angle in radians.
	 * @param {number} aEndAngle - The end angle in radians.
	 * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
	 * @return {Path} A reference to this path.
	 */
	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	/**
	 * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
	 * to the current point
	 *
	 * @param {number} aX - The x coordinate of the center of the ellipse offsetted from the previous curve.
	 * @param {number} aY - The y coordinate of the center of the ellipse offsetted from the previous curve.
	 * @param {number} xRadius - The radius of the ellipse in the x axis.
	 * @param {number} yRadius - The radius of the ellipse in the y axis.
	 * @param {number} aStartAngle - The start angle in radians.
	 * @param {number} aEndAngle - The end angle in radians.
	 * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
	 * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
	 * @return {Path} A reference to this path.
	 */
	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	/**
	 * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
	 *
	 * @param {number} aX - The x coordinate of the absolute center of the ellipse.
	 * @param {number} aY - The y coordinate of the absolute center of the ellipse.
	 * @param {number} xRadius - The radius of the ellipse in the x axis.
	 * @param {number} yRadius - The radius of the ellipse in the y axis.
	 * @param {number} aStartAngle - The start angle in radians.
	 * @param {number} aEndAngle - The end angle in radians.
	 * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
	 * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
	 * @return {Path} A reference to this path.
	 */
	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

/**
 * Defines an arbitrary 2d shape plane using paths with optional holes. It
 * can be used with {@link ExtrudeGeometry}, {@link ShapeGeometry}, to get
 * points, or to get triangulated faces.
 *
 * ```js
 * const heartShape = new THREE.Shape();
 *
 * heartShape.moveTo( 25, 25 );
 * heartShape.bezierCurveTo( 25, 25, 20, 0, 0, 0 );
 * heartShape.bezierCurveTo( - 30, 0, - 30, 35, - 30, 35 );
 * heartShape.bezierCurveTo( - 30, 55, - 10, 77, 25, 95 );
 * heartShape.bezierCurveTo( 60, 77, 80, 55, 80, 35 );
 * heartShape.bezierCurveTo( 80, 35, 80, 0, 50, 0 );
 * heartShape.bezierCurveTo( 35, 0, 25, 25, 25, 25 );
 *
 * const extrudeSettings = {
 * 	depth: 8,
 * 	bevelEnabled: true,
 * 	bevelSegments: 2,
 * 	steps: 2,
 * 	bevelSize: 1,
 * 	bevelThickness: 1
 * };
 *
 * const geometry = new THREE.ExtrudeGeometry( heartShape, extrudeSettings );
 * const mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
 * ```
 *
 * @augments Path
 */
class Shape extends Path {

	/**
	 * Constructs a new shape.
	 *
	 * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
	 */
	constructor( points ) {

		super( points );

		/**
		 * The UUID of the shape.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		this.type = 'Shape';

		/**
		 * Defines the holes in the shape. Hole definitions must use the
		 * opposite winding order (CW/CCW) than the outer shape.
		 *
		 * @type {Array<Path>}
		 * @readonly
		 */
		this.holes = [];

	}

	/**
	 * Returns an array representing each contour of the holes
	 * as a list of 2D points.
	 *
	 * @param {number} divisions - The fineness of the result.
	 * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
	 */
	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	/**
	 * Returns an object that holds contour data for the shape and its holes as
	 * arrays of 2D points.
	 *
	 * @param {number} divisions - The fineness of the result.
	 * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
	 */
	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/* eslint-disable */
// copy of mapbox/earcut version 3.0.1
// https://github.com/mapbox/earcut/tree/v3.0.1

function earcut(data, holeIndices, dim = 2) {

    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    let minX, minY, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = Infinity;
        minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = dim; i < outerLen; i += dim) {
            const x = data[i];
            const y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    } else {
        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    let p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    let stop = ear;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        const prev = ear.prev;
        const next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i, ear.i, next.i); // cut off the triangle

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox
    const x0 = Math.min(ax, bx, cx),
        y0 = Math.min(ay, by, cy),
        x1 = Math.max(ax, bx, cx),
        y1 = Math.max(ay, by, cy);

    let p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox
    const x0 = Math.min(ax, bx, cx),
        y0 = Math.min(ay, by, cy),
        x1 = Math.max(ax, bx, cx),
        y1 = Math.max(ay, by, cy);

    // z-order range for the current triangle bbox;
    const minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    let p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles) {
    let p = start;
    do {
        const a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i, p.i, b.i);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];

    for (let i = 0, len = holeIndices.length; i < len; i++) {
        const start = holeIndices[i] * dim;
        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        const list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareXYSlope);

    // process holes from left to right
    for (let i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareXYSlope(a, b) {
    let result = a.x - b.x;
    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find
    // the bridge to the outer shell is always the point that they meet at.
    if (result === 0) {
        result = a.y - b.y;
        if (result === 0) {
            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);
            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);
            result = aSlope - bSlope;
        }
    }
    return result;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    const bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    // unless they intersect at a vertex, then choose the vertex
    if (equals(hole, p)) return p;
    do {
        if (equals(hole, p.next)) return p.next;
        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let numMerges;
    let inSize = 1;

    do {
        let p = list;
        let e;
        list = null;
        let tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            let q = p;
            let pSize = 0;
            for (let i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            let qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a point lies within a convex triangle but false if its equal to the first point of the triangle
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = createNode(a.i, a.x, a.y),
        b2 = createNode(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = createNode(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function createNode(i, x, y) {
    return {
        i, // vertex index in coordinates array
        x, y, // vertex coordinates
        prev: null, // previous and next vertex nodes in a polygon ring
        next: null,
        z: 0, // z-order curve value
        prevZ: null, // previous and next nodes in z-order
        nextZ: null,
        steiner: false // indicates whether this is a steiner point
    };
}

function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

class Earcut {

	/**
	 * Triangulates the given shape definition by returning an array of triangles.
	 *
	 * @param {Array<number>} data - An array with 2D points.
	 * @param {Array<number>} holeIndices - An array with indices defining holes.
	 * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
	 * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
	 * representing vertex indices.
	 */
	static triangulate( data, holeIndices, dim = 2 ) {

		return earcut( data, holeIndices, dim );

	}

}

/**
 * A class containing utility functions for shapes.
 *
 * @hideconstructor
 */
class ShapeUtils {

	/**
	 * Calculate area of a ( 2D ) contour polygon.
	 *
	 * @param {Array<Vector2>} contour - An array of 2D points.
	 * @return {number} The area.
	 */
	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	/**
	 * Returns `true` if the given contour uses a clockwise winding order.
	 *
	 * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
	 * @return {boolean} Whether the given contour uses a clockwise winding order or not.
	 */
	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	/**
	 * Triangulates the given shape definition.
	 *
	 * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
	 * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
	 * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
	 */
	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * ```js
 * const length = 12, width = 8;
 *
 * const shape = new THREE.Shape();
 * shape.moveTo( 0,0 );
 * shape.lineTo( 0, width );
 * shape.lineTo( length, width );
 * shape.lineTo( length, 0 );
 * shape.lineTo( 0, 0 );
 *
 * const geometry = new THREE.ExtrudeGeometry( shape );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 * const mesh = new THREE.Mesh( geometry, material ) ;
 * scene.add( mesh );
 * ```
 *
 * @augments BufferGeometry
 */
class ExtrudeGeometry extends BufferGeometry {

	/**
	 * Constructs a new extrude geometry.
	 *
	 * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
	 * @param {ExtrudeGeometry~Options} [options] - The extrude settings.
	 */
	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( -0.5, 0.5 ), new Vector2( -0.5, -0.5 ), new Vector2( 0.5, -0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}

			/**Merges index-adjacent points that are within a threshold distance of each other. Array is modified in-place. Threshold distance is empirical, and scaled based on the magnitude of point coordinates.
			 * @param {Array<Vector2>} points
			*/
			function mergeOverlappingPoints( points ) {

				const THRESHOLD = 1e-10;
				const THRESHOLD_SQ = THRESHOLD * THRESHOLD;
				let prevPos = points[ 0 ];
				for ( let i = 1; i <= points.length; i ++ ) {

					const currentIndex = i % points.length;
					const currentPos = points[ currentIndex ];
					const dx = currentPos.x - prevPos.x;
					const dy = currentPos.y - prevPos.y;
					const distSq = dx * dx + dy * dy;

					const scalingFactorSqrt = Math.max(
						Math.abs( currentPos.x ),
						Math.abs( currentPos.y ),
						Math.abs( prevPos.x ),
						Math.abs( prevPos.y )
					);
					const thresholdSqScaled = THRESHOLD_SQ * scalingFactorSqrt * scalingFactorSqrt;
					if ( distSq <= thresholdSqScaled ) {

						points.splice( currentIndex, 1 );
						i --;
						continue;

					}

					prevPos = currentPos;

				}

			}

			mergeOverlappingPoints( vertices );
			holes.forEach( mergeOverlappingPoints );

			const numHoles = holes.length;

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0; h < numHoles; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return pt.clone().addScaledVector( vec, size );

			}

			const vlen = vertices.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = numHoles; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}

			let faces;

			if ( bevelSegments === 0 ) {

				faces = ShapeUtils.triangulateShape( contour, holes );

			} else {

				const contractedContourVertices = [];
				const expandedHoleVertices = [];

				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( let b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

						v( vert.x, vert.y, - z );
						if ( t === 0 ) contractedContourVertices.push( vert );

					}

					// expand holes

					for ( let h = 0, hl = numHoles; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];
						const oneHoleVertices = [];
						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							v( vert.x, vert.y, - z );
							if ( t === 0 ) oneHoleVertices.push( vert );

						}

						if ( t === 0 ) expandedHoleVertices.push( oneHoleVertices );

					}

				}

				faces = ShapeUtils.triangulateShape( contractedContourVertices, expandedHoleVertices );

			}

			const flen = faces.length;

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @param {Array<Shape>} shapes - An array of shapes.
	 * @return {ExtrudeGeometry} A new instance.
	 */
	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	data.options = Object.assign( {}, options );

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

/**
 * A geometry class for representing an icosahedron.
 *
 * ```js
 * const geometry = new THREE.IcosahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const icosahedron = new THREE.Mesh( geometry, material );
 * scene.add( icosahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 */
class IcosahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new icosahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the icosahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			-1, t, 0, 	1, t, 0, 	-1, - t, 0, 	1, - t, 0,
			0, -1, t, 	0, 1, t,	0, -1, - t, 	0, 1, - t,
			t, 0, -1, 	t, 0, 1, 	- t, 0, -1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {IcosahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

/**
 * Creates meshes with axial symmetry like vases. The lathe rotates around the Y axis.
 *
 * ```js
 * const points = [];
 * for ( let i = 0; i < 10; i ++ ) {
 * 	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
 * }
 * const geometry = new THREE.LatheGeometry( points );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const lathe = new THREE.Mesh( geometry, material );
 * scene.add( lathe );
 * ```
 *
 * @augments BufferGeometry
 */
class LatheGeometry extends BufferGeometry {

	/**
	 * Constructs a new lathe geometry.
	 *
	 * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point
	 * must be greater than zero.
	 * @param {number} [segments=12] - The number of circumference segments to generate.
	 * @param {number} [phiStart=0] - The starting angle in radians.
	 * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
	 * closed lathe, less than 2PI is a portion.
	 */
	constructor( points = [ new Vector2( 0, -0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {LatheGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

/**
 * A geometry class for representing an octahedron.
 *
 * ```js
 * const geometry = new THREE.OctahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const octahedron = new THREE.Mesh( geometry, material );
 * scene.add( octahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 */
class OctahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new octahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the octahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	-1, 0, 0,	0, 1, 0,
			0, -1, 0, 	0, 0, 1,	0, 0, -1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {OctahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

/**
 * A geometry class for representing a plane.
 *
 * ```js
 * const geometry = new THREE.PlaneGeometry( 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
 * const plane = new THREE.Mesh( geometry, material );
 * scene.add( plane );
 * ```
 *
 * @augments BufferGeometry
 */
class PlaneGeometry extends BufferGeometry {

	/**
	 * Constructs a new plane geometry.
	 *
	 * @param {number} [width=1] - The width along the X axis.
	 * @param {number} [height=1] - The height along the Y axis
	 * @param {number} [widthSegments=1] - The number of segments along the X axis.
	 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
	 */
	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {PlaneGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

/**
 * A class for generating a two-dimensional ring geometry.
 *
 * ```js
 * const geometry = new THREE.RingGeometry( 1, 5, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
 * const mesh = new THREE.Mesh( geometry, material );
 * scene.add( mesh );
 * ```
 *
 * @augments BufferGeometry
 */
class RingGeometry extends BufferGeometry {

	/**
	 * Constructs a new ring geometry.
	 *
	 * @param {number} [innerRadius=0.5] - The inner radius of the ring.
	 * @param {number} [outerRadius=1] - The outer radius of the ring.
	 * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
	 * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
	 * @param {number} [thetaStart=0] - Starting angle in radians.
	 * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
	 */
	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {RingGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

/**
 * Creates an one-sided polygonal geometry from one or more path shapes.
 *
 * ```js
 * const arcShape = new THREE.Shape()
 *	.moveTo( 5, 1 )
 *	.absarc( 1, 1, 4, 0, Math.PI * 2, false );
 *
 * const geometry = new THREE.ShapeGeometry( arcShape );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } );
 * const mesh = new THREE.Mesh( geometry, material ) ;
 * scene.add( mesh );
 * ```
 *
 * @augments BufferGeometry
 */
class ShapeGeometry extends BufferGeometry {

	/**
	 * Constructs a new shape geometry.
	 *
	 * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
	 * @param {number} [curveSegments=12] - Number of segments per shape.
	 */
	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( -0.5, -0.5 ), new Vector2( 0.5, -0.5 ) ] ), curveSegments = 12 ) {

		super();

		this.type = 'ShapeGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// indices

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @param {Array<Shape>} shapes - An array of shapes.
	 * @return {ShapeGeometry} A new instance.
	 */
	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

/**
 * A class for generating a sphere geometry.
 *
 * ```js
 * const geometry = new THREE.SphereGeometry( 15, 32, 16 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const sphere = new THREE.Mesh( geometry, material );
 * scene.add( sphere );
 * ```
 *
 * @augments BufferGeometry
 */
class SphereGeometry extends BufferGeometry {

	/**
	 * Constructs a new sphere geometry.
	 *
	 * @param {number} [radius=1] - The sphere radius.
	 * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
	 * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
	 * @param {number} [phiStart=0] - The horizontal starting angle in radians.
	 * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
	 * @param {number} [thetaStart=0] - The vertical starting angle in radians.
	 * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
	 */
	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 && thetaStart === 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

				uOffset = -0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {SphereGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

/**
 * A geometry class for representing an tetrahedron.
 *
 * ```js
 * const geometry = new THREE.TetrahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const tetrahedron = new THREE.Mesh( geometry, material );
 * scene.add( tetrahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 */
class TetrahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new tetrahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the tetrahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	-1, -1, 1, 	-1, 1, -1, 	1, -1, -1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {TetrahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

/**
 * A geometry class for representing an torus.
 *
 * ```js
 * const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const torus = new THREE.Mesh( geometry, material );
 * scene.add( torus );
 * ```
 *
 * @augments BufferGeometry
 */
class TorusGeometry extends BufferGeometry {

	/**
	 * Constructs a new torus geometry.
	 *
	 * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
	 * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
	 * @param {number} [radialSegments=12] - The number of radial segments.
	 * @param {number} [tubularSegments=48] - The number of tubular segments.
	 * @param {number} [arc=Math.PI*2] - Central angle in radians.
	 */
	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {TorusGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

/**
 * Creates a torus knot, the particular shape of which is defined by a pair
 * of coprime integers, p and q. If p and q are not coprime, the result will
 * be a torus link.
 *
 * ```js
 * const geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const torusKnot = new THREE.Mesh( geometry, material );
 * scene.add( torusKnot );
 * ```
 *
 * @augments BufferGeometry
 */
class TorusKnotGeometry extends BufferGeometry {

	/**
	 * Constructs a new torus knot geometry.
	 *
	 * @param {number} [radius=1] - Radius of the torus knot.
	 * @param {number} [tube=0.4] - Radius of the tube.
	 * @param {number} [tubularSegments=64] - The number of tubular segments.
	 * @param {number} [radialSegments=8] - The number of radial segments.
	 * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
	 * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
	 */
	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();

		this.type = 'TorusKnotGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {TorusKnotGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

/**
 * Creates a tube that extrudes along a 3D curve.
 *
 * ```js
 * class CustomSinCurve extends THREE.Curve {
 *
 * 	getPoint( t, optionalTarget = new THREE.Vector3() ) {
 *
 * 		const tx = t * 3 - 1.5;
 * 		const ty = Math.sin( 2 * Math.PI * t );
 * 		const tz = 0;
 *
 * 		return optionalTarget.set( tx, ty, tz );
 * 	}
 *
 * }
 *
 * const path = new CustomSinCurve( 10 );
 * const geometry = new THREE.TubeGeometry( path, 20, 2, 8, false );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * scene.add( mesh );
 * ```
 *
 * @augments BufferGeometry
 */
class TubeGeometry extends BufferGeometry {

	/**
	 * Constructs a new tube geometry.
	 *
	 * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
	 * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
	 * @param {number} [radius=1] -The radius of the tube.
	 * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
	 * @param {boolean} [closed=false] - Whether the tube is closed or not.
	 */
	constructor( path = new QuadraticBezierCurve3( new Vector3( -1, -1, 0 ), new Vector3( -1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();

		this.type = 'TubeGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {TubeGeometry} A new instance.
	 */
	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

/**
 * Can be used as a helper object to visualize a geometry as a wireframe.
 *
 * ```js
 * const geometry = new THREE.SphereGeometry();
 *
 * const wireframe = new THREE.WireframeGeometry( geometry );
 *
 * const line = new THREE.LineSegments( wireframe );
 * line.material.depthWrite = false;
 * line.material.opacity = 0.25;
 * line.material.transparent = true;
 *
 * scene.add( line );
 * ```
 *
 * Note: It is not yet possible to serialize/deserialize instances of this class.
 *
 * @augments BufferGeometry
 */
class WireframeGeometry extends BufferGeometry {

	/**
	 * Constructs a new wireframe geometry.
	 *
	 * @param {?BufferGeometry} [geometry=null] - The geometry.
	 */
	constructor( geometry = null ) {

		super();

		this.type = 'WireframeGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

/**
 * This material can receive shadows, but otherwise is completely transparent.
 *
 * ```js
 * const geometry = new THREE.PlaneGeometry( 2000, 2000 );
 * geometry.rotateX( - Math.PI / 2 );
 *
 * const material = new THREE.ShadowMaterial();
 * material.opacity = 0.2;
 *
 * const plane = new THREE.Mesh( geometry, material );
 * plane.position.y = -200;
 * plane.receiveShadow = true;
 * scene.add( plane );
 * ```
 *
 * @augments Material
 */
class ShadowMaterial extends Material {

	/**
	 * Constructs a new shadow material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.color = new Color( 0x000000 );

		/**
		 * Overwritten since shadow materials are transparent
		 * by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.transparent = true;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

/**
 * This class works just like {@link ShaderMaterial}, except that definitions
 * of built-in uniforms and attributes are not automatically prepended to the
 * GLSL shader code.
 *
 * `RawShaderMaterial` can only be used with {@link WebGLRenderer}.
 *
 * @augments ShaderMaterial
 */
class RawShaderMaterial extends ShaderMaterial {

	/**
	 * Constructs a new raw shader material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super( parameters );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isRawShaderMaterial = true;

		this.type = 'RawShaderMaterial';

	}

}

/**
 * A standard physically based material, using Metallic-Roughness workflow.
 *
 * Physically based rendering (PBR) has recently become the standard in many
 * 3D applications, such as [Unity]{@link https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/},
 * [Unreal]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/} and
 * [3D Studio Max]{@link http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017}.
 *
 * This approach differs from older approaches in that instead of using
 * approximations for the way in which light interacts with a surface, a
 * physically correct model is used. The idea is that, instead of tweaking
 * materials to look good under specific lighting, a material can be created
 * that will react 'correctly' under all lighting scenarios.
 *
 * In practice this gives a more accurate and realistic looking result than
 * the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
 * being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
 * shading.
 *
 * Note that for best results you should always specify an environment map when using this material.
 *
 * For a non-technical introduction to the concept of PBR and how to set up a
 * PBR material, check out these articles by the people at [marmoset]{@link https://www.marmoset.co}:
 *
 * - [Basic Theory of Physically Based Rendering]{@link https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/}
 * - [Physically Based Rendering and You Can Too]{@link https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/}
 *
 * Technical details of the approach used in three.js (and most other PBR systems) can be found is this
 * [paper from Disney]{@link https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf}
 * (pdf), by Brent Burley.
 *
 * @augments Material
 */
class MeshStandardMaterial extends Material {

	/**
	 * Constructs a new mesh standard material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshStandardMaterial = true;

		this.type = 'MeshStandardMaterial';

		this.defines = { 'STANDARD': '' };

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
		 * means fully diffuse. If `roughnessMap` is also provided,
		 * both values are multiplied.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.roughness = 1.0;

		/**
		 * How much the material is like a metal. Non-metallic materials such as wood
		 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
		 * A value between `0.0` and `1.0` could be used for a rusty metal look.
		 * If `metalnessMap` is also provided, both values are multiplied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.metalness = 0.0;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The green channel of this texture is used to alter the roughness of the
		 * material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.roughnessMap = null;

		/**
		 * The blue channel of this texture is used to alter the metalness of the
		 * material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.metalnessMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map. To ensure a physically correct rendering, environment maps
		 * are internally pre-processed with {@link PMREMGenerator}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * Scales the effect of the environment map by multiplying its color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.envMapIntensity = 1.0;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * An extension of the {@link MeshStandardMaterial}, providing more advanced
 * physically-based rendering properties:
 *
 * - Anisotropy: Ability to represent the anisotropic property of materials
 * as observable with brushed metals.
 * - Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
 * a clear, reflective layer on top of another layer that may be irregular or rough.
 * Clearcoat approximates this effect, without the need for a separate transparent surface.
 * - Iridescence: Allows to render the effect where hue varies  depending on the viewing
 * angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
 * wings of many insects.
 * - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
 * transparent materials are less reflective. Physically-based transmission provides a more
 * realistic option for thin, transparent surfaces like glass.
 * - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
 * - Sheen: Can be used for representing cloth and fabric materials.
 *
 * As a result of these complex shading features, `MeshPhysicalMaterial` has a
 * higher performance cost, per pixel, than other three.js materials. Most
 * effects are disabled by default, and add cost as they are enabled. For
 * best results, always specify an environment map when using this material.
 *
 * @augments MeshStandardMaterial
 */
class MeshPhysicalMaterial extends MeshStandardMaterial {

	/**
	 * Constructs a new mesh physical material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		/**
		 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
		 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
		 * property provides additional rotation to the vectors in the texture.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.anisotropyRotation = 0;

		/**
		 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
		 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
		 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.anisotropyMap = null;

		/**
		 * The red channel of this texture is multiplied against `clearcoat`,
		 * for per-pixel control over a coating's intensity.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatMap = null;

		/**
		 * Roughness of the clear coat layer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.clearcoatRoughness = 0.0;

		/**
		 * The green channel of this texture is multiplied against
		 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatRoughnessMap = null;

		/**
		 * How much `clearcoatNormalMap` affects the clear coat layer, from
		 * `(0,0)` to `(1,1)`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.clearcoatNormalScale = new Vector2( 1, 1 );

		/**
		 * Can be used to enable independent normals for the clear coat layer.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatNormalMap = null;

		/**
		 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
		 *
		 * @type {number}
		 * @default 1.5
		 */
		this.ior = 1.5;

		/**
		 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
		 * corresponds to an index-of-refraction of `1.5`.
		 *
		 * This models the reflectivity of non-metallic materials. It has no effect
		 * when `metalness` is `1.0`
		 *
		 * @name MeshPhysicalMaterial#reflectivity
		 * @type {number}
		 * @default 0.5
		 */
		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		/**
		 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
		 * control over iridescence.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.iridescenceMap = null;

		/**
		 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
		 * Between `1.0` to `2.333`.
		 *
		 * @type {number}
		 * @default 1.3
		 */
		this.iridescenceIOR = 1.3;

		/**
		 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
		 *
		 * @type {Array<number,number>}
		 * @default [100,400]
		 */
		this.iridescenceThicknessRange = [ 100, 400 ];

		/**
		 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
		 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
		 * - `0.0` in the green channel will result in thickness equal to first element of the array.
		 * - `1.0` in the green channel will result in thickness equal to second element of the array.
		 * - Values in-between will linearly interpolate between the elements of the array.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.iridescenceThicknessMap = null;

		/**
		 * The sheen tint.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.sheenColor = new Color( 0x000000 );

		/**
		 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
		 * over sheen tint.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.sheenColorMap = null;

		/**
		 * Roughness of the sheen layer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.sheenRoughness = 1.0;

		/**
		 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
		 * over sheen roughness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.sheenRoughnessMap = null;

		/**
		 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
		 * optical transparency.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.transmissionMap = null;

		/**
		 * The thickness of the volume beneath the surface. The value is given in the
		 * coordinate space of the mesh. If the value is `0` the material is
		 * thin-walled. Otherwise the material is a volume boundary.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.thickness = 0;

		/**
		 * A texture that defines the thickness, stored in the green channel. This will
		 * be multiplied by `thickness`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.thicknessMap = null;

		/**
		 * Density of the medium given as the average distance that light travels in
		 * the medium before interacting with a particle. The value is given in world
		 * space units, and must be greater than zero.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.attenuationDistance = Infinity;

		/**
		 * The color that white light turns into due to absorption when reaching the
		 * attenuation distance.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.attenuationColor = new Color( 1, 1, 1 );

		/**
		 * A float that scales the amount of specular reflection for non-metals only.
		 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.specularIntensity = 1.0;

		/**
		 * The alpha channel of this texture is multiplied against `specularIntensity`,
		 * for per-pixel control over specular intensity.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularIntensityMap = null;

		/**
		 * Tints the specular reflection at normal incidence for non-metals only.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.specularColor = new Color( 1, 1, 1 );

		/**
		 * The RGB channels of this texture are multiplied against `specularColor`,
		 * for per-pixel control over specular color.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularColorMap = null;

		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0.0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	/**
	 * The anisotropy strength.
	 *
	 * @type {number}
	 * @default 0
	 */
	get anisotropy() {

		return this._anisotropy;

	}

	set anisotropy( value ) {

		if ( this._anisotropy > 0 !== value > 0 ) {

			this.version ++;

		}

		this._anisotropy = value;

	}

	/**
	 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
	 * clear coat related properties to enable multilayer materials that have a
	 * thin translucent layer over the base layer.
	 *
	 * @type {number}
	 * @default 0
	 */
	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}
	/**
	 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
	 * the surface and the viewer, from `0.0` to `1.0`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	/**
	 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
	 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
	 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
	 *
	 * @type {number}
	 * @default 0
	 */
	get dispersion() {

		return this._dispersion;

	}

	set dispersion( value ) {

		if ( this._dispersion > 0 !== value > 0 ) {

			this.version ++;

		}

		this._dispersion = value;

	}

	/**
	 * The intensity of the sheen layer, from `0.0` to `1.0`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	/**
	 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
	 *
	 * Thin, transparent or semitransparent, plastic or glass materials remain
	 * largely reflective even if they are fully transmissive. The transmission
	 * property can be used to model these materials.
	 *
	 * When transmission is non-zero, `opacity` should be  set to `1`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.dispersion = source.dispersion;
		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

/**
 * A material for shiny surfaces with specular highlights.
 *
 * The material uses a non-physically based [Blinn-Phong]{@link https://en.wikipedia.org/wiki/Blinn-Phong_shading_model}
 * model for calculating reflectance. Unlike the Lambertian model used in the
 * {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
 * highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
 *
 * Performance will generally be greater when using this material over the
 * {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
 * some graphical accuracy.
 *
 * @augments Material
 */
class MeshPhongMaterial extends Material {

	/**
	 * Constructs a new mesh phong material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
		 *
		 * This defines how shiny the material is and the color of its shine.
		 *
		 * @type {Color}
		 */
		this.specular = new Color( 0x111111 );

		/**
		 * How shiny the specular highlight is; a higher value gives a sharper highlight.
		 *
		 * @type {number}
		 * @default 30
		 */
		this.shininess = 30;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The specular map value affects both how much the specular surface
		 * highlight contributes and how much of the environment map affects the
		 * surface.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * How to combine the result of the surface's color with the environment map, if any.
		 *
		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		 * blend between the two colors.
		 *
		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
		 * @default MultiplyOperation
		 */
		this.combine = MultiplyOperation;

		/**
		 * How much the environment map affects the surface.
		 * The valid range is between `0` (no reflections) and `1` (full reflections).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.reflectivity = 1;

		/**
		 * The index of refraction (IOR) of air (approximately 1) divided by the
		 * index of refraction of the material. It is used with environment mapping
		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		 * The refraction ratio should not exceed `1`.
		 *
		 * @type {number}
		 * @default 0.98
		 */
		this.refractionRatio = 0.98;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * A material implementing toon shading.
 *
 * @augments Material
 */
class MeshToonMaterial extends Material {

	/**
	 * Constructs a new mesh toon material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * Gradient map for toon shading. It's required to set
		 * {@link Texture#minFilter} and {@link Texture#magFilter} to {@linkNearestFilter}
		 * when using this type of texture.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.gradientMap = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

/**
 * A material that maps the normal vectors to RGB colors.
 *
 * @augments Material
 */
class MeshNormalMaterial extends Material {

	/**
	 * Constructs a new mesh normal material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * WebGL and WebGPU ignore this property and always render
		 * 1 pixel wide lines.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

/**
 * A material for non-shiny surfaces, without specular highlights.
 *
 * The material uses a non-physically based [Lambertian]{@link https://en.wikipedia.org/wiki/Lambertian_reflectance}
 * model for calculating reflectance. This can simulate some surfaces (such
 * as untreated wood or stone) well, but cannot simulate shiny surfaces with
 * specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
 * shading.
 *
 * Due to the simplicity of the reflectance and illumination models,
 * performance will be greater when using this material over the
 * {@link MeshPhongMaterial}, {@link MeshStandardMaterial} or
 * {@link MeshPhysicalMaterial}, at the cost of some graphical accuracy.
 *
 * @augments Material
 */
class MeshLambertMaterial extends Material {

	/**
	 * Constructs a new mesh lambert material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * Specular map used by the material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * How to combine the result of the surface's color with the environment map, if any.
		 *
		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		 * blend between the two colors.
		 *
		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
		 * @default MultiplyOperation
		 */
		this.combine = MultiplyOperation;

		/**
		 * How much the environment map affects the surface.
		 * The valid range is between `0` (no reflections) and `1` (full reflections).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.reflectivity = 1;

		/**
		 * The index of refraction (IOR) of air (approximately 1) divided by the
		 * index of refraction of the material. It is used with environment mapping
		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		 * The refraction ratio should not exceed `1`.
		 *
		 * @type {number}
		 * @default 0.98
		 */
		this.refractionRatio = 0.98;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * A material for drawing geometry by depth. Depth is based off of the camera
 * near and far plane. White is nearest, black is farthest.
 *
 * @augments Material
 */
class MeshDepthMaterial extends Material {

	/**
	 * Constructs a new mesh depth material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		/**
		 * Type for depth packing.
		 *
		 * @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
		 * @default BasicDepthPacking
		 */
		this.depthPacking = BasicDepthPacking;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * WebGL and WebGPU ignore this property and always render
		 * 1 pixel wide lines.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

/**
 * A material used internally for implementing shadow mapping with
 * point lights.
 *
 * Can also be used to customize the shadow casting of an object by assigning
 * an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
 * The following examples demonstrates this approach in order to ensure
 * transparent parts of objects do no cast shadows.
 *
 * @augments Material
 */
class MeshDistanceMaterial extends Material {

	/**
	 * Constructs a new mesh distance material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

/**
 * This material is defined by a MatCap (or Lit Sphere) texture, which encodes the
 * material color and shading.
 *
 * `MeshMatcapMaterial` does not respond to lights since the matcap image file encodes
 * baked lighting. It will cast a shadow onto an object that receives shadows
 * (and shadow clipping works), but it will not self-shadow or receive
 * shadows.
 *
 * @augments Material
 */
class MeshMatcapMaterial extends Material {

	/**
	 * Constructs a new mesh matcap material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * The matcap map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.matcap = null;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * A material for rendering line primitives.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * ```js
 * const material = new THREE.LineDashedMaterial( {
 * 	color: 0xffffff,
 * 	scale: 1,
 * 	dashSize: 3,
 * 	gapSize: 1,
 * } );
 * ```
 *
 * @augments LineBasicMaterial
 */
class LineDashedMaterial extends LineBasicMaterial {

	/**
	 * Constructs a new line dashed material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineDashedMaterial = true;
		this.type = 'LineDashedMaterial';

		/**
		 * The scale of the dashed part of a line.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.scale = 1;

		/**
		 * The size of the dash. This is both the gap with the stroke.
		 *
		 * @type {number}
		 * @default 3
		 */
		this.dashSize = 3;

		/**
		 * The size of the gap.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

/**
 * Converts an array to a specific type.
 *
 * @param {TypedArray|Array} array - The array to convert.
 * @param {TypedArray.constructor} type - The constructor of a typed array that defines the new type.
 * @return {TypedArray} The converted array.
 */
function convertArray( array, type ) {

	if ( ! array || array.constructor === type ) return array;

	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

		return new type( array ); // create typed array

	}

	return Array.prototype.slice.call( array ); // create Array

}

/**
 * Returns `true` if the given object is a typed array.
 *
 * @param {any} object - The object to check.
 * @return {boolean} Whether the given object is a typed array.
 */
function isTypedArray( object ) {

	return ArrayBuffer.isView( object ) && ! ( object instanceof DataView );

}

/**
 * Returns an array by which times and values can be sorted.
 *
 * @param {Array<number>} times - The keyframe time values.
 * @return {Array<number>} The array.
 */
function getKeyframeOrder( times ) {

	function compareTime( i, j ) {

		return times[ i ] - times[ j ];

	}

	const n = times.length;
	const result = new Array( n );
	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

	result.sort( compareTime );

	return result;

}

/**
 * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
 *
 * @param {Array<number>} values - The values to sort.
 * @param {number} stride - The stride.
 * @param {Array<number>} order - The sort order.
 * @return {Array<number>} The sorted values.
 */
function sortedArray( values, stride, order ) {

	const nValues = values.length;
	const result = new values.constructor( nValues );

	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

		const srcOffset = order[ i ] * stride;

		for ( let j = 0; j !== stride; ++ j ) {

			result[ dstOffset ++ ] = values[ srcOffset + j ];

		}

	}

	return result;

}

/**
 * Used for parsing AOS keyframe formats.
 *
 * @param {Array<number>} jsonKeys - A list of JSON keyframes.
 * @param {Array<number>} times - This array will be filled with keyframe times by this function.
 * @param {Array<number>} values - This array will be filled with keyframe values by this function.
 * @param {string} valuePropertyName - The name of the property to use.
 */
function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

	let i = 1, key = jsonKeys[ 0 ];

	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

		key = jsonKeys[ i ++ ];

	}

	if ( key === undefined ) return; // no data

	let value = key[ valuePropertyName ];
	if ( value === undefined ) return; // no data

	if ( Array.isArray( value ) ) {

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( ...value ); // push all elements

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else if ( value.toArray !== undefined ) {

		// ...assume THREE.Math-ish

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				value.toArray( values, values.length );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else {

		// otherwise push as-is

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( value );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	}

}

/**
 * Creates a new clip, containing only the segment of the original clip between the given frames.
 *
 * @param {AnimationClip} sourceClip - The values to sort.
 * @param {string} name - The name of the clip.
 * @param {number} startFrame - The start frame.
 * @param {number} endFrame - The end frame.
 * @param {number} [fps=30] - The FPS.
 * @return {AnimationClip} The new sub clip.
 */
function subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

	const clip = sourceClip.clone();

	clip.name = name;

	const tracks = [];

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		const track = clip.tracks[ i ];
		const valueSize = track.getValueSize();

		const times = [];
		const values = [];

		for ( let j = 0; j < track.times.length; ++ j ) {

			const frame = track.times[ j ] * fps;

			if ( frame < startFrame || frame >= endFrame ) continue;

			times.push( track.times[ j ] );

			for ( let k = 0; k < valueSize; ++ k ) {

				values.push( track.values[ j * valueSize + k ] );

			}

		}

		if ( times.length === 0 ) continue;

		track.times = convertArray( times, track.times.constructor );
		track.values = convertArray( values, track.values.constructor );

		tracks.push( track );

	}

	clip.tracks = tracks;

	// find minimum .times value across all tracks in the trimmed clip

	let minStartTime = Infinity;

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

			minStartTime = clip.tracks[ i ].times[ 0 ];

		}

	}

	// shift all tracks such that clip begins at t=0

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		clip.tracks[ i ].shift( -1 * minStartTime );

	}

	clip.resetDuration();

	return clip;

}

/**
 * Converts the keyframes of the given animation clip to an additive format.
 *
 * @param {AnimationClip} targetClip - The clip to make additive.
 * @param {number} [referenceFrame=0] - The reference frame.
 * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
 * @param {number} [fps=30] - The FPS.
 * @return {AnimationClip} The updated clip which is now additive.
 */
function makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

	if ( fps <= 0 ) fps = 30;

	const numTracks = referenceClip.tracks.length;
	const referenceTime = referenceFrame / fps;

	// Make each track's values relative to the values at the reference frame
	for ( let i = 0; i < numTracks; ++ i ) {

		const referenceTrack = referenceClip.tracks[ i ];
		const referenceTrackType = referenceTrack.ValueTypeName;

		// Skip this track if it's non-numeric
		if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

		// Find the track in the target clip whose name and type matches the reference track
		const targetTrack = targetClip.tracks.find( function ( track ) {

			return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

		} );

		if ( targetTrack === undefined ) continue;

		let referenceOffset = 0;
		const referenceValueSize = referenceTrack.getValueSize();

		if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			referenceOffset = referenceValueSize / 3;

		}

		let targetOffset = 0;
		const targetValueSize = targetTrack.getValueSize();

		if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			targetOffset = targetValueSize / 3;

		}

		const lastIndex = referenceTrack.times.length - 1;
		let referenceValue;

		// Find the value to subtract out of the track
		if ( referenceTime <= referenceTrack.times[ 0 ] ) {

			// Reference frame is earlier than the first keyframe, so just use the first keyframe
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

			// Reference frame is after the last keyframe, so just use the last keyframe
			const startIndex = lastIndex * referenceValueSize + referenceOffset;
			const endIndex = startIndex + referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else {

			// Interpolate to the reference value
			const interpolant = referenceTrack.createInterpolant();
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			interpolant.evaluate( referenceTime );
			referenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );

		}

		// Conjugate the quaternion
		if ( referenceTrackType === 'quaternion' ) {

			const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
			referenceQuat.toArray( referenceValue );

		}

		// Subtract the reference value from all of the track values

		const numTimes = targetTrack.times.length;
		for ( let j = 0; j < numTimes; ++ j ) {

			const valueStart = j * targetValueSize + targetOffset;

			if ( referenceTrackType === 'quaternion' ) {

				// Multiply the conjugate for quaternion track types
				Quaternion.multiplyQuaternionsFlat(
					targetTrack.values,
					valueStart,
					referenceValue,
					0,
					targetTrack.values,
					valueStart
				);

			} else {

				const valueEnd = targetValueSize - targetOffset * 2;

				// Subtract each value for all other numeric track types
				for ( let k = 0; k < valueEnd; ++ k ) {

					targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

				}

			}

		}

	}

	targetClip.blendMode = AdditiveAnimationBlendMode;

	return targetClip;

}

/**
 * A class with various methods to assist with animations.
 *
 * @hideconstructor
 */
class AnimationUtils {

	/**
	 * Converts an array to a specific type
	 *
	 * @static
	 * @param {TypedArray|Array} array - The array to convert.
	 * @param {TypedArray.constructor} type - The constructor of a type array.
	 * @return {TypedArray} The converted array
	 */
	static convertArray( array, type ) {

		return convertArray( array, type );

	}

	/**
	 * Returns `true` if the given object is a typed array.
	 *
	 * @static
	 * @param {any} object - The object to check.
	 * @return {boolean} Whether the given object is a typed array.
	 */
	static isTypedArray( object ) {

		return isTypedArray( object );

	}

	/**
	 * Returns an array by which times and values can be sorted.
	 *
	 * @static
	 * @param {Array<number>} times - The keyframe time values.
	 * @return {Array<number>} The array.
	 */
	static getKeyframeOrder( times ) {

		return getKeyframeOrder( times );

	}

	/**
	 * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
	 *
	 * @static
	 * @param {Array<number>} values - The values to sort.
	 * @param {number} stride - The stride.
	 * @param {Array<number>} order - The sort order.
	 * @return {Array<number>} The sorted values.
	 */
	static sortedArray( values, stride, order ) {

		return sortedArray( values, stride, order );

	}

	/**
	 * Used for parsing AOS keyframe formats.
	 *
	 * @static
	 * @param {Array<number>} jsonKeys - A list of JSON keyframes.
	 * @param {Array<number>} times - This array will be filled with keyframe times by this method.
	 * @param {Array<number>} values - This array will be filled with keyframe values by this method.
	 * @param {string} valuePropertyName - The name of the property to use.
	 */
	static flattenJSON( jsonKeys, times, values, valuePropertyName ) {

		flattenJSON( jsonKeys, times, values, valuePropertyName );

	}

	/**
	 * Creates a new clip, containing only the segment of the original clip between the given frames.
	 *
	 * @static
	 * @param {AnimationClip} sourceClip - The values to sort.
	 * @param {string} name - The name of the clip.
	 * @param {number} startFrame - The start frame.
	 * @param {number} endFrame - The end frame.
	 * @param {number} [fps=30] - The FPS.
	 * @return {AnimationClip} The new sub clip.
	 */
	static subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		return subclip( sourceClip, name, startFrame, endFrame, fps );

	}

	/**
	 * Converts the keyframes of the given animation clip to an additive format.
	 *
	 * @static
	 * @param {AnimationClip} targetClip - The clip to make additive.
	 * @param {number} [referenceFrame=0] - The reference frame.
	 * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
	 * @param {number} [fps=30] - The FPS.
	 * @return {AnimationClip} The updated clip which is now additive.
	 */
	static makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		return makeClipAdditive( targetClip, referenceFrame, referenceClip, fps );

	}

}

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References: {@link http://www.oodesign.com/template-method-pattern.html}
 *
 * @abstract
 */
class Interpolant {

	/**
	 * Constructs a new interpolant.
	 *
	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	 * @param {TypedArray} sampleValues - The sample values.
	 * @param {number} sampleSize - The sample size
	 * @param {TypedArray} [resultBuffer] - The result buffer.
	 */
	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		/**
		 * The parameter positions.
		 *
		 * @type {TypedArray}
		 */
		this.parameterPositions = parameterPositions;

		/**
		 * A cache index.
		 *
		 * @private
		 * @type {number}
		 * @default 0
		 */
		this._cachedIndex = 0;

		/**
		 * The result buffer.
		 *
		 * @type {TypedArray}
		 */
		this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor( sampleSize );

		/**
		 * The sample values.
		 *
		 * @type {TypedArray}
		 */
		this.sampleValues = sampleValues;

		/**
		 * The value size.
		 *
		 * @type {TypedArray}
		 */
		this.valueSize = sampleSize;

		/**
		 * The interpolation settings.
		 *
		 * @type {?Object}
		 * @default null
		 */
		this.settings = null;

		/**
		 * The default settings object.
		 *
		 * @type {Object}
		 */
		this.DefaultSettings_ = {};

	}

	/**
	 * Evaluate the interpolant at position `t`.
	 *
	 * @param {number} t - The interpolation factor.
	 * @return {TypedArray} The result buffer.
	 */
	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	/**
	 * Returns the interpolation settings.
	 *
	 * @return {Object} The interpolation settings.
	 */
	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	/**
	 * Copies a sample value to the result buffer.
	 *
	 * @param {number} index - An index into the sample value buffer.
	 * @return {TypedArray} The result buffer.
	 */
	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	/**
	 * Copies a sample value to the result buffer.
	 *
	 * @abstract
	 * @param {number} i1 - An index into the sample value buffer.
	 * @param {number} t0 - The previous interpolation factor.
	 * @param {number} t - The current interpolation factor.
	 * @param {number} t1 - The next interpolation factor.
	 * @return {TypedArray} The result buffer.
	 */
	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	/**
	 * Optional method that is executed when the interval has changed.
	 *
	 * @param {number} i1 - An index into the sample value buffer.
	 * @param {number} t0 - The previous interpolation factor.
	 * @param {number} t - The current interpolation factor.
	 */
	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @augments Interpolant
 */
class CubicInterpolant extends Interpolant {

	/**
	 * Constructs a new cubic interpolant.
	 *
	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	 * @param {TypedArray} sampleValues - The sample values.
	 * @param {number} sampleSize - The sample size
	 * @param {TypedArray} [resultBuffer] - The result buffer.
	 */
	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( -1.5 - 2 * wP ) * pp + ( -0.5 + wP ) * p + 1;
		const s1 = ( -1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

/**
 * A basic linear interpolant.
 *
 * @augments Interpolant
 */
class LinearInterpolant extends Interpolant {

	/**
	 * Constructs a new linear interpolant.
	 *
	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	 * @param {TypedArray} sampleValues - The sample values.
	 * @param {number} sampleSize - The sample size
	 * @param {TypedArray} [resultBuffer] - The result buffer.
	 */
	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 *
 * @augments Interpolant
 */
class DiscreteInterpolant extends Interpolant {

	/**
	 * Constructs a new discrete interpolant.
	 *
	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	 * @param {TypedArray} sampleValues - The sample values.
	 * @param {number} sampleSize - The sample size
	 * @param {TypedArray} [resultBuffer] - The result buffer.
	 */
	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

/**
 * Represents s a timed sequence of keyframes, which are composed of lists of
 * times and related values, and which are used to animate a specific property
 * of an object.
 */
class KeyframeTrack {

	/**
	 * Constructs a new keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		/**
		 * The track's name can refer to morph targets or bones or
		 * possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}
		 * for the forms of strings that can be parsed for property binding.
		 *
		 * @type {string}
		 */
		this.name = name;

		/**
		 * The keyframe times.
		 *
		 * @type {Float32Array}
		 */
		this.times = convertArray( times, this.TimeBufferType );

		/**
		 * The keyframe values.
		 *
		 * @type {Float32Array}
		 */
		this.values = convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	/**
	 * Converts the keyframe track to JSON.
	 *
	 * @static
	 * @param {KeyframeTrack} track - The keyframe track to serialize.
	 * @return {Object} The serialized keyframe track as JSON.
	 */
	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': convertArray( track.times, Array ),
				'values': convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	/**
	 * Factory method for creating a new discrete interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {DiscreteInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	/**
	 * Factory method for creating a new linear interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {LinearInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	/**
	 * Factory method for creating a new smooth interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {CubicInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	/**
	 * Defines the interpolation factor method for this keyframe track.
	 *
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	/**
	 * Returns the current interpolation type.
	 *
	 * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
	 */
	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	/**
	 * Returns the value size.
	 *
	 * @return {number} The value size.
	 */
	getValueSize() {

		return this.values.length / this.times.length;

	}

	/**
	 * Moves all keyframes either forward or backward in time.
	 *
	 * @param {number} timeOffset - The offset to move the time values.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	/**
	 * Scale all keyframe times by a factor (useful for frame - seconds conversions).
	 *
	 * @param {number} timeScale - The time scale.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	/**
	 * Removes keyframes before and after animation without changing any values within the defined time range.
	 *
	 * Note: The method does not shift around keys to the start of the track time, because for interpolated
	 * keys this will change their values
	 *
	 * @param {number} startTime - The start time.
	 * @param {number} endTime - The end time.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== -1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = times.slice( from, to );
			this.values = this.values.slice( from * stride, to * stride );

		}

		return this;

	}

	/**
	 * Performs minimal validation on the keyframe track. Returns `true` if the values
	 * are valid.
	 *
	 * @return {boolean} Whether the keyframes are valid or not.
	 */
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	/**
	 * Optimizes this keyframe track by removing equivalent sequential keys (which are
	 * common in morph target sequences).
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	optimize() {

		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = this.times.slice(),
			values = this.values.slice(),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = times.slice( 0, writeIndex );
			this.values = values.slice( 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	/**
	 * Returns a new keyframe track with copied values from this instance.
	 *
	 * @return {KeyframeTrack} A clone of this instance.
	 */
	clone() {

		const times = this.times.slice();
		const values = this.values.slice();

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default ''
 */
KeyframeTrack.prototype.ValueTypeName = '';

/**
 * The time buffer type of this keyframe track.
 *
 * @type {TypedArray|Array}
 * @default Float32Array.constructor
 */
KeyframeTrack.prototype.TimeBufferType = Float32Array;

/**
 * The value buffer type of this keyframe track.
 *
 * @type {TypedArray|Array}
 * @default Float32Array.constructor
 */
KeyframeTrack.prototype.ValueBufferType = Float32Array;

/**
 * The default interpolation type of this keyframe track.
 *
 * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
 * @default InterpolateLinear
 */
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A track for boolean keyframe values.
 *
 * @augments KeyframeTrack
 */
class BooleanKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new boolean keyframe track.
	 *
	 * This keyframe track type has no `interpolation` parameter because the
	 * interpolation is always discrete.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 */
	constructor( name, times, values ) {

		super( name, times, values );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'bool'
 */
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';

/**
 * The value buffer type of this keyframe track.
 *
 * @type {TypedArray|Array}
 * @default Array.constructor
 */
BooleanKeyframeTrack.prototype.ValueBufferType = Array;

/**
 * The default interpolation type of this keyframe track.
 *
 * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
 * @default InterpolateDiscrete
 */
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A track for color keyframe values.
 *
 * @augments KeyframeTrack
 */
class ColorKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new color keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor( name, times, values, interpolation ) {

		super( name, times, values, interpolation );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'color'
 */
ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A track for numeric keyframe values.
 *
 * @augments KeyframeTrack
 */
class NumberKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new number keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor( name, times, values, interpolation ) {

		super( name, times, values, interpolation );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'number'
 */
NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @augments Interpolant
 */
class QuaternionLinearInterpolant extends Interpolant {

	/**
	 * Constructs a new SLERP interpolant.
	 *
	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
	 * @param {TypedArray} sampleValues - The sample values.
	 * @param {number} sampleSize - The sample size
	 * @param {TypedArray} [resultBuffer] - The result buffer.
	 */
	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A track for Quaternion keyframe values.
 *
 * @augments KeyframeTrack
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new Quaternion keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor( name, times, values, interpolation ) {

		super( name, times, values, interpolation );

	}

	/**
	 * Overwritten so the method returns Quaternion based interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {QuaternionLinearInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'quaternion'
 */
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
// DefaultInterpolation is inherited;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A track for string keyframe values.
 *
 * @augments KeyframeTrack
 */
class StringKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new string keyframe track.
	 *
	 * This keyframe track type has no `interpolation` parameter because the
	 * interpolation is always discrete.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 */
	constructor( name, times, values ) {

		super( name, times, values );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'string'
 */
StringKeyframeTrack.prototype.ValueTypeName = 'string';

/**
 * The value buffer type of this keyframe track.
 *
 * @type {TypedArray|Array}
 * @default Array.constructor
 */
StringKeyframeTrack.prototype.ValueBufferType = Array;

/**
 * The default interpolation type of this keyframe track.
 *
 * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
 * @default InterpolateDiscrete
 */
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A track for vector keyframe values.
 *
 * @augments KeyframeTrack
 */
class VectorKeyframeTrack extends KeyframeTrack {

	/**
	 * Constructs a new vector keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor( name, times, values, interpolation ) {

		super( name, times, values, interpolation );

	}

}

/**
 * The value type name.
 *
 * @type {String}
 * @default 'vector'
 */
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

/**
 * A reusable set of keyframe tracks which represent an animation.
 */
class AnimationClip {

	/**
	 * Constructs a new animation clip.
	 *
	 * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
	 * use the static interface of this class for creating clips. In most cases though, animation clips
	 * will automatically be created by loaders when importing animated 3D assets.
	 *
	 * @param {string} [name=''] - The clip's name.
	 * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
	 * the duration will be calculated from the passed keyframes.
	 * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
	 * is blended/combined when two or more animations are simultaneously played.
	 */
	constructor( name = '', duration = -1, tracks = [], blendMode = NormalAnimationBlendMode ) {

		/**
		 * The clip's name.
		 *
		 * @type {string}
		 */
		this.name = name;

		/**
		 *  An array of keyframe tracks.
		 *
		 * @type {Array<KeyframeTrack>}
		 */
		this.tracks = tracks;

		/**
		 * The clip's duration in seconds.
		 *
		 * @type {number}
		 */
		this.duration = duration;

		/**
		 * Defines how the animation is blended/combined when two or more animations
		 * are simultaneously played.
		 *
		 * @type {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)}
		 */
		this.blendMode = blendMode;

		/**
		 * The UUID of the animation clip.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}

	/**
	 * Factory method for creating an animation clip from the given JSON.
	 *
	 * @static
	 * @param {Object} json - The serialized animation clip.
	 * @return {AnimationClip} The new animation clip.
	 */
	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	/**
	 * Serializes the given animation clip into JSON.
	 *
	 * @static
	 * @param {AnimationClip} clip - The animation clip to serialize.
	 * @return {Object} The JSON object.
	 */
	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	/**
	 * Returns a new animation clip from the passed morph targets array of a
	 * geometry, taking a name and the number of frames per second.
	 *
	 * Note: The fps parameter is required, but the animation speed can be
	 * overridden via {@link AnimationAction#setDuration}.
	 *
	 * @static
	 * @param {string} name - The name of the animation clip.
	 * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
	 * @param {number} fps - The Frames-Per-Second value.
	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
	 * @return {AnimationClip} The new animation clip.
	 */
	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = getKeyframeOrder( times );
			times = sortedArray( times, 1, order );
			values = sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, -1, tracks );

	}

	/**
	 * Searches for an animation clip by name, taking as its first parameter
	 * either an array of clips, or a mesh or geometry that contains an
	 * array named "animations" property.
	 *
	 * @static
	 * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
	 * @param {string} name - The name to search for.
	 * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
	 */
	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	/**
	 * Returns an array of new AnimationClips created from the morph target
	 * sequences of a geometry, trying to sort morph target names into
	 * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
	 *
	 * See {@link MD2Loader#parse} as an example for how the method should be used.
	 *
	 * @static
	 * @param {Array<Object>} morphTargets - A sequence of morph targets.
	 * @param {number} fps - The Frames-Per-Second value.
	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
	 * @return {Array<AnimationClip>} An array of new animation clips.
	 */
	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	/**
	 * Parses the `animation.hierarchy` format and returns a new animation clip.
	 *
	 * @static
	 * @deprecated since r175.
	 * @param {Object} animation - A serialized animation clip as JSON.
	 * @param {Array<Bones>} bones - An array of bones.
	 * @return {?AnimationClip} The new animation clip.
	 */
	static parseAnimation( animation, bones ) {

		console.warn( 'THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185' );

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || -1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = -1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	/**
	 * Sets the duration of this clip to the duration of its longest keyframe track.
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	/**
	 * Trims all tracks to the clip's duration.
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	/**
	 * Performs minimal validation on each track in the clip. Returns `true` if all
	 * tracks are valid.
	 *
	 * @return {boolean} Whether the clip's keyframes are valid or not.
	 */
	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	/**
	 * Optimizes each track by removing equivalent sequential keys (which are
	 * common in morph target sequences).
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	/**
	 * Returns a new animation clip with copied values from this instance.
	 *
	 * @return {AnimationClip} A clone of this instance.
	 */
	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	/**
	 * Serializes this animation clip into JSON.
	 *
	 * @return {Object} The JSON object.
	 */
	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

/**
 * @class
 * @classdesc A simple caching system, used internally by {@link FileLoader}.
 * To enable caching across all loaders that use {@link FileLoader}, add `THREE.Cache.enabled = true.` once in your app.
 * @hideconstructor
 */
const Cache = {

	/**
	 * Whether caching is enabled or not.
	 *
	 * @static
	 * @type {boolean}
	 * @default false
	 */
	enabled: false,

	/**
	 * A dictionary that holds cached files.
	 *
	 * @static
	 * @type {Object<string,Object>}
	 */
	files: {},

	/**
	 * Adds a cache entry with a key to reference the file. If this key already
	 * holds a file, it is overwritten.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 * @param {Object} file -  The file to be cached.
	 */
	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	/**
	 * Gets the cached value for the given key.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
	 */
	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	/**
	 * Removes the cached file associated with the given key.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 */
	remove: function ( key ) {

		delete this.files[ key ];

	},

	/**
	 * Remove all values from the cache.
	 *
	 * @static
	 */
	clear: function () {

		this.files = {};

	}

};

/**
 * Handles and keeps track of loaded and pending data. A default global
 * instance of this class is created and used by loaders if not supplied
 * manually.
 *
 * In general that should be sufficient, however there are times when it can
 * be useful to have separate loaders - for example if you want to show
 * separate loading bars for objects and textures.
 *
 * ```js
 * const manager = new THREE.LoadingManager();
 * manager.onLoad = () => console.log( 'Loading complete!' );
 *
 * const loader1 = new OBJLoader( manager );
 * const loader2 = new ColladaLoader( manager );
 * ```
 */
class LoadingManager {

	/**
	 * Constructs a new loading manager.
	 *
	 * @param {Function} [onLoad] - Executes when all items have been loaded.
	 * @param {Function} [onProgress] - Executes when single items have been loaded.
	 * @param {Function} [onError] - Executes when an error occurs.
	 */
	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		/**
		 * Executes when an item starts loading.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onStart = undefined;

		/**
		 * Executes when all items have been loaded.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onLoad = onLoad;

		/**
		 * Executes when single items have been loaded.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onProgress = onProgress;

		/**
		 * Executes when an error occurs.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onError = onError;

		/**
		 * This should be called by any loader using the manager when the loader
		 * starts loading an item.
		 *
		 * @param {string} url - The URL to load.
		 */
		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		/**
		 * This should be called by any loader using the manager when the loader
		 * ended loading an item.
		 *
		 * @param {string} url - The URL of the loaded item.
		 */
		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		/**
		 * This should be called by any loader using the manager when the loader
		 * encounters an error when loading an item.
		 *
		 * @param {string} url - The URL of the item that produces an error.
		 */
		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		/**
		 * Given a URL, uses the URL modifier callback (if any) and returns a
		 * resolved URL. If no URL modifier is set, returns the original URL.
		 *
		 * @param {string} url - The URL to load.
		 * @return {string} The resolved URL.
		 */
		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		/**
		 * If provided, the callback will be passed each resource URL before a
		 * request is sent. The callback may return the original URL, or a new URL to
		 * override loading behavior. This behavior can be used to load assets from
		 * .ZIP files, drag-and-drop APIs, and Data URIs.
		 *
		 * ```js
		 * const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};
		 *
		 * const manager = new THREE.LoadingManager();
		 *
		 * // Initialize loading manager with URL callback.
		 * const objectURLs = [];
		 * manager.setURLModifier( ( url ) => {
		 *
		 * 	url = URL.createObjectURL( blobs[ url ] );
		 * 	objectURLs.push( url );
		 * 	return url;
		 *
		 * } );
		 *
		 * // Load as usual, then revoke the blob URLs.
		 * const loader = new GLTFLoader( manager );
		 * loader.load( 'fish.gltf', (gltf) => {
		 *
		 * 	scene.add( gltf.scene );
		 * 	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );
		 *
		 * } );
		 * ```
		 *
		 * @param {function(string):string} transform - URL modifier callback. Called with an URL and must return a resolved URL.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		/**
		 * Registers a loader with the given regular expression. Can be used to
		 * define what loader should be used in order to load specific files. A
		 * typical use case is to overwrite the default loader for textures.
		 *
		 * ```js
		 * // add handler for TGA textures
		 * manager.addHandler( /\.tga$/i, new TGALoader() );
		 * ```
		 *
		 * @param {string} regex - A regular expression.
		 * @param {Loader} loader - A loader that should handle matched cases.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		/**
		 * Removes the loader for the given regular expression.
		 *
		 * @param {string} regex - A regular expression.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== -1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		/**
		 * Can be used to retrieve the registered loader for the given file path.
		 *
		 * @param {string} file - The file path.
		 * @return {?Loader} The registered loader. Returns `null` if no loader was found.
		 */
		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

/**
 * The global default loading manager.
 *
 * @constant
 * @type {LoadingManager}
 */
const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

/**
 * Abstract base class for loaders.
 *
 * @abstract
 */
class Loader {

	/**
	 * Constructs a new loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		/**
		 * The loading manager.
		 *
		 * @type {LoadingManager}
		 * @default DefaultLoadingManager
		 */
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		/**
		 * The crossOrigin string to implement CORS for loading the url from a
		 * different domain that allows CORS.
		 *
		 * @type {string}
		 * @default 'anonymous'
		 */
		this.crossOrigin = 'anonymous';

		/**
		 * Whether the XMLHttpRequest uses credentials.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * The base path from which the asset will be loaded.
		 *
		 * @type {string}
		 */
		this.path = '';

		/**
		 * The base path from which additional resources like textures will be loaded.
		 *
		 * @type {string}
		 */
		this.resourcePath = '';

		/**
		 * The [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
		 * used in HTTP request.
		 *
		 * @type {Object<string, any>}
		 */
		this.requestHeader = {};

	}

	/**
	 * This method needs to be implemented by all concrete loaders. It holds the
	 * logic for loading assets from the backend.
	 *
	 * @param {string} url - The path/URL of the file to be loaded.
	 * @param {Function} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @param {onErrorCallback} [onError] - Executed when errors occur.
	 */
	load( /* url, onLoad, onProgress, onError */ ) {}

	/**
	 * A async version of {@link Loader#load}.
	 *
	 * @param {string} url - The path/URL of the file to be loaded.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @return {Promise} A Promise that resolves when the asset has been loaded.
	 */
	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	/**
	 * This method needs to be implemented by all concrete loaders. It holds the
	 * logic for parsing the asset into three.js entities.
	 *
	 * @param {any} data - The data to parse.
	 */
	parse( /* data */ ) {}

	/**
	 * Sets the `crossOrigin` String to implement CORS for loading the URL
	 * from a different domain that allows CORS.
	 *
	 * @param {string} crossOrigin - The `crossOrigin` value.
	 * @return {Loader} A reference to this instance.
	 */
	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	/**
	 * Whether the XMLHttpRequest uses credentials such as cookies, authorization
	 * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.
	 *
	 * Note: This setting has no effect if you are loading files locally or from the same domain.
	 *
	 * @param {boolean} value - The `withCredentials` value.
	 * @return {Loader} A reference to this instance.
	 */
	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	/**
	 * Sets the base path for the asset.
	 *
	 * @param {string} path - The base path.
	 * @return {Loader} A reference to this instance.
	 */
	setPath( path ) {

		this.path = path;
		return this;

	}

	/**
	 * Sets the base path for dependent resources like textures.
	 *
	 * @param {string} resourcePath - The resource path.
	 * @return {Loader} A reference to this instance.
	 */
	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	/**
	 * Sets the given request header.
	 *
	 * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
	 * for configuring the HTTP request.
	 * @return {Loader} A reference to this instance.
	 */
	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

/**
 * Callback for onProgress in loaders.
 *
 * @callback onProgressCallback
 * @param {ProgressEvent} event - An instance of `ProgressEvent` that represents the current loading status.
 */

/**
 * Callback for onError in loaders.
 *
 * @callback onErrorCallback
 * @param {Error} error - The error which occurred during the loading process.
 */

/**
 * The default material name that is used by loaders
 * when creating materials for loaded 3D objects.
 *
 * Note: Not all loaders might honor this setting.
 *
 * @static
 * @type {string}
 * @default '__DEFAULT'
 */
Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

/**
 * A low level class for loading resources with the Fetch API, used internally by
 * most loaders. It can also be used directly to load any file type that does
 * not have a loader.
 *
 * This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`
 * once to your application.
 *
 * ```js
 * const loader = new THREE.FileLoader();
 * const data = await loader.loadAsync( 'example.txt' );
 * ```
 *
 * @augments Loader
 */
class FileLoader extends Loader {

	/**
	 * Constructs a new file loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

		/**
		 * The expected mime type.
		 *
		 * @type {string}
		 */
		this.mimeType = '';

		/**
		 * The expected response type.
		 *
		 * @type {('arraybuffer'|'blob'|'document'|'json'|'')}
		 * @default ''
		 */
		this.responseType = '';

	}

	/**
	 * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(any)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @param {onErrorCallback} [onError] - Executed when errors occur.
	 * @return {any|undefined} The cached resource if available.
	 */
	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();

					// Nginx needs X-File-Size check
					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								}, ( e ) => {

									controller.error( e );

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === '' ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	/**
	 * Sets the expected response type.
	 *
	 * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
	 * @return {FileLoader} A reference to this file loader.
	 */
	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	/**
	 * Sets the expected mime type of the loaded file.
	 *
	 * @param {string} value - The mime type.
	 * @return {FileLoader} A reference to this file loader.
	 */
	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

/**
 * Class for loading animation clips in the JSON format. The files are internally
 * loaded via {@link FileLoader}.
 *
 * ```js
 * const loader = new THREE.AnimationLoader();
 * const animations = await loader.loadAsync( 'animations/animation.js' );
 * ```
 *
 * @augments Loader
 */
class AnimationLoader extends Loader {

	/**
	 * Constructs a new animation loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the loaded animations as an array
	 * holding instances of {@link AnimationClip} to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Array<AnimationClip>)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	/**
	 * Parses the given JSON object and returns an array of animation clips.
	 *
	 * @param {Object} json - The serialized animation clips.
	 * @return {Array<AnimationClip>} The parsed animation clips.
	 */
	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract base class for loading compressed texture formats S3TC, ASTC or ETC.
 * Textures are internally loaded via {@link FileLoader}.
 *
 * Derived classes have to implement the `parse()` method which holds the parsing
 * for the respective format.
 *
 * @abstract
 * @augments Loader
 */
class CompressedTextureLoader extends Loader {

	/**
	 * Constructs a new compressed texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded compressed texture
	 * to the `onLoad()` callback. The method also returns a new texture object which can
	 * directly be used for material creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(CompressedTexture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {CompressedTexture} The compressed texture.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

/**
 * A loader for loading images. The class loads images with the HTML `Image` API.
 *
 * ```js
 * const loader = new THREE.ImageLoader();
 * const image = await loader.loadAsync( 'image.png' );
 * ```
 * Please note that `ImageLoader` has dropped support for progress
 * events in `r84`. For an `ImageLoader` that supports progress events, see
 * [this thread]{@link https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639}.
 *
 * @augments Loader
 */
class ImageLoader extends Loader {

	/**
	 * Constructs a new image loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded image
	 * to the `onLoad()` callback. The method also returns a new `Image` object which can
	 * directly be used for texture creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Image)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {Image} The image.
	 */
	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

/**
 * Class for loading cube textures. Images are internally loaded via {@link ImageLoader}.
 *
 * The loader returns an instance of {@link CubeTexture} and expects the cube map to
 * be defined as six separate images representing the sides of a cube. Other cube map definitions
 * like vertical and horizontal cross, column and row layouts are not supported.
 *
 * Note that, by convention, cube maps are specified in a coordinate system
 * in which positive-x is to the right when looking up the positive-z axis --
 * in other words, using a left-handed coordinate system. Since three.js uses
 * a right-handed coordinate system, environment maps used in three.js will
 * have pos-x and neg-x swapped.
 *
 * The loaded cube texture is in sRGB color space. Meaning {@link Texture#colorSpace}
 * is set to `SRGBColorSpace` by default.
 *
 * ```js
 * const loader = new THREE.CubeTextureLoader().setPath( 'textures/cubeMaps/' );
 * const cubeTexture = await loader.loadAsync( [
 * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
 * ] );
 * scene.background = cubeTexture;
 * ```
 *
 * @augments Loader
 */
class CubeTextureLoader extends Loader {

	/**
	 * Constructs a new cube texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the fully loaded cube texture
	 * to the `onLoad()` callback. The method also returns a new cube texture object which can
	 * directly be used for material creation. If you do it this way, the cube texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {Array<string>} urls - Array of 6 URLs to images, one for each side of the
	 * cube texture. The urls should be specified in the following order: pos-x,
	 * neg-x, pos-y, neg-y, pos-z, neg-z. An array of data URIs are allowed as well.
	 * @param {function(CubeTexture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {CubeTexture} The cube texture.
	 */
	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();
		texture.colorSpace = SRGBColorSpace;

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract base class for loading binary texture formats RGBE, EXR or TGA.
 * Textures are internally loaded via {@link FileLoader}.
 *
 * Derived classes have to implement the `parse()` method which holds the parsing
 * for the respective format.
 *
 * @abstract
 * @augments Loader
 */
class DataTextureLoader extends Loader {

	/**
	 * Constructs a new data texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded data texture
	 * to the `onLoad()` callback. The method also returns a new texture object which can
	 * directly be used for material creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(DataTexture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {DataTexture} The data texture.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			let texData;

			try {

				texData = scope.parse( buffer );

			} catch ( error ) {

				if ( onError !== undefined ) {

					onError( error );

				} else {

					console.error( error );
					return;

				}

			}

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.colorSpace !== undefined ) {

				texture.colorSpace = texData.colorSpace;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

/**
 * Class for loading textures. Images are internally
 * loaded via {@link ImageLoader}.
 *
 * ```js
 * const loader = new THREE.TextureLoader();
 * const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );
 *
 * const material = new THREE.MeshBasicMaterial( { map:texture } );
 * ```
 * Please note that `TextureLoader` has dropped support for progress
 * events in `r84`. For a `TextureLoader` that supports progress events, see
 * [this thread]{@link https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145}.
 *
 * @augments Loader
 */
class TextureLoader extends Loader {

	/**
	 * Constructs a new texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the fully loaded texture
	 * to the `onLoad()` callback. The method also returns a new texture object which can
	 * directly be used for material creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {Texture} The texture.
	 */
	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

/**
 * Abstract base class for lights - all other light types inherit the
 * properties and methods described here.
 *
 * @abstract
 * @augments Object3D
 */
class Light extends Object3D {

	/**
	 * Constructs a new light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity = 1 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLight = true;

		this.type = 'Light';

		/**
		 * The light's color.
		 *
		 * @type {Color}
		 */
		this.color = new Color( color );

		/**
		 * The light's intensity.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.intensity = intensity;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
		if ( this.target !== undefined ) data.object.target = this.target.uuid;

		return data;

	}

}

/**
 * A light source positioned directly above the scene, with color fading from
 * the sky color to the ground color.
 *
 * This light cannot be used to cast shadows.
 *
 * ```js
 * const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class HemisphereLight extends Light {

	/**
	 * Constructs a new hemisphere light.
	 *
	 * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
	 * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		/**
		 * The light's ground color.
		 *
		 * @type {Color}
		 */
		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

/**
 * Abstract base class for light shadow classes. These classes
 * represent the shadow configuration for different light types.
 *
 * @abstract
 */
class LightShadow {

	/**
	 * Constructs a new light shadow.
	 *
	 * @param {Camera} camera - The light's view of the world.
	 */
	constructor( camera ) {

		/**
		 * The light's view of the world.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * The intensity of the shadow. The default is `1`.
		 * Valid values are in the range `[0, 1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.intensity = 1;

		/**
		 * Shadow map bias, how much to add or subtract from the normalized depth
		 * when deciding whether a surface is in shadow.
		 *
		 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
		 * may help reduce artifacts in shadows.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.bias = 0;

		/**
		 * Defines how much the position used to query the shadow map is offset along
		 * the object normal. The default is `0`. Increasing this value can be used to
		 * reduce shadow acne especially in large scenes where light shines onto
		 * geometry at a shallow angle. The cost is that shadows may appear distorted.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.normalBias = 0;

		/**
		 * Setting this to values greater than 1 will blur the edges of the shadow.
		 * High values will cause unwanted banding effects in the shadows - a greater
		 * map size will allow for a higher value to be used here before these effects
		 * become visible.
		 *
		 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
		 * and it is recommended to increase softness by decreasing the shadow map size instead.
		 *
		 * The property has no effect when the shadow map type is `BasicShadowMap`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.radius = 1;

		/**
		 * The amount of samples to use when blurring a VSM shadow map.
		 *
		 * @type {number}
		 * @default 8
		 */
		this.blurSamples = 8;

		/**
		 * Defines the width and height of the shadow map. Higher values give better quality
		 * shadows at the cost of computation time. Values must be powers of two.
		 *
		 * @type {Vector2}
		 * @default (512,512)
		 */
		this.mapSize = new Vector2( 512, 512 );

		/**
		 * The type of shadow texture. The default is `UnsignedByteType`.
		 *
		 * @type {number}
		 * @default UnsignedByteType
		 */
		this.mapType = UnsignedByteType;

		/**
		 * The depth map generated using the internal camera; a location beyond a
		 * pixel's depth is in shadow. Computed internally during rendering.
		 *
		 * @type {?RenderTarget}
		 * @default null
		 */
		this.map = null;

		/**
		 * The distribution map generated using the internal camera; an occlusion is
		 * calculated based on the distribution of depths. Computed internally during
		 * rendering.
		 *
		 * @type {?RenderTarget}
		 * @default null
		 */
		this.mapPass = null;

		/**
		 * Model to shadow camera space, to compute location and depth in shadow map.
		 * This is computed internally during rendering.
		 *
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();

		/**
		 * Enables automatic updates of the light's shadow. If you do not require dynamic
		 * lighting / shadows, you may set this to `false`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoUpdate = true;

		/**
		 * When set to `true`, shadow maps will be updated in the next `render` call.
		 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
		 * set this property to `true` and then make a render call to update the light's shadow.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	/**
	 * Used internally by the renderer to get the number of viewports that need
	 * to be rendered for this shadow.
	 *
	 * @return {number} The viewport count.
	 */
	getViewportCount() {

		return this._viewportCount;

	}

	/**
	 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
	 *
	 * @return {Frustum} The shadow camera frustum.
	 */
	getFrustum() {

		return this._frustum;

	}

	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 *
	 * @param {Light} light - The light for which the shadow is being rendered.
	 */
	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( _projScreenMatrix$1 );

	}

	/**
	 * Returns a viewport definition for the given viewport index.
	 *
	 * @param {number} viewportIndex - The viewport index.
	 * @return {Vector4} The viewport.
	 */
	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	/**
	 * Returns the frame extends.
	 *
	 * @return {Vector2} The frame extends.
	 */
	getFrameExtents() {

		return this._frameExtents;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	/**
	 * Copies the values of the given light shadow instance to this instance.
	 *
	 * @param {LightShadow} source - The light shadow to copy.
	 * @return {LightShadow} A reference to this light shadow instance.
	 */
	copy( source ) {

		this.camera = source.camera.clone();

		this.intensity = source.intensity;

		this.bias = source.bias;
		this.radius = source.radius;

		this.autoUpdate = source.autoUpdate;
		this.needsUpdate = source.needsUpdate;
		this.normalBias = source.normalBias;
		this.blurSamples = source.blurSamples;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	/**
	 * Returns a new light shadow instance with copied values from this instance.
	 *
	 * @return {LightShadow} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Serializes the light shadow into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized light shadow.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON() {

		const object = {};

		if ( this.intensity !== 1 ) object.intensity = this.intensity;
		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

/**
 * Represents the shadow configuration of directional lights.
 *
 * @augments LightShadow
 */
class SpotLightShadow extends LightShadow {

	/**
	 * Constructs a new spot light shadow.
	 */
	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSpotLightShadow = true;

		/**
		 * Used to focus the shadow camera. The camera's field of view is set as a
		 * percentage of the spotlight's field-of-view. Range is `[0, 1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

/**
 * This light gets emitted from a single point in one direction, along a cone
 * that increases in size the further from the light it gets.
 *
 * This light can cast shadows - see the {@link SpotLightShadow} for details.
 *
 * ```js
 * // white spotlight shining from the side, modulated by a texture
 * const spotLight = new THREE.SpotLight( 0xffffff );
 * spotLight.position.set( 100, 1000, 100 );
 * spotLight.map = new THREE.TextureLoader().load( url );
 *
 * spotLight.castShadow = true;
 * spotLight.shadow.mapSize.width = 1024;
 * spotLight.shadow.mapSize.height = 1024;
 * spotLight.shadow.camera.near = 500;
 * spotLight.shadow.camera.far = 4000;
 * spotLight.shadow.camera.fov = 30;s
 * ```
 *
 * @augments Light
 */
class SpotLight extends Light {

	/**
	 * Constructs a new spot light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	 * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
	 * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
	 */
	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		/**
		 * The spot light points from its position to the
		 * target's position.
		 *
		 * For the target's position to be changed to anything other
		 * than the default, it must be added to the scene.
		 *
		 * It is also possible to set the target to be another 3D object
		 * in the scene. The light will now track the target object.
		 *
		 * @type {Object3D}
		 */
		this.target = new Object3D();

		/**
		 * Maximum range of the light. `0` means no limit.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.distance = distance;

		/**
		 * Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
		 *
		 * @type {number}
		 * @default Math.PI/3
		 */
		this.angle = angle;

		/**
		 * Percent of the spotlight cone that is attenuated due to penumbra.
		 * Value range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.penumbra = penumbra;

		/**
		 * The amount the light dims along the distance of the light. In context of
		 * physically-correct rendering the default value should not be changed.
		 *
		 * @type {number}
		 * @default 2
		 */
		this.decay = decay;

		/**
		 * A texture used to modulate the color of the light. The spot light
		 * color is mixed with the RGB value of this texture, with a ratio
		 * corresponding to its alpha value. The cookie-like masking effect is
		 * reproduced using pixel values (0, 0, 0, 1-cookie_value).
		 *
		 * *Warning*: This property is disabled if {@link Object3D#castShadow} is set to `false`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * This property holds the light's shadow configuration.
		 *
		 * @type {SpotLightShadow}
		 */
		this.shadow = new SpotLightShadow();

	}

	/**
	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
	 *  Changing the power will also change the light's intensity.
	 *
	 * @type {number}
	 */
	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

/**
 * Represents the shadow configuration of point lights.
 *
 * @augments LightShadow
 */
class PointLightShadow extends LightShadow {

	/**
	 * Constructs a new point light shadow.
	 */
	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
		];

	}

	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 *
	 * @param {Light} light - The light for which the shadow is being rendered.
	 * @param {number} [viewportIndex=0] - The viewport index.
	 */
	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

/**
 * A light that gets emitted from a single point in all directions. A common
 * use case for this is to replicate the light emitted from a bare
 * lightbulb.
 *
 * This light can cast shadows - see the {@link PointLightShadow} for details.
 *
 * ```js
 * const light = new THREE.PointLight( 0xff0000, 1, 100 );
 * light.position.set( 50, 50, 50 );
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class PointLight extends Light {

	/**
	 * Constructs a new point light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
	 */
	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointLight = true;

		this.type = 'PointLight';

		/**
		 * When distance is zero, light will attenuate according to inverse-square
		 * law to infinite distance. When distance is non-zero, light will attenuate
		 * according to inverse-square law until near the distance cutoff, where it
		 * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
		 * physically correct.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.distance = distance;

		/**
		 * The amount the light dims along the distance of the light. In context of
		 * physically-correct rendering the default value should not be changed.
		 *
		 * @type {number}
		 * @default 2
		 */
		this.decay = decay;

		/**
		 * This property holds the light's shadow configuration.
		 *
		 * @type {PointLightShadow}
		 */
		this.shadow = new PointLightShadow();

	}

	/**
	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
	 * Changing the power will also change the light's intensity.
	 *
	 * @type {number}
	 */
	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

/**
 * Camera that uses [orthographic projection]{@link https://en.wikipedia.org/wiki/Orthographic_projection}.
 *
 * In this projection mode, an object's size in the rendered image stays
 * constant regardless of its distance from the camera. This can be useful
 * for rendering 2D scenes and UI elements, amongst other things.
 *
 * ```js
 * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
 * scene.add( camera );
 * ```
 *
 * @augments Camera
 */
class OrthographicCamera extends Camera {

	/**
	 * Constructs a new orthographic camera.
	 *
	 * @param {number} [left=-1] - The left plane of the camera's frustum.
	 * @param {number} [right=1] - The right plane of the camera's frustum.
	 * @param {number} [top=1] - The top plane of the camera's frustum.
	 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
	 * @param {number} [near=0.1] - The camera's near plane.
	 * @param {number} [far=2000] - The camera's far plane.
	 */
	constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		/**
		 * The zoom factor of the camera.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.zoom = 1;

		/**
		 * Represents the frustum window specification. This property should not be edited
		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		 *
		 * @type {?Object}
		 * @default null
		 */
		this.view = null;

		/**
		 * The left plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.left = left;

		/**
		 * The right plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.right = right;

		/**
		 * The top plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.top = top;

		/**
		 * The bottom plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.bottom = bottom;

		/**
		 * The camera's near plane. The valid range is greater than `0`
		 * and less than the current value of {@link OrthographicCamera#far}.
		 *
		 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
		 * valid value for an orthographic camera's near plane.
		 *
		 * @type {number}
		 * @default 0.1
		 */
		this.near = near;

		/**
		 * The camera's far plane. Must be greater than the
		 * current value of {@link OrthographicCamera#near}.
		 *
		 * @type {number}
		 * @default 2000
		 */
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * @param {number} fullWidth - The full width of multiview setup.
	 * @param {number} fullHeight - The full height of multiview setup.
	 * @param {number} x - The horizontal offset of the subcamera.
	 * @param {number} y - The vertical offset of the subcamera.
	 * @param {number} width - The width of subcamera.
	 * @param {number} height - The height of subcamera.
	 * @see {@link PerspectiveCamera#setViewOffset}
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	/**
	 * Removes the view offset from the projection matrix.
	 */
	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	/**
	 * Updates the camera's projection matrix. Must be called after any change of
	 * camera properties.
	 */
	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

/**
 * Represents the shadow configuration of directional lights.
 *
 * @augments LightShadow
 */
class DirectionalLightShadow extends LightShadow {

	/**
	 * Constructs a new directional light shadow.
	 */
	constructor() {

		super( new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDirectionalLightShadow = true;

	}

}

/**
 * A light that gets emitted in a specific direction. This light will behave
 * as though it is infinitely far away and the rays produced from it are all
 * parallel. The common use case for this is to simulate daylight; the sun is
 * far enough away that its position can be considered to be infinite, and
 * all light rays coming from it are parallel.
 *
 * A common point of confusion for directional lights is that setting the
 * rotation has no effect. This is because three.js's DirectionalLight is the
 * equivalent to what is often called a 'Target Direct Light' in other
 * applications.
 *
 * This means that its direction is calculated as pointing from the light's
 * {@link Object3D#position} to the {@link DirectionalLight#target} position
 * (as opposed to a 'Free Direct Light' that just has a rotation
 * component).
 *
 * This light can cast shadows - see the {@link DirectionalLightShadow} for details.
 *
 * ```js
 * // White directional light at half intensity shining from the top.
 * const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
 * scene.add( directionalLight );
 * ```
 *
 * @augments Light
 */
class DirectionalLight extends Light {

	/**
	 * Constructs a new directional light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		/**
		 * The directional light points from its position to the
		 * target's position.
		 *
		 * For the target's position to be changed to anything other
		 * than the default, it must be added to the scene.
		 *
		 * It is also possible to set the target to be another 3D object
		 * in the scene. The light will now track the target object.
		 *
		 * @type {Object3D}
		 */
		this.target = new Object3D();

		/**
		 * This property holds the light's shadow configuration.
		 *
		 * @type {DirectionalLightShadow}
		 */
		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

/**
 * This light globally illuminates all objects in the scene equally.
 *
 * It cannot be used to cast shadows as it does not have a direction.
 *
 * ```js
 * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class AmbientLight extends Light {

	/**
	 * Constructs a new ambient light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

/**
 * This class emits light uniformly across the face a rectangular plane.
 * This light type can be used to simulate light sources such as bright
 * windows or strip lighting.
 *
 * Important Notes:
 *
 * - There is no shadow support.
 * - Only PBR materials are supported.
 * - You have to include `RectAreaLightUniformsLib` (`WebGLRenderer`) or `RectAreaLightTexturesLib` (`WebGPURenderer`)
 * into your app and init the uniforms/textures.
 *
 * ```js
 * RectAreaLightUniformsLib.init(); // only relevant for WebGLRenderer
 * THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() ); //  only relevant for WebGPURenderer
 *
 * const intensity = 1; const width = 10; const height = 10;
 * const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
 * rectLight.position.set( 5, 5, 0 );
 * rectLight.lookAt( 0, 0, 0 );
 * scene.add( rectLight )
 * ```
 *
 * @augments Light
 */
class RectAreaLight extends Light {

	/**
	 * Constructs a new area light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 * @param {number} [width=10] - The width of the light.
	 * @param {number} [height=10] - The height of the light.
	 */
	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isRectAreaLight = true;

		this.type = 'RectAreaLight';

		/**
		 * The width of the light.
		 *
		 * @type {number}
		 * @default 10
		 */
		this.width = width;

		/**
		 * The height of the light.
		 *
		 * @type {number}
		 * @default 10
		 */
		this.height = height;

	}

	/**
	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
	 * Changing the power will also change the light's intensity.
	 *
	 * @type {number}
	 */
	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

/**
 * Represents a third-order spherical harmonics (SH). Light probes use this class
 * to encode lighting information.
 *
 * - Primary reference: {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf}
 * - Secondary reference: {@link https://www.ppsloan.org/publications/StupidSH36.pdf}
 */
class SphericalHarmonics3 {

	/**
	 * Constructs a new spherical harmonics.
	 */
	constructor() {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSphericalHarmonics3 = true;

		/**
		 * An array holding the (9) SH coefficients.
		 *
		 * @type {Array<Vector3>}
		 */
		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	/**
	 * Sets the given SH coefficients to this instance by copying
	 * the values.
	 *
	 * @param {Array<Vector3>} coefficients - The SH coefficients.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	/**
	 * Sets all SH coefficients to `0`.
	 *
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	/**
	 * Returns the radiance in the direction of the given normal.
	 *
	 * @param {Vector3} normal - The normal vector (assumed to be unit length)
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The radiance.
	 */
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	/**
	 * Returns the irradiance (radiance convolved with cosine lobe) in the
	 * direction of the given normal.
	 *
	 * @param {Vector3} normal - The normal vector (assumed to be unit length)
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The irradiance.
	 */
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	/**
	 * Adds the given SH to this instance.
	 *
	 * @param {SphericalHarmonics3} sh - The SH to add.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	/**
	 * A convenience method for performing {@link SphericalHarmonics3#add} and
	 * {@link SphericalHarmonics3#scale} at once.
	 *
	 * @param {SphericalHarmonics3} sh - The SH to add.
	 * @param {number} s - The scale factor.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	/**
	 * Scales this SH by the given scale factor.
	 *
	 * @param {number} s - The scale factor.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	/**
	 * Linear interpolates between the given SH and this instance by the given
	 * alpha factor.
	 *
	 * @param {SphericalHarmonics3} sh - The SH to interpolate with.
	 * @param {number} alpha - The alpha factor.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	/**
	 * Returns `true` if this spherical harmonics is equal with the given one.
	 *
	 * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
	 * @return {boolean} Whether this spherical harmonics is equal with the given one.
	 */
	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Copies the values of the given spherical harmonics to this instance.
	 *
	 * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
	 */
	copy( sh ) {

		return this.set( sh.coefficients );

	}

	/**
	 * Returns a new spherical harmonics with copied values from this instance.
	 *
	 * @return {SphericalHarmonics3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Sets the SH coefficients of this instance from the given array.
	 *
	 * @param {Array<number>} array - An array holding the SH coefficients.
	 * @param {number} [offset=0] - The array offset where to start copying.
	 * @return {SphericalHarmonics3} A clone of this instance.
	 */
	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	/**
	 * Returns an array with the SH coefficients, or copies them into the provided
	 * array. The coefficients are represented as numbers.
	 *
	 * @param {Array<number>} [array=[]] - The target array.
	 * @param {number} [offset=0] - The array offset where to start copying.
	 * @return {Array<number>} An array with flat SH coefficients.
	 */
	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	/**
	 * Computes the SH basis for the given normal vector.
	 *
	 * @param {Vector3} normal - The normal.
	 * @param {Array<number>} shBasis - The target array holding the SH basis.
	 */
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

/**
 * Light probes are an alternative way of adding light to a 3D scene. Unlike
 * classical light sources (e.g. directional, point or spot lights), light
 * probes do not emit light. Instead they store information about light
 * passing through 3D space. During rendering, the light that hits a 3D
 * object is approximated by using the data from the light probe.
 *
 * Light probes are usually created from (radiance) environment maps. The
 * class {@link LightProbeGenerator} can be used to create light probes from
 * cube textures or render targets. However, light estimation data could also
 * be provided in other forms e.g. by WebXR. This enables the rendering of
 * augmented reality content that reacts to real world lighting.
 *
 * The current probe implementation in three.js supports so-called diffuse
 * light probes. This type of light probe is functionally equivalent to an
 * irradiance environment map.
 *
 * @augments Light
 */
class LightProbe extends Light {

	/**
	 * Constructs a new light probe.
	 *
	 * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLightProbe = true;

		/**
		 * A light probe uses spherical harmonics to encode lighting information.
		 *
		 * @type {SphericalHarmonics3}
		 */
		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	/**
	 * Deserializes the light prove from the given JSON.
	 *
	 * @param {Object} json - The JSON holding the serialized light probe.
	 * @return {LightProbe} A reference to this light probe.
	 */
	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

/**
 * Class for loading geometries. The files are internally
 * loaded via {@link FileLoader}.
 *
 * ```js
 * const loader = new THREE.MaterialLoader();
 * const material = await loader.loadAsync( 'material.json' );
 * ```
 * This loader does not support node materials. Use {@link NodeMaterialLoader} instead.
 *
 * @augments Loader
 */
class MaterialLoader extends Loader {

	/**
	 * Constructs a new material loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

		/**
		 * A dictionary holding textures used by the material.
		 *
		 * @type {Object<string,Texture>}
		 */
		this.textures = {};

	}

	/**
	 * Starts loading from the given URL and pass the loaded material to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Material)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	/**
	 * Parses the given JSON object and returns a material.
	 *
	 * @param {Object} json - The serialized material.
	 * @return {Material} The parsed material.
	 */
	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = this.createMaterialFromType( json.type );

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.dispersion !== undefined ) material.dispersion = json.dispersion;
		if ( json.iridescence !== undefined ) material.iridescence = json.iridescence;
		if ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;
		if ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;
		if ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;
		if ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;
		if ( json.blendDst !== undefined ) material.blendDst = json.blendDst;
		if ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;
		if ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;
		if ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;
		if ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;
		if ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );
		if ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;
		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== undefined ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;
		if ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		if ( json.lights !== undefined ) material.lights = json.lights;
		if ( json.clipping !== undefined ) material.clipping = json.clipping;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );
		if ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	/**
	 * Textures are not embedded in the material JSON so they have
	 * to be injected before the loading process starts.
	 *
	 * @param {Object} value - A dictionary holding textures for material properties.
	 * @return {MaterialLoader} A reference to this material loader.
	 */
	setTextures( value ) {

		this.textures = value;
		return this;

	}

	/**
	 * Creates a material for the given type.
	 *
	 * @param {string} type - The material type.
	 * @return {Material} The new material.
	 */
	createMaterialFromType( type ) {

		return MaterialLoader.createMaterialFromType( type );

	}

	/**
	 * Creates a material for the given type.
	 *
	 * @static
	 * @param {string} type - The material type.
	 * @return {Material} The new material.
	 */
	static createMaterialFromType( type ) {

		const materialLib = {
			ShadowMaterial,
			SpriteMaterial,
			RawShaderMaterial,
			ShaderMaterial,
			PointsMaterial,
			MeshPhysicalMaterial,
			MeshStandardMaterial,
			MeshPhongMaterial,
			MeshToonMaterial,
			MeshNormalMaterial,
			MeshLambertMaterial,
			MeshDepthMaterial,
			MeshDistanceMaterial,
			MeshBasicMaterial,
			MeshMatcapMaterial,
			LineDashedMaterial,
			LineBasicMaterial,
			Material
		};

		return new materialLib[ type ]();

	}

}

/**
 * A class with loader utility functions.
 */
class LoaderUtils {

	/**
	 * Extracts the base URL from the given URL.
	 *
	 * @param {string} url -The URL to extract the base URL from.
	 * @return {string} The extracted base URL.
	 */
	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === -1 ) return './';

		return url.slice( 0, index + 1 );

	}

	/**
	 * Resolves relative URLs against the given path. Absolute paths, data urls,
	 * and blob URLs will be returned as is. Invalid URLs will return an empty
	 * string.
	 *
	 * @param {string} url -The URL to resolve.
	 * @param {string} path - The base path for relative URLs to be resolved against.
	 * @return {string} The resolved URL.
	 */
	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

/**
 * An instanced version of a geometry.
 */
class InstancedBufferGeometry extends BufferGeometry {

	/**
	 * Constructs a new instanced buffer geometry.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInstancedBufferGeometry = true;

		this.type = 'InstancedBufferGeometry';

		/**
		 * The instance count.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

/**
 * Class for loading geometries. The files are internally
 * loaded via {@link FileLoader}.
 *
 * ```js
 * const loader = new THREE.BufferGeometryLoader();
 * const geometry = await loader.loadAsync( 'models/json/pressure.json' );
 *
 * const material = new THREE.MeshBasicMaterial( { color: 0xF5F5F5 } );
 * const object = new THREE.Mesh( geometry, material );
 * scene.add( object );
 * ```
 *
 * @augments Loader
 */
class BufferGeometryLoader extends Loader {

	/**
	 * Constructs a new geometry loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	/**
	 * Parses the given JSON object and returns a geometry.
	 *
	 * @param {Object} json - The serialized geometry.
	 * @return {BufferGeometry} The parsed geometry.
	 */
	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

/**
 * A loader for loading a JSON resource in the [JSON Object/Scene format]{@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4}.
 * The files are internally loaded via {@link FileLoader}.
 *
 * ```js
 * const loader = new THREE.ObjectLoader();
 * const obj = await loader.loadAsync( 'models/json/example.json' );
 * scene.add( obj );
 *
 * // Alternatively, to parse a previously loaded JSON structure
 * const object = await loader.parseAsync( a_json_object );
 * scene.add( object );
 * ```
 *
 * @augments Loader
 */
class ObjectLoader extends Loader {

	/**
	 * Constructs a new object loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the loaded 3D object to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Object3D)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				if ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\'t load ' + url ) );

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	/**
	 * Async version of {@link ObjectLoader#load}.
	 *
	 * @async
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @return {Promise<Object3D>} A Promise that resolves with the loaded 3D object.
	 */
	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	/**
	 * Parses the given JSON. This is used internally by {@link ObjectLoader#load}
	 * but can also be used directly to parse a previously loaded JSON structure.
	 *
	 * @param {Object} json - The serialized 3D object.
	 * @param {onLoad} onLoad - Executed when all resources (e.g. textures) have been fully loaded.
	 * @return {Object3D} The parsed 3D object.
	 */
	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );
		this.bindLightTargets( object );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ].data instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	/**
	 * Async version of {@link ObjectLoader#parse}.
	 *
	 * @param {Object} json - The serialized 3D object.
	 * @return {Promise<Object3D>} A Promise that resolves with the parsed 3D object.
	 */
	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );
		this.bindLightTargets( object );

		return object;

	}

	// internals

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );
						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( cache[ data.uuid ] === undefined ) {

					cache[ data.uuid ] = loader.parse( data );

				}

				materials[ data.uuid ] = cache[ data.uuid ];

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );


				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				const source = images[ data.image ];
				const image = source.data;

				let texture;

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture();

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture();

					} else {

						texture = new Texture();

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.source = source;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
				if ( data.channel !== undefined ) texture.channel = data.channel;

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;
				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
				if ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

					if ( data.fog.name !== '' ) {

						object.fog.name = data.fog.name;

					}

				}

				if ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;
				if ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;
				if ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );

				if ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;
				if ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );
				object.target = data.target || '';

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
				object.target = data.target || '';

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'BatchedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new BatchedMesh( data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material );
				object.geometry = geometry;
				object.perObjectFrustumCulled = data.perObjectFrustumCulled;
				object.sortObjects = data.sortObjects;

				object._drawRanges = data.drawRanges;
				object._reservedRanges = data.reservedRanges;

				object._geometryInfo = data.geometryInfo.map( info => {

					let box = null;
					let sphere = null;
					if ( info.boundingBox !== undefined ) {

						box = new Box3();
						box.min.fromArray( info.boundingBox.min );
						box.max.fromArray( info.boundingBox.max );

					}

					if ( info.boundingSphere !== undefined ) {

						sphere = new Sphere();
						sphere.radius = info.boundingSphere.radius;
						sphere.center.fromArray( info.boundingSphere.center );

					}

					return {
						...info,
						boundingBox: box,
						boundingSphere: sphere
					};

				} );
				object._instanceInfo = data.instanceInfo;

				object._availableInstanceIds = data._availableInstanceIds;
				object._availableGeometryIds = data._availableGeometryIds;

				object._nextIndexStart = data.nextIndexStart;
				object._nextVertexStart = data.nextVertexStart;
				object._geometryCount = data.geometryCount;

				object._maxInstanceCount = data.maxInstanceCount;
				object._maxVertexCount = data.maxVertexCount;
				object._maxIndexCount = data.maxIndexCount;

				object._geometryInitialized = data.geometryInitialized;

				object._matricesTexture = getTexture( data.matricesTexture.uuid );

				object._indirectTexture = getTexture( data.indirectTexture.uuid );

				if ( data.colorsTexture !== undefined ) {

					object._colorsTexture = getTexture( data.colorsTexture.uuid );

				}

				if ( data.boundingSphere !== undefined ) {

					object.boundingSphere = new Sphere();
					object.boundingSphere.center.fromArray( data.boundingSphere.center );
					object.boundingSphere.radius = data.boundingSphere.radius;

				}

				if ( data.boundingBox !== undefined ) {

					object.boundingBox = new Box3();
					object.boundingBox.min.fromArray( data.boundingBox.min );
					object.boundingBox.max.fromArray( data.boundingBox.max );

				}

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.up !== undefined ) object.up.fromArray( data.up );

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.intensity !== undefined ) object.shadow.intensity = data.shadow.intensity;
			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance, level.hysteresis );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	bindLightTargets( object ) {

		object.traverse( function ( child ) {

			if ( child.isDirectionalLight || child.isSpotLight ) {

				const uuid = child.target;

				const target = object.getObjectByProperty( 'uuid', uuid );

				if ( target !== undefined ) {

					child.target = target;

				} else {

					child.target = new Object3D();

				}

			}

		} );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

/**
 * A loader for loading images as an [ImageBitmap]{@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap}.
 * An `ImageBitmap` provides an asynchronous and resource efficient pathway to prepare
 * textures for rendering.
 *
 * Note that {@link Texture#flipY} and {@link Texture#premultiplyAlpha} are ignored with image bitmaps.
 * They needs these configuration on bitmap creation unlike regular images need them on uploading to GPU.
 *
 * You need to set the equivalent options via {@link ImageBitmapLoader#setOptions} instead.
 *
 * Also note that unlike {@link FileLoader}, this loader does not avoid multiple concurrent requests to the same URL.
 *
 * ```js
 * const loader = new THREE.ImageBitmapLoader();
 * loader.setOptions( { imageOrientation: 'flipY' } ); // set options if needed
 * const imageBitmap = await loader.loadAsync( 'image.png' );
 *
 * const texture = new THREE.Texture( imageBitmap );
 * texture.needsUpdate = true;
 * ```
 *
 * @augments Loader
 */
class ImageBitmapLoader extends Loader {

	/**
	 * Constructs a new image bitmap loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		/**
		 * Represents the loader options.
		 *
		 * @type {Object}
		 * @default {premultiplyAlpha:'none'}
		 */
		this.options = { premultiplyAlpha: 'none' };

	}

	/**
	 * Sets the given loader options. The structure of the object must match the `options` parameter of
	 * [createImageBitmap]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap}.
	 *
	 * @param {Object} options - The loader options to set.
	 * @return {ImageBitmapLoader} A reference to this image bitmap loader.
	 */
	setOptions( options ) {

		this.options = options;

		return this;

	}

	/**
	 * Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(ImageBitmap)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {ImageBitmap|undefined} The image bitmap.
	 */
	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			// If cached is a promise, wait for it to resolve
			if ( cached.then ) {

				cached.then( imageBitmap => {

					if ( onLoad ) onLoad( imageBitmap );

					scope.manager.itemEnd( url );

				} ).catch( e => {

					if ( onError ) onError( e );

				} );
				return;

			}

			// If cached is not a promise (i.e., it's already an imageBitmap)
			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		const promise = fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

			return imageBitmap;

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			Cache.remove( url );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		Cache.add( url, promise );
		scope.manager.itemStart( url );

	}

}

let _context;

/**
 * Manages the global audio context in the engine.
 *
 * @hideconstructor
 */
class AudioContext {

	/**
	 * Returns the global native audio context.
	 *
	 * @return {AudioContext} The native audio context.
	 */
	static getContext() {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	}

	/**
	 * Allows to set the global native audio context from outside.
	 *
	 * @param {AudioContext} value - The native context to set.
	 */
	static setContext( value ) {

		_context = value;

	}

}

/**
 * Class for loading audio buffers. Audios are internally
 * loaded via {@link FileLoader}.
 *
 * ```js
 * const audioListener = new THREE.AudioListener();
 * const ambientSound = new THREE.Audio( audioListener );
 *
 * const loader = new THREE.AudioLoader();
 * const audioBuffer = await loader.loadAsync( 'audio/ambient_ocean.ogg' );
 *
 * ambientSound.setBuffer( audioBuffer );
 * ambientSound.play();
 * ```
 *
 * @augments Loader
 */
class AudioLoader extends Loader {

	/**
	 * Constructs a new audio loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded audio buffer
	 * to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(AudioBuffer)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} ).catch( handleError );

			} catch ( e ) {

				handleError( e );

			}

		}, onProgress, onError );

		function handleError( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );

		}

	}

}

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
const _projectionMatrix = /*@__PURE__*/ new Matrix4();

/**
 * A special type of camera that uses two perspective cameras with
 * stereoscopic projection. Can be used for rendering stereo effects
 * like [3D Anaglyph]{@link https://en.wikipedia.org/wiki/Anaglyph_3D} or
 * [Parallax Barrier]{@link https://en.wikipedia.org/wiki/parallax_barrier}.
 */
class StereoCamera {

	/**
	 * Constructs a new stereo camera.
	 */
	constructor() {

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'StereoCamera';

		/**
		 * The aspect.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aspect = 1;

		/**
		 * The eye separation which represents the distance
		 * between the left and right camera.
		 *
		 * @type {number}
		 * @default 0.064
		 */
		this.eyeSep = 0.064;

		/**
		 * The camera representing the left eye. This is added to layer `1` so objects to be
		 * rendered by the left camera must also be added to this layer.
		 *
		 * @type {PerspectiveCamera}
		 */
		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		/**
		 * The camera representing the right eye. This is added to layer `2` so objects to be
		 * rendered by the right camera must also be added to this layer.
		 *
		 * @type {PerspectiveCamera}
		 */
		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	/**
	 * Updates the stereo camera based on the given perspective camera.
	 *
	 * @param {PerspectiveCamera} camera - The perspective camera.
	 */
	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy( camera.projectionMatrix );
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( _projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( _projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

/**
 * This type of camera can be used in order to efficiently render a scene with a
 * predefined set of cameras. This is an important performance aspect for
 * rendering VR scenes.
 *
 * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
 * to define for each sub camera the `viewport` property which determines the
 * part of the viewport that is rendered with this camera.
 *
 * @augments PerspectiveCamera
 */
class ArrayCamera extends PerspectiveCamera {

	/**
	 * Constructs a new array camera.
	 *
	 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
	 */
	constructor( array = [] ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isArrayCamera = true;

		/**
		 * Whether this camera is used with multiview rendering or not.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isMultiViewCamera = false;

		/**
		 * An array of perspective sub cameras.
		 *
		 * @type {Array<PerspectiveCamera>}
		 */
		this.cameras = array;

	}

}

/**
 * Class for keeping track of time.
 */
class Clock {

	/**
	 * Constructs a new clock.
	 *
	 * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
	 * `getDelta()` is called for the first time.
	 */
	constructor( autoStart = true ) {

		/**
		 * If set to `true`, the clock starts automatically when `getDelta()` is called
		 * for the first time.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoStart = autoStart;

		/**
		 * Holds the time at which the clock's `start()` method was last called.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.startTime = 0;

		/**
		 * Holds the time at which the clock's `start()`, `getElapsedTime()` or
		 * `getDelta()` methods were last called.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.oldTime = 0;

		/**
		 * Keeps track of the total time that the clock has been running.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.elapsedTime = 0;

		/**
		 * Whether the clock is running or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.running = false;

	}

	/**
	 * Starts the clock. When `autoStart` is set to `true`, the method is automatically
	 * called by the class.
	 */
	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	/**
	 * Stops the clock.
	 */
	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	/**
	 * Returns the elapsed time in seconds.
	 *
	 * @return {number} The elapsed time.
	 */
	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	/**
	 * Returns the delta time in seconds.
	 *
	 * @return {number} The delta time.
	 */
	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return performance.now();

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

/**
 * The class represents a virtual listener of the all positional and non-positional audio effects
 * in the scene. A three.js application usually creates a single listener. It is a mandatory
 * constructor parameter for audios entities like {@link Audio} and {@link PositionalAudio}.
 *
 * In most cases, the listener object is a child of the camera. So the 3D transformation of the
 * camera represents the 3D transformation of the listener.
 *
 * @augments Object3D
 */
class AudioListener extends Object3D {

	/**
	 * Constructs a new audio listener.
	 */
	constructor() {

		super();

		this.type = 'AudioListener';

		/**
		 * The native audio context.
		 *
		 * @type {AudioContext}
		 * @readonly
		 */
		this.context = AudioContext.getContext();

		/**
		 * The gain node used for volume control.
		 *
		 * @type {GainNode}
		 * @readonly
		 */
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		/**
		 * An optional filter.
		 *
		 * Defined via {@link AudioListener#setFilter}.
		 *
		 * @type {?AudioNode}
		 * @default null
		 * @readonly
		 */
		this.filter = null;

		/**
		 * Time delta values required for `linearRampToValueAtTime()` usage.
		 *
		 * @type {number}
		 * @default 0
		 * @readonly
		 */
		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	/**
	 * Returns the listener's input node.
	 *
	 * This method is used by other audio nodes to connect to this listener.
	 *
	 * @return {GainNode} The input node.
	 */
	getInput() {

		return this.gain;

	}

	/**
	 * Removes the current filter from this listener.
	 *
	 * @return {AudioListener} A reference to this listener.
	 */
	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	/**
	 * Returns the current set filter.
	 *
	 * @return {?AudioNode} The filter.
	 */
	getFilter() {

		return this.filter;

	}

	/**
	 * Sets the given filter to this listener.
	 *
	 * @param {AudioNode} value - The filter to set.
	 * @return {AudioListener} A reference to this listener.
	 */
	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	/**
	 * Returns the applications master volume.
	 *
	 * @return {number} The master volume.
	 */
	getMasterVolume() {

		return this.gain.gain.value;

	}

	/**
	 * Sets the applications master volume. This volume setting affects
	 * all audio nodes in the scene.
	 *
	 * @param {number} value - The master volume to set.
	 * @return {AudioListener} A reference to this listener.
	 */
	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, -1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

/**
 * Represents a non-positional ( global ) audio object.
 *
 * This and related audio modules make use of the [Web Audio API]{@link https://www.w3.org/TR/webaudio-1.1/}.
 *
 * ```js
 * // create an AudioListener and add it to the camera
 * const listener = new THREE.AudioListener();
 * camera.add( listener );
 *
 * // create a global audio source
 * const sound = new THREE.Audio( listener );
 *
 * // load a sound and set it as the Audio object's buffer
 * const audioLoader = new THREE.AudioLoader();
 * audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
 * 	sound.setBuffer( buffer );
 * 	sound.setLoop( true );
 * 	sound.setVolume( 0.5 );
 * 	sound.play();
 * });
 * ```
 *
 * @augments Object3D
 */
class Audio extends Object3D {

	/**
	 * Constructs a new audio.
	 *
	 * @param {AudioListener} listener - The global audio listener.
	 */
	constructor( listener ) {

		super();

		this.type = 'Audio';

		/**
		 * The global audio listener.
		 *
		 * @type {AudioListener}
		 * @readonly
		 */
		this.listener = listener;

		/**
		 * The audio context.
		 *
		 * @type {AudioContext}
		 * @readonly
		 */
		this.context = listener.context;

		/**
		 * The gain node used for volume control.
		 *
		 * @type {GainNode}
		 * @readonly
		 */
		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		/**
		 * Whether to start playback automatically or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.autoplay = false;

		/**
		 * A reference to an audio buffer.
		 *
		 * Defined via {@link Audio#setBuffer}.
		 *
		 * @type {?AudioBuffer}
		 * @default null
		 * @readonly
		 */
		this.buffer = null;

		/**
		 * Modify pitch, measured in cents. +/- 100 is a semitone.
		 * +/- 1200 is an octave.
		 *
		 * Defined via {@link Audio#setDetune}.
		 *
		 * @type {number}
		 * @default 0
		 * @readonly
		 */
		this.detune = 0;

		/**
		 * Whether the audio should loop or not.
		 *
		 * Defined via {@link Audio#setLoop}.
		 *
		 * @type {boolean}
		 * @default false
		 * @readonly
		 */
		this.loop = false;

		/**
		 * Defines where in the audio buffer the replay should
		 * start, in seconds.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.loopStart = 0;

		/**
		 * Defines where in the audio buffer the replay should
		 * stop, in seconds.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.loopEnd = 0;

		/**
		 * An offset to the time within the audio buffer the playback
		 * should begin, in seconds.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.offset = 0;

		/**
		 * Overrides the default duration of the audio.
		 *
		 * @type {undefined|number}
		 * @default undefined
		 */
		this.duration = undefined;

		/**
		 * The playback speed.
		 *
		 * Defined via {@link Audio#setPlaybackRate}.
		 *
		 * @type {number}
		 * @readonly
		 * @default 1
		 */
		this.playbackRate = 1;

		/**
		 * Indicates whether the audio is playing or not.
		 *
		 * This flag will be automatically set when using {@link Audio#play},
		 * {@link Audio#pause}, {@link Audio#stop}.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isPlaying = false;

		/**
		 * Indicates whether the audio playback can be controlled
		 * with method like {@link Audio#play} or {@link Audio#pause}.
		 *
		 * This flag will be automatically set when audio sources are
		 * defined.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.hasPlaybackControl = true;

		/**
		 * Holds a reference to the current audio source.
		 *
		 * The property is automatically by one of the `set*()` methods.
		 *
		 * @type {?AudioNode}
		 * @readonly
		 * @default null
		 */
		this.source = null;

		/**
		 * Defines the source type.
		 *
		 * The property is automatically by one of the `set*()` methods.
		 *
		 * @type {('empty'|'audioNode'|'mediaNode'|'mediaStreamNode'|'buffer')}
		 * @readonly
		 * @default 'empty'
		 */
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		/**
		 * Can be used to apply a variety of low-order filters to create
		 * more complex sound effects e.g. via `BiquadFilterNode`.
		 *
		 * The property is automatically set by {@link Audio#setFilters}.
		 *
		 * @type {Array<AudioNode>}
		 * @readonly
		 */
		this.filters = [];

	}

	/**
	 * Returns the output audio node.
	 *
	 * @return {GainNode} The output node.
	 */
	getOutput() {

		return this.gain;

	}

	/**
	 * Sets the given audio node as the source of this instance.
	 *
	 * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
	 *
	 * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
	 * @return {Audio} A reference to this instance.
	 */
	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	/**
	 * Sets the given media element as the source of this instance.
	 *
	 * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
	 *
	 * @param {HTMLMediaElement} mediaElement - The media element.
	 * @return {Audio} A reference to this instance.
	 */
	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	/**
	 * Sets the given media stream as the source of this instance.
	 *
	 * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
	 *
	 * @param {MediaStream} mediaStream - The media stream.
	 * @return {Audio} A reference to this instance.
	 */
	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	/**
	 * Sets the given audio buffer as the source of this instance.
	 *
	 * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
	 *
	 * @param {AudioBuffer} audioBuffer - The audio buffer.
	 * @return {Audio} A reference to this instance.
	 */
	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	/**
	 * Starts the playback of the audio.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
	 * @return {Audio|undefined} A reference to this instance.
	 */
	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	/**
	 * Pauses the playback of the audio.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @return {Audio|undefined} A reference to this instance.
	 */
	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	/**
	 * Stops the playback of the audio.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
	 * @return {Audio|undefined} A reference to this instance.
	 */
	stop( delay = 0 ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		if ( this.source !== null ) {

			this.source.stop( this.context.currentTime + delay );
			this.source.onended = null;

		}

		this.isPlaying = false;

		return this;

	}

	/**
	 * Connects to the audio source. This is used internally on
	 * initialisation and when setting / removing filters.
	 *
	 * @return {Audio} A reference to this instance.
	 */
	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	/**
	 * Disconnects to the audio source. This is used internally on
	 * initialisation and when setting / removing filters.
	 *
	 * @return {Audio|undefined} A reference to this instance.
	 */
	disconnect() {

		if ( this._connected === false ) {

			return;

		}

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	/**
	 * Returns the current set filters.
	 *
	 * @return {Array<AudioNode>} The list of filters.
	 */
	getFilters() {

		return this.filters;

	}

	/**
	 * Sets an array of filters and connects them with the audio source.
	 *
	 * @param {Array<AudioNode>} [value] - A list of filters.
	 * @return {Audio} A reference to this instance.
	 */
	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	/**
	 * Defines the detuning of oscillation in cents.
	 *
	 * @param {number} value - The detuning of oscillation in cents.
	 * @return {Audio} A reference to this instance.
	 */
	setDetune( value ) {

		this.detune = value;

		if ( this.isPlaying === true && this.source.detune !== undefined ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	/**
	 * Returns the detuning of oscillation in cents.
	 *
	 * @return {number} The detuning of oscillation in cents.
	 */
	getDetune() {

		return this.detune;

	}

	/**
	 * Returns the first filter in the list of filters.
	 *
	 * @return {AudioNode|undefined} The first filter in the list of filters.
	 */
	getFilter() {

		return this.getFilters()[ 0 ];

	}

	/**
	 * Applies a single filter node to the audio.
	 *
	 * @param {AudioNode} [filter] - The filter to set.
	 * @return {Audio} A reference to this instance.
	 */
	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	/**
	 * Sets the playback rate.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @param {number} [value] - The playback rate to set.
	 * @return {Audio|undefined} A reference to this instance.
	 */
	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	/**
	 * Returns the current playback rate.

	 * @return {number} The playback rate.
	 */
	getPlaybackRate() {

		return this.playbackRate;

	}

	/**
	 * Automatically called when playback finished.
	 */
	onEnded() {

		this.isPlaying = false;
		this._progress = 0;

	}

	/**
	 * Returns the loop flag.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @return {boolean} Whether the audio should loop or not.
	 */
	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	/**
	 * Sets the loop flag.
	 *
	 * Can only be used with compatible audio sources that allow playback control.
	 *
	 * @param {boolean} value - Whether the audio should loop or not.
	 * @return {Audio|undefined} A reference to this instance.
	 */
	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	/**
	 * Sets the loop start value which defines where in the audio buffer the replay should
	 * start, in seconds.
	 *
	 * @param {number} value - The loop start value.
	 * @return {Audio} A reference to this instance.
	 */
	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	/**
	 * Sets the loop end value which defines where in the audio buffer the replay should
	 * stop, in seconds.
	 *
	 * @param {number} value - The loop end value.
	 * @return {Audio} A reference to this instance.
	 */
	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	/**
	 * Returns the volume.
	 *
	 * @return {number} The volume.
	 */
	getVolume() {

		return this.gain.gain.value;

	}

	/**
	 * Sets the volume.
	 *
	 * @param {number} value - The volume to set.
	 * @return {Audio} A reference to this instance.
	 */
	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.sourceType !== 'buffer' ) {

			console.warn( 'THREE.Audio: Audio source type cannot be copied.' );

			return this;

		}

		this.autoplay = source.autoplay;

		this.buffer = source.buffer;
		this.detune = source.detune;
		this.loop = source.loop;
		this.loopStart = source.loopStart;
		this.loopEnd = source.loopEnd;
		this.offset = source.offset;
		this.duration = source.duration;
		this.playbackRate = source.playbackRate;
		this.hasPlaybackControl = source.hasPlaybackControl;
		this.sourceType = source.sourceType;

		this.filters = source.filters.slice();

		return this;

	}

	clone( recursive ) {

		return new this.constructor( this.listener ).copy( this, recursive );

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

/**
 * Represents a positional audio object.
 *
 * ```js
 * // create an AudioListener and add it to the camera
 * const listener = new THREE.AudioListener();
 * camera.add( listener );
 *
 * // create the PositionalAudio object (passing in the listener)
 * const sound = new THREE.PositionalAudio( listener );
 *
 * // load a sound and set it as the PositionalAudio object's buffer
 * const audioLoader = new THREE.AudioLoader();
 * audioLoader.load( 'sounds/song.ogg', function( buffer ) {
 * 	sound.setBuffer( buffer );
 * 	sound.setRefDistance( 20 );
 * 	sound.play();
 * });
 *
 * // create an object for the sound to play from
 * const sphere = new THREE.SphereGeometry( 20, 32, 16 );
 * const material = new THREE.MeshPhongMaterial( { color: 0xff2200 } );
 * const mesh = new THREE.Mesh( sphere, material );
 * scene.add( mesh );
 *
 * // finally add the sound to the mesh
 * mesh.add( sound );
 *
 * @augments Audio
 */
class PositionalAudio extends Audio {

	/**
	 * Constructs a positional audio.
	 *
	 * @param {AudioListener} listener - The global audio listener.
	 */
	constructor( listener ) {

		super( listener );

		/**
		 * The panner node represents the location, direction, and behavior of an audio
		 * source in 3D space.
		 *
		 * @type {PannerNode}
		 * @readonly
		 */
		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	connect() {

		super.connect();

		this.panner.connect( this.gain );

		return this;

	}

	disconnect() {

		super.disconnect();

		this.panner.disconnect( this.gain );

		return this;

	}

	getOutput() {

		return this.panner;

	}

	/**
	 * Returns the current reference distance.
	 *
	 * @return {number} The reference distance.
	 */
	getRefDistance() {

		return this.panner.refDistance;

	}

	/**
	 * Defines the reference distance for reducing volume as the audio source moves
	 * further from the listener – i.e. the distance at which the volume reduction
	 * starts taking effect.
	 *
	 * @param {number} value - The reference distance to set.
	 * @return {PositionalAudio} A reference to this instance.
	 */
	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	/**
	 * Returns the current rolloff factor.
	 *
	 * @return {number} The rolloff factor.
	 */
	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	/**
	 * Defines how quickly the volume is reduced as the source moves away from the listener.
	 *
	 * @param {number} value - The rolloff factor.
	 * @return {PositionalAudio} A reference to this instance.
	 */
	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	/**
	 * Returns the current distance model.
	 *
	 * @return {('linear'|'inverse'|'exponential')} The distance model.
	 */
	getDistanceModel() {

		return this.panner.distanceModel;

	}

	/**
	 * Defines which algorithm to use to reduce the volume of the audio source
	 * as it moves away from the listener.
	 *
	 * Read [the spec]{@link https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype}
	 * for more details.
	 *
	 * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
	 * @return {PositionalAudio} A reference to this instance.
	 */
	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	/**
	 * Returns the current max distance.
	 *
	 * @return {number} The max distance.
	 */
	getMaxDistance() {

		return this.panner.maxDistance;

	}

	/**
	 * Defines the maximum distance between the audio source and the listener,
	 * after which the volume is not reduced any further.
	 *
	 * This value is used only by the `linear` distance model.
	 *
	 * @param {number} value - The max distance.
	 * @return {PositionalAudio} A reference to this instance.
	 */
	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	/**
	 * Sets the directional cone in which the audio can be listened.
	 *
	 * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
	 * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
	 * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
	 * @return {PositionalAudio} A reference to this instance.
	 */
	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

/**
 * This class can be used to analyse audio data.
 *
 * ```js
 * // create an AudioListener and add it to the camera
 * const listener = new THREE.AudioListener();
 * camera.add( listener );
 *
 * // create an Audio source
 * const sound = new THREE.Audio( listener );
 *
 * // load a sound and set it as the Audio object's buffer
 * const audioLoader = new THREE.AudioLoader();
 * audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
 * 	sound.setBuffer( buffer );
 * 	sound.setLoop(true);
 * 	sound.setVolume(0.5);
 * 	sound.play();
 * });
 *
 * // create an AudioAnalyser, passing in the sound and desired fftSize
 * const analyser = new THREE.AudioAnalyser( sound, 32 );
 *
 * // get the average frequency of the sound
 * const data = analyser.getAverageFrequency();
 * ```
 */
class AudioAnalyser {

	/**
	 * Constructs a new audio analyzer.
	 *
	 * @param {Audio} audio - The audio to analyze.
	 * @param {number} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
	 */
	constructor( audio, fftSize = 2048 ) {

		/**
		 * The global audio listener.
		 *
		 * @type {AnalyserNode}
		 */
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		/**
		 * Holds the analyzed data.
		 *
		 * @type {Uint8Array}
		 */
		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	/**
	 * Returns an array with frequency data of the audio.
	 *
	 * Each item in the array represents the decibel value for a specific frequency.
	 * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
	 * For example, for 48000 sample rate, the last item of the array will represent
	 * the decibel value for 24000 Hz.
	 *
	 * @return {Uint8Array} The frequency data.
	 */
	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	/**
	 * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
	 *
	 * @return {number} The average frequency.
	 */
	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

/**
 * Buffered scene graph property that allows weighted accumulation; used internally.
 */
class PropertyMixer {

	/**
	 * Constructs a new property mixer.
	 *
	 * @param {PropertyBinding} binding - The property binding.
	 * @param {string} typeName - The keyframe track type name.
	 * @param {number} valueSize - The keyframe track value size.
	 */
	constructor( binding, typeName, valueSize ) {

		/**
		 * The property binding.
		 *
		 * @type {PropertyBinding}
		 */
		this.binding = binding;

		/**
		 * The keyframe track value size.
		 *
		 * @type {number}
		 */
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		/**
		 * TODO
		 *
		 * @type {number}
		 * @default 0
		 */
		this.cumulativeWeight = 0;

		/**
		 * TODO
		 *
		 * @type {number}
		 * @default 0
		 */
		this.cumulativeWeightAdditive = 0;

		/**
		 * TODO
		 *
		 * @type {number}
		 * @default 0
		 */
		this.useCount = 0;

		/**
		 * TODO
		 *
		 * @type {number}
		 * @default 0
		 */
		this.referenceCount = 0;

	}

	/**
	 * Accumulates data in the `incoming` region into `accu<i>`.
	 *
	 * @param {number} accuIndex - The accumulation index.
	 * @param {number} weight - The weight.
	 */
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	/**
	 * Accumulates data in the `incoming` region into `add`.
	 *
	 * @param {number} weight - The weight.
	 */
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	/**
	 * Applies the state of `accu<i>` to the binding when accus differ.
	 *
	 * @param {number} accuIndex - The accumulation index.
	 */
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}


	/**
	 * Remembers the state of the bound property and copy it to both accus.
	 */
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	/**
	 * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
	 */
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	// internals

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.


/**
 * This holds a reference to a real property in the scene graph; used internally.
 */
class PropertyBinding {

	/**
	 * Constructs a new property binding.
	 *
	 * @param {Object} rootNode - The root node.
	 * @param {string} path - The path.
	 * @param {?Object} [parsedPath] - The parsed path.
	 */
	constructor( rootNode, path, parsedPath ) {

		/**
		 * The object path to the animated property.
		 *
		 * @type {string}
		 */
		this.path = path;

		/**
		 * An object holding information about the path.
		 *
		 * @type {Object}
		 */
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		/**
		 * The object owns the animated property.
		 *
		 * @type {?Object}
		 */
		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

		/**
		 * The root node.
		 *
		 * @type {Object3D|Skeleton}
		 */
		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	/**
	 * Factory method for creating a property binding from the given parameters.
	 *
	 * @static
	 * @param {Object} root - The root node.
	 * @param {string} path - The path.
	 * @param {?Object} [parsedPath] - The parsed path.
	 * @return {PropertyBinding|Composite} The created property binding or composite.
	 */
	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name - Node name to be sanitized.
	 * @return {string} The sanitized node name.
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	/**
	 * Parses the given track name (an object path to an animated property) and
	 * returns an object with information about the path. Matches strings in the following forms:
	 *
	 * - nodeName.property
	 * - nodeName.property[accessor]
	 * - nodeName.material.property[accessor]
	 * - uuid.property[accessor]
	 * - uuid.objectName[objectIndex].propertyName[propertyIndex]
	 * - parentName/nodeName.property
	 * - parentName/parentName/nodeName.property[index]
	 * - .bone[Armature.DEF_cog].position
	 * - scene:helium_balloon_model:helium_balloon_model.position
	 *
	 * @static
	 * @param {string} trackName - The track name to parse.
	 * @return {Object} The parsed track name as an object.
	 */
	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== -1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== -1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	/**
	 * Searches for a node in the hierarchy of the given root object by the given
	 * node name.
	 *
	 * @static
	 * @param {Object} root - The root object.
	 * @param {string|number} nodeName - The name of the node.
	 * @return {?Object} The found node. Returns `null` if no object was found.
	 */
	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	/**
	 * Creates a getter / setter pair for the property tracked by this binding.
	 */
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				case 'map':

					if ( 'map' in targetObject ) {

						targetObject = targetObject.map;
						break;

					}

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.map ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
						return;

					}

					targetObject = targetObject.material.map;
					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.isMaterial === true ) {

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.isObject3D === true ) {

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	/**
	 * Unbinds the property.
	 */
	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * - Add objects you would otherwise pass as 'root' to the
 * constructor or the .clipAction method of AnimationMixer.
 * - Instead pass this object as 'root'.
 * - You can also add and remove objects later when the mixer is running.
 *
 * Note:
 *
 * - Objects of this class appear as one object to the mixer,
 * so cache control of the individual objects must be done on the group.
 *
 * Limitation:
 *
 * - The animated properties must be compatible among the all objects in the group.
 * - A single property can either be controlled through a target group or directly, but not both.
 */
class AnimationObjectGroup {

	/**
	 * Constructs a new animation group.
	 *
	 * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
	 */
	constructor() {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isAnimationObjectGroup = true;

		/**
		 * The UUID of the 3D object.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	/**
	 * Adds an arbitrary number of objects to this animation group.
	 *
	 * @param {...Object3D} arguments - The 3D objects to add.
	 */
	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	/**
	 * Removes an arbitrary number of objects to this animation group
	 *
	 * @param {...Object3D} arguments - The 3D objects to remove.
	 */
	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	/**
	 * Deallocates all memory resources for the passed 3D objects of this animation group.
	 *
	 * @param {...Object3D} arguments - The 3D objects to uncache.
	 */
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

/**
 * An instance of `AnimationAction` schedules the playback of an animation which is
 * stored in {@link AnimationClip}.
 */
class AnimationAction {

	/**
	 * Constructs a new animation action.
	 *
	 * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
	 * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
	 * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
	 */
	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;

		/**
		 * Defines how the animation is blended/combined when two or more animations
		 * are simultaneously played.
		 *
		 * @type {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)}
		 */
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		/**
		 * The loop mode, set via {@link AnimationAction#setLoop}.
		 *
		 * @type {(LoopRepeat|LoopOnce|LoopPingPong)}
		 * @default LoopRepeat
		 */
		this.loop = LoopRepeat;
		this._loopCount = -1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		/**
		 * The local time of this action (in seconds, starting with `0`).
		 *
		 * The value gets clamped or wrapped to `[0,clip.duration]` (according to the
		 * loop state).
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.time = 0;

		/**
		 * Scaling factor for the {@link AnimationAction#time}. A value of `0` causes the
		 * animation to pause. Negative values cause the animation to play backwards.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		/**
		 * The degree of influence of this action (in the interval `[0, 1]`). Values
		 * between `0` (no impact) and `1` (full impact) can be used to blend between
		 * several actions.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.weight = 1;
		this._effectiveWeight = 1;

		/**
		 * The number of repetitions of the performed clip over the course of this action.
		 * Can be set via {@link AnimationAction#setLoop}.
		 *
		 * Setting this number has no effect if {@link AnimationAction#loop} is set to
		 * `THREE:LoopOnce`.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.repetitions = Infinity;

		/**
		 * If set to `true`, the playback of the action is paused.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.paused = false;

		/**
		 * If set to `false`, the action is disabled so it has no impact.
		 *
		 * When the action is re-enabled, the animation continues from its current
		 * time (setting `enabled` to `false` doesn't reset the action).
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enabled = true;

		/**
		 * If set to true the animation will automatically be paused on its last frame.
		 *
		 * If set to false, {@link AnimationAction#enabled} will automatically be switched
		 * to `false` when the last loop of the action has finished, so that this action has
		 * no further impact.
		 *
		 * Note: This member has no impact if the action is interrupted (it
		 * has only an effect if its last loop has really finished).
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clampWhenFinished = false;

		/**
		 * Enables smooth interpolation without separate clips for start, loop and end.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.zeroSlopeAtStart = true;

		/**
		 * Enables smooth interpolation without separate clips for start, loop and end.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.zeroSlopeAtEnd = true;

	}

	/**
	 * Starts the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	play() {

		this._mixer._activateAction( this );

		return this;

	}

	/**
	 * Stops the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	/**
	 * Resets the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = -1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	/**
	 * Returns `true` if the animation is running.
	 *
	 * @return {boolean} Whether the animation is running or not.
	 */
	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	/**
	 * Returns `true` when {@link AnimationAction#play} has been called.
	 *
	 * @return {boolean} Whether the animation is scheduled or not.
	 */
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	/**
	 * Defines the time when the animation should start.
	 *
	 * @param {number} time - The start time in seconds.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	startAt( time ) {

		this._startTime = time;

		return this;

	}

	/**
	 * Configures the loop settings for this action.
	 *
	 * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
	 * @param {number} repetitions - The number of repetitions.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	/**
	 * Sets the effective weight of this action.
	 *
	 * An action has no effect and thus an effective weight of zero when the
	 * action is disabled.
	 *
	 * @param {number} weight - The weight to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	/**
	 * Returns the effective weight of this action.
	 *
	 * @return {number} The effective weight.
	 */
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	/**
	 * Fades the animation in by increasing its weight gradually from `0` to `1`,
	 * within the passed time interval.
	 *
	 * @param {number} duration - The duration of the fade.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	/**
	 * Fades the animation out by decreasing its weight gradually from `1` to `0`,
	 * within the passed time interval.
	 *
	 * @param {number} duration - The duration of the fade.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	/**
	 * Causes this action to fade in and the given action to fade out,
	 * within the passed time interval.
	 *
	 * @param {AnimationAction} fadeOutAction - The animation action to fade out.
	 * @param {number} duration - The duration of the fade.
	 * @param {boolean} [warp=false] - Whether warping should be used or not.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	crossFadeFrom( fadeOutAction, duration, warp = false ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp === true ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	/**
	 * Causes this action to fade out and the given action to fade in,
	 * within the passed time interval.
	 *
	 * @param {AnimationAction} fadeInAction - The animation action to fade in.
	 * @param {number} duration - The duration of the fade.
	 * @param {boolean} [warp=false] - Whether warping should be used or not.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	crossFadeTo( fadeInAction, duration, warp = false ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	/**
	 * Stops any fading which is applied to this action.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	/**
	 * Sets the effective time scale of this action.
	 *
	 * An action has no effect and thus an effective time scale of zero when the
	 * action is paused.
	 *
	 * @param {number} timeScale - The time scale to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	/**
	 * Returns the effective time scale of this action.
	 *
	 * @return {number} The effective time scale.
	 */
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	/**
	 * Sets the duration for a single loop of this action.
	 *
	 * @param {number} duration - The duration to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	/**
	 * Synchronizes this action with the passed other action.
	 *
	 * @param {AnimationAction} action - The action to sync with.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	/**
	 * Decelerates this animation's speed to `0` within the passed time interval.
	 *
	 * @param {number} duration - The duration.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	/**
	 * Changes the playback speed, within the passed time interval, by modifying
	 * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
	 * `endTimeScale`.
	 *
	 * @param {number} startTimeScale - The start time scale.
	 * @param {number} endTimeScale - The end time scale.
	 * @param {number} duration - The duration.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	/**
	 * Stops any scheduled warping which is applied to this action.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	/**
	 * Returns the animation mixer of this animation action.
	 *
	 * @return {AnimationMixer} The animation mixer.
	 */
	getMixer() {

		return this._mixer;

	}

	/**
	 * Returns the animation clip of this animation action.
	 *
	 * @return {AnimationClip} The animation clip.
	 */
	getClip() {

		return this._clip;

	}

	/**
	 * Returns the root object of this animation action.
	 *
	 * @return {Object3D} The root object.
	 */
	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				deltaTime = 0;

			} else {


				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === -1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === -1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === -1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : -1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

const _controlInterpolantsResultBuffer = new Float32Array( 1 );

/**
 * `AnimationMixer` is a player for animations on a particular object in
 * the scene. When multiple objects in the scene are animated independently,
 * one `AnimationMixer` may be used for each object.
 */
class AnimationMixer extends EventDispatcher {

	/**
	 * Constructs a new animation mixer.
	 *
	 * @param {Object3D} root - The object whose animations shall be played by this mixer.
	 */
	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		/**
		 * The global mixer time (in seconds; starting with `0` on the mixer's creation).
		 *
		 * @type {number}
		 * @default 0
		 */
		this.time = 0;

		/**
		 * A scaling factor for the global time.
		 *
		 * Note: Setting this member to `0` and later back to `1` is a
		 * possibility to pause/unpause all actions that are controlled by this
		 * mixer.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				++ binding.referenceCount;
				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, _controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	/**
	 * Returns an instance of {@link AnimationAction} for the passed clip.
	 *
	 * If an action fitting the clip and root parameters doesn't yet exist, it
	 * will be created by this method. Calling this method several times with the
	 * same clip and root parameters always returns the same action.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
	 * @return {?AnimationAction} The animation action.
	 */
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	/**
	 * Returns an existing animation action for the passed clip.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
	 */
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	/**
	 * Deactivates all previously scheduled actions on this mixer.
	 *
	 * @return {AnimationMixer} A reference to thi animation mixer.
	 */
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	/**
	 * Advances the global mixer time and updates the animation.
	 *
	 * This is usually done in the render loop by passing the delta
	 * time from {@link Clock} or {@link Timer}.
	 *
	 * @param {number} deltaTime - The delta time in seconds.
	 * @return {AnimationMixer} A reference to thi animation mixer.
	 */
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	/**
	 * Sets the global mixer to a specific time and updates the animation accordingly.
	 *
	 * This is useful when you need to jump to an exact time in an animation. The
	 * input parameter will be scaled by {@link AnimationMixer#timeScale}
	 *
	 * @param {number} time - The time to set in seconds.
	 * @return {AnimationMixer} A reference to thi animation mixer.
	 */
	setTime( time ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( time ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	/**
	 * Returns this mixer's root object.
	 *
	 * @return {Object3D} The mixer's root object.
	 */
	getRoot() {

		return this._root;

	}

	/**
	 * Deallocates all memory resources for a clip. Before using this method make
	 * sure to call {@link AnimationAction#stop} for all related actions.
	 *
	 * @param {AnimationClip} clip - The clip to uncache.
	 */
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	/**
	 * Deallocates all memory resources for a root object. Before using this
	 * method make sure to call {@link AnimationAction#stop} for all related
	 * actions or alternatively {@link AnimationMixer#stopAllAction} when the
	 * mixer operates on a single root.
	 *
	 * @param {Object3D} root - The root object to uncache.
	 */
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	/**
	 * Deallocates all memory resources for an action. The action is identified by the
	 * given clip and an optional root object. Before using this method make
	 * sure to call {@link AnimationAction#stop} to deactivate the action.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 */
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

/**
 * Represents a 3D render target.
 *
 * @augments RenderTarget
 */
class RenderTarget3D extends RenderTarget {

	/**
	 * Constructs a new 3D render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {number} [depth=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isRenderTarget3D = true;

		this.depth = depth;

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {Data3DTexture}
		 */
		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

/**
 * Represents an array render target.
 *
 * @augments RenderTarget
 */
class RenderTargetArray extends RenderTarget {

	/**
	 * Constructs a new 3D render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {number} [depth=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		this.isRenderTargetArray = true;

		this.depth = depth;

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {DataArrayTexture}
		 */
		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

/**
 * Represents a uniform which is a global shader variable. They are passed to shader programs.
 *
 * When declaring a uniform of a {@link ShaderMaterial}, it is declared by value or by object.
 * ```js
 * uniforms: {
 * 	time: { value: 1.0 },
 * 	resolution: new Uniform( new Vector2() )
 * };
 * ```
 * Since this class can only be used in context of {@link ShaderMaterial}, it is only supported
 * in {@link WebGLRenderer}.
 */
class Uniform {

	/**
	 * Constructs a new uniform.
	 *
	 * @param {any} value - The uniform value.
	 */
	constructor( value ) {

		/**
		 * The uniform value.
		 *
		 * @type {any}
		 */
		this.value = value;

	}

	/**
	 * Returns a new uniform with copied values from this instance.
	 * If the value has a `clone()` method, the value is cloned as well.
	 *
	 * @return {Uniform} A clone of this instance.
	 */
	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

let _id = 0;

/**
 * A class for managing multiple uniforms in a single group. The renderer will process
 * such a definition as a single UBO.
 *
 * Since this class can only be used in context of {@link ShaderMaterial}, it is only supported
 * in {@link WebGLRenderer}.
 *
 * @augments EventDispatcher
 */
class UniformsGroup extends EventDispatcher {

	/**
	 * Constructs a new uniforms group.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isUniformsGroup = true;

		/**
		 * The ID of the 3D object.
		 *
		 * @name UniformsGroup#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _id ++ } );

		/**
		 * The name of the uniforms group.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The buffer usage.
		 *
		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		 * @default StaticDrawUsage
		 */
		this.usage = StaticDrawUsage;

		/**
		 * An array holding the uniforms.
		 *
		 * @type {Array<Uniform>}
		 */
		this.uniforms = [];

	}

	/**
	 * Adds the given uniform to this uniforms group.
	 *
	 * @param {Uniform} uniform - The uniform to add.
	 * @return {UniformsGroup} A reference to this uniforms group.
	 */
	add( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	/**
	 * Removes the given uniform from this uniforms group.
	 *
	 * @param {Uniform} uniform - The uniform to remove.
	 * @return {UniformsGroup} A reference to this uniforms group.
	 */
	remove( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== -1 ) this.uniforms.splice( index, 1 );

		return this;

	}

	/**
	 * Sets the name of this uniforms group.
	 *
	 * @param {string} name - The name to set.
	 * @return {UniformsGroup} A reference to this uniforms group.
	 */
	setName( name ) {

		this.name = name;

		return this;

	}

	/**
	 * Sets the usage of this uniforms group.
	 *
	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	 * @return {UniformsGroup} A reference to this uniforms group.
	 */
	setUsage( value ) {

		this.usage = value;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Texture#dispose
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Copies the values of the given uniforms group to this instance.
	 *
	 * @param {UniformsGroup} source - The uniforms group to copy.
	 * @return {UniformsGroup} A reference to this uniforms group.
	 */
	copy( source ) {

		this.name = source.name;
		this.usage = source.usage;

		const uniformsSource = source.uniforms;

		this.uniforms.length = 0;

		for ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {

			const uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];

			for ( let j = 0; j < uniforms.length; j ++ ) {

				this.uniforms.push( uniforms[ j ].clone() );

			}

		}

		return this;

	}

	/**
	 * Returns a new uniforms group with copied values from this instance.
	 *
	 * @return {UniformsGroup} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * An instanced version of an interleaved buffer.
 *
 * @augments InterleavedBuffer
 */
class InstancedInterleavedBuffer extends InterleavedBuffer {

	/**
	 * Constructs a new instanced interleaved buffer.
	 *
	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
	 * @param {number} stride - The number of typed-array elements per vertex.
	 * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
	 */
	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInstancedInterleavedBuffer = true;

		/**
		 * Defines how often a value of this buffer attribute should be repeated,
		 * see {@link InstancedBufferAttribute#meshPerAttribute}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

/**
 * An alternative version of a buffer attribute with more control over the VBO.
 *
 * The renderer does not construct a VBO for this kind of attribute. Instead, it uses
 * whatever VBO is passed in constructor and can later be altered via the `buffer` property.
 *
 * The most common use case for this class is when some kind of GPGPU calculation interferes
 * or even produces the VBOs in question.
 *
 * Notice that this class can only be used with {@link WebGLRenderer}.
 */
class GLBufferAttribute {

	/**
	 * Constructs a new GL buffer attribute.
	 *
	 * @param {WebGLBuffer} buffer - The native WebGL buffer.
	 * @param {number} type - The native data type (e.g. `gl.FLOAT`).
	 * @param {number} itemSize - The item size.
	 * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
	 * @param {number} count - The expected number of vertices in VBO.
	 */
	constructor( buffer, type, itemSize, elementSize, count ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isGLBufferAttribute = true;

		/**
		 * The name of the buffer attribute.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The native WebGL buffer.
		 *
		 * @type {WebGLBuffer}
		 */
		this.buffer = buffer;

		/**
		 * The native data type.
		 *
		 * @type {number}
		 */
		this.type = type;

		/**
		 * The item size, see {@link BufferAttribute#itemSize}.
		 *
		 * @type {number}
		 */
		this.itemSize = itemSize;

		/**
		 * The corresponding size (in bytes) for the given `type` parameter.
		 *
		 * @type {number}
		 */
		this.elementSize = elementSize;

		/**
		 * The expected number of vertices in VBO.
		 *
		 * @type {number}
		 */
		this.count = count;

		/**
		 * A version number, incremented every time the `needsUpdate` is set to `true`.
		 *
		 * @type {number}
		 */
		this.version = 0;

	}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Sets the given native WebGL buffer.
	 *
	 * @param {WebGLBuffer} buffer - The buffer to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	/**
	 * Sets the given native data type and element size.
	 *
	 * @param {number} type - The native data type (e.g. `gl.FLOAT`).
	 * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	/**
	 * Sets the item size.
	 *
	 * @param {number} itemSize - The item size.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	/**
	 * Sets the count (the expected number of vertices in VBO).
	 *
	 * @param {number} count - The count.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setCount( count ) {

		this.count = count;

		return this;

	}

}

const _matrix = /*@__PURE__*/ new Matrix4();

/**
 * This class is designed to assist with raycasting. Raycasting is used for
 * mouse picking (working out what objects in the 3d space the mouse is over)
 * amongst other things.
 */
class Raycaster {

	/**
	 * Constructs a new raycaster.
	 *
	 * @param {Vector3} origin - The origin vector where the ray casts from.
	 * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
	 * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
	 * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
	 */
	constructor( origin, direction, near = 0, far = Infinity ) {

		/**
		 * The ray used for raycasting.
		 *
		 * @type {Ray}
		 */
		this.ray = new Ray( origin, direction );

		/**
		 * All results returned are further away than near. Near can't be negative.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.near = near;

		/**
		 * All results returned are further away than near. Near can't be negative.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.far = far;

		/**
		 * The camera to use when raycasting against view-dependent objects such as
		 * billboarded objects like sprites. This field can be set manually or
		 * is set when calling `setFromCamera()`.
		 *
		 * @type {?Camera}
		 * @default null
		 */
		this.camera = null;

		/**
		 * Allows to selectively ignore 3D objects when performing intersection tests.
		 * The following code example ensures that only 3D objects on layer `1` will be
		 * honored by raycaster.
		 * ```js
		 * raycaster.layers.set( 1 );
		 * object.layers.enable( 1 );
		 * ```
		 *
		 * @type {Layers}
		 */
		this.layers = new Layers();


		/**
		 * A parameter object that configures the raycasting. It has the structure:
		 *
		 * ```
		 * {
		 * 	Mesh: {},
		 * 	Line: { threshold: 1 },
		 * 	LOD: {},
		 * 	Points: { threshold: 1 },
		 * 	Sprite: {}
		 * }
		 * ```
		 * Where `threshold` is the precision of the raycaster when intersecting objects, in world units.
		 *
		 * @type {Object}
		 */
		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	/**
	 * Updates the ray with a new origin and direction by copying the values from the arguments.
	 *
	 * @param {Vector3} origin - The origin vector where the ray casts from.
	 * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
	 */
	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	/**
	 * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
	 *
	 * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
	 * X and Y components should be between `-1` and `1`.
	 * @param {Camera} camera - The camera from which the ray should originate.
	 */
	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	/**
	 * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
	 *
	 * @param {WebXRController} controller - The controller to copy the position and direction from.
	 * @return {Raycaster} A reference to this raycaster.
	 */
	setFromXRController( controller ) {

		_matrix.identity().extractRotation( controller.matrixWorld );

		this.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		this.ray.direction.set( 0, 0, -1 ).applyMatrix4( _matrix );

		return this;

	}

	/**
	 * The intersection point of a raycaster intersection test.
	 * @typedef {Object} Raycaster~Intersection
	 * @property {number} distance - The distance from the ray's origin to the intersection point.
	 * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
	 * intersection to the nearest point on the ray. For other objects it will be `undefined`.
	 * @property {Vector3} point - The intersection point, in world coordinates.
	 * @property {Object} face - The face that has been intersected.
	 * @property {number} faceIndex - The face index.
	 * @property {Object3D} object - The 3D object that has been intersected.
	 * @property {Vector2} uv - U,V coordinates at point of intersection.
	 * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
	 * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.
	 * @property {number} instanceId - The index number of the instance where the ray
	 * intersects the {@link InstancedMesh}.
	 */

	/**
	 * Checks all intersection between the ray and the object with or without the
	 * descendants. Intersections are returned sorted by distance, closest first.
	 *
	 * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
	 * evaluating whether the ray intersects the object or not. This allows meshes to respond
	 * differently to ray casting than lines or points.
	 *
	 * Note that for meshes, faces must be pointed towards the origin of the ray in order
	 * to be detected; intersections of the ray passing through the back of a face will not
	 * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
	 * to `THREE.DoubleSide`.
	 *
	 * @param {Object3D} object - The 3D object to check for intersection with the ray.
	 * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
	 * Otherwise it only checks intersection with the object.
	 * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
	 * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
	 */
	intersectObject( object, recursive = true, intersects = [] ) {

		intersect( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	/**
	 * Checks all intersection between the ray and the objects with or without
	 * the descendants. Intersections are returned sorted by distance, closest first.
	 *
	 * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
	 * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
	 * Otherwise it only checks intersection with the object.
	 * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
	 * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
	 */
	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersect( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersect( object, raycaster, intersects, recursive ) {

	let propagate = true;

	if ( object.layers.test( raycaster.layers ) ) {

		const result = object.raycast( raycaster, intersects );

		if ( result === false ) propagate = false;

	}

	if ( propagate === true && recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersect( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * This class can be used to represent points in 3D space as
 * [Spherical coordinates]{@link https://en.wikipedia.org/wiki/Spherical_coordinate_system}.
 */
class Spherical {

	/**
	 * Constructs a new spherical.
	 *
	 * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
	 * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
	 * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
	 */
	constructor( radius = 1, phi = 0, theta = 0 ) {

		/**
		 * The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.radius = radius;

		/**
		 * The polar angle in radians from the y (up) axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.phi = phi;

		/**
		 * The equator/azimuthal angle in radians around the y (up) axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.theta = theta;

	}

	/**
	 * Sets the spherical components by copying the given values.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} phi - The polar angle.
	 * @param {number} theta - The azimuthal angle.
	 * @return {Spherical} A reference to this spherical.
	 */
	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	/**
	 * Copies the values of the given spherical to this instance.
	 *
	 * @param {Spherical} other - The spherical to copy.
	 * @return {Spherical} A reference to this spherical.
	 */
	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	/**
	 * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
	 * `0.000001`.
	 *
	 * @return {Spherical} A reference to this spherical.
	 */
	makeSafe() {

		const EPS = 0.000001;
		this.phi = clamp( this.phi, EPS, Math.PI - EPS );

		return this;

	}

	/**
	 * Sets the spherical components from the given vector which is assumed to hold
	 * Cartesian coordinates.
	 *
	 * @param {Vector3} v - The vector to set.
	 * @return {Spherical} A reference to this spherical.
	 */
	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	/**
	 * Sets the spherical components from the given Cartesian coordinates.
	 *
	 * @param {number} x - The x value.
	 * @param {number} y - The x value.
	 * @param {number} z - The x value.
	 * @return {Spherical} A reference to this spherical.
	 */
	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, -1, 1 ) );

		}

		return this;

	}

	/**
	 * Returns a new spherical with copied values from this instance.
	 *
	 * @return {Spherical} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * This class can be used to represent points in 3D space as
 * [Cylindrical coordinates]{@link https://en.wikipedia.org/wiki/Cylindrical_coordinate_system}.
 */
class Cylindrical {

	/**
	 * Constructs a new cylindrical.
	 *
	 * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
	 * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
	 * @param {number} [y=0] - The height above the x-z plane.
	 */
	constructor( radius = 1, theta = 0, y = 0 ) {

		/**
		 * The distance from the origin to a point in the x-z plane.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.radius = radius;

		/**
		 * A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.theta = theta;

		/**
		 * The height above the x-z plane.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.y = y;

	}

	/**
	 * Sets the cylindrical components by copying the given values.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} theta - The theta angle.
	 * @param {number} y - The height value.
	 * @return {Cylindrical} A reference to this cylindrical.
	 */
	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	/**
	 * Copies the values of the given cylindrical to this instance.
	 *
	 * @param {Cylindrical} other - The cylindrical to copy.
	 * @return {Cylindrical} A reference to this cylindrical.
	 */
	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	/**
	 * Sets the cylindrical components from the given vector which is assumed to hold
	 * Cartesian coordinates.
	 *
	 * @param {Vector3} v - The vector to set.
	 * @return {Cylindrical} A reference to this cylindrical.
	 */
	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	/**
	 * Sets the cylindrical components from the given Cartesian coordinates.
	 *
	 * @param {number} x - The x value.
	 * @param {number} y - The x value.
	 * @param {number} z - The x value.
	 * @return {Cylindrical} A reference to this cylindrical.
	 */
	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	/**
	 * Returns a new cylindrical with copied values from this instance.
	 *
	 * @return {Cylindrical} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Represents a 2x2 matrix.
 *
 * A Note on Row-Major and Column-Major Ordering:
 *
 * The constructor and {@link Matrix2#set} method take arguments in
 * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
 * order, while internally they are stored in the {@link Matrix2#elements} array in column-major order.
 * This means that calling:
 * ```js
 * const m = new THREE.Matrix2();
 * m.set( 11, 12,
 *        21, 22 );
 * ```
 * will result in the elements array containing:
 * ```js
 * m.elements = [ 11, 21,
 *                12, 22 ];
 * ```
 * and internally all calculations are performed using column-major ordering.
 * However, as the actual ordering makes no difference mathematically and
 * most people are used to thinking about matrices in row-major order, the
 * three.js documentation shows matrices in row-major order. Just bear in
 * mind that if you are reading the source code, you'll have to take the
 * transpose of any matrices outlined here to make sense of the calculations.
 */
class Matrix2 {

	/**
	 * Constructs a new 2x2 matrix. The arguments are supposed to be
	 * in row-major order. If no arguments are provided, the constructor
	 * initializes the matrix as an identity matrix.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 */
	constructor( n11, n12, n21, n22 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Matrix2.prototype.isMatrix2 = true;

		/**
		 * A column-major list of matrix values.
		 *
		 * @type {Array<number>}
		 */
		this.elements = [
			1, 0,
			0, 1,
		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n21, n22 );

		}

	}

	/**
	 * Sets this matrix to the 2x2 identity matrix.
	 *
	 * @return {Matrix2} A reference to this matrix.
	 */
	identity() {

		this.set(
			1, 0,
			0, 1,
		);

		return this;

	}

	/**
	 * Sets the elements of the matrix from the given array.
	 *
	 * @param {Array<number>} array - The matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Matrix2} A reference to this matrix.
	 */
	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 4; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	/**
	 * Sets the elements of the matrix.The arguments are supposed to be
	 * in row-major order.
	 *
	 * @param {number} n11 - 1-1 matrix element.
	 * @param {number} n12 - 1-2 matrix element.
	 * @param {number} n21 - 2-1 matrix element.
	 * @param {number} n22 - 2-2 matrix element.
	 * @return {Matrix2} A reference to this matrix.
	 */
	set( n11, n12, n21, n22 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 2 ] = n12;
		te[ 1 ] = n21; te[ 3 ] = n22;

		return this;

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

/**
 * Represents an axis-aligned bounding box (AABB) in 2D space.
 */
class Box2 {

	/**
	 * Constructs a new bounding box.
	 *
	 * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
	 * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
	 */
	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBox2 = true;

		/**
		 * The lower boundary of the box.
		 *
		 * @type {Vector2}
		 */
		this.min = min;

		/**
		 * The upper boundary of the box.
		 *
		 * @type {Vector2}
		 */
		this.max = max;

	}

	/**
	 * Sets the lower and upper boundaries of this box.
	 * Please note that this method only copies the values from the given objects.
	 *
	 * @param {Vector2} min - The lower boundary of the box.
	 * @param {Vector2} max - The upper boundary of the box.
	 * @return {Box2} A reference to this bounding box.
	 */
	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given array.
	 *
	 * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
	 * @return {Box2} A reference to this bounding box.
	 */
	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	/**
	 * Centers this box on the given center vector and sets this box's width, height and
	 * depth to the given size values.
	 *
	 * @param {Vector2} center - The center of the box.
	 * @param {Vector2} size - The x and y dimensions of the box.
	 * @return {Box2} A reference to this bounding box.
	 */
	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	/**
	 * Returns a new box with copied values from this instance.
	 *
	 * @return {Box2} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given box to this instance.
	 *
	 * @param {Box2} box - The box to copy.
	 * @return {Box2} A reference to this bounding box.
	 */
	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	/**
	 * Makes this box empty which means in encloses a zero space in 2D.
	 *
	 * @return {Box2} A reference to this bounding box.
	 */
	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	/**
	 * Returns true if this box includes zero points within its bounds.
	 * Note that a box with equal lower and upper bounds still includes one
	 * point, the one both bounds share.
	 *
	 * @return {boolean} Whether this box is empty or not.
	 */
	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	/**
	 * Returns the center point of this box.
	 *
	 * @param {Vector2} target - The target vector that is used to store the method's result.
	 * @return {Vector2} The center point.
	 */
	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	/**
	 * Returns the dimensions of this box.
	 *
	 * @param {Vector2} target - The target vector that is used to store the method's result.
	 * @return {Vector2} The size.
	 */
	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	/**
	 * Expands the boundaries of this box to include the given point.
	 *
	 * @param {Vector2} point - The point that should be included by the bounding box.
	 * @return {Box2} A reference to this bounding box.
	 */
	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	/**
	 * Expands this box equilaterally by the given vector. The width of this
	 * box will be expanded by the x component of the vector in both
	 * directions. The height of this box will be expanded by the y component of
	 * the vector in both directions.
	 *
	 * @param {Vector2} vector - The vector that should expand the bounding box.
	 * @return {Box2} A reference to this bounding box.
	 */
	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	/**
	 * Expands each dimension of the box by the given scalar. If negative, the
	 * dimensions of the box will be contracted.
	 *
	 * @param {number} scalar - The scalar value that should expand the bounding box.
	 * @return {Box2} A reference to this bounding box.
	 */
	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	/**
	 * Returns `true` if the given point lies within or on the boundaries of this box.
	 *
	 * @param {Vector2} point - The point to test.
	 * @return {boolean} Whether the bounding box contains the given point or not.
	 */
	containsPoint( point ) {

		return point.x >= this.min.x && point.x <= this.max.x &&
			point.y >= this.min.y && point.y <= this.max.y;

	}

	/**
	 * Returns `true` if this bounding box includes the entirety of the given bounding box.
	 * If this box and the given one are identical, this function also returns `true`.
	 *
	 * @param {Box2} box - The bounding box to test.
	 * @return {boolean} Whether the bounding box contains the given bounding box or not.
	 */
	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	/**
	 * Returns a point as a proportion of this box's width and height.
	 *
	 * @param {Vector2} point - A point in 2D space.
	 * @param {Vector2} target - The target vector that is used to store the method's result.
	 * @return {Vector2} A point as a proportion of this box's width and height.
	 */
	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	/**
	 * Returns `true` if the given bounding box intersects with this bounding box.
	 *
	 * @param {Box2} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with this bounding box.
	 */
	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
			box.max.y >= this.min.y && box.min.y <= this.max.y;

	}

	/**
	 * Clamps the given point within the bounds of this box.
	 *
	 * @param {Vector2} point - The point to clamp.
	 * @param {Vector2} target - The target vector that is used to store the method's result.
	 * @return {Vector2} The clamped point.
	 */
	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	/**
	 * Returns the euclidean distance from any edge of this box to the specified point. If
	 * the given point lies inside of this box, the distance will be `0`.
	 *
	 * @param {Vector2} point - The point to compute the distance to.
	 * @return {number} The euclidean distance.
	 */
	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$4 ).distanceTo( point );

	}

	/**
	 * Computes the intersection of this bounding box and the given one, setting the upper
	 * bound of this box to the lesser of the two boxes' upper bounds and the
	 * lower bound of this box to the greater of the two boxes' lower bounds. If
	 * there's no overlap, makes this box empty.
	 *
	 * @param {Box2} box - The bounding box to intersect with.
	 * @return {Box2} A reference to this bounding box.
	 */
	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	/**
	 * Computes the union of this box and another and the given one, setting the upper
	 * bound of this box to the greater of the two boxes' upper bounds and the
	 * lower bound of this box to the lesser of the two boxes' lower bounds.
	 *
	 * @param {Box2} box - The bounding box that will be unioned with this instance.
	 * @return {Box2} A reference to this bounding box.
	 */
	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	/**
	 * Adds the given offset to both the upper and lower bounds of this bounding box,
	 * effectively moving it in 2D space.
	 *
	 * @param {Vector2} offset - The offset that should be used to translate the bounding box.
	 * @return {Box2} A reference to this bounding box.
	 */
	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	/**
	 * Returns `true` if this bounding box is equal with the given one.
	 *
	 * @param {Box2} box - The box to test for equality.
	 * @return {boolean} Whether this bounding box is equal with the given one.
	 */
	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

/**
 * An analytical line segment in 3D space represented by a start and end point.
 */
class Line3 {

	/**
	 * Constructs a new line segment.
	 *
	 * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
	 * @param {Vector3} [end=(0,0,0)] - End of the line segment.
	 */
	constructor( start = new Vector3(), end = new Vector3() ) {

		/**
		 * Start of the line segment.
		 *
		 * @type {Vector3}
		 */
		this.start = start;

		/**
		 * End of the line segment.
		 *
		 * @type {Vector3}
		 */
		this.end = end;

	}

	/**
	 * Sets the start and end values by copying the given vectors.
	 *
	 * @param {Vector3} start - The start point.
	 * @param {Vector3} end - The end point.
	 * @return {Line3} A reference to this line segment.
	 */
	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	/**
	 * Copies the values of the given line segment to this instance.
	 *
	 * @param {Line3} line - The line segment to copy.
	 * @return {Line3} A reference to this line segment.
	 */
	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	/**
	 * Returns the center of the line segment.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The center point.
	 */
	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	/**
	 * Returns the delta vector of the line segment's start and end point.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The delta vector.
	 */
	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	/**
	 * Returns the squared Euclidean distance between the line' start and end point.
	 *
	 * @return {number} The squared Euclidean distance.
	 */
	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	/**
	 * Returns the Euclidean distance between the line' start and end point.
	 *
	 * @return {number} The Euclidean distance.
	 */
	distance() {

		return this.start.distanceTo( this.end );

	}

	/**
	 * Returns a vector at a certain position along the line segment.
	 *
	 * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The delta vector.
	 */
	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	/**
	 * Returns a point parameter based on the closest point as projected on the line segment.
	 *
	 * @param {Vector3} point - The point for which to return a point parameter.
	 * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
	 * @return {number} The point parameter.
	 */
	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	/**
	 * Returns the closets point on the line for a given point.
	 *
	 * @param {Vector3} point - The point to compute the closest point on the line for.
	 * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
	 * @param {Vector3} target -  The target vector that is used to store the method's result.
	 * @return {Vector3} The closest point on the line.
	 */
	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	/**
	 * Applies a 4x4 transformation matrix to this line segment.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @return {Line3} A reference to this line segment.
	 */
	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	/**
	 * Returns `true` if this line segment is equal with the given one.
	 *
	 * @param {Line3} line - The line segment to test for equality.
	 * @return {boolean} Whether this line segment is equal with the given one.
	 */
	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	/**
	 * Returns a new line segment with copied values from this instance.
	 *
	 * @return {Line3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

/**
 * This displays a cone shaped helper object for a {@link SpotLight}.
 *
 * ```js
 * const spotLight = new THREE.SpotLight( 0xffffff );
 * spotLight.position.set( 10, 10, 10 );
 * scene.add( spotLight );
 *
 * const spotLightHelper = new THREE.SpotLightHelper( spotLight );
 * scene.add( spotLightHelper );
 * ```
 *
 * @augments Object3D
 */
class SpotLightHelper extends Object3D {

	/**
	 * Constructs a new spot light helper.
	 *
	 * @param {HemisphereLight} light - The light to be visualized.
	 * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
	 * the color of the light.
	 */
	constructor( light, color ) {

		super();

		/**
		 * The light being visualized.
		 *
		 * @type {SpotLight}
		 */
		this.light = light;

		this.matrixAutoUpdate = false;

		/**
		 * The color parameter passed in the constructor.
		 * If not set, the helper will take the color of the light.
		 *
		 * @type {number|Color|string}
		 */
		this.color = color;

		this.type = 'SpotLightHelper';

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	-1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, -1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	/**
	 * Updates the helper to match the position and direction of the
	 * light being visualized.
	 */
	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		// update the local matrix based on the parent and light target transforms
		if ( this.parent ) {

			this.parent.updateWorldMatrix( true );

			this.matrix
				.copy( this.parent.matrixWorld )
				.invert()
				.multiply( this.light.matrixWorld );

		} else {

			this.matrix.copy( this.light.matrixWorld );

		}

		this.matrixWorld.copy( this.light.matrixWorld );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();

/**
 * A helper object to assist with visualizing a {@link Skeleton}.
 *
 * ```js
 * const helper = new THREE.SkeletonHelper( skinnedMesh );
 * scene.add( helper );
 * ```
 *
 * @augments LineSegments
 */
class SkeletonHelper extends LineSegments {

	/**
	 * Constructs a new hemisphere light helper.
	 *
	 * @param {Object3D} object -  Usually an instance of {@link SkinnedMesh}. However, any 3D object
	 * can be used if it represents a hierarchy of bones (see {@link Bone}).
	 */
	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSkeletonHelper = true;

		this.type = 'SkeletonHelper';

		/**
		 * The object being visualized.
		 *
		 * @type {Object3D}
		 */
		this.root = object;

		/**
		 * he list of bones that the helper visualizes.
		 *
		 * @type {Array<Bone>}
		 */
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object.isBone === true ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push( ...getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

/**
 * This displays a helper object consisting of a spherical mesh for
 * visualizing an instance of {@link PointLight}.
 *
 * ```js
 * const pointLight = new THREE.PointLight( 0xff0000, 1, 100 );
 * pointLight.position.set( 10, 10, 10 );
 * scene.add( pointLight );
 *
 * const sphereSize = 1;
 * const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
 * scene.add( pointLightHelper );
 * ```
 *
 * @augments Mesh
 */
class PointLightHelper extends Mesh {

	/**
	 * Constructs a new point light helper.
	 *
	 * @param {PointLight} light - The light to be visualized.
	 * @param {number} [sphereSize=1] - The size of the sphere helper.
	 * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
	 * the color of the light.
	 */
	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		/**
		 * The light being visualized.
		 *
		 * @type {HemisphereLight}
		 */
		this.light = light;

		/**
		 * The color parameter passed in the constructor.
		 * If not set, the helper will take the color of the light.
		 *
		 * @type {number|Color|string}
		 */
		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	/**
	 * Updates the helper to match the position of the
	 * light being visualized.
	 */
	update() {

		this.light.updateWorldMatrix( true, false );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

/**
 * Creates a visual aid consisting of a spherical mesh for a
 * given {@link HemisphereLight}.
 *
 * ```js
 * const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
 * const helper = new THREE.HemisphereLightHelper( light, 5 );
 * scene.add( helper );
 * ```
 *
 * @augments Object3D
 */
class HemisphereLightHelper extends Object3D {

	/**
	 * Constructs a new hemisphere light helper.
	 *
	 * @param {HemisphereLight} light - The light to be visualized.
	 * @param {number} [size=1] - The size of the mesh used to visualize the light.
	 * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
	 * the color of the light.
	 */
	constructor( light, size, color ) {

		super();

		/**
		 * The light being visualized.
		 *
		 * @type {HemisphereLight}
		 */
		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		/**
		 * The color parameter passed in the constructor.
		 * If not set, the helper will take the color of the light.
		 *
		 * @type {number|Color|string}
		 */
		this.color = color;

		this.type = 'HemisphereLightHelper';

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	/**
	 * Updates the helper to match the position and direction of the
	 * light being visualized.
	 */
	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		this.light.updateWorldMatrix( true, false );

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

/**
 * The helper is an object to define grids. Grids are two-dimensional
 * arrays of lines.
 *
 * ```js
 * const size = 10;
 * const divisions = 10;
 *
 * const gridHelper = new THREE.GridHelper( size, divisions );
 * scene.add( gridHelper );
 * ```
 *
 * @augments LineSegments
 */
class GridHelper extends LineSegments {

	/**
	 * Constructs a new grid helper.
	 *
	 * @param {number} [size=10] - The size of the grid.
	 * @param {number} [divisions=10] - The number of divisions across the grid.
	 * @param {number|Color|string} [color1=0x444444] - The color of the center line.
	 * @param {number|Color|string} [color2=0x888888] - The color of the lines of the grid.
	 */
	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

/**
 * This helper is an object to define polar grids. Grids are
 * two-dimensional arrays of lines.
 *
 * ```js
 * const radius = 10;
 * const sectors = 16;
 * const rings = 8;
 * const divisions = 64;
 *
 * const helper = new THREE.PolarGridHelper( radius, sectors, rings, divisions );
 * scene.add( helper );
 * ```
 *
 * @augments LineSegments
 */
class PolarGridHelper extends LineSegments {

	/**
	 * Constructs a new polar grid helper.
	 *
	 * @param {number} [radius=10] - The radius of the polar grid. This can be any positive number.
	 * @param {number} [sectors=16] - The number of sectors the grid will be divided into. This can be any positive integer.
	 * @param {number} [rings=16] - The number of rings. This can be any positive integer.
	 * @param {number} [divisions=64] - The number of line segments used for each circle. This can be any positive integer.
	 * @param {number|Color|string} [color1=0x444444] - The first color used for grid elements.
	 * @param {number|Color|string} [color2=0x888888] -  The second color used for grid elements.
	 */
	constructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the sectors

		if ( sectors > 1 ) {

			for ( let i = 0; i < sectors; i ++ ) {

				const v = ( i / sectors ) * ( Math.PI * 2 );

				const x = Math.sin( v ) * radius;
				const z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				const color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

		}

		// create the rings

		for ( let i = 0; i < rings; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / rings * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

/**
 * Helper object to assist with visualizing a {@link DirectionalLight}'s
 * effect on the scene. This consists of plane and a line representing the
 * light's position and direction.
 *
 * ```js
 * const light = new THREE.DirectionalLight( 0xFFFFFF );
 * scene.add( light );
 *
 * const helper = new THREE.DirectionalLightHelper( light, 5 );
 * scene.add( helper );
 * ```
 *
 * @augments Object3D
 */
class DirectionalLightHelper extends Object3D {

	/**
	 * Constructs a new directional light helper.
	 *
	 * @param {DirectionalLight} light - The light to be visualized.
	 * @param {number} [size=1] - The dimensions of the plane.
	 * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
	 * the color of the light.
	 */
	constructor( light, size, color ) {

		super();

		/**
		 * The light being visualized.
		 *
		 * @type {DirectionalLight}
		 */
		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		/**
		 * The color parameter passed in the constructor.
		 * If not set, the helper will take the color of the light.
		 *
		 * @type {number|Color|string}
		 */
		this.color = color;

		this.type = 'DirectionalLightHelper';

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		/**
		 * Contains the line showing the location of the directional light.
		 *
		 * @type {Line}
		 */
		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		/**
		 * Represents the target line of the directional light.
		 *
		 * @type {Line}
		 */
		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	/**
	 * Updates the helper to match the position and direction of the
	 * light being visualized.
	 */
	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 * This helps with visualizing what a camera contains in its frustum. It
 * visualizes the frustum of a camera using a line segments.
 *
 * Based on frustum visualization in [lightgl.js shadowmap example]{@link https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html}.
 *
 * `CameraHelper` must be a child of the scene.
 *
 * ```js
 * const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
 * const helper = new THREE.CameraHelper( camera );
 * scene.add( helper );
 * ```
 *
 * @augments LineSegments
 */
class CameraHelper extends LineSegments {

	/**
	 * Constructs a new arrow helper.
	 *
	 * @param {Camera} camera - The camera to visualize.
	 */
	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// near

		addLine( 'n1', 'n2' );
		addLine( 'n2', 'n4' );
		addLine( 'n4', 'n3' );
		addLine( 'n3', 'n1' );

		// far

		addLine( 'f1', 'f2' );
		addLine( 'f2', 'f4' );
		addLine( 'f4', 'f3' );
		addLine( 'f3', 'f1' );

		// sides

		addLine( 'n1', 'f1' );
		addLine( 'n2', 'f2' );
		addLine( 'n3', 'f3' );
		addLine( 'n4', 'f4' );

		// cone

		addLine( 'p', 'n1' );
		addLine( 'p', 'n2' );
		addLine( 'p', 'n3' );
		addLine( 'p', 'n4' );

		// up

		addLine( 'u1', 'u2' );
		addLine( 'u2', 'u3' );
		addLine( 'u3', 'u1' );

		// target

		addLine( 'c', 't' );
		addLine( 'p', 'c' );

		// cross

		addLine( 'cn1', 'cn2' );
		addLine( 'cn3', 'cn4' );

		addLine( 'cf1', 'cf2' );
		addLine( 'cf3', 'cf4' );

		function addLine( a, b ) {

			addPoint( a );
			addPoint( b );

		}

		function addPoint( id ) {

			vertices.push( 0, 0, 0 );
			colors.push( 0, 0, 0 );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		/**
		 * The camera being visualized.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		/**
		 * This contains the points used to visualize the camera.
		 *
		 * @type {Object<string,Array<number>>}
		 */
		this.pointMap = pointMap;

		this.update();

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		this.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );

	}

	/**
	 * Defines the colors of the helper.
	 *
	 * @param {Color} frustum - The frustum line color.
	 * @param {Color} cone - The cone line color.
	 * @param {Color} up - The up line color.
	 * @param {Color} target - The target line color.
	 * @param {Color} cross - The cross line color.
	 */
	setColors( frustum, cone, up, target, cross ) {

		const geometry = this.geometry;

		const colorAttribute = geometry.getAttribute( 'color' );

		// near

		colorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2
		colorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4
		colorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3
		colorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1

		// far

		colorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2
		colorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4
		colorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3
		colorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1

		// sides

		colorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1
		colorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2
		colorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3
		colorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4

		// cone

		colorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1
		colorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2
		colorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3
		colorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4

		// up

		colorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2
		colorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3
		colorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1

		// target

		colorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t
		colorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c

		// cross

		colorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2
		colorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4

		colorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2
		colorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4

		colorAttribute.needsUpdate = true;

	}

	/**
	 * Updates the helper based on the projection matrix of the camera.
	 */
	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// Adjust z values based on coordinate system
		const nearZ = this.camera.coordinateSystem === WebGLCoordinateSystem ? -1 : 0;

		// center / target
		setPoint( 'c', pointMap, geometry, _camera, 0, 0, nearZ );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, -1, -1, nearZ );
		setPoint( 'n2', pointMap, geometry, _camera, w, -1, nearZ );
		setPoint( 'n3', pointMap, geometry, _camera, -1, h, nearZ );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, nearZ );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, -1, -1, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, -1, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, -1, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ );
		setPoint( 'u2', pointMap, geometry, _camera, -1 * 0.7, h * 1.1, nearZ );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, nearZ );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, -1, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, -1, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, -1, 0, nearZ );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, nearZ );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, -1, nearZ );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, nearZ );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

/**
 * Helper object to graphically show the world-axis-aligned bounding box
 * around an object. The actual bounding box is handled with {@link Box3},
 * this is just a visual helper for debugging. It can be automatically
 * resized with {@link BoxHelper#update} when the object it's created from
 * is transformed. Note that the object must have a geometry for this to work,
 * so it won't work with sprites.
 *
 * ```js
 * const sphere = new THREE.SphereGeometry();
 * const object = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( 0xff0000 ) );
 * const box = new THREE.BoxHelper( object, 0xffff00 );
 * scene.add( box );
 * ```
 *
 * @augments LineSegments
 */
class BoxHelper extends LineSegments {

	/**
	 * Constructs a new box helper.
	 *
	 * @param {Object3D} [object] - The 3D object to show the world-axis-aligned bounding box.
	 * @param {number|Color|string} [color=0xffff00] - The box's color.
	 */
	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		/**
		 * The 3D object being visualized.
		 *
		 * @type {Object3D}
		 */
		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	/**
	 * Updates the helper's geometry to match the dimensions of the object,
	 * including any children.
	 */
	update() {

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

	/**
	 * Updates the wireframe box for the passed object.
	 *
	 * @param {Object3D} object - The 3D object to create the helper for.
	 * @return {BoxHelper} A reference to this instance.
	 */
	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.object = source.object;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

/**
 * A helper object to visualize an instance of {@link Box3}.
 *
 * ```js
 * const box = new THREE.Box3();
 * box.setFromCenterAndSize( new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 2, 1, 3 ) );
 *
 * const helper = new THREE.Box3Helper( box, 0xffff00 );
 * scene.add( helper )
 * ```
 *
 * @augments LineSegments
 */
class Box3Helper extends LineSegments {

	/**
	 * Constructs a new box3 helper.
	 *
	 * @param {Box3} box - The box to visualize.
	 * @param {number|Color|string} [color=0xffff00] - The box's color.
	 */
	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		/**
		 * The box being visualized.
		 *
		 * @type {Box3}
		 */
		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

/**
 * A helper object to visualize an instance of {@link Plane}.
 *
 * ```js
 * const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
 * const helper = new THREE.PlaneHelper( plane, 1, 0xffff00 );
 * scene.add( helper );
 * ```
 *
 * @augments Line
 */
class PlaneHelper extends Line {

	/**
	 * Constructs a new plane helper.
	 *
	 * @param {Plane} plane - The plane to be visualized.
	 * @param {number} [size=1] - The side length of plane helper.
	 * @param {number|Color|string} [hex=0xffff00] - The helper's color.
	 */
	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		/**
		 * The plane being visualized.
		 *
		 * @type {Plane}
		 */
		this.plane = plane;

		/**
		 * The side length of plane helper.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.size = size;

		const positions2 = [ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		this.position.set( 0, 0, 0 );

		this.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );

		this.lookAt( this.plane.normal );

		this.translateZ( - this.plane.constant );

		super.updateMatrixWorld( force );

	}

	/**
	 * Updates the helper to match the position and direction of the
	 * light being visualized.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

/**
 * An 3D arrow object for visualizing directions.
 *
 * ```js
 * const dir = new THREE.Vector3( 1, 2, 0 );
 *
 * //normalize the direction vector (convert to vector of length 1)
 * dir.normalize();
 *
 * const origin = new THREE.Vector3( 0, 0, 0 );
 * const length = 1;
 * const hex = 0xffff00;
 *
 * const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
 * scene.add( arrowHelper );
 * ```
 *
 * @augments Object3D
 */
class ArrowHelper extends Object3D {

	/**
	 * Constructs a new arrow helper.
	 *
	 * @param {Vector3} [dir=(0, 0, 1)] - The (normalized) direction vector.
	 * @param {Vector3} [origin=(0, 0, 0)] - Point at which the arrow starts.
	 * @param {number} [length=1] - Length of the arrow in world units.
	 * @param {(number|Color|string)} [color=0xffff00] - Color of the arrow.
	 * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
	 * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
	 */
	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new ConeGeometry( 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, -0.5, 0 );

		}

		this.position.copy( origin );

		/**
		 * The line part of the arrow helper.
		 *
		 * @type {Line}
		 */
		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		/**
		 * The cone part of the arrow helper.
		 *
		 * @type {Mesh}
		 */
		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	/**
	 * Sets the direction of the helper.
	 *
	 * @param {Vector3} dir - The normalized direction vector.
	 */
	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < -0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	/**
	 * Sets the length of the helper.
	 *
	 * @param {number} length - Length of the arrow in world units.
	 * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
	 * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
	 */
	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	/**
	 * Sets the color of the helper.
	 *
	 * @param {number|Color|string} color - The color to set.
	 */
	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.line.geometry.dispose();
		this.line.material.dispose();
		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

}

/**
 * An axis object to visualize the 3 axes in a simple way.
 * The X axis is red. The Y axis is green. The Z axis is blue.
 *
 * ```js
 * const axesHelper = new THREE.AxesHelper( 5 );
 * scene.add( axesHelper );
 * ```
 *
 * @augments LineSegments
 */
class AxesHelper extends LineSegments {

	/**
	 * Constructs a new axes helper.
	 *
	 * @param {number} [size=1] - Size of the lines representing the axes.
	 */
	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	/**
	 * Defines the colors of the axes helper.
	 *
	 * @param {number|Color|string} xAxisColor - The color for the x axis.
	 * @param {number|Color|string} yAxisColor - The color for the y axis.
	 * @param {number|Color|string} zAxisColor - The color for the z axis.
	 * @return {AxesHelper} A reference to this axes helper.
	 */
	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

/**
 * This class is used to convert a series of paths to an array of
 * shapes. It is specifically used in context of fonts and SVG.
 */
class ShapePath {

	/**
	 * Constructs a new shape path.
	 */
	constructor() {

		this.type = 'ShapePath';

		/**
		 * The color of the shape.
		 *
		 * @type {Color}
		 */
		this.color = new Color();

		/**
		 * The paths that have been generated for this shape.
		 *
		 * @type {Array<Path>}
		 * @default null
		 */
		this.subPaths = [];

		/**
		 * The current path that is being generated.
		 *
		 * @type {?Path}
		 * @default null
		 */
		this.currentPath = null;

	}

	/**
	 * Creates a new path and moves it current point to the given one.
	 *
	 * @param {number} x - The x coordinate.
	 * @param {number} y - The y coordinate.
	 * @return {ShapePath} A reference to this shape path.
	 */
	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	/**
	 * Adds an instance of {@link LineCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} x - The x coordinate of the end point.
	 * @param {number} y - The y coordinate of the end point.
	 * @return {ShapePath} A reference to this shape path.
	 */
	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	/**
	 * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} aCPx - The x coordinate of the control point.
	 * @param {number} aCPy - The y coordinate of the control point.
	 * @param {number} aX - The x coordinate of the end point.
	 * @param {number} aY - The y coordinate of the end point.
	 * @return {ShapePath} A reference to this shape path.
	 */
	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	/**
	 * Adds an instance of {@link CubicBezierCurve} to the path by connecting
	 * the current point with the given one.
	 *
	 * @param {number} aCP1x - The x coordinate of the first control point.
	 * @param {number} aCP1y - The y coordinate of the first control point.
	 * @param {number} aCP2x - The x coordinate of the second control point.
	 * @param {number} aCP2y - The y coordinate of the second control point.
	 * @param {number} aX - The x coordinate of the end point.
	 * @param {number} aY - The y coordinate of the end point.
	 * @return {ShapePath} A reference to this shape path.
	 */
	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	/**
	 * Adds an instance of {@link SplineCurve} to the path by connecting
	 * the current point with the given list of points.
	 *
	 * @param {Array<Vector2>} pts - An array of points in 2D space.
	 * @return {ShapePath} A reference to this shape path.
	 */
	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	/**
	 * Converts the paths into an array of shapes.
	 *
	 * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
	 * If this flag is set to `true`, then those are flipped.
	 * @return {Array<Shape>} An array of shapes.
	 */
	toShapes( isCCW ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			let toChange = 0;

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange ++;

							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}

			if ( toChange > 0 && ambiguous === false ) {

				newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

/**
 * Abstract base class for controls.
 *
 * @abstract
 * @augments EventDispatcher
 */
class Controls extends EventDispatcher {

	/**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
	 */
	constructor( object, domElement = null ) {

		super();

		/**
		 * The object that is managed by the controls.
		 *
		 * @type {Object3D}
		 */
		this.object = object;

		/**
		 * The HTML element used for event listeners.
		 *
		 * @type {?HTMLDOMElement}
		 * @default null
		 */
		this.domElement = domElement;

		/**
		 * Whether the controls responds to user input or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enabled = true;

		/**
		 * The internal state of the controls.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.state = -1;

		/**
		 * This object defines the keyboard input of the controls.
		 *
		 * @type {Object}
		 */
		this.keys = {};

		/**
		 * This object defines what type of actions are assigned to the available mouse buttons.
		 * It depends on the control implementation what kind of mouse buttons and actions are supported.
		 *
		 * @type {{LEFT: ?number, MIDDLE: ?number, RIGHT: ?number}}
		 */
		this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };

		/**
		 * This object defines what type of actions are assigned to what kind of touch interaction.
		 * It depends on the control implementation what kind of touch interaction and actions are supported.
		 *
		 * @type {{ONE: ?number, TWO: ?number}}
		 */
		this.touches = { ONE: null, TWO: null };

	}

	/**
	 * Connects the controls to the DOM. This method has so called "side effects" since
	 * it adds the module's event listeners to the DOM.
	 *
	 * @param {HTMLDOMElement} element - The DOM element to connect to.
	 */
	connect( element ) {

		if ( element === undefined ) {

			console.warn( 'THREE.Controls: connect() now requires an element.' ); // @deprecated, the warning can be removed with r185
			return;

		}

		if ( this.domElement !== null ) this.disconnect();

		this.domElement = element;

	}

	/**
	 * Disconnects the controls from the DOM.
	 */
	disconnect() {}

	/**
	 * Call this method if you no longer want use to the controls. It frees all internal
	 * resources and removes all event listeners.
	 */
	dispose() {}

	/**
	 * Controls should implement this method if they have to update their internal state
	 * per simulation step.
	 *
	 * @param {number} [delta] - The time delta in seconds.
	 */
	update( /* delta */ ) {}

}

/**
 * Scales the texture as large as possible within its surface without cropping
 * or stretching the texture. The method preserves the original aspect ratio of
 * the texture. Akin to CSS `object-fit: contain`
 *
 * @param {Texture} texture - The texture.
 * @param {number} aspect - The texture's aspect ratio.
 * @return {Texture} The updated texture.
 */
function contain( texture, aspect ) {

	const imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;

	if ( imageAspect > aspect ) {

		texture.repeat.x = 1;
		texture.repeat.y = imageAspect / aspect;

		texture.offset.x = 0;
		texture.offset.y = ( 1 - texture.repeat.y ) / 2;

	} else {

		texture.repeat.x = aspect / imageAspect;
		texture.repeat.y = 1;

		texture.offset.x = ( 1 - texture.repeat.x ) / 2;
		texture.offset.y = 0;

	}

	return texture;

}

/**
 * Scales the texture to the smallest possible size to fill the surface, leaving
 * no empty space. The method preserves the original aspect ratio of the texture.
 * Akin to CSS `object-fit: cover`.
 *
 * @param {Texture} texture - The texture.
 * @param {number} aspect - The texture's aspect ratio.
 * @return {Texture} The updated texture.
 */
function cover( texture, aspect ) {

	const imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;

	if ( imageAspect > aspect ) {

		texture.repeat.x = aspect / imageAspect;
		texture.repeat.y = 1;

		texture.offset.x = ( 1 - texture.repeat.x ) / 2;
		texture.offset.y = 0;

	} else {

		texture.repeat.x = 1;
		texture.repeat.y = imageAspect / aspect;

		texture.offset.x = 0;
		texture.offset.y = ( 1 - texture.repeat.y ) / 2;

	}

	return texture;

}

/**
 * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
 *
 * @param {Texture} texture - The texture.
 * @return {Texture} The updated texture.
 */
function fill( texture ) {

	texture.repeat.x = 1;
	texture.repeat.y = 1;

	texture.offset.x = 0;
	texture.offset.y = 0;

	return texture;

}

/**
 * Determines how many bytes must be used to represent the texture.
 *
 * @param {number} width - The width of the texture.
 * @param {number} height - The height of the texture.
 * @param {number} format - The texture's format.
 * @param {number} type - The texture's type.
 * @return {number} The byte length.
 */
function getByteLength( width, height, format, type ) {

	const typeByteLength = getTextureTypeByteLength( type );

	switch ( format ) {

		// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
		case AlphaFormat:
			return width * height;
		case RedFormat:
			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RedIntegerFormat:
			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGFormat:
			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGIntegerFormat:
			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBFormat:
			return ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBAFormat:
			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBAIntegerFormat:
			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
		case RGB_S3TC_DXT1_Format:
		case RGBA_S3TC_DXT1_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
		case RGBA_S3TC_DXT3_Format:
		case RGBA_S3TC_DXT5_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
		case RGB_PVRTC_2BPPV1_Format:
		case RGBA_PVRTC_2BPPV1_Format:
			return ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;
		case RGB_PVRTC_4BPPV1_Format:
		case RGBA_PVRTC_4BPPV1_Format:
			return ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
		case RGB_ETC1_Format:
		case RGB_ETC2_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
		case RGBA_ETC2_EAC_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
		case RGBA_ASTC_4x4_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
		case RGBA_ASTC_5x4_Format:
			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
		case RGBA_ASTC_5x5_Format:
			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_6x5_Format:
			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_6x6_Format:
			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_8x5_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_8x6_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_8x8_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
		case RGBA_ASTC_10x5_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_10x6_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_10x8_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
		case RGBA_ASTC_10x10_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
		case RGBA_ASTC_12x10_Format:
			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
		case RGBA_ASTC_12x12_Format:
			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;

		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
		case RGBA_BPTC_Format:
		case RGB_BPTC_SIGNED_Format:
		case RGB_BPTC_UNSIGNED_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
		case RED_RGTC1_Format:
		case SIGNED_RED_RGTC1_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;
		case RED_GREEN_RGTC2_Format:
		case SIGNED_RED_GREEN_RGTC2_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

	}

	throw new Error(
		`Unable to determine texture byte length for ${format} format.`,
	);

}

function getTextureTypeByteLength( type ) {

	switch ( type ) {

		case UnsignedByteType:
		case ByteType:
			return { byteLength: 1, components: 1 };
		case UnsignedShortType:
		case ShortType:
		case HalfFloatType:
			return { byteLength: 2, components: 1 };
		case UnsignedShort4444Type:
		case UnsignedShort5551Type:
			return { byteLength: 2, components: 4 };
		case UnsignedIntType:
		case IntType:
		case FloatType:
			return { byteLength: 4, components: 1 };
		case UnsignedInt5999Type:
			return { byteLength: 4, components: 3 };

	}

	throw new Error( `Unknown texture type ${type}.` );

}

/**
 * A class containing utility functions for textures.
 *
 * @hideconstructor
 */
class TextureUtils {

	/**
	 * Scales the texture as large as possible within its surface without cropping
	 * or stretching the texture. The method preserves the original aspect ratio of
	 * the texture. Akin to CSS `object-fit: contain`
	 *
	 * @param {Texture} texture - The texture.
	 * @param {number} aspect - The texture's aspect ratio.
	 * @return {Texture} The updated texture.
	 */
	static contain( texture, aspect ) {

		return contain( texture, aspect );

	}

	/**
	 * Scales the texture to the smallest possible size to fill the surface, leaving
	 * no empty space. The method preserves the original aspect ratio of the texture.
	 * Akin to CSS `object-fit: cover`.
	 *
	 * @param {Texture} texture - The texture.
	 * @param {number} aspect - The texture's aspect ratio.
	 * @return {Texture} The updated texture.
	 */
	static cover( texture, aspect ) {

		return cover( texture, aspect );

	}

	/**
	 * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
	 *
	 * @param {Texture} texture - The texture.
	 * @return {Texture} The updated texture.
	 */
	static fill( texture ) {

		return fill( texture );

	}

	/**
	 * Determines how many bytes must be used to represent the texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} format - The texture's format.
	 * @param {number} type - The texture's type.
	 * @return {number} The byte length.
	 */
	static getByteLength( width, height, format, type ) {

		return getByteLength( width, height, format, type );

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

export { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthArrayTexture, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, FrustumArray, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InterpolationSamplingMode, InterpolationSamplingType, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RAD2DEG, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RenderTarget3D, RenderTargetArray, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TextureUtils, TimestampQuery, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLRenderTarget, WebGPUCoordinateSystem, WebXRController, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, arrayNeedsUint32, cloneUniforms, createCanvasElement, createElementNS, getByteLength, getUnlitUniformColorSpace, mergeUniforms, probeAsync, toNormalizedProjectionMatrix, toReversedProjectionMatrix, warnOnce };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWUuY29yZS5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyIsIi4uL3NyYy9tYXRoL01hdGhVdGlscy5qcyIsIi4uL3NyYy9tYXRoL1ZlY3RvcjIuanMiLCIuLi9zcmMvbWF0aC9NYXRyaXgzLmpzIiwiLi4vc3JjL3V0aWxzLmpzIiwiLi4vc3JjL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzIiwiLi4vc3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzIiwiLi4vc3JjL3RleHR1cmVzL1NvdXJjZS5qcyIsIi4uL3NyYy90ZXh0dXJlcy9UZXh0dXJlLmpzIiwiLi4vc3JjL21hdGgvVmVjdG9yNC5qcyIsIi4uL3NyYy9jb3JlL1JlbmRlclRhcmdldC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanMiLCIuLi9zcmMvdGV4dHVyZXMvRGF0YUFycmF5VGV4dHVyZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvV2ViR0xBcnJheVJlbmRlclRhcmdldC5qcyIsIi4uL3NyYy90ZXh0dXJlcy9EYXRhM0RUZXh0dXJlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9XZWJHTDNEUmVuZGVyVGFyZ2V0LmpzIiwiLi4vc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIi4uL3NyYy9tYXRoL1ZlY3RvcjMuanMiLCIuLi9zcmMvbWF0aC9Cb3gzLmpzIiwiLi4vc3JjL21hdGgvU3BoZXJlLmpzIiwiLi4vc3JjL21hdGgvUmF5LmpzIiwiLi4vc3JjL21hdGgvTWF0cml4NC5qcyIsIi4uL3NyYy9tYXRoL0V1bGVyLmpzIiwiLi4vc3JjL2NvcmUvTGF5ZXJzLmpzIiwiLi4vc3JjL2NvcmUvT2JqZWN0M0QuanMiLCIuLi9zcmMvbWF0aC9UcmlhbmdsZS5qcyIsIi4uL3NyYy9tYXRoL0NvbG9yLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanMiLCIuLi9zcmMvZXh0cmFzL0RhdGFVdGlscy5qcyIsIi4uL3NyYy9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzIiwiLi4vc3JjL29iamVjdHMvTWVzaC5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdF92ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0X2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzIiwiLi4vc3JjL2NhbWVyYXMvQ2FtZXJhLmpzIiwiLi4vc3JjL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMiLCIuLi9zcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzIiwiLi4vc3JjL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9XZWJHTEN1YmVSZW5kZXJUYXJnZXQuanMiLCIuLi9zcmMvb2JqZWN0cy9Hcm91cC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2VieHIvV2ViWFJDb250cm9sbGVyLmpzIiwiLi4vc3JjL3NjZW5lcy9Gb2dFeHAyLmpzIiwiLi4vc3JjL3NjZW5lcy9Gb2cuanMiLCIuLi9zcmMvc2NlbmVzL1NjZW5lLmpzIiwiLi4vc3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMiLCIuLi9zcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanMiLCIuLi9zcmMvb2JqZWN0cy9TcHJpdGUuanMiLCIuLi9zcmMvb2JqZWN0cy9MT0QuanMiLCIuLi9zcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qcyIsIi4uL3NyYy9vYmplY3RzL0JvbmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanMiLCIuLi9zcmMvb2JqZWN0cy9Ta2VsZXRvbi5qcyIsIi4uL3NyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9vYmplY3RzL0luc3RhbmNlZE1lc2guanMiLCIuLi9zcmMvbWF0aC9QbGFuZS5qcyIsIi4uL3NyYy9tYXRoL0ZydXN0dW0uanMiLCIuLi9zcmMvbWF0aC9GcnVzdHVtQXJyYXkuanMiLCIuLi9zcmMvb2JqZWN0cy9CYXRjaGVkTWVzaC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMiLCIuLi9zcmMvb2JqZWN0cy9MaW5lLmpzIiwiLi4vc3JjL29iamVjdHMvTGluZVNlZ21lbnRzLmpzIiwiLi4vc3JjL29iamVjdHMvTGluZUxvb3AuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzIiwiLi4vc3JjL29iamVjdHMvUG9pbnRzLmpzIiwiLi4vc3JjL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qcyIsIi4uL3NyYy90ZXh0dXJlcy9WaWRlb0ZyYW1lVGV4dHVyZS5qcyIsIi4uL3NyYy90ZXh0dXJlcy9GcmFtZWJ1ZmZlclRleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvQ29tcHJlc3NlZFRleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvQ29tcHJlc3NlZEFycmF5VGV4dHVyZS5qcyIsIi4uL3NyYy90ZXh0dXJlcy9Db21wcmVzc2VkQ3ViZVRleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qcyIsIi4uL3NyYy90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvRGVwdGhBcnJheVRleHR1cmUuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9DYXBzdWxlR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9Db25lR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0VkZ2VzR2VvbWV0cnkuanMiLCIuLi9zcmMvZXh0cmFzL2NvcmUvQ3VydmUuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0NhdG11bGxSb21DdXJ2ZTMuanMiLCIuLi9zcmMvZXh0cmFzL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzIiwiLi4vc3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzIiwiLi4vc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanMiLCIuLi9zcmMvZXh0cmFzL2NvcmUvUGF0aC5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9TaGFwZS5qcyIsIi4uL3NyYy9leHRyYXMvbGliL2VhcmN1dC5qcyIsIi4uL3NyYy9leHRyYXMvRWFyY3V0LmpzIiwiLi4vc3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvU2hhcGVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1NwaGVyZUdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvVGV0cmFoZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1RvcnVzR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1dpcmVmcmFtZUdlb21ldHJ5LmpzIiwiLi4vc3JjL21hdGVyaWFscy9TaGFkb3dNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvUmF3U2hhZGVyTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hTdGFuZGFyZE1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoUGh5c2ljYWxNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hUb29uTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaExhbWJlcnRNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hEaXN0YW5jZU1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoTWF0Y2FwTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qcyIsIi4uL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uVXRpbHMuanMiLCIuLi9zcmMvbWF0aC9JbnRlcnBvbGFudC5qcyIsIi4uL3NyYy9tYXRoL2ludGVycG9sYW50cy9DdWJpY0ludGVycG9sYW50LmpzIiwiLi4vc3JjL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzIiwiLi4vc3JjL21hdGgvaW50ZXJwb2xhbnRzL0Rpc2NyZXRlSW50ZXJwb2xhbnQuanMiLCIuLi9zcmMvYW5pbWF0aW9uL0tleWZyYW1lVHJhY2suanMiLCIuLi9zcmMvYW5pbWF0aW9uL3RyYWNrcy9Cb29sZWFuS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9hbmltYXRpb24vdHJhY2tzL0NvbG9yS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9hbmltYXRpb24vdHJhY2tzL051bWJlcktleWZyYW1lVHJhY2suanMiLCIuLi9zcmMvbWF0aC9pbnRlcnBvbGFudHMvUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LmpzIiwiLi4vc3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanMiLCIuLi9zcmMvYW5pbWF0aW9uL3RyYWNrcy9TdHJpbmdLZXlmcmFtZVRyYWNrLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi90cmFja3MvVmVjdG9yS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uQ2xpcC5qcyIsIi4uL3NyYy9sb2FkZXJzL0NhY2hlLmpzIiwiLi4vc3JjL2xvYWRlcnMvTG9hZGluZ01hbmFnZXIuanMiLCIuLi9zcmMvbG9hZGVycy9Mb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9GaWxlTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvQW5pbWF0aW9uTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9JbWFnZUxvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0N1YmVUZXh0dXJlTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvRGF0YVRleHR1cmVMb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9UZXh0dXJlTG9hZGVyLmpzIiwiLi4vc3JjL2xpZ2h0cy9MaWdodC5qcyIsIi4uL3NyYy9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzIiwiLi4vc3JjL2xpZ2h0cy9MaWdodFNoYWRvdy5qcyIsIi4uL3NyYy9saWdodHMvU3BvdExpZ2h0U2hhZG93LmpzIiwiLi4vc3JjL2xpZ2h0cy9TcG90TGlnaHQuanMiLCIuLi9zcmMvbGlnaHRzL1BvaW50TGlnaHRTaGFkb3cuanMiLCIuLi9zcmMvbGlnaHRzL1BvaW50TGlnaHQuanMiLCIuLi9zcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMiLCIuLi9zcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHRTaGFkb3cuanMiLCIuLi9zcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanMiLCIuLi9zcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qcyIsIi4uL3NyYy9saWdodHMvUmVjdEFyZWFMaWdodC5qcyIsIi4uL3NyYy9tYXRoL1NwaGVyaWNhbEhhcm1vbmljczMuanMiLCIuLi9zcmMvbGlnaHRzL0xpZ2h0UHJvYmUuanMiLCIuLi9zcmMvbG9hZGVycy9NYXRlcmlhbExvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0xvYWRlclV0aWxzLmpzIiwiLi4vc3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanMiLCIuLi9zcmMvbG9hZGVycy9CdWZmZXJHZW9tZXRyeUxvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL09iamVjdExvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0ltYWdlQml0bWFwTG9hZGVyLmpzIiwiLi4vc3JjL2F1ZGlvL0F1ZGlvQ29udGV4dC5qcyIsIi4uL3NyYy9sb2FkZXJzL0F1ZGlvTG9hZGVyLmpzIiwiLi4vc3JjL2NhbWVyYXMvU3RlcmVvQ2FtZXJhLmpzIiwiLi4vc3JjL2NhbWVyYXMvQXJyYXlDYW1lcmEuanMiLCIuLi9zcmMvY29yZS9DbG9jay5qcyIsIi4uL3NyYy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzIiwiLi4vc3JjL2F1ZGlvL0F1ZGlvLmpzIiwiLi4vc3JjL2F1ZGlvL1Bvc2l0aW9uYWxBdWRpby5qcyIsIi4uL3NyYy9hdWRpby9BdWRpb0FuYWx5c2VyLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eU1peGVyLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eUJpbmRpbmcuanMiLCIuLi9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbk9iamVjdEdyb3VwLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi9BbmltYXRpb25BY3Rpb24uanMiLCIuLi9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbk1peGVyLmpzIiwiLi4vc3JjL2NvcmUvUmVuZGVyVGFyZ2V0M0QuanMiLCIuLi9zcmMvY29yZS9SZW5kZXJUYXJnZXRBcnJheS5qcyIsIi4uL3NyYy9jb3JlL1VuaWZvcm0uanMiLCIuLi9zcmMvY29yZS9Vbmlmb3Jtc0dyb3VwLmpzIiwiLi4vc3JjL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanMiLCIuLi9zcmMvY29yZS9HTEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9jb3JlL1JheWNhc3Rlci5qcyIsIi4uL3NyYy9tYXRoL1NwaGVyaWNhbC5qcyIsIi4uL3NyYy9tYXRoL0N5bGluZHJpY2FsLmpzIiwiLi4vc3JjL21hdGgvTWF0cml4Mi5qcyIsIi4uL3NyYy9tYXRoL0JveDIuanMiLCIuLi9zcmMvbWF0aC9MaW5lMy5qcyIsIi4uL3NyYy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL0dyaWRIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9Qb2xhckdyaWRIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQm94SGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQm94M0hlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL1BsYW5lSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQXJyb3dIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9BeGVzSGVscGVyLmpzIiwiLi4vc3JjL2V4dHJhcy9jb3JlL1NoYXBlUGF0aC5qcyIsIi4uL3NyYy9leHRyYXMvQ29udHJvbHMuanMiLCIuLi9zcmMvZXh0cmFzL1RleHR1cmVVdGlscy5qcyIsIi4uL3NyYy9UaHJlZS5Db3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSRVZJU0lPTiA9ICcxNzYnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgbW91c2UgYnV0dG9ucyBhbmQgaW50ZXJhY3Rpb24gdHlwZXMgaW4gY29udGV4dCBvZiBjb250cm9scy5cbiAqXG4gKiBAdHlwZSB7Q29uc3RhbnRzTW91c2V9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRvdWNoIGludGVyYWN0aW9uIHR5cGVzIGluIGNvbnRleHQgb2YgY29udHJvbHMuXG4gKlxuICogQHR5cGUge0NvbnN0YW50c1RvdWNofVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBUT1VDSCA9IHsgUk9UQVRFOiAwLCBQQU46IDEsIERPTExZX1BBTjogMiwgRE9MTFlfUk9UQVRFOiAzIH07XG5cbi8qKlxuICogRGlzYWJsZXMgZmFjZSBjdWxsaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlTm9uZSA9IDA7XG5cbi8qKlxuICogQ3VsbHMgYmFjayBmYWNlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuXG4vKipcbiAqIEN1bGxzIGZyb250IGZhY2VzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnQgPSAyO1xuXG4vKipcbiAqIEN1bGxzIGJvdGggZnJvbnQgYW5kIGJhY2sgZmFjZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuXG4vKipcbiAqIEdpdmVzIHVuZmlsdGVyZWQgc2hhZG93IG1hcHMgLSBmYXN0ZXN0LCBidXQgbG93ZXN0IHF1YWxpdHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQmFzaWNTaGFkb3dNYXAgPSAwO1xuXG4vKipcbiAqIEZpbHRlcnMgc2hhZG93IG1hcHMgdXNpbmcgdGhlIFBlcmNlbnRhZ2UtQ2xvc2VyIEZpbHRlcmluZyAoUENGKSBhbGdvcml0aG0uXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUENGU2hhZG93TWFwID0gMTtcblxuLyoqXG4gKiBGaWx0ZXJzIHNoYWRvdyBtYXBzIHVzaW5nIHRoZSBQZXJjZW50YWdlLUNsb3NlciBGaWx0ZXJpbmcgKFBDRikgYWxnb3JpdGhtIHdpdGhcbiAqIGJldHRlciBzb2Z0IHNoYWRvd3MgZXNwZWNpYWxseSB3aGVuIHVzaW5nIGxvdy1yZXNvbHV0aW9uIHNoYWRvdyBtYXBzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xuXG4vKipcbiAqIEZpbHRlcnMgc2hhZG93IG1hcHMgdXNpbmcgdGhlIFZhcmlhbmNlIFNoYWRvdyBNYXAgKFZTTSkgYWxnb3JpdGhtLlxuICogV2hlbiB1c2luZyBWU01TaGFkb3dNYXAgYWxsIHNoYWRvdyByZWNlaXZlcnMgd2lsbCBhbHNvIGNhc3Qgc2hhZG93cy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuXG4vKipcbiAqIE9ubHkgZnJvbnQgZmFjZXMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEZyb250U2lkZSA9IDA7XG5cbi8qKlxuICogT25seSBiYWNrIGZhY2VzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBCYWNrU2lkZSA9IDE7XG5cbi8qKlxuICogQm90aCBmcm9udCBhbmQgYmFjayBmYWNlcyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRG91YmxlU2lkZSA9IDI7XG5cbi8qKlxuICogTm8gYmxlbmRpbmcgaXMgcGVyZm9ybWVkIHdoaWNoIGVmZmVjdGl2ZWx5IGRpc2FibGVzXG4gKiBhbHBoYSB0cmFuc3BhcmVuY3kuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTm9CbGVuZGluZyA9IDA7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYmxlbmRpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTm9ybWFsQmxlbmRpbmcgPSAxO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYWRkaXRpdmUgYmxlbmRpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5cbi8qKlxuICogUmVwcmVzZW50cyBzdWJ0cmFjdGl2ZSBibGVuZGluZy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblxuLyoqXG4gKiBSZXByZXNlbnRzIG11bHRpcGx5IGJsZW5kaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE11bHRpcGx5QmxlbmRpbmcgPSA0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3VzdG9tIGJsZW5kaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEN1c3RvbUJsZW5kaW5nID0gNTtcblxuLyoqXG4gKiBBIGBzb3VyY2UgKyBkZXN0aW5hdGlvbmAgYmxlbmRpbmcgZXF1YXRpb24uXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWRkRXF1YXRpb24gPSAxMDA7XG5cbi8qKlxuICogQSBgc291cmNlIC0gZGVzdGluYXRpb25gIGJsZW5kaW5nIGVxdWF0aW9uLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5cbi8qKlxuICogQSBgZGVzdGluYXRpb24gLSBzb3VyY2VgIGJsZW5kaW5nIGVxdWF0aW9uLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuXG4vKipcbiAqIEEgYmxlbmQgZXF1YXRpb24gdGhhdCB1c2VzIHRoZSBtaW5pbXVtIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24uXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTWluRXF1YXRpb24gPSAxMDM7XG5cbi8qKlxuICogQSBibGVuZCBlcXVhdGlvbiB0aGF0IHVzZXMgdGhlIG1heGltdW0gb2Ygc291cmNlIGFuZCBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgYDBgLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9GYWN0b3IgPSAyMDA7XG5cbi8qKlxuICogTXVsdGlwbGllcyBhbGwgY29sb3JzIGJ5IGAxYC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBPbmVGYWN0b3IgPSAyMDE7XG5cbi8qKlxuICogTXVsdGlwbGllcyBhbGwgY29sb3JzIGJ5IHRoZSBzb3VyY2UgY29sb3JzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFNyY0NvbG9yRmFjdG9yID0gMjAyO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgYWxsIGNvbG9ycyBieSBgMWAgbWludXMgZWFjaCBzb3VyY2UgY29sb3IuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgdGhlIHNvdXJjZSBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBTcmNBbHBoYUZhY3RvciA9IDIwNDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgMSBtaW51cyB0aGUgc291cmNlIGFscGhhIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5cbi8qKlxuICogTXVsdGlwbGllcyBhbGwgY29sb3JzIGJ5IHRoZSBkZXN0aW5hdGlvbiBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBEc3RBbHBoYUZhY3RvciA9IDIwNjtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgYDFgIG1pbnVzIHRoZSBkZXN0aW5hdGlvbiBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgYWxsIGNvbG9ycyBieSB0aGUgZGVzdGluYXRpb24gY29sb3IuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5cbi8qKlxuICogTXVsdGlwbGllcyBhbGwgY29sb3JzIGJ5IGAxYCBtaW51cyBlYWNoIGRlc3RpbmF0aW9uIGNvbG9yLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0aGUgUkdCIGNvbG9ycyBieSB0aGUgc21hbGxlciBvZiBlaXRoZXIgdGhlIHNvdXJjZSBhbHBoYVxuICogdmFsdWUgb3IgdGhlIHZhbHVlIG9mIGAxYCBtaW51cyB0aGUgZGVzdGluYXRpb24gYWxwaGEgdmFsdWUuIFRoZSBhbHBoYVxuICogdmFsdWUgaXMgbXVsdGlwbGllZCBieSBgMWAuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgYSBjb25zdGFudCBjb2xvci5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBDb25zdGFudENvbG9yRmFjdG9yID0gMjExO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgYWxsIGNvbG9ycyBieSBgMWAgbWludXMgYSBjb25zdGFudCBjb2xvci5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3IgPSAyMTI7XG5cbi8qKlxuICogTXVsdGlwbGllcyBhbGwgY29sb3JzIGJ5IGEgY29uc3RhbnQgYWxwaGEgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQ29uc3RhbnRBbHBoYUZhY3RvciA9IDIxMztcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFsbCBjb2xvcnMgYnkgMSBtaW51cyBhIGNvbnN0YW50IGFscGhhIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzQ29uc3RhbnRBbHBoYUZhY3RvciA9IDIxNDtcblxuLyoqXG4gKiBOZXZlciBwYXNzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE5ldmVyRGVwdGggPSAwO1xuXG4vKipcbiAqIEFsd2F5cyBwYXNzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEFsd2F5c0RlcHRoID0gMTtcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIGRlcHRoIGJ1ZmZlciB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBMZXNzRGVwdGggPSAyO1xuXG4vKipcbiAqIFBhc3MgaWYgdGhlIGluY29taW5nIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZGVwdGggYnVmZmVyIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbERlcHRoID0gMztcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBlcXVhbHMgdGhlIGRlcHRoIGJ1ZmZlciB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBFcXVhbERlcHRoID0gNDtcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRlcHRoIGJ1ZmZlciB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG5cbi8qKlxuICogUGFzcyBpZiB0aGUgaW5jb21pbmcgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBkZXB0aCBidWZmZXIgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgR3JlYXRlckRlcHRoID0gNjtcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIGRlcHRoIGJ1ZmZlciB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOb3RFcXVhbERlcHRoID0gNztcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHRoZSBlbnZpcm9ubWVudCBtYXAgY29sb3Igd2l0aCB0aGUgc3VyZmFjZSBjb2xvci5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBNdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5cbi8qKlxuICogVXNlcyByZWZsZWN0aXZpdHkgdG8gYmxlbmQgYmV0d2VlbiB0aGUgdHdvIGNvbG9ycy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuXG4vKipcbiAqIEFkZHMgdGhlIHR3byBjb2xvcnMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWRkT3BlcmF0aW9uID0gMjtcblxuLyoqXG4gKiBObyB0b25lIG1hcHBpbmcgaXMgYXBwbGllZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOb1RvbmVNYXBwaW5nID0gMDtcblxuLyoqXG4gKiBMaW5lYXIgdG9uZSBtYXBwaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExpbmVhclRvbmVNYXBwaW5nID0gMTtcblxuLyoqXG4gKiBSZWluaGFyZCB0b25lIG1hcHBpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG5cbi8qKlxuICogQ2luZW9uIHRvbmUgbWFwcGluZy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBDaW5lb25Ub25lTWFwcGluZyA9IDM7XG5cbi8qKlxuICogQUNFUyBGaWxtaWMgdG9uZSBtYXBwaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEFDRVNGaWxtaWNUb25lTWFwcGluZyA9IDQ7XG5cbi8qKlxuICogQ3VzdG9tIHRvbmUgbWFwcGluZy5cbiAqXG4gKiBFeHBlY3RzIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIGJ5IG1vZGlmeWluZyBzaGFkZXIgY29kZSBvZiB0aGUgbWF0ZXJpYWwncyBmcmFnbWVudCBzaGFkZXIuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQ3VzdG9tVG9uZU1hcHBpbmcgPSA1O1xuXG4vKipcbiAqIEFnWCB0b25lIG1hcHBpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWdYVG9uZU1hcHBpbmcgPSA2O1xuXG4vKipcbiAqIE5ldXRyYWwgdG9uZSBtYXBwaW5nLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBLaHJvbm9zIDNEIENvbW1lcmNlIEdyb3VwIHN0YW5kYXJkIHRvbmUgbWFwcGluZy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOZXV0cmFsVG9uZU1hcHBpbmcgPSA3O1xuXG4vKipcbiAqIFRoZSBza2lubmVkIG1lc2ggc2hhcmVzIHRoZSBzYW1lIHdvcmxkIHNwYWNlIGFzIHRoZSBza2VsZXRvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBBdHRhY2hlZEJpbmRNb2RlID0gJ2F0dGFjaGVkJztcblxuLyoqXG4gKiBUaGUgc2tpbm5lZCBtZXNoIGRvZXMgbm90IHNoYXJlIHRoZSBzYW1lIHdvcmxkIHNwYWNlIGFzIHRoZSBza2VsZXRvbi5cbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBza2VsZXRvbiBpcyBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIHNraW5uZWQgbWVzaGVzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IERldGFjaGVkQmluZE1vZGUgPSAnZGV0YWNoZWQnO1xuXG4vKipcbiAqIE1hcHMgdGV4dHVyZXMgdXNpbmcgdGhlIGdlb21ldHJ5J3MgVVYgY29vcmRpbmF0ZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgVVZNYXBwaW5nID0gMzAwO1xuXG4vKipcbiAqIFJlZmxlY3Rpb24gbWFwcGluZyBmb3IgY3ViZSB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5cbi8qKlxuICogUmVmcmFjdGlvbiBtYXBwaW5nIGZvciBjdWJlIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcblxuLyoqXG4gKiBSZWZsZWN0aW9uIG1hcHBpbmcgZm9yIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcblxuLyoqXG4gKiBSZWZyYWN0aW9uIG1hcHBpbmcgZm9yIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcblxuLyoqXG4gKiBSZWZsZWN0aW9uIG1hcHBpbmcgZm9yIFBNUkVNIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuXG4vKipcbiAqIFRoZSB0ZXh0dXJlIHdpbGwgc2ltcGx5IHJlcGVhdCB0byBpbmZpbml0eS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XG5cbi8qKlxuICogVGhlIGxhc3QgcGl4ZWwgb2YgdGhlIHRleHR1cmUgc3RyZXRjaGVzIHRvIHRoZSBlZGdlIG9mIHRoZSBtZXNoLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuXG4vKipcbiAqIFRoZSB0ZXh0dXJlIHdpbGwgcmVwZWF0cyB0byBpbmZpbml0eSwgbWlycm9yaW5nIG9uIGVhY2ggcmVwZWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB0ZXh0dXJlIGVsZW1lbnQgdGhhdCBpcyBuZWFyZXN0IChpbiBNYW5oYXR0YW4gZGlzdGFuY2UpXG4gKiB0byB0aGUgc3BlY2lmaWVkIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5cbi8qKlxuICogQ2hvb3NlcyB0aGUgbWlwbWFwIHRoYXQgbW9zdCBjbG9zZWx5IG1hdGNoZXMgdGhlIHNpemUgb2YgdGhlIHBpeGVsIGJlaW5nIHRleHR1cmVkXG4gKiBhbmQgdXNlcyB0aGUgYE5lYXJlc3RGaWx0ZXJgIGNyaXRlcmlvbiAodGhlIHRleGVsIG5lYXJlc3QgdG8gdGhlIGNlbnRlciBvZiB0aGUgcGl4ZWwpXG4gKiB0byBwcm9kdWNlIGEgdGV4dHVyZSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0OyAvLyBsZWdhY3lcblxuLyoqXG4gKiBDaG9vc2VzIHRoZSB0d28gbWlwbWFwcyB0aGF0IG1vc3QgY2xvc2VseSBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgcGl4ZWwgYmVpbmcgdGV4dHVyZWQgYW5kXG4gKiB1c2VzIHRoZSBgTmVhcmVzdEZpbHRlcmAgY3JpdGVyaW9uIHRvIHByb2R1Y2UgYSB0ZXh0dXJlIHZhbHVlIGZyb20gZWFjaCBtaXBtYXAuXG4gKiBUaGUgZmluYWwgdGV4dHVyZSB2YWx1ZSBpcyBhIHdlaWdodGVkIGF2ZXJhZ2Ugb2YgdGhvc2UgdHdvIHZhbHVlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTsgLy8gbGVnYWN5XG5cbi8qKlxuICogUmV0dXJucyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciB0ZXh0dXJlIGVsZW1lbnRzIHRoYXQgYXJlIGNsb3Nlc3QgdG8gdGhlIHNwZWNpZmllZFxuICogdGV4dHVyZSBjb29yZGluYXRlcywgYW5kIGNhbiBpbmNsdWRlIGl0ZW1zIHdyYXBwZWQgb3IgcmVwZWF0ZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBhIHRleHR1cmUsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiBgd3JhcFNgIGFuZCBgd3JhcFRgLCBhbmQgb24gdGhlIGV4YWN0IG1hcHBpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTGluZWFyRmlsdGVyID0gMTAwNjtcblxuLyoqXG4gKiBDaG9vc2VzIHRoZSBtaXBtYXAgdGhhdCBtb3N0IGNsb3NlbHkgbWF0Y2hlcyB0aGUgc2l6ZSBvZiB0aGUgcGl4ZWwgYmVpbmcgdGV4dHVyZWQgYW5kIHVzZXNcbiAqIHRoZSBgTGluZWFyRmlsdGVyYCBjcml0ZXJpb24gKGEgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciB0ZXhlbHMgdGhhdCBhcmUgY2xvc2VzdCB0byB0aGVcbiAqIGNlbnRlciBvZiB0aGUgcGl4ZWwpIHRvIHByb2R1Y2UgYSB0ZXh0dXJlIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuZXhwb3J0IGNvbnN0IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3OyAvLyBsZWdhY3lcblxuLyoqXG4gKiBDaG9vc2VzIHRoZSB0d28gbWlwbWFwcyB0aGF0IG1vc3QgY2xvc2VseSBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgcGl4ZWwgYmVpbmcgdGV4dHVyZWQgYW5kIHVzZXNcbiAqIHRoZSBgTGluZWFyRmlsdGVyYCBjcml0ZXJpb24gdG8gcHJvZHVjZSBhIHRleHR1cmUgdmFsdWUgZnJvbSBlYWNoIG1pcG1hcC4gVGhlIGZpbmFsIHRleHR1cmUgdmFsdWVcbiAqIGlzIGEgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aG9zZSB0d28gdmFsdWVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExpbmVhck1pcG1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODsgLy8gbGVnYWN5XG5cbi8qKlxuICogQW4gdW5zaWduZWQgYnl0ZSBkYXRhIHR5cGUgZm9yIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuXG4vKipcbiAqIEEgYnl0ZSBkYXRhIHR5cGUgZm9yIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcblxuLyoqXG4gKiBBIHNob3J0IGRhdGEgdHlwZSBmb3IgdGV4dHVyZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU2hvcnRUeXBlID0gMTAxMTtcblxuLyoqXG4gKiBBbiB1bnNpZ25lZCBzaG9ydCBkYXRhIHR5cGUgZm9yIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcblxuLyoqXG4gKiBBbiBpbnQgZGF0YSB0eXBlIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBJbnRUeXBlID0gMTAxMztcblxuLyoqXG4gKiBBbiB1bnNpZ25lZCBpbnQgZGF0YSB0eXBlIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuXG4vKipcbiAqIEEgZmxvYXQgZGF0YSB0eXBlIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBGbG9hdFR5cGUgPSAxMDE1O1xuXG4vKipcbiAqIEEgaGFsZiBmbG9hdCBkYXRhIHR5cGUgZm9yIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xuXG4vKipcbiAqIEFuIHVuc2lnbmVkIHNob3J0IDRfNF80XzQgKHBhY2tlZCkgZGF0YSB0eXBlIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xuXG4vKipcbiAqIEFuIHVuc2lnbmVkIHNob3J0IDVfNV81XzEgKHBhY2tlZCkgZGF0YSB0eXBlIGZvciB0ZXh0dXJlcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xuXG4vKipcbiAqIEFuIHVuc2lnbmVkIGludCAyNF84IGRhdGEgdHlwZSBmb3IgdGV4dHVyZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcblxuLyoqXG4gKiBBbiB1bnNpZ25lZCBpbnQgNV85XzlfOSAocGFja2VkKSBkYXRhIHR5cGUgZm9yIHRleHR1cmVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkSW50NTk5OVR5cGUgPSAzNTkwMjtcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSBjb21wb25lbnRzIGFuZCByZWFkcyBqdXN0IHRoZSBhbHBoYSBjb21wb25lbnQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuXG4vKipcbiAqIERpc2NhcmRzIHRoZSBhbHBoYSBjb21wb25lbnQgYW5kIHJlYWRzIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNvbXBvbmVudC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JGb3JtYXQgPSAxMDIyO1xuXG4vKipcbiAqIFJlYWRzIHRoZSByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYSBjb21wb25lbnRzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuXG4vKipcbiAqIFJlYWRzIGVhY2ggZWxlbWVudCBhcyBhIHNpbmdsZSBkZXB0aCB2YWx1ZSwgY29udmVydHMgaXQgdG8gZmxvYXRpbmcgcG9pbnQsIGFuZCBjbGFtcHMgdG8gdGhlIHJhbmdlIGBbMCwxXWAuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRGVwdGhGb3JtYXQgPSAxMDI2O1xuXG4vKipcbiAqIFJlYWRzIGVhY2ggZWxlbWVudCBpcyBhIHBhaXIgb2YgZGVwdGggYW5kIHN0ZW5jaWwgdmFsdWVzLiBUaGUgZGVwdGggY29tcG9uZW50IG9mIHRoZSBwYWlyIGlzIGludGVycHJldGVkIGFzXG4gKiBpbiBgRGVwdGhGb3JtYXRgLiBUaGUgc3RlbmNpbCBjb21wb25lbnQgaXMgaW50ZXJwcmV0ZWQgYmFzZWQgb24gdGhlIGRlcHRoICsgc3RlbmNpbCBpbnRlcm5hbCBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIGNvbXBvbmVudHMgYW5kIHJlYWRzIGp1c3QgdGhlIHJlZCBjb21wb25lbnQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUmVkRm9ybWF0ID0gMTAyODtcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIGNvbXBvbmVudHMgYW5kIHJlYWRzIGp1c3QgdGhlIHJlZCBjb21wb25lbnQuIFRoZSB0ZXhlbHMgYXJlIHJlYWQgYXMgaW50ZWdlcnMgaW5zdGVhZCBvZiBmbG9hdGluZyBwb2ludC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSZWRJbnRlZ2VyRm9ybWF0ID0gMTAyOTtcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgYWxwaGEsIGFuZCBibHVlIGNvbXBvbmVudHMgYW5kIHJlYWRzIHRoZSByZWQsIGFuZCBncmVlbiBjb21wb25lbnRzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHRm9ybWF0ID0gMTAzMDtcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgYWxwaGEsIGFuZCBibHVlIGNvbXBvbmVudHMgYW5kIHJlYWRzIHRoZSByZWQsIGFuZCBncmVlbiBjb21wb25lbnRzLiBUaGUgdGV4ZWxzIGFyZSByZWFkIGFzIGludGVnZXJzIGluc3RlYWQgb2YgZmxvYXRpbmcgcG9pbnQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdJbnRlZ2VyRm9ybWF0ID0gMTAzMTtcblxuLyoqXG4gKiBEaXNjYXJkcyB0aGUgYWxwaGEgY29tcG9uZW50IGFuZCByZWFkcyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSBjb21wb25lbnQuIFRoZSB0ZXhlbHMgYXJlIHJlYWQgYXMgaW50ZWdlcnMgaW5zdGVhZCBvZiBmbG9hdGluZyBwb2ludC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JJbnRlZ2VyRm9ybWF0ID0gMTAzMjtcblxuLyoqXG4gKiBSZWFkcyB0aGUgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgY29tcG9uZW50cy4gVGhlIHRleGVscyBhcmUgcmVhZCBhcyBpbnRlZ2VycyBpbnN0ZWFkIG9mIGZsb2F0aW5nIHBvaW50LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFJbnRlZ2VyRm9ybWF0ID0gMTAzMztcblxuLyoqXG4gKiBBIERYVDEtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0IgaW1hZ2UgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5cbi8qKlxuICogQSBEWFQxLWNvbXByZXNzZWQgaW1hZ2UgaW4gYW4gUkdCIGltYWdlIGZvcm1hdCB3aXRoIGEgc2ltcGxlIG9uL29mZiBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcblxuLyoqXG4gKiBBIERYVDMtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0JBIGltYWdlIGZvcm1hdC4gQ29tcGFyZWQgdG8gYSAzMi1iaXQgUkdCQSB0ZXh0dXJlLCBpdCBvZmZlcnMgNDoxIGNvbXByZXNzaW9uLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xuXG4vKipcbiAqIEEgRFhUNS1jb21wcmVzc2VkIGltYWdlIGluIGFuIFJHQkEgaW1hZ2UgZm9ybWF0LiBJdCBhbHNvIHByb3ZpZGVzIGEgNDoxIGNvbXByZXNzaW9uLCBidXQgZGlmZmVycyB0byB0aGUgRFhUM1xuICogY29tcHJlc3Npb24gaW4gaG93IHRoZSBhbHBoYSBjb21wcmVzc2lvbiBpcyBkb25lLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDMzNzc5O1xuXG4vKipcbiAqIFBWUlRDIFJHQiBjb21wcmVzc2lvbiBpbiA0LWJpdCBtb2RlLiBPbmUgYmxvY2sgZm9yIGVhY2ggNMOXNCBwaXhlbHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0MDtcblxuLyoqXG4gKiBQVlJUQyBSR0IgY29tcHJlc3Npb24gaW4gMi1iaXQgbW9kZS4gT25lIGJsb2NrIGZvciBlYWNoIDjDlzQgcGl4ZWxzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5cbi8qKlxuICogUFZSVEMgUkdCQSBjb21wcmVzc2lvbiBpbiA0LWJpdCBtb2RlLiBPbmUgYmxvY2sgZm9yIGVhY2ggNMOXNCBwaXhlbHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDI7XG5cbi8qKlxuICogUFZSVEMgUkdCQSBjb21wcmVzc2lvbiBpbiAyLWJpdCBtb2RlLiBPbmUgYmxvY2sgZm9yIGVhY2ggOMOXNCBwaXhlbHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5cbi8qKlxuICogRVRDMSBSR0IgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQl9FVEMxX0Zvcm1hdCA9IDM2MTk2O1xuXG4vKipcbiAqIEVUQzIgUkdCIGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JfRVRDMl9Gb3JtYXQgPSAzNzQ5MjtcblxuLyoqXG4gKiBFVEMyIFJHQkEgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfRVRDMl9FQUNfRm9ybWF0ID0gMzc0OTY7XG5cbi8qKlxuICogQVNUQyBSR0JBIDR4NCBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzR4NF9Gb3JtYXQgPSAzNzgwODtcblxuLyoqXG4gKiBBU1RDIFJHQkEgNXg0IGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xuXG4vKipcbiAqIEFTVEMgUkdCQSA1eDUgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ181eDVfRm9ybWF0ID0gMzc4MTA7XG5cbi8qKlxuICogQVNUQyBSR0JBIDZ4NSBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgPSAzNzgxMTtcblxuLyoqXG4gKiBBU1RDIFJHQkEgNng2IGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xuXG4vKipcbiAqIEFTVEMgUkdCQSA4eDUgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDVfRm9ybWF0ID0gMzc4MTM7XG5cbi8qKlxuICogQVNUQyBSR0JBIDh4NiBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgPSAzNzgxNDtcblxuLyoqXG4gKiBBU1RDIFJHQkEgOHg4IGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xuXG4vKipcbiAqIEFTVEMgUkdCQSAxMHg1IGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSAzNzgxNjtcblxuLyoqXG4gKiBBU1RDIFJHQkEgMTB4NiBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5cbi8qKlxuICogQVNUQyBSR0JBIDEweDggZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xuXG4vKipcbiAqIEFTVEMgUkdCQSAxMHgxMCBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuXG4vKipcbiAqIEFTVEMgUkdCQSAxMngxMCBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuXG4vKipcbiAqIEFTVEMgUkdCQSAxMngxMiBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xuXG4vKipcbiAqIEJQVEMgUkdCQSBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuXG4vKipcbiAqIEJQVEMgU2lnbmVkIFJHQiBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdCA9IDM2NDk0O1xuXG4vKipcbiAqIEJQVEMgVW5zaWduZWQgUkdCIGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQgPSAzNjQ5NTtcblxuLyoqXG4gKiBSR1RDMSBSZWQgZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4MztcblxuLyoqXG4gKiBSR1RDMSBTaWduZWQgUmVkIGZvcm1hdC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCA9IDM2Mjg0O1xuXG4vKipcbiAqIFJHVEMyIFJlZCBHcmVlbiBmb3JtYXQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCA9IDM2Mjg1O1xuXG4vKipcbiAqIFJHVEMyIFNpZ25lZCBSZWQgR3JlZW4gZm9ybWF0LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0ID0gMzYyODY7XG5cbi8qKlxuICogQW5pbWF0aW9ucyBhcmUgcGxheWVkIG9uY2UuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTG9vcE9uY2UgPSAyMjAwO1xuXG4vKipcbiAqIEFuaW1hdGlvbnMgYXJlIHBsYXllZCB3aXRoIGEgY2hvc2VuIG51bWJlciBvZiByZXBldGl0aW9ucywgZWFjaCB0aW1lIGp1bXBpbmcgZnJvbVxuICogdGhlIGVuZCBvZiB0aGUgY2xpcCBkaXJlY3RseSB0byBpdHMgYmVnaW5uaW5nLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExvb3BSZXBlYXQgPSAyMjAxO1xuXG4vKipcbiAqIEFuaW1hdGlvbnMgYXJlIHBsYXllZCB3aXRoIGEgY2hvc2VuIG51bWJlciBvZiByZXBldGl0aW9ucywgYWx0ZXJuYXRlbHkgcGxheWluZyBmb3J3YXJkXG4gKiBhbmQgYmFja3dhcmQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcblxuLyoqXG4gKiBEaXNjcmV0ZSBpbnRlcnBvbGF0aW9uIG1vZGUgZm9yIGtleWZyYW1lIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcblxuLyoqXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvbiBtb2RlIGZvciBrZXlmcmFtZSB0cmFja3MuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuXG4vKipcbiAqIFNtb290aCBpbnRlcnBvbGF0aW9uIG1vZGUgZm9yIGtleWZyYW1lIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG5cbi8qKlxuICogWmVybyBjdXJ2YXR1cmUgZW5kaW5nIGZvciBhbmltYXRpb25zLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuXG4vKipcbiAqIFplcm8gc2xvcGUgZW5kaW5nIGZvciBhbmltYXRpb25zLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5cbi8qKlxuICogV3JhcCBhcm91bmQgZW5kaW5nIGZvciBhbmltYXRpb25zLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFdyYXBBcm91bmRFbmRpbmcgPSAyNDAyO1xuXG4vKipcbiAqIERlZmF1bHQgYW5pbWF0aW9uIGJsZW5kIG1vZGUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcblxuLyoqXG4gKiBBZGRpdGl2ZSBhbmltYXRpb24gYmxlbmQgbW9kZS4gQ2FuIGJlIHVzZWQgdG8gbGF5ZXIgbW90aW9ucyBvbiB0b3Agb2ZcbiAqIGVhY2ggb3RoZXIgdG8gYnVpbGQgY29tcGxleCBwZXJmb3JtYW5jZXMgZnJvbSBzbWFsbGVyIHJlLXVzYWJsZSBhc3NldHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAxO1xuXG4vKipcbiAqIEZvciBldmVyeSB0aHJlZSB2ZXJ0aWNlcyBkcmF3IGEgc2luZ2xlIHRyaWFuZ2xlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcblxuLyoqXG4gKiBGb3IgZWFjaCB2ZXJ0ZXggZHJhdyBhIHRyaWFuZ2xlIGZyb20gdGhlIGxhc3QgdGhyZWUgdmVydGljZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcblxuLyoqXG4gKiBGb3IgZWFjaCB2ZXJ0ZXggZHJhdyBhIHRyaWFuZ2xlIGZyb20gdGhlIGZpcnN0IHZlcnRleCBhbmQgdGhlIGxhc3QgdHdvIHZlcnRpY2VzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuXG4vKipcbiAqIEJhc2ljIGRlcHRoIHBhY2tpbmcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuXG4vKipcbiAqIEEgZGVwdGggdmFsdWUgaXMgcGFja2VkIGludG8gMzIgYml0IFJHQkEuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5cbi8qKlxuICogQSBkZXB0aCB2YWx1ZSBpcyBwYWNrZWQgaW50byAyNCBiaXQgUkdCLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJHQkRlcHRoUGFja2luZyA9IDMyMDI7XG5cbi8qKlxuICogQSBkZXB0aCB2YWx1ZSBpcyBwYWNrZWQgaW50byAxNiBiaXQgUkcuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUkdEZXB0aFBhY2tpbmcgPSAzMjAzO1xuXG4vKipcbiAqIE5vcm1hbCBpbmZvcm1hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdW5kZXJseWluZyBzdXJmYWNlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5cbi8qKlxuICogTm9ybWFsIGluZm9ybWF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBvYmplY3Qgb3JpZW50YXRpb24uXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXG4vLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cblxuLyoqXG4gKiBObyBjb2xvciBzcGFjZS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcblxuLyoqXG4gKiBzUkdCIGNvbG9yIHNwYWNlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuXG4vKipcbiAqIHNSR0ItbGluZWFyIGNvbG9yIHNwYWNlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcblxuLyoqXG4gKiBMaW5lYXIgdHJhbnNmZXIgZnVuY3Rpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTGluZWFyVHJhbnNmZXIgPSAnbGluZWFyJztcblxuLyoqXG4gKiBzUkdCIHRyYW5zZmVyIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFNSR0JUcmFuc2ZlciA9ICdzcmdiJztcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGVuY2lsIGJ1ZmZlciB2YWx1ZSB0byBgMGAuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgWmVyb1N0ZW5jaWxPcCA9IDA7XG5cbi8qKlxuICogS2VlcHMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgS2VlcFN0ZW5jaWxPcCA9IDc2ODA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RlbmNpbCBidWZmZXIgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCByZWZlcmVuY2UgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgUmVwbGFjZVN0ZW5jaWxPcCA9IDc2ODE7XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgY3VycmVudCBzdGVuY2lsIGJ1ZmZlciB2YWx1ZS4gQ2xhbXBzIHRvIHRoZSBtYXhpbXVtIHJlcHJlc2VudGFibGUgdW5zaWduZWQgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgSW5jcmVtZW50U3RlbmNpbE9wID0gNzY4MjtcblxuLyoqXG4gKiBEZWNyZW1lbnRzIHRoZSBjdXJyZW50IHN0ZW5jaWwgYnVmZmVyIHZhbHVlLiBDbGFtcHMgdG8gYDBgLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IERlY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODM7XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgY3VycmVudCBzdGVuY2lsIGJ1ZmZlciB2YWx1ZS4gV3JhcHMgc3RlbmNpbCBidWZmZXIgdmFsdWUgdG8gemVybyB3aGVuIGluY3JlbWVudGluZ1xuICogdGhlIG1heGltdW0gcmVwcmVzZW50YWJsZSB1bnNpZ25lZCB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5cbi8qKlxuICogRGVjcmVtZW50cyB0aGUgY3VycmVudCBzdGVuY2lsIGJ1ZmZlciB2YWx1ZS4gV3JhcHMgc3RlbmNpbCBidWZmZXIgdmFsdWUgdG8gdGhlIG1heGltdW0gcmVwcmVzZW50YWJsZVxuICogdW5zaWduZWQgdmFsdWUgd2hlbiBkZWNyZW1lbnRpbmcgYSBzdGVuY2lsIGJ1ZmZlciB2YWx1ZSBvZiBgMGAuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU2O1xuXG4vKipcbiAqIEludmVydHMgdGhlIGN1cnJlbnQgc3RlbmNpbCBidWZmZXIgdmFsdWUgYml0d2lzZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBJbnZlcnRTdGVuY2lsT3AgPSA1Mzg2O1xuXG4vKipcbiAqIFdpbGwgbmV2ZXIgcmV0dXJuIHRydWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTmV2ZXJTdGVuY2lsRnVuYyA9IDUxMjtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZSBzdGVuY2lsIHJlZmVyZW5jZSB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgc3RlbmNpbCB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBMZXNzU3RlbmNpbEZ1bmMgPSA1MTM7XG5cbi8qKlxuICogV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RlbmNpbCByZWZlcmVuY2UgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc3RlbmNpbCB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHN0ZW5jaWwgcmVmZXJlbmNlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBzdGVuY2lsIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHN0ZW5jaWwgcmVmZXJlbmNlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBzdGVuY2lsIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZSBzdGVuY2lsIHJlZmVyZW5jZSB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc3RlbmNpbCB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHN0ZW5jaWwgcmVmZXJlbmNlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBzdGVuY2lsIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuXG4vKipcbiAqIFdpbGwgYWx3YXlzIHJldHVybiB0cnVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuXG4vKipcbiAqIE5ldmVyIHBhc3MuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuXG4vKipcbiAqIFBhc3MgaWYgdGhlIGluY29taW5nIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgdGV4dHVyZSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBMZXNzQ29tcGFyZSA9IDUxMztcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBlcXVhbHMgdGhlIHRleHR1cmUgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRXF1YWxDb21wYXJlID0gNTE0O1xuXG4vKipcbiAqIFBhc3MgaWYgdGhlIGluY29taW5nIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdGV4dHVyZSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuXG4vKipcbiAqIFBhc3MgaWYgdGhlIGluY29taW5nIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGV4dHVyZSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBHcmVhdGVyQ29tcGFyZSA9IDUxNjtcblxuLyoqXG4gKiBQYXNzIGlmIHRoZSBpbmNvbWluZyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHRleHR1cmUgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgTm90RXF1YWxDb21wYXJlID0gNTE3O1xuXG4vKipcbiAqIFBhc3MgaWYgdGhlIGluY29taW5nIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdGV4dHVyZSB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuXG4vKipcbiAqIEFsd2F5cyBwYXNzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEFsd2F5c0NvbXBhcmUgPSA1MTk7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSBzcGVjaWZpZWQgb25jZSBieSB0aGUgYXBwbGljYXRpb24sIGFuZCB1c2VkIG1hbnlcbiAqIHRpbWVzIGFzIHRoZSBzb3VyY2UgZm9yIGRyYXdpbmcgYW5kIGltYWdlIHNwZWNpZmljYXRpb24gY29tbWFuZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSByZXNwZWNpZmllZCByZXBlYXRlZGx5IGJ5IHRoZSBhcHBsaWNhdGlvbiwgYW5kXG4gKiB1c2VkIG1hbnkgdGltZXMgYXMgdGhlIHNvdXJjZSBmb3IgZHJhd2luZyBhbmQgaW1hZ2Ugc3BlY2lmaWNhdGlvbiBjb21tYW5kcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSBzcGVjaWZpZWQgb25jZSBieSB0aGUgYXBwbGljYXRpb24sIGFuZCB1c2VkIGF0IG1vc3RcbiAqIGEgZmV3IHRpbWVzIGFzIHRoZSBzb3VyY2UgZm9yIGRyYXdpbmcgYW5kIGltYWdlIHNwZWNpZmljYXRpb24gY29tbWFuZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtRHJhd1VzYWdlID0gMzUwNDA7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSBzcGVjaWZpZWQgb25jZSBieSByZWFkaW5nIGRhdGEgZnJvbSB0aGUgM0QgQVBJLCBhbmQgcXVlcmllZFxuICogbWFueSB0aW1lcyBieSB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSByZXNwZWNpZmllZCByZXBlYXRlZGx5IGJ5IHJlYWRpbmcgZGF0YSBmcm9tIHRoZSAzRCBBUEksIGFuZCBxdWVyaWVkXG4gKiBtYW55IHRpbWVzIGJ5IHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBEeW5hbWljUmVhZFVzYWdlID0gMzUwNDk7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSBzcGVjaWZpZWQgb25jZSBieSByZWFkaW5nIGRhdGEgZnJvbSB0aGUgM0QgQVBJLCBhbmQgcXVlcmllZCBhdCBtb3N0XG4gKiBhIGZldyB0aW1lcyBieSB0aGUgYXBwbGljYXRpb25cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1SZWFkVXNhZ2UgPSAzNTA0MTtcblxuLyoqXG4gKiBUaGUgY29udGVudHMgYXJlIGludGVuZGVkIHRvIGJlIHNwZWNpZmllZCBvbmNlIGJ5IHJlYWRpbmcgZGF0YSBmcm9tIHRoZSAzRCBBUEksIGFuZCB1c2VkIG1hbnkgdGltZXMgYXNcbiAqIHRoZSBzb3VyY2UgZm9yIFdlYkdMIGRyYXdpbmcgYW5kIGltYWdlIHNwZWNpZmljYXRpb24gY29tbWFuZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgU3RhdGljQ29weVVzYWdlID0gMzUwNDY7XG5cbi8qKlxuICogVGhlIGNvbnRlbnRzIGFyZSBpbnRlbmRlZCB0byBiZSByZXNwZWNpZmllZCByZXBlYXRlZGx5IGJ5IHJlYWRpbmcgZGF0YSBmcm9tIHRoZSAzRCBBUEksIGFuZCB1c2VkIG1hbnkgdGltZXNcbiAqIGFzIHRoZSBzb3VyY2UgZm9yIFdlYkdMIGRyYXdpbmcgYW5kIGltYWdlIHNwZWNpZmljYXRpb24gY29tbWFuZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgRHluYW1pY0NvcHlVc2FnZSA9IDM1MDUwO1xuXG4vKipcbiAqIFRoZSBjb250ZW50cyBhcmUgaW50ZW5kZWQgdG8gYmUgc3BlY2lmaWVkIG9uY2UgYnkgcmVhZGluZyBkYXRhIGZyb20gdGhlIDNEIEFQSSwgYW5kIHVzZWQgYXQgbW9zdCBhIGZldyB0aW1lc1xuICogYXMgdGhlIHNvdXJjZSBmb3IgV2ViR0wgZHJhd2luZyBhbmQgaW1hZ2Ugc3BlY2lmaWNhdGlvbiBjb21tYW5kcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1Db3B5VXNhZ2UgPSAzNTA0MjtcblxuLyoqXG4gKiBHTFNMIDEgc2hhZGVyIGNvZGUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgR0xTTDEgPSAnMTAwJztcblxuLyoqXG4gKiBHTFNMIDMgc2hhZGVyIGNvZGUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuLyoqXG4gKiBXZWJHTCBjb29yZGluYXRlIHN5c3RlbS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gPSAyMDAwO1xuXG4vKipcbiAqIFdlYkdQVSBjb29yZGluYXRlIHN5c3RlbS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydCBjb25zdCBXZWJHUFVDb29yZGluYXRlU3lzdGVtID0gMjAwMTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgdGltZXN0YW1wIHF1ZXJ5IHR5cGVzLlxuICpcbiAqIEB0eXBlIHtDb25zdGFudHNUaW1lc3RhbXBRdWVyeX1cbiAqIEBjb25zdGFudFxuICovXG5leHBvcnQgY29uc3QgVGltZXN0YW1wUXVlcnkgPSB7XG5cdENPTVBVVEU6ICdjb21wdXRlJyxcblx0UkVOREVSOiAncmVuZGVyJ1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIG1vdXNlIGJ1dHRvbnMgYW5kIGludGVyYWN0aW9uIHR5cGVzIGluIGNvbnRleHQgb2YgY29udHJvbHMuXG4gKlxuICogQHR5cGUge0NvbnN0YW50c0ludGVycG9sYXRpb25TYW1wbGluZ1R5cGV9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEludGVycG9sYXRpb25TYW1wbGluZ1R5cGUgPSB7XG5cdFBFUlNQRUNUSVZFOiAncGVyc3BlY3RpdmUnLFxuXHRMSU5FQVI6ICdsaW5lYXInLFxuXHRGTEFUOiAnZmxhdCdcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IGludGVycG9sYXRpb24gc2FtcGxpbmcgbW9kZXMuXG4gKlxuICogQHR5cGUge0NvbnN0YW50c0ludGVycG9sYXRpb25TYW1wbGluZ01vZGV9XG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IEludGVycG9sYXRpb25TYW1wbGluZ01vZGUgPSB7XG5cdE5PUk1BTDogJ25vcm1hbCcsXG5cdENFTlRST0lEOiAnY2VudHJvaWQnLFxuXHRTQU1QTEU6ICdzYW1wbGUnLFxuXHRGTEFUX0ZJUlNUOiAnZmxhdCBmaXJzdCcsXG5cdEZMQVRfRUlUSEVSOiAnZmxhdCBlaXRoZXInXG59O1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIG1vdXNlIGJ1dHRvbnMgYW5kIGludGVyYWN0aW9uIHR5cGVzIGluIGNvbnRleHQgb2YgY29udHJvbHMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RhbnRzTW91c2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNSURETEUgLSBUaGUgbGVmdCBtb3VzZSBidXR0b24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEVGVCAtIFRoZSBtaWRkbGUgbW91c2UgYnV0dG9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFJJR0hUIC0gVGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBST1RBVEUgLSBBIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBET0xMWSAtIEEgZG9sbHkgaW50ZXJhY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gUEFOIC0gQSBwYW4gaW50ZXJhY3Rpb24uXG4gKiovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgdG91Y2ggaW50ZXJhY3Rpb24gdHlwZXMgaW4gY29udGV4dCBvZiBjb250cm9scy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb25zdGFudHNUb3VjaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFJPVEFURSAtIEEgcm90YXRlIGludGVyYWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFBBTiAtIEEgcGFuIGludGVyYWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IERPTExZX1BBTiAtIFRoZSBkb2xseS1wYW4gaW50ZXJhY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gRE9MTFlfUk9UQVRFIC0gQSBkb2xseS1yb3RhdGUgaW50ZXJhY3Rpb24uXG4gKiovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCB0aW1lc3RhbXAgcXVlcnkgdHlwZXMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RhbnRzVGltZXN0YW1wUXVlcnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDT01QVVRFIC0gQSBgY29tcHV0ZWAgdGltZXN0YW1wIHF1ZXJ5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFJFTkRFUiAtIEEgYHJlbmRlcmAgdGltZXN0YW1wIHF1ZXJ5LlxuICoqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCBpbnRlcnBvbGF0aW9uIHNhbXBsaW5nIHR5cGVzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnN0YW50c0ludGVycG9sYXRpb25TYW1wbGluZ1R5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBQRVJTUEVDVElWRSAtIFBlcnNwZWN0aXZlLWNvcnJlY3QgaW50ZXJwb2xhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMSU5FQVIgLSBMaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBGTEFUIC0gRmxhdCBpbnRlcnBvbGF0aW9uLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IGludGVycG9sYXRpb24gc2FtcGxpbmcgbW9kZXMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RhbnRzSW50ZXJwb2xhdGlvblNhbXBsaW5nTW9kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IE5PUk1BTCAtIE5vcm1hbCBzYW1wbGluZyBtb2RlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IENFTlRST0lEIC0gQ2VudHJvaWQgc2FtcGxpbmcgbW9kZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTQU1QTEUgLSBTYW1wbGUtc3BlY2lmaWMgc2FtcGxpbmcgbW9kZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBGTEFUX0ZJUlNUIC0gRmxhdCBpbnRlcnBvbGF0aW9uIHVzaW5nIHRoZSBmaXJzdCB2ZXJ0ZXguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gRkxBVF9FSVRIRVIgLSBGbGF0IGludGVycG9sYXRpb24gdXNpbmcgZWl0aGVyIHZlcnRleC5cbiAqL1xuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZXMgYWxsb3dzIHRvIGRpc3BhdGNoIGV2ZW50IG9iamVjdHMgb24gY3VzdG9tIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBNYWluIHJlcG9zaXRvcnk6IFtldmVudGRpc3BhdGNoZXIuanNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL31cbiAqXG4gKiBDb2RlIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogY2xhc3MgQ2FyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAqIFx0c3RhcnQoKSB7XG4gKlx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3N0YXJ0JywgbWVzc2FnZTogJ3Zyb29tIHZyb29tIScgfSApO1xuICpcdH1cbiAqfTtcbiAqXG4gKiAvLyBVc2luZyBldmVudHMgd2l0aCB0aGUgY3VzdG9tIG9iamVjdFxuICogY29uc3QgY2FyID0gbmV3IENhcigpO1xuICogY2FyLmFkZEV2ZW50TGlzdGVuZXIoICdzdGFydCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gKiBcdGFsZXJ0KCBldmVudC5tZXNzYWdlICk7XG4gKiB9ICk7XG4gKlxuICogY2FyLnN0YXJ0KCk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuXHQgKi9cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBldmVudCBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGV2ZW50IGxpc3RlbmVyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBnaXZlbiBldmVudCB0eXBlLlxuXHQgKi9cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuXHQgKi9cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgYW4gZXZlbnQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgdGhhdCBnZXRzIGZpcmVkLlxuXHQgKi9cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdC8vIE1ha2UgYSBjb3B5LCBpbiBjYXNlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCB3aGlsZSBpdGVyYXRpbmcuXG5cdFx0XHRjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoIDAgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBFdmVudERpc3BhdGNoZXIgfTtcbiIsImNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgW1VVSURde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbGx5X3VuaXF1ZV9pZGVudGlmaWVyfVxuICogKHVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyKS5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVUlELlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0Y29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQxICYgMHhmZiBdICsgX2x1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIF9sdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIF9sdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XG5cblx0Ly8gLnRvTG93ZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuXHRyZXR1cm4gdXVpZC50b0xvd2VyQ2FzZSgpO1xuXG59XG5cbi8qKlxuICogQ2xhbXBzIHRoZSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXggdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjbGFtcGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjbGFtcCggdmFsdWUsIG1pbiwgbWF4ICkge1xuXG5cdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgRXVjbGlkZWFuIG1vZHVsbyBvZiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0aGF0XG4gKiBpcyBgKCAoIG4gJSBtICkgKyBtICkgJSBtYC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBmaXJzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbSAtIFRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgRXVjbGlkZWFuIG1vZHVsby5cbiAqL1xuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cblxuXHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xuXG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIGA8YTEsIGEyPmAgdG8gcmFuZ2UgYDxiMSwgYjI+YFxuICogZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBiZSBtYXBwZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gYTEgLSBNaW5pbXVtIHZhbHVlIGZvciByYW5nZSBBLlxuICogQHBhcmFtIHtudW1iZXJ9IGEyIC0gTWF4aW11bSB2YWx1ZSBmb3IgcmFuZ2UgQS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiMSAtIE1pbmltdW0gdmFsdWUgZm9yIHJhbmdlIEIuXG4gKiBAcGFyYW0ge251bWJlcn0gYjIgLSBNYXhpbXVtIHZhbHVlIGZvciByYW5nZSBCLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBMaW5lYXIoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGVyY2VudGFnZSBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gIG9mIHRoZSBnaXZlbiB2YWx1ZVxuICogYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBzdGFydCBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gQSB2YWx1ZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cbiAqL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdC8vIGh0dHBzOi8vd3d3LmdhbWVkZXYubmV0L3R1dG9yaWFscy9wcm9ncmFtbWluZy9nZW5lcmFsLWFuZC1nYW1lcGxheS1wcm9ncmFtbWluZy9pbnZlcnNlLWxlcnAtYS1zdXBlci11c2VmdWwteWV0LW9mdGVuLW92ZXJsb29rZWQtZnVuY3Rpb24tcjUyMzAvXG5cblx0aWYgKCB4ICE9PSB5ICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgLSB4ICkgLyAoIHkgLSB4ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgZnJvbSB0d28ga25vd24gcG9pbnRzIGJhc2VkIG9uIHRoZSBnaXZlbiBpbnRlcnZhbCAtXG4gKiBgdCA9IDBgIHdpbGwgcmV0dXJuIGB4YCBhbmQgYHQgPSAxYCB3aWxsIHJldHVybiBgeWAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgc3RhcnQgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vKipcbiAqIFNtb290aGx5IGludGVycG9sYXRlIGEgbnVtYmVyIGZyb20gYHhgIHRvIGB5YCBpbiAgYSBzcHJpbmctbGlrZSBtYW5uZXIgdXNpbmcgYSBkZWx0YVxuICogdGltZSB0byBtYWludGFpbiBmcmFtZSByYXRlIGluZGVwZW5kZW50IG1vdmVtZW50LiBGb3IgZGV0YWlscywgc2VlXG4gKiBbRnJhbWUgcmF0ZSBpbmRlcGVuZGVudCBkYW1waW5nIHVzaW5nIGxlcnBde0BsaW5rIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL30uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgY3VycmVudCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsYW1iZGEgLSBBIGhpZ2hlciBsYW1iZGEgdmFsdWUgd2lsbCBtYWtlIHRoZSBtb3ZlbWVudCBtb3JlIHN1ZGRlbixcbiAqIGFuZCBhIGxvd2VyIHZhbHVlIHdpbGwgbWFrZSB0aGUgbW92ZW1lbnQgbW9yZSBncmFkdWFsLlxuICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gRGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBkYW1wKCB4LCB5LCBsYW1iZGEsIGR0ICkge1xuXG5cdHJldHVybiBsZXJwKCB4LCB5LCAxIC0gTWF0aC5leHAoIC0gbGFtYmRhICogZHQgKSApO1xuXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIHRoYXQgYWx0ZXJuYXRlcyBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIGBsZW5ndGhgIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBwaW5ncG9uZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTFdIC0gVGhlIHBvc2l0aXZlIHZhbHVlIHRoZSBmdW5jdGlvbiB3aWxsIHBpbmdwb25nIHRvLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYWx0ZXJuYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGluZ3BvbmcoIHgsIGxlbmd0aCA9IDEgKSB7XG5cblx0Ly8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcblxuXHRyZXR1cm4gbGVuZ3RoIC0gTWF0aC5hYnMoIGV1Y2xpZGVhbk1vZHVsbyggeCwgbGVuZ3RoICogMiApIC0gbGVuZ3RoICk7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGBbMCwxXWAgdGhhdCByZXByZXNlbnRzIHRoZSBwZXJjZW50YWdlIHRoYXQgYHhgIGhhc1xuICogbW92ZWQgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAsIGJ1dCBzbW9vdGhlZCBvciBzbG93ZWQgZG93biB0aGUgY2xvc2VyIGB4YCBpcyB0b1xuICogdGhlIGBtaW5gIGFuZCBgbWF4YC5cbiAqXG4gKiBTZWUgW1Ntb290aHN0ZXBde0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBldmFsdWF0ZSBiYXNlZCBvbiBpdHMgcG9zaXRpb24gYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluIHZhbHVlLiBBbnkgeCB2YWx1ZSBiZWxvdyBtaW4gd2lsbCBiZSBgMGAuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heCB2YWx1ZS4gQW55IHggdmFsdWUgYWJvdmUgbWF4IHdpbGwgYmUgYDFgLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYWx0ZXJuYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc21vb3Roc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG59XG5cbi8qKlxuICogQSBbdmFyaWF0aW9uIG9uIHNtb290aHN0ZXBde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXAjVmFyaWF0aW9uc31cbiAqIHRoYXQgaGFzIHplcm8gMXN0IGFuZCAybmQgb3JkZXIgZGVyaXZhdGl2ZXMgYXQgeD0wIGFuZCB4PTEuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUgYmFzZWQgb24gaXRzIHBvc2l0aW9uIGJldHdlZW4gbWluIGFuZCBtYXguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbiB2YWx1ZS4gQW55IHggdmFsdWUgYmVsb3cgbWluIHdpbGwgYmUgYDBgLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXggdmFsdWUuIEFueSB4IHZhbHVlIGFib3ZlIG1heCB3aWxsIGJlIGAxYC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFsdGVybmF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNtb290aGVyc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGZyb20gYDxsb3csIGhpZ2g+YCBpbnRlcnZhbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IC0gVGhlIGxvd2VyIHZhbHVlIGJvdW5kYXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggLSBUaGUgdXBwZXIgdmFsdWUgYm91bmRhcnlcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gcmFuZEludCggbG93LCBoaWdoICkge1xuXG5cdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGZsb2F0IGZyb20gYDxsb3csIGhpZ2g+YCBpbnRlcnZhbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IC0gVGhlIGxvd2VyIHZhbHVlIGJvdW5kYXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggLSBUaGUgdXBwZXIgdmFsdWUgYm91bmRhcnlcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gZmxvYXQuXG4gKi9cbmZ1bmN0aW9uIHJhbmRGbG9hdCggbG93LCBoaWdoICkge1xuXG5cdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgZnJvbSBgPC1yYW5nZS8yLCByYW5nZS8yPmAgaW50ZXJ2YWwuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlIC0gRGVmaW5lcyB0aGUgdmFsdWUgcmFuZ2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0LlxuICovXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgYFswLCAxXWAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzXSAtIFRoZSBpbnRlZ2VyIHNlZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0LlxuICovXG5mdW5jdGlvbiBzZWVkZWRSYW5kb20oIHMgKSB7XG5cblx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSBfc2VlZCA9IHM7XG5cblx0Ly8gTXVsYmVycnkzMiBnZW5lcmF0b3JcblxuXHRsZXQgdCA9IF9zZWVkICs9IDB4NkQyQjc5RjU7XG5cblx0dCA9IE1hdGguaW11bCggdCBeIHQgPj4+IDE1LCB0IHwgMSApO1xuXG5cdHQgXj0gdCArIE1hdGguaW11bCggdCBeIHQgPj4+IDcsIHQgfCA2MSApO1xuXG5cdHJldHVybiAoICggdCBeIHQgPj4+IDE0ICkgPj4+IDAgKSAvIDQyOTQ5NjcyOTY7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgLSBBIHZhbHVlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb252ZXJ0ZWQgdmFsdWUgaW4gcmFkaWFucy5cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoIGRlZ3JlZXMgKSB7XG5cblx0cmV0dXJuIGRlZ3JlZXMgKiBERUcyUkFEO1xuXG59XG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIC0gQSB2YWx1ZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29udmVydGVkIHZhbHVlIGluIGRlZ3JlZXMuXG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKCByYWRpYW5zICkge1xuXG5cdHJldHVybiByYWRpYW5zICogUkFEMkRFRztcblxufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBudW1iZXIgaXMgYSBwb3dlciBvZiB0d28uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvIG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNQb3dlck9mVHdvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaW5kIGEgUE9UIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBjZWlsUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmNlaWwoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFyZ2VzdCBwb3dlciBvZiB0d28gdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmluZCBhIFBPVCBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsYXJnZXN0IHBvd2VyIG9mIHR3byB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIGZyb20gdGhlIFtJbnRyaW5zaWMgUHJvcGVyIEV1bGVyIEFuZ2xlc117QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzfVxuICogZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYW5nbGVzIGFuZCBvcmRlci5cbiAqXG4gKiBSb3RhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGF4ZXMgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBieSBvcmRlcjpcbiAqIHJvdGF0aW9uIGJ5IGFuZ2xlIGBhYCBpcyBhcHBsaWVkIGZpcnN0LCB0aGVuIGJ5IGFuZ2xlIGBiYCwgdGhlbiBieSBhbmdsZSBgY2AuXG4gKlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIC0gVGhlIHF1YXRlcm5pb24gdG8gc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGEgLSBUaGUgcm90YXRpb24gYXBwbGllZCB0byB0aGUgZmlyc3QgYXhpcywgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIHJvdGF0aW9uIGFwcGxpZWQgdG8gdGhlIHNlY29uZCBheGlzLCBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtudW1iZXJ9IGMgLSBUaGUgcm90YXRpb24gYXBwbGllZCB0byB0aGUgdGhpcmQgYXhpcywgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7KCdYWVgnfCdYWlgnfCdZWFknfCdZWlknfCdaWFonfCdaWVonKX0gb3JkZXIgLSBBIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBheGVzIG9yZGVyLlxuICovXG5mdW5jdGlvbiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCBxLCBhLCBiLCBjLCBvcmRlciApIHtcblxuXHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0Y29uc3Qgc2luID0gTWF0aC5zaW47XG5cblx0Y29uc3QgYzIgPSBjb3MoIGIgLyAyICk7XG5cdGNvbnN0IHMyID0gc2luKCBiIC8gMiApO1xuXG5cdGNvbnN0IGMxMyA9IGNvcyggKCBhICsgYyApIC8gMiApO1xuXHRjb25zdCBzMTMgPSBzaW4oICggYSArIGMgKSAvIDIgKTtcblxuXHRjb25zdCBjMV8zID0gY29zKCAoIGEgLSBjICkgLyAyICk7XG5cdGNvbnN0IHMxXzMgPSBzaW4oICggYSAtIGMgKSAvIDIgKTtcblxuXHRjb25zdCBjM18xID0gY29zKCAoIGMgLSBhICkgLyAyICk7XG5cdGNvbnN0IHMzXzEgPSBzaW4oICggYyAtIGEgKSAvIDIgKTtcblxuXHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdGNhc2UgJ1hZWCc6XG5cdFx0XHRxLnNldCggYzIgKiBzMTMsIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdZWlknOlxuXHRcdFx0cS5zZXQoIHMyICogczFfMywgYzIgKiBzMTMsIHMyICogYzFfMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWlhaJzpcblx0XHRcdHEuc2V0KCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBzMTMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1haWCc6XG5cdFx0XHRxLnNldCggYzIgKiBzMTMsIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdZWFknOlxuXHRcdFx0cS5zZXQoIHMyICogYzNfMSwgYzIgKiBzMTMsIHMyICogczNfMSwgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWllaJzpcblx0XHRcdHEuc2V0KCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBzMTMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoVXRpbHM6IC5zZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogRGVub3JtYWxpemVzIHRoZSBnaXZlbiB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHR5cGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZW5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gYXJyYXkgLSBUaGUgdHlwZWQgYXJyYXkgdGhhdCBkZWZpbmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGVub3JtYWxpemUgKGZsb2F0KSB2YWx1ZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cbiAqL1xuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB0eXBlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgZmxvYXQgdmFsdWUgaW4gdGhlIHJhbmdlIGBbMCwxXWAgdG8gbm9ybWFsaXplLlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSBhcnJheSAtIFRoZSB0eXBlZCBhcnJheSB0aGF0IGRlZmluZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBub3JtYWxpemUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQSBjb2xsZWN0aW9uIG9mIG1hdGggdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IE1hdGhVdGlscyA9IHtcblx0REVHMlJBRDogREVHMlJBRCxcblx0UkFEMkRFRzogUkFEMkRFRyxcblx0LyoqXG5cdCAqIEdlbmVyYXRlIGEgW1VVSURde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbGx5X3VuaXF1ZV9pZGVudGlmaWVyfVxuXHQgKiAodW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIpLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVVJRC5cblx0ICovXG5cdGdlbmVyYXRlVVVJRDogZ2VuZXJhdGVVVUlELFxuXHQvKipcblx0ICogQ2xhbXBzIHRoZSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNsYW1wLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbiB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXggdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNsYW1wZWQgdmFsdWUuXG5cdCAqL1xuXHRjbGFtcDogY2xhbXAsXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgRXVjbGlkZWFuIG1vZHVsbyBvZiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0aGF0XG5cdCAqIGlzIGAoICggbiAlIG0gKSArIG0gKSAlIG1gLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgZmlyc3QgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbSAtIFRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBFdWNsaWRlYW4gbW9kdWxvLlxuXHQgKi9cblx0ZXVjbGlkZWFuTW9kdWxvOiBldWNsaWRlYW5Nb2R1bG8sXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIGxpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgYDxhMSwgYTI+YCB0byByYW5nZSBgPGIxLCBiMj5gXG5cdCAqIGZvciB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBiZSBtYXBwZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhMSAtIE1pbmltdW0gdmFsdWUgZm9yIHJhbmdlIEEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhMiAtIE1heGltdW0gdmFsdWUgZm9yIHJhbmdlIEEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBiMSAtIE1pbmltdW0gdmFsdWUgZm9yIHJhbmdlIEIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBiMiAtIE1heGltdW0gdmFsdWUgZm9yIHJhbmdlIEIuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCB2YWx1ZS5cblx0ICovXG5cdG1hcExpbmVhcjogbWFwTGluZWFyLFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGVyY2VudGFnZSBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gIG9mIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKiBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgc3RhcnQgcG9pbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBBIHZhbHVlIGJldHdlZW4gc3RhcnQgYW5kIGVuZC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqL1xuXHRpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgbGluZWFybHkgaW50ZXJwb2xhdGVkIGZyb20gdHdvIGtub3duIHBvaW50cyBiYXNlZCBvbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgLVxuXHQgKiBgdCA9IDBgIHdpbGwgcmV0dXJuIGB4YCBhbmQgYHQgPSAxYCB3aWxsIHJldHVybiBgeWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBzdGFydCBwb2ludFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZS5cblx0ICovXG5cdGxlcnA6IGxlcnAsXG5cdC8qKlxuXHQgKiBTbW9vdGhseSBpbnRlcnBvbGF0ZSBhIG51bWJlciBmcm9tIGB4YCB0byBgeWAgaW4gIGEgc3ByaW5nLWxpa2UgbWFubmVyIHVzaW5nIGEgZGVsdGFcblx0ICogdGltZSB0byBtYWludGFpbiBmcmFtZSByYXRlIGluZGVwZW5kZW50IG1vdmVtZW50LiBGb3IgZGV0YWlscywgc2VlXG5cdCAqIFtGcmFtZSByYXRlIGluZGVwZW5kZW50IGRhbXBpbmcgdXNpbmcgbGVycF17QGxpbmsgaHR0cDovL3d3dy5yb3J5ZHJpc2NvbGwuY29tLzIwMTYvMDMvMDcvZnJhbWUtcmF0ZS1pbmRlcGVuZGVudC1kYW1waW5nLXVzaW5nLWxlcnAvfS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWV0aG9kXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGN1cnJlbnQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHRhcmdldCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhbWJkYSAtIEEgaGlnaGVyIGxhbWJkYSB2YWx1ZSB3aWxsIG1ha2UgdGhlIG1vdmVtZW50IG1vcmUgc3VkZGVuLFxuXHQgKiBhbmQgYSBsb3dlciB2YWx1ZSB3aWxsIG1ha2UgdGhlIG1vdmVtZW50IG1vcmUgZ3JhZHVhbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gRGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG5cdCAqL1xuXHRkYW1wOiBkYW1wLFxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIHRoYXQgYWx0ZXJuYXRlcyBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIGBsZW5ndGhgIHBhcmFtZXRlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWV0aG9kXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHZhbHVlIHRvIHBpbmdwb25nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0xXSAtIFRoZSBwb3NpdGl2ZSB2YWx1ZSB0aGUgZnVuY3Rpb24gd2lsbCBwaW5ncG9uZyB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgYWx0ZXJuYXRlZCB2YWx1ZS5cblx0ICovXG5cdHBpbmdwb25nOiBwaW5ncG9uZyxcblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbiB0aGUgcmFuZ2UgYFswLDFdYCB0aGF0IHJlcHJlc2VudHMgdGhlIHBlcmNlbnRhZ2UgdGhhdCBgeGAgaGFzXG5cdCAqIG1vdmVkIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLCBidXQgc21vb3RoZWQgb3Igc2xvd2VkIGRvd24gdGhlIGNsb3NlciBgeGAgaXMgdG9cblx0ICogdGhlIGBtaW5gIGFuZCBgbWF4YC5cblx0ICpcblx0ICogU2VlIFtTbW9vdGhzdGVwXXtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXB9IGZvciBtb3JlIGRldGFpbHMuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBldmFsdWF0ZSBiYXNlZCBvbiBpdHMgcG9zaXRpb24gYmV0d2VlbiBtaW4gYW5kIG1heC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW4gdmFsdWUuIEFueSB4IHZhbHVlIGJlbG93IG1pbiB3aWxsIGJlIGAwYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXggdmFsdWUuIEFueSB4IHZhbHVlIGFib3ZlIG1heCB3aWxsIGJlIGAxYC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgYWx0ZXJuYXRlZCB2YWx1ZS5cblx0ICovXG5cdHNtb290aHN0ZXA6IHNtb290aHN0ZXAsXG5cdC8qKlxuXHQgKiBBIFt2YXJpYXRpb24gb24gc21vb3Roc3RlcF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcCNWYXJpYXRpb25zfVxuXHQgKiB0aGF0IGhhcyB6ZXJvIDFzdCBhbmQgMm5kIG9yZGVyIGRlcml2YXRpdmVzIGF0IHg9MCBhbmQgeD0xLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUgYmFzZWQgb24gaXRzIHBvc2l0aW9uIGJldHdlZW4gbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluIHZhbHVlLiBBbnkgeCB2YWx1ZSBiZWxvdyBtaW4gd2lsbCBiZSBgMGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4IHZhbHVlLiBBbnkgeCB2YWx1ZSBhYm92ZSBtYXggd2lsbCBiZSBgMWAuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFsdGVybmF0ZWQgdmFsdWUuXG5cdCAqL1xuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0LyoqXG5cdCAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBmcm9tIGA8bG93LCBoaWdoPmAgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG93IC0gVGhlIGxvd2VyIHZhbHVlIGJvdW5kYXJ5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGlnaCAtIFRoZSB1cHBlciB2YWx1ZSBib3VuZGFyeVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIuXG5cdCAqL1xuXHRyYW5kSW50OiByYW5kSW50LFxuXHQvKipcblx0ICogUmV0dXJucyBhIHJhbmRvbSBmbG9hdCBmcm9tIGA8bG93LCBoaWdoPmAgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG93IC0gVGhlIGxvd2VyIHZhbHVlIGJvdW5kYXJ5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGlnaCAtIFRoZSB1cHBlciB2YWx1ZSBib3VuZGFyeVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0LlxuXHQgKi9cblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgZnJvbSBgPC1yYW5nZS8yLCByYW5nZS8yPmAgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UgLSBEZWZpbmVzIHRoZSB2YWx1ZSByYW5nZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdC5cblx0ICovXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHQvKipcblx0ICogUmV0dXJucyBhIGRldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3NdIC0gVGhlIGludGVnZXIgc2VlZC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdC5cblx0ICovXG5cdHNlZWRlZFJhbmRvbTogc2VlZGVkUmFuZG9tLFxuXHQvKipcblx0ICogQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgLSBBIHZhbHVlIGluIGRlZ3JlZXMuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbnZlcnRlZCB2YWx1ZSBpbiByYWRpYW5zLlxuXHQgKi9cblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHQvKipcblx0ICogQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgLSBBIHZhbHVlIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbnZlcnRlZCB2YWx1ZSBpbiBkZWdyZWVzLlxuXHQgKi9cblx0cmFkVG9EZWc6IHJhZFRvRGVnLFxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3by5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWV0aG9kXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvIG9yIG5vdC5cblx0ICovXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmluZCBhIFBPVCBmb3IuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyLlxuXHQgKi9cblx0Y2VpbFBvd2VyT2ZUd286IGNlaWxQb3dlck9mVHdvLFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGFyZ2VzdCBwb3dlciBvZiB0d28gdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWV0aG9kXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaW5kIGEgUE9UIGZvci5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGFyZ2VzdCBwb3dlciBvZiB0d28gdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlci5cblx0ICovXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBmcm9tIHRoZSBbSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXNde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX2FuZ2xlc31cblx0ICogZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYW5nbGVzIGFuZCBvcmRlci5cblx0ICpcblx0ICogUm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgb3JkZXI6XG5cdCAqIHJvdGF0aW9uIGJ5IGFuZ2xlIGBhYCBpcyBhcHBsaWVkIGZpcnN0LCB0aGVuIGJ5IGFuZ2xlIGBiYCwgdGhlbiBieSBhbmdsZSBgY2AuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgLSBUaGUgcXVhdGVybmlvbiB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gVGhlIHJvdGF0aW9uIGFwcGxpZWQgdG8gdGhlIGZpcnN0IGF4aXMsIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIHJvdGF0aW9uIGFwcGxpZWQgdG8gdGhlIHNlY29uZCBheGlzLCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYyAtIFRoZSByb3RhdGlvbiBhcHBsaWVkIHRvIHRoZSB0aGlyZCBheGlzLCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0geygnWFlYJ3wnWFpYJ3wnWVhZJ3wnWVpZJ3wnWlhaJ3wnWllaJyl9IG9yZGVyIC0gQSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgYXhlcyBvcmRlci5cblx0ICovXG5cdHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6IHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIsXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHR5cGVkIGFycmF5LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGZsb2F0IHZhbHVlIGluIHRoZSByYW5nZSBgWzAsMV1gIHRvIG5vcm1hbGl6ZS5cblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBhcnJheSAtIFRoZSB0eXBlZCBhcnJheSB0aGF0IGRlZmluZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5vcm1hbGl6ZSB2YWx1ZS5cblx0ICovXG5cdG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuXHQvKipcblx0ICogRGVub3JtYWxpemVzIHRoZSBnaXZlbiB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHR5cGVkIGFycmF5LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlbm9ybWFsaXplLlxuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGFycmF5IC0gVGhlIHR5cGVkIGFycmF5IHRoYXQgZGVmaW5lcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB2YWx1ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGVub3JtYWxpemUgKGZsb2F0KSB2YWx1ZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICovXG5cdGRlbm9ybWFsaXplOiBkZW5vcm1hbGl6ZVxufTtcblxuZXhwb3J0IHtcblx0REVHMlJBRCxcblx0UkFEMkRFRyxcblx0Z2VuZXJhdGVVVUlELFxuXHRjbGFtcCxcblx0ZXVjbGlkZWFuTW9kdWxvLFxuXHRtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwLFxuXHRsZXJwLFxuXHRkYW1wLFxuXHRwaW5ncG9uZyxcblx0c21vb3Roc3RlcCxcblx0c21vb3RoZXJzdGVwLFxuXHRyYW5kSW50LFxuXHRyYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZCxcblx0c2VlZGVkUmFuZG9tLFxuXHRkZWdUb1JhZCxcblx0cmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3byxcblx0Y2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3byxcblx0c2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcixcblx0bm9ybWFsaXplLFxuXHRkZW5vcm1hbGl6ZSxcblx0TWF0aFV0aWxzXG59O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgMkQgdmVjdG9yLiBBIDJEIHZlY3RvciBpcyBhbiBvcmRlcmVkIHBhaXIgb2YgbnVtYmVyc1xuICogKGxhYmVsZWQgeCBhbmQgeSksIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhIG51bWJlciBvZiB0aGluZ3MsIHN1Y2ggYXM6XG4gKlxuICogLSBBIHBvaW50IGluIDJEIHNwYWNlIChpLmUuIGEgcG9zaXRpb24gb24gYSBwbGFuZSkuXG4gKiAtIEEgZGlyZWN0aW9uIGFuZCBsZW5ndGggYWNyb3NzIGEgcGxhbmUuIEluIHRocmVlLmpzIHRoZSBsZW5ndGggd2lsbFxuICogYWx3YXlzIGJlIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2Uoc3RyYWlnaHQtbGluZSBkaXN0YW5jZSkgZnJvbSBgKDAsIDApYCB0byBgKHgsIHkpYFxuICogYW5kIHRoZSBkaXJlY3Rpb24gaXMgYWxzbyBtZWFzdXJlZCBmcm9tIGAoMCwgMClgIHRvd2FyZHMgYCh4LCB5KWAuXG4gKiAtIEFueSBhcmJpdHJhcnkgb3JkZXJlZCBwYWlyIG9mIG51bWJlcnMuXG4gKlxuICogVGhlcmUgYXJlIG90aGVyIHRoaW5ncyBhIDJEIHZlY3RvciBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQsIHN1Y2ggYXNcbiAqIG1vbWVudHVtIHZlY3RvcnMsIGNvbXBsZXggbnVtYmVycyBhbmQgc28gb24sIGhvd2V2ZXIgdGhlc2UgYXJlIHRoZSBtb3N0XG4gKiBjb21tb24gdXNlcyBpbiB0aHJlZS5qcy5cbiAqXG4gKiBJdGVyYXRpbmcgdGhyb3VnaCBhIHZlY3RvciBpbnN0YW5jZSB3aWxsIHlpZWxkIGl0cyBjb21wb25lbnRzIGAoeCwgeSlgIGluXG4gKiB0aGUgY29ycmVzcG9uZGluZyBvcmRlci5cbiAqIGBgYGpzXG4gKiBjb25zdCBhID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDEgKTtcbiAqXG4gKiAvL25vIGFyZ3VtZW50czsgd2lsbCBiZSBpbml0aWFsaXNlZCB0byAoMCwgMClcbiAqIGNvbnN0IGIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKTtcbiAqXG4gKiBjb25zdCBkID0gYS5kaXN0YW5jZVRvKCBiICk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgVmVjdG9yMiB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgMkQgdmVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB4IHZhbHVlIG9mIHRoaXMgdmVjdG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHkgdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueSA9IHk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbGlhcyBmb3Ige0BsaW5rIFZlY3RvcjIjeH0uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgd2lkdGgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54O1xuXG5cdH1cblxuXHRzZXQgd2lkdGgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy54ID0gdmFsdWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbGlhcyBmb3Ige0BsaW5rIFZlY3RvcjIjeX0uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgaGVpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueTtcblxuXHR9XG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBvZiB0aGUgeCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIG9mIHRoZSB5IGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXQoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHZhbHVlIHRvIHNldCBmb3IgYWxsIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeCBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWxsb3dzIHRvIHNldCBhIHZlY3RvciBjb21wb25lbnQgd2l0aCBhbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGNvbXBvbmVudCBpbmRleC4gYDBgIGVxdWFscyB0byB4LCBgMWAgZXF1YWxzIHRvIHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB2ZWN0b3IgY29tcG9uZW50IHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgY29tcG9uZW50IGluZGV4LiBgMGAgZXF1YWxzIHRvIHgsIGAxYCBlcXVhbHMgdG8geS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBBIHZlY3RvciBjb21wb25lbnQgdmFsdWUuXG5cdCAqL1xuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUgdG8gYWxsIGNvbXBvbmVudHMgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHMgLSBUaGUgc2NhbGFyIHRvIGFkZC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9ycyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBhIC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBiIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIGZhY3RvciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYgLSBUaGUgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBmYWN0b3IgdGhhdCBzY2FsZXMgYHZgLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdiAtIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHNjYWxhciB2YWx1ZSBmcm9tIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBzdWJ0cmFjdC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3JzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IGEgLSBUaGUgZmlyc3QgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IGIgLSBUaGUgc2Vjb25kIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGUgZ2l2ZW4gdmVjdG9yIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBtdWx0aXBseS5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGUgZ2l2ZW4gc2NhbGFyIHZhbHVlIHdpdGggYWxsIGNvbXBvbmVudHMgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bXVsdGlwbHlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlcyB0aGlzIGluc3RhbmNlIGJ5IHRoZSBnaXZlbiB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdiAtIFRoZSB2ZWN0b3IgdG8gZGl2aWRlLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGRpdmlkZSggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB0byBkaXZpZGUuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciAod2l0aCBhbiBpbXBsaWNpdCAxIGFzIHRoZSAzcmQgY29tcG9uZW50KSBieVxuXHQgKiB0aGUgZ2l2ZW4gM3gzIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIG1hdHJpeCB0byBhcHBseS5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF07XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCBvciB5IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gdmVjdG9yJ3MgeCBvciB5XG5cdCAqIHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtaW4gdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdiAtIFRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bWluKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCBvciB5IHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gdmVjdG9yJ3MgeCBvciB5XG5cdCAqIHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtYXggdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdiAtIFRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bWF4KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCBvciB5IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IHZlY3RvcidzIHggb3IgeVxuXHQgKiB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCBvciB5IHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluIHZlY3RvcidzIHggb3IgeSB2YWx1ZSxcblx0ICogaXQgaXMgcmVwbGFjZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gbWluIC0gVGhlIG1pbmltdW0geCBhbmQgeSB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gbWF4IC0gVGhlIG1heGltdW0geCBhbmQgeSB2YWx1ZXMgaW4gdGhlIGRlc2lyZWQgcmFuZ2UuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y2xhbXAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IGNsYW1wKCB0aGlzLngsIG1pbi54LCBtYXgueCApO1xuXHRcdHRoaXMueSA9IGNsYW1wKCB0aGlzLnksIG1pbi55LCBtYXgueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGlzIHZlY3RvcidzIHggb3IgeSB2YWx1ZXMgYXJlIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IHZhbHVlLCB0aGV5IGFyZVxuXHQgKiByZXBsYWNlZCBieSB0aGUgbWF4IHZhbHVlLlxuXHQgKiBJZiB0aGlzIHZlY3RvcidzIHggb3IgeSB2YWx1ZXMgYXJlIGxlc3MgdGhhbiB0aGUgbWluIHZhbHVlLCB0aGV5IGFyZVxuXHQgKiByZXBsYWNlZCBieSB0aGUgbWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluVmFsIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4VmFsIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IGNsYW1wKCB0aGlzLngsIG1pblZhbCwgbWF4VmFsICk7XG5cdFx0dGhpcy55ID0gY2xhbXAoIHRoaXMueSwgbWluVmFsLCBtYXhWYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5XG5cdCAqIHRoZSBtYXggdmFsdWUuXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgbWluIHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieSB0aGVcblx0ICogbWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIHZlY3RvciBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIHZlY3RvciBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIGNsYW1wKCBsZW5ndGgsIG1pbiwgbWF4ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGFyZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWVcblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhcmUgcm91bmRlZCB0b3dhcmRzIHplcm8gKHVwIGlmIG5lZ2F0aXZlLFxuXHQgKiBkb3duIGlmIHBvc2l0aXZlKSB0byBhbiBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEludmVydHMgdGhpcyB2ZWN0b3IgLSBpLmUuIHNldHMgeCA9IC14IGFuZCB5ID0gLXkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBnaXZlbiB2ZWN0b3Igd2l0aCB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc3VsdCBvZiB0aGUgZG90IHByb2R1Y3QuXG5cdCAqL1xuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc3VsdCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cblx0ICovXG5cdGNyb3NzKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIEV1Y2xpZGVhbiBsZW5ndGggKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tXG5cdCAqICgwLCAwKSB0byAoeCwgeSkuIElmIHlvdSBhcmUgY29tcGFyaW5nIHRoZSBsZW5ndGhzIG9mIHZlY3RvcnMsIHlvdSBzaG91bGRcblx0ICogY29tcGFyZSB0aGUgbGVuZ3RoIHNxdWFyZWQgaW5zdGVhZCBhcyBpdCBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRsZW5ndGhTcSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgIEV1Y2xpZGVhbiBsZW5ndGggKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tICgwLCAwKSB0byAoeCwgeSkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIE1hbmhhdHRhbiBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICovXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGlzIHZlY3RvciB0byBhIHVuaXQgdmVjdG9yIC0gdGhhdCBpcywgc2V0cyBpdCBlcXVhbCB0byBhIHZlY3RvclxuXHQgKiB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0IHdpdGggYSB2ZWN0b3IgbGVuZ3RoIG9mIGAxYC5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRub3JtYWxpemUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb2YgdGhpcyB2ZWN0b3Igd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqL1xuXHRhbmdsZSgpIHtcblxuXHRcdGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMiggLSB0aGlzLnksIC0gdGhpcy54ICkgKyBNYXRoLlBJO1xuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgZ2l2ZW4gdmVjdG9yIGFuZCB0aGlzIGluc3RhbmNlIGluIHJhZGlhbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdiAtIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgYW5nbGUgd2l0aC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICovXG5cdGFuZ2xlVG8oIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaXN0YW5jZS5cblx0ICovXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKiBJZiB5b3UgYXJlIGp1c3QgY29tcGFyaW5nIHRoZSBkaXN0YW5jZSB3aXRoIGFub3RoZXIgZGlzdGFuY2UsIHlvdSBzaG91bGQgY29tcGFyZVxuXHQgKiB0aGUgZGlzdGFuY2Ugc3F1YXJlZCBpbnN0ZWFkIGFzIGl0IGlzIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50IHRvIGNhbGN1bGF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBzcXVhcmVkIGRpc3RhbmNlIHRvLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIGRpc3RhbmNlLlxuXHQgKi9cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIE1hbmhhdHRhbiBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2IC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBNYW5oYXR0YW4gZGlzdGFuY2UgdG8uXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIE1hbmhhdHRhbiBkaXN0YW5jZS5cblx0ICovXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHZlY3RvciB0byBhIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0XG5cdCAqIHdpdGggdGhlIHNwZWNpZmllZCBsZW5ndGguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBUaGUgbmV3IGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRMZW5ndGgoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHRoZSBnaXZlbiB2ZWN0b3IgYW5kIHRoaXMgaW5zdGFuY2UsIHdoZXJlXG5cdCAqIGFscGhhIGlzIHRoZSBwZXJjZW50IGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIC0gYWxwaGEgPSAwIHdpbGwgYmUgdGhpc1xuXHQgKiB2ZWN0b3IsIGFuZCBhbHBoYSA9IDEgd2lsbCBiZSB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYgLSBUaGUgdmVjdG9yIHRvIGludGVycG9sYXRlIHRvd2FyZHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciwgdHlwaWNhbGx5IGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bGVycCggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHRoZSBnaXZlbiB2ZWN0b3JzLCB3aGVyZSBhbHBoYSBpcyB0aGUgcGVyY2VudFxuXHQgKiBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSAtIGFscGhhID0gMCB3aWxsIGJlIGZpcnN0IHZlY3RvciwgYW5kIGFscGhhID0gMSB3aWxsXG5cdCAqIGJlIHRoZSBzZWNvbmQgb25lLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxIC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSB2MiAtIFRoZSBzZWNvbmQgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IsIHR5cGljYWxseSBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyB2ZWN0b3IgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYgLSBUaGUgdmVjdG9yIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmVjdG9yIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyB2ZWN0b3IncyB4IHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0IF1gIGFuZCB5XG5cdCAqIHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0ICsgMSBdYC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnJheSAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHZlY3RvciBjb21wb25lbnQgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIFRoZSBvZmZzZXQgaW50byB0aGUgYXJyYXkuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKi9cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBmcm9tIHRoZSBnaXZlbiBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIC0gVGhlIGJ1ZmZlciBhdHRyaWJ1dGUgaG9sZGluZyB2ZWN0b3IgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhpcyB2ZWN0b3IgYXJvdW5kIHRoZSBnaXZlbiBjZW50ZXIgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IGNlbnRlciAtIFRoZSBwb2ludCBhcm91bmQgd2hpY2ggdG8gcm90YXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgdG8gcm90YXRlLCBpbiByYWRpYW5zLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHJvdGF0ZUFyb3VuZCggY2VudGVyLCBhbmdsZSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggYW5nbGUgKSwgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuXHRcdGNvbnN0IHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcblxuXHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgZWFjaCBjb21wb25lbnQgb2YgdGhpcyB2ZWN0b3IgdG8gYSBwc2V1ZG8tcmFuZG9tIHZhbHVlIGJldHdlZW4gYDBgIGFuZFxuXHQgKiBgMWAsIGV4Y2x1ZGluZyBgMWAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy54O1xuXHRcdHlpZWxkIHRoaXMueTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgVmVjdG9yMiB9O1xuIiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgM3gzIG1hdHJpeC5cbiAqXG4gKiBBIE5vdGUgb24gUm93LU1ham9yIGFuZCBDb2x1bW4tTWFqb3IgT3JkZXJpbmc6XG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIGFuZCB7QGxpbmsgTWF0cml4MyNzZXR9IG1ldGhvZCB0YWtlIGFyZ3VtZW50cyBpblxuICogW3Jvdy1tYWpvcl17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcn1cbiAqIG9yZGVyLCB3aGlsZSBpbnRlcm5hbGx5IHRoZXkgYXJlIHN0b3JlZCBpbiB0aGUge0BsaW5rIE1hdHJpeDMjZWxlbWVudHN9IGFycmF5IGluIGNvbHVtbi1tYWpvciBvcmRlci5cbiAqIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nOlxuICogYGBganNcbiAqIGNvbnN0IG0gPSBuZXcgVEhSRUUuTWF0cml4KCk7XG4gKiBtLnNldCggMTEsIDEyLCAxMyxcbiAqICAgICAgICAyMSwgMjIsIDIzLFxuICogICAgICAgIDMxLCAzMiwgMzMgKTtcbiAqIGBgYFxuICogd2lsbCByZXN1bHQgaW4gdGhlIGVsZW1lbnRzIGFycmF5IGNvbnRhaW5pbmc6XG4gKiBgYGBqc1xuICogbS5lbGVtZW50cyA9IFsgMTEsIDIxLCAzMSxcbiAqICAgICAgICAgICAgICAgIDEyLCAyMiwgMzIsXG4gKiAgICAgICAgICAgICAgICAxMywgMjMsIDMzIF07XG4gKiBgYGBcbiAqIGFuZCBpbnRlcm5hbGx5IGFsbCBjYWxjdWxhdGlvbnMgYXJlIHBlcmZvcm1lZCB1c2luZyBjb2x1bW4tbWFqb3Igb3JkZXJpbmcuXG4gKiBIb3dldmVyLCBhcyB0aGUgYWN0dWFsIG9yZGVyaW5nIG1ha2VzIG5vIGRpZmZlcmVuY2UgbWF0aGVtYXRpY2FsbHkgYW5kXG4gKiBtb3N0IHBlb3BsZSBhcmUgdXNlZCB0byB0aGlua2luZyBhYm91dCBtYXRyaWNlcyBpbiByb3ctbWFqb3Igb3JkZXIsIHRoZVxuICogdGhyZWUuanMgZG9jdW1lbnRhdGlvbiBzaG93cyBtYXRyaWNlcyBpbiByb3ctbWFqb3Igb3JkZXIuIEp1c3QgYmVhciBpblxuICogbWluZCB0aGF0IGlmIHlvdSBhcmUgcmVhZGluZyB0aGUgc291cmNlIGNvZGUsIHlvdSdsbCBoYXZlIHRvIHRha2UgdGhlXG4gKiB0cmFuc3Bvc2Ugb2YgYW55IG1hdHJpY2VzIG91dGxpbmVkIGhlcmUgdG8gbWFrZSBzZW5zZSBvZiB0aGUgY2FsY3VsYXRpb25zLlxuICovXG5jbGFzcyBNYXRyaXgzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyAzeDMgbWF0cml4LiBUaGUgYXJndW1lbnRzIGFyZSBzdXBwb3NlZCB0byBiZVxuXHQgKiBpbiByb3ctbWFqb3Igb3JkZXIuIElmIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBpbml0aWFsaXplcyB0aGUgbWF0cml4IGFzIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTFdIC0gMS0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xMl0gLSAxLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjEzXSAtIDEtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMjFdIC0gMi0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24yMl0gLSAyLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjIzXSAtIDItMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMzFdIC0gMy0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24zMl0gLSAzLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjMzXSAtIDMtMyBtYXRyaXggZWxlbWVudC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0TWF0cml4My5wcm90b3R5cGUuaXNNYXRyaXgzID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgY29sdW1uLW1ham9yIGxpc3Qgb2YgbWF0cml4IHZhbHVlcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuXHRcdCAqL1xuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0XTtcblxuXHRcdGlmICggbjExICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc2V0KCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGUgbWF0cml4LlRoZSBhcmd1bWVudHMgYXJlIHN1cHBvc2VkIHRvIGJlXG5cdCAqIGluIHJvdy1tYWpvciBvcmRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTFdIC0gMS0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xMl0gLSAxLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjEzXSAtIDEtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMjFdIC0gMi0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24yMl0gLSAyLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjIzXSAtIDItMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMzFdIC0gMy0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24zMl0gLSAzLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjMzXSAtIDMtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIG1hdHJpeCB0byB0aGUgM3gzIGlkZW50aXR5IG1hdHJpeC5cblx0ICpcblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXggdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIG1hdHJpeCB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGNvcHkoIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTtcblx0XHR0ZVsgMyBdID0gbWVbIDMgXTsgdGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdO1xuXHRcdHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTsgdGVbIDggXSA9IG1lWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHRoZSBiYXNpcyBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSB0aHJlZSBheGlzIHZlY3RvcnMgcHJvdmlkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30geEF4aXMgLSBUaGUgYmFzaXMncyB4IGF4aXMuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30geUF4aXMgLSBUaGUgYmFzaXMncyB5IGF4aXMuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gekF4aXMgLSBUaGUgYmFzaXMncyB6IGF4aXMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0ZXh0cmFjdEJhc2lzKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGlzIG1hdHJpeCB0byB0aGUgdXBwZXIgM3gzIG1hdHJpeCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIDR4NCBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0c2V0RnJvbU1hdHJpeDQoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbIDggXSxcblx0XHRcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyA5IF0sXG5cdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUG9zdC1tdWx0aXBsaWVzIHRoaXMgbWF0cml4IGJ5IHRoZSBnaXZlbiAzeDMgbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDN9IG0gLSBUaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcmUtbXVsdGlwbGllcyB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gM3gzIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHByZW11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGVzIHRoZSBnaXZlbiAzeDMgbWF0cmljZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIGluIHRoaXMgbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDN9IGEgLSBUaGUgZmlyc3QgbWF0cml4LlxuXHQgKiBAcGFyYW0ge01hdHJpeDN9IGIgLSBUaGUgc2Vjb25kIG1hdHJpeC5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtdWx0aXBseU1hdHJpY2VzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyAzIF0sIGIxMyA9IGJlWyA2IF07XG5cdFx0Y29uc3QgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNSBdLCBiMzMgPSBiZVsgOCBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcblx0XHR0ZVsgMyBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xuXHRcdHRlWyA2IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xuXHRcdHRlWyA0IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzI7XG5cdFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG5cdFx0dGVbIDUgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcblx0XHR0ZVsgOCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIGV2ZXJ5IGNvbXBvbmVudCBvZiB0aGUgbWF0cml4IGJ5IHRoZSBnaXZlbiBzY2FsYXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNjYWxhci5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRldGVybWluYW50LlxuXHQgKi9cblx0ZGV0ZXJtaW5hbnQoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuXHRcdFx0ZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG5cdH1cblxuXHQvKipcblx0ICogSW52ZXJ0cyB0aGlzIG1hdHJpeCwgdXNpbmcgdGhlIFthbmFseXRpYyBtZXRob2Rde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludmVydGlibGVfbWF0cml4I0FuYWx5dGljX3NvbHV0aW9ufS5cblx0ICogWW91IGNhbiBub3QgaW52ZXJ0IHdpdGggYSBkZXRlcm1pbmFudCBvZiB6ZXJvLiBJZiB5b3UgYXR0ZW1wdCB0aGlzLCB0aGUgbWV0aG9kIHByb2R1Y2VzXG5cdCAqIGEgemVybyBtYXRyaXggaW5zdGVhZC5cblx0ICpcblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRpbnZlcnQoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sXG5cdFx0XHRuMTIgPSB0ZVsgMyBdLCBuMjIgPSB0ZVsgNCBdLCBuMzIgPSB0ZVsgNSBdLFxuXHRcdFx0bjEzID0gdGVbIDYgXSwgbjIzID0gdGVbIDcgXSwgbjMzID0gdGVbIDggXSxcblxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxuXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNwb3NlcyB0aGlzIG1hdHJpeCBpbiBwbGFjZS5cblx0ICpcblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRsZXQgdG1wO1xuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xuXHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBub3JtYWwgbWF0cml4IHdoaWNoIGlzIHRoZSBpbnZlcnNlIHRyYW5zcG9zZSBvZiB0aGUgdXBwZXJcblx0ICogbGVmdCAzeDMgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXg0IC0gVGhlIDR4NCBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0Z2V0Tm9ybWFsTWF0cml4KCBtYXRyaXg0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQoIG1hdHJpeDQgKS5pbnZlcnQoKS50cmFuc3Bvc2UoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9zZXMgdGhpcyBtYXRyaXggaW50byB0aGUgc3VwcGxpZWQgYXJyYXksIGFuZCByZXR1cm5zIGl0c2VsZiB1bmNoYW5nZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gciAtIEFuIGFycmF5IHRvIHN0b3JlIHRoZSB0cmFuc3Bvc2VkIG1hdHJpeCBlbGVtZW50cy5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHR0cmFuc3Bvc2VJbnRvQXJyYXkoIHIgKSB7XG5cblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHJbIDAgXSA9IG1bIDAgXTtcblx0XHRyWyAxIF0gPSBtWyAzIF07XG5cdFx0clsgMiBdID0gbVsgNiBdO1xuXHRcdHJbIDMgXSA9IG1bIDEgXTtcblx0XHRyWyA0IF0gPSBtWyA0IF07XG5cdFx0clsgNSBdID0gbVsgNyBdO1xuXHRcdHJbIDYgXSA9IG1bIDIgXTtcblx0XHRyWyA3IF0gPSBtWyA1IF07XG5cdFx0clsgOCBdID0gbVsgOCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBVViB0cmFuc2Zvcm0gbWF0cml4IGZyb20gb2Zmc2V0LCByZXBlYXQsIHJvdGF0aW9uLCBhbmQgY2VudGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHggLSBPZmZzZXQgeC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gT2Zmc2V0IHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzeCAtIFJlcGVhdCB4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3kgLSBSZXBlYXQgeS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gUm90YXRpb24sIGluIHJhZGlhbnMuIFBvc2l0aXZlIHZhbHVlcyByb3RhdGUgY291bnRlcmNsb2Nrd2lzZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGN4IC0gQ2VudGVyIHggb2Ygcm90YXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjeSAtIENlbnRlciB5IG9mIHJvdGF0aW9uXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNjYWxlcyB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3ggLSBUaGUgYW1vdW50IHRvIHNjYWxlIGluIHRoZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzeSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgaW4gdGhlIFkgYXhpcy5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSAtIFRoZSByb3RhdGlvbiBpbiByYWRpYW5zLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHJvdGF0ZSggdGhldGEgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVJvdGF0aW9uKCAtIHRoZXRhICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gc2NhbGFyIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHR4IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIFggYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIFkgYXhpcy5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHR0cmFuc2xhdGUoIHR4LCB0eSApIHtcblxuXHRcdHRoaXMucHJlbXVsdGlwbHkoIF9tMy5tYWtlVHJhbnNsYXRpb24oIHR4LCB0eSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gZm9yIDJEIFRyYW5zZm9ybXNcblxuXHQvKipcblx0ICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIDJEIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ8VmVjdG9yMn0geCAtIFRoZSBhbW91bnQgdG8gdHJhbnNsYXRlIGluIHRoZSBYIGF4aXMgb3IgYWx0ZXJuYXRpdmVseSBhIHRyYW5zbGF0aW9uIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgWSBheGlzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG1ha2VUcmFuc2xhdGlvbiggeCwgeSApIHtcblxuXHRcdGlmICggeC5pc1ZlY3RvcjIgKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgueCxcblx0XHRcdFx0MCwgMSwgeC55LFxuXHRcdFx0XHQwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCB4LFxuXHRcdFx0XHQwLCAxLCB5LFxuXHRcdFx0XHQwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSAyRCByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgLSBUaGUgcm90YXRpb24gaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7TWF0cml4M30gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIDJEIHNjYWxlIHRyYW5zZm9ybS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIGluIHRoZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGFtb3VudCB0byBzY2FsZSBpbiB0aGUgWSBheGlzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG1ha2VTY2FsZSggeCwgeSApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLFxuXHRcdFx0MCwgeSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgbWF0cml4IGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgbWF0cml4IGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFycmF5IC0gVGhlIG1hdHJpeCBlbGVtZW50cyBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgzfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBhcnJheS4gSWYgbm8gYXJyYXkgaXMgcHJvdmlkZWQsXG5cdCAqIHRoZSBtZXRob2QgcmV0dXJucyBhIG5ldyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbYXJyYXk9W11dIC0gVGhlIHRhcmdldCBhcnJheSBob2xkaW5nIHRoZSBtYXRyaXggZWxlbWVudHMgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIG1hdHJpeCBlbGVtZW50cyBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG5cdCAqL1xuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbWF0cml4IHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hdHJpeDN9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9tMyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKTtcblxuZXhwb3J0IHsgTWF0cml4MyB9O1xuIiwiZnVuY3Rpb24gYXJyYXlNaW4oIGFycmF5ICkge1xuXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIEluZmluaXR5O1xuXG5cdGxldCBtaW4gPSBhcnJheVsgMCBdO1xuXG5cdGZvciAoIGxldCBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGFycmF5WyBpIF0gPCBtaW4gKSBtaW4gPSBhcnJheVsgaSBdO1xuXG5cdH1cblxuXHRyZXR1cm4gbWluO1xuXG59XG5cbmZ1bmN0aW9uIGFycmF5TWF4KCBhcnJheSApIHtcblxuXHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiAtIEluZmluaXR5O1xuXG5cdGxldCBtYXggPSBhcnJheVsgMCBdO1xuXG5cdGZvciAoIGxldCBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGFycmF5WyBpIF0gPiBtYXggKSBtYXggPSBhcnJheVsgaSBdO1xuXG5cdH1cblxuXHRyZXR1cm4gbWF4O1xuXG59XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoIGFycmF5ICkge1xuXG5cdC8vIGFzc3VtZXMgbGFyZ2VyIHZhbHVlcyB1c3VhbGx5IG9uIGxhc3RcblxuXHRmb3IgKCBsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS0gaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+PSA2NTUzNSApIHJldHVybiB0cnVlOyAvLyBhY2NvdW50IGZvciBQUklNSVRJVkVfUkVTVEFSVF9GSVhFRF9JTkRFWCwgIzI0NTY1XG5cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5jb25zdCBUWVBFRF9BUlJBWVMgPSB7XG5cdEludDhBcnJheTogSW50OEFycmF5LFxuXHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxuXHRVaW50OENsYW1wZWRBcnJheTogVWludDhDbGFtcGVkQXJyYXksXG5cdEludDE2QXJyYXk6IEludDE2QXJyYXksXG5cdFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcblx0SW50MzJBcnJheTogSW50MzJBcnJheSxcblx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuXHRGbG9hdDMyQXJyYXk6IEZsb2F0MzJBcnJheSxcblx0RmxvYXQ2NEFycmF5OiBGbG9hdDY0QXJyYXlcbn07XG5cbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXkoIHR5cGUsIGJ1ZmZlciApIHtcblxuXHRyZXR1cm4gbmV3IFRZUEVEX0FSUkFZU1sgdHlwZSBdKCBidWZmZXIgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMoIG5hbWUgKSB7XG5cblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCBuYW1lICk7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzRWxlbWVudCgpIHtcblxuXHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cdGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0cmV0dXJuIGNhbnZhcztcblxufVxuXG5jb25zdCBfY2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk9uY2UoIG1lc3NhZ2UgKSB7XG5cblx0aWYgKCBtZXNzYWdlIGluIF9jYWNoZSApIHJldHVybjtcblxuXHRfY2FjaGVbIG1lc3NhZ2UgXSA9IHRydWU7XG5cblx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cbn1cblxuZnVuY3Rpb24gcHJvYmVBc3luYyggZ2wsIHN5bmMsIGludGVydmFsICkge1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRmdW5jdGlvbiBwcm9iZSgpIHtcblxuXHRcdFx0c3dpdGNoICggZ2wuY2xpZW50V2FpdFN5bmMoIHN5bmMsIGdsLlNZTkNfRkxVU0hfQ09NTUFORFNfQklULCAwICkgKSB7XG5cblx0XHRcdFx0Y2FzZSBnbC5XQUlUX0ZBSUxFRDpcblx0XHRcdFx0XHRyZWplY3QoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIGdsLlRJTUVPVVRfRVhQSVJFRDpcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBwcm9iZSwgaW50ZXJ2YWwgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJlc29sdmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c2V0VGltZW91dCggcHJvYmUsIGludGVydmFsICk7XG5cblx0fSApO1xuXG59XG5cbmZ1bmN0aW9uIHRvTm9ybWFsaXplZFByb2plY3Rpb25NYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSB7XG5cblx0Y29uc3QgbSA9IHByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cblx0Ly8gQ29udmVydCBbLTEsIDFdIHRvIFswLCAxXSBwcm9qZWN0aW9uIG1hdHJpeFxuXHRtWyAyIF0gPSAwLjUgKiBtWyAyIF0gKyAwLjUgKiBtWyAzIF07XG5cdG1bIDYgXSA9IDAuNSAqIG1bIDYgXSArIDAuNSAqIG1bIDcgXTtcblx0bVsgMTAgXSA9IDAuNSAqIG1bIDEwIF0gKyAwLjUgKiBtWyAxMSBdO1xuXHRtWyAxNCBdID0gMC41ICogbVsgMTQgXSArIDAuNSAqIG1bIDE1IF07XG5cbn1cblxuZnVuY3Rpb24gdG9SZXZlcnNlZFByb2plY3Rpb25NYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSB7XG5cblx0Y29uc3QgbSA9IHByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdGNvbnN0IGlzUGVyc3BlY3RpdmVNYXRyaXggPSBtWyAxMSBdID09PSAtIDE7XG5cblx0Ly8gUmV2ZXJzZSBbMCwgMV0gcHJvamVjdGlvbiBtYXRyaXhcblx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4ICkge1xuXG5cdFx0bVsgMTAgXSA9IC0gbVsgMTAgXSAtIDE7XG5cdFx0bVsgMTQgXSA9IC0gbVsgMTQgXTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0bVsgMTAgXSA9IC0gbVsgMTAgXTtcblx0XHRtWyAxNCBdID0gLSBtWyAxNCBdICsgMTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgYXJyYXlNaW4sIGFycmF5TWF4LCBhcnJheU5lZWRzVWludDMyLCBnZXRUeXBlZEFycmF5LCBjcmVhdGVFbGVtZW50TlMsIGNyZWF0ZUNhbnZhc0VsZW1lbnQsIHdhcm5PbmNlLCBwcm9iZUFzeW5jLCB0b05vcm1hbGl6ZWRQcm9qZWN0aW9uTWF0cml4LCB0b1JldmVyc2VkUHJvamVjdGlvbk1hdHJpeCB9O1xuIiwiaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UsIExpbmVhclNSR0JDb2xvclNwYWNlLCBTUkdCVHJhbnNmZXIsIExpbmVhclRyYW5zZmVyLCBOb0NvbG9yU3BhY2UgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4vTWF0cml4My5qcyc7XG5cbmNvbnN0IExJTkVBUl9SRUM3MDlfVE9fWFlaID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpLnNldChcblx0MC40MTIzOTA4LCAwLjM1NzU4NDMsIDAuMTgwNDgwOCxcblx0MC4yMTI2MzkwLCAwLjcxNTE2ODcsIDAuMDcyMTkyMyxcblx0MC4wMTkzMzA4LCAwLjExOTE5NDgsIDAuOTUwNTMyMlxuKTtcblxuY29uc3QgWFlaX1RPX0xJTkVBUl9SRUM3MDkgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkuc2V0KFxuXHQzLjI0MDk2OTksIC0gMS41MzczODMyLCAtIDAuNDk4NjEwOCxcblx0LSAwLjk2OTI0MzYsIDEuODc1OTY3NSwgMC4wNDE1NTUxLFxuXHQwLjA1NTYzMDEsIC0gMC4yMDM5NzcwLCAxLjA1Njk3MTVcbik7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yTWFuYWdlbWVudCgpIHtcblxuXHRjb25zdCBDb2xvck1hbmFnZW1lbnQgPSB7XG5cblx0XHRlbmFibGVkOiB0cnVlLFxuXG5cdFx0d29ya2luZ0NvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuXG5cdFx0LyoqXG5cdFx0ICogSW1wbGVtZW50YXRpb25zIG9mIHN1cHBvcnRlZCBjb2xvciBzcGFjZXMuXG5cdFx0ICpcblx0XHQgKiBSZXF1aXJlZDpcblx0XHQgKlx0LSBwcmltYXJpZXM6IGNocm9tYXRpY2l0eSBjb29yZGluYXRlcyBbIHJ4IHJ5IGd4IGd5IGJ4IGJ5IF1cblx0XHQgKlx0LSB3aGl0ZVBvaW50OiByZWZlcmVuY2Ugd2hpdGUgWyB4IHkgXVxuXHRcdCAqXHQtIHRyYW5zZmVyOiB0cmFuc2ZlciBmdW5jdGlvbiAocHJlLWRlZmluZWQpXG5cdFx0ICpcdC0gdG9YWVo6IE1hdHJpeDMgUkdCIHRvIFhZWiB0cmFuc2Zvcm1cblx0XHQgKlx0LSBmcm9tWFlaOiBNYXRyaXgzIFhZWiB0byBSR0IgdHJhbnNmb3JtXG5cdFx0ICpcdC0gbHVtaW5hbmNlQ29lZmZpY2llbnRzOiBSR0IgbHVtaW5hbmNlIGNvZWZmaWNpZW50c1xuXHRcdCAqXG5cdFx0ICogT3B0aW9uYWw6XG5cdFx0ICogIC0gb3V0cHV0Q29sb3JTcGFjZUNvbmZpZzogeyBkcmF3aW5nQnVmZmVyQ29sb3JTcGFjZTogQ29sb3JTcGFjZSB9XG5cdFx0ICogIC0gd29ya2luZ0NvbG9yU3BhY2VDb25maWc6IHsgdW5wYWNrQ29sb3JTcGFjZTogQ29sb3JTcGFjZSB9XG5cdFx0ICpcblx0XHQgKiBSZWZlcmVuY2U6XG5cdFx0ICogLSBodHRwczovL3d3dy5ydXNzZWxsY290dHJlbGwuY29tL3Bob3RvL21hdHJpeENhbGN1bGF0b3IuaHRtXG5cdFx0ICovXG5cdFx0c3BhY2VzOiB7fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uICggY29sb3IsIHNvdXJjZUNvbG9yU3BhY2UsIHRhcmdldENvbG9yU3BhY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSB8fCBzb3VyY2VDb2xvclNwYWNlID09PSB0YXJnZXRDb2xvclNwYWNlIHx8ICEgc291cmNlQ29sb3JTcGFjZSB8fCAhIHRhcmdldENvbG9yU3BhY2UgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGNvbG9yO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5zcGFjZXNbIHNvdXJjZUNvbG9yU3BhY2UgXS50cmFuc2ZlciA9PT0gU1JHQlRyYW5zZmVyICkge1xuXG5cdFx0XHRcdGNvbG9yLnIgPSBTUkdCVG9MaW5lYXIoIGNvbG9yLnIgKTtcblx0XHRcdFx0Y29sb3IuZyA9IFNSR0JUb0xpbmVhciggY29sb3IuZyApO1xuXHRcdFx0XHRjb2xvci5iID0gU1JHQlRvTGluZWFyKCBjb2xvci5iICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnNwYWNlc1sgc291cmNlQ29sb3JTcGFjZSBdLnByaW1hcmllcyAhPT0gdGhpcy5zcGFjZXNbIHRhcmdldENvbG9yU3BhY2UgXS5wcmltYXJpZXMgKSB7XG5cblx0XHRcdFx0Y29sb3IuYXBwbHlNYXRyaXgzKCB0aGlzLnNwYWNlc1sgc291cmNlQ29sb3JTcGFjZSBdLnRvWFlaICk7XG5cdFx0XHRcdGNvbG9yLmFwcGx5TWF0cml4MyggdGhpcy5zcGFjZXNbIHRhcmdldENvbG9yU3BhY2UgXS5mcm9tWFlaICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnNwYWNlc1sgdGFyZ2V0Q29sb3JTcGFjZSBdLnRyYW5zZmVyID09PSBTUkdCVHJhbnNmZXIgKSB7XG5cblx0XHRcdFx0Y29sb3IuciA9IExpbmVhclRvU1JHQiggY29sb3IuciApO1xuXHRcdFx0XHRjb2xvci5nID0gTGluZWFyVG9TUkdCKCBjb2xvci5nICk7XG5cdFx0XHRcdGNvbG9yLmIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29sb3I7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbVdvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbiAoIGNvbG9yLCB0YXJnZXRDb2xvclNwYWNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0KCBjb2xvciwgdGhpcy53b3JraW5nQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApO1xuXG5cdFx0fSxcblxuXHRcdHRvV29ya2luZ0NvbG9yU3BhY2U6IGZ1bmN0aW9uICggY29sb3IsIHNvdXJjZUNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNvbnZlcnQoIGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0UHJpbWFyaWVzOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNwYWNlc1sgY29sb3JTcGFjZSBdLnByaW1hcmllcztcblxuXHRcdH0sXG5cblx0XHRnZXRUcmFuc2ZlcjogZnVuY3Rpb24gKCBjb2xvclNwYWNlICkge1xuXG5cdFx0XHRpZiAoIGNvbG9yU3BhY2UgPT09IE5vQ29sb3JTcGFjZSApIHJldHVybiBMaW5lYXJUcmFuc2ZlcjtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3BhY2VzWyBjb2xvclNwYWNlIF0udHJhbnNmZXI7XG5cblx0XHR9LFxuXG5cdFx0Z2V0THVtaW5hbmNlQ29lZmZpY2llbnRzOiBmdW5jdGlvbiAoIHRhcmdldCwgY29sb3JTcGFjZSA9IHRoaXMud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQuZnJvbUFycmF5KCB0aGlzLnNwYWNlc1sgY29sb3JTcGFjZSBdLmx1bWluYW5jZUNvZWZmaWNpZW50cyApO1xuXG5cdFx0fSxcblxuXHRcdGRlZmluZTogZnVuY3Rpb24gKCBjb2xvclNwYWNlcyApIHtcblxuXHRcdFx0T2JqZWN0LmFzc2lnbiggdGhpcy5zcGFjZXMsIGNvbG9yU3BhY2VzICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gSW50ZXJuYWwgQVBJc1xuXG5cdFx0X2dldE1hdHJpeDogZnVuY3Rpb24gKCB0YXJnZXRNYXRyaXgsIHNvdXJjZUNvbG9yU3BhY2UsIHRhcmdldENvbG9yU3BhY2UgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXRNYXRyaXhcblx0XHRcdFx0LmNvcHkoIHRoaXMuc3BhY2VzWyBzb3VyY2VDb2xvclNwYWNlIF0udG9YWVogKVxuXHRcdFx0XHQubXVsdGlwbHkoIHRoaXMuc3BhY2VzWyB0YXJnZXRDb2xvclNwYWNlIF0uZnJvbVhZWiApO1xuXG5cdFx0fSxcblxuXHRcdF9nZXREcmF3aW5nQnVmZmVyQ29sb3JTcGFjZTogZnVuY3Rpb24gKCBjb2xvclNwYWNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGFjZXNbIGNvbG9yU3BhY2UgXS5vdXRwdXRDb2xvclNwYWNlQ29uZmlnLmRyYXdpbmdCdWZmZXJDb2xvclNwYWNlO1xuXG5cdFx0fSxcblxuXHRcdF9nZXRVbnBhY2tDb2xvclNwYWNlOiBmdW5jdGlvbiAoIGNvbG9yU3BhY2UgPSB0aGlzLndvcmtpbmdDb2xvclNwYWNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGFjZXNbIGNvbG9yU3BhY2UgXS53b3JraW5nQ29sb3JTcGFjZUNvbmZpZy51bnBhY2tDb2xvclNwYWNlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBzUkdCIGRlZmluaXRpb25zXG5cdCAqL1xuXG5cdGNvbnN0IFJFQzcwOV9QUklNQVJJRVMgPSBbIDAuNjQwLCAwLjMzMCwgMC4zMDAsIDAuNjAwLCAwLjE1MCwgMC4wNjAgXTtcblx0Y29uc3QgUkVDNzA5X0xVTUlOQU5DRV9DT0VGRklDSUVOVFMgPSBbIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgXTtcblx0Y29uc3QgRDY1ID0gWyAwLjMxMjcsIDAuMzI5MCBdO1xuXG5cdENvbG9yTWFuYWdlbWVudC5kZWZpbmUoIHtcblxuXHRcdFsgTGluZWFyU1JHQkNvbG9yU3BhY2UgXToge1xuXHRcdFx0cHJpbWFyaWVzOiBSRUM3MDlfUFJJTUFSSUVTLFxuXHRcdFx0d2hpdGVQb2ludDogRDY1LFxuXHRcdFx0dHJhbnNmZXI6IExpbmVhclRyYW5zZmVyLFxuXHRcdFx0dG9YWVo6IExJTkVBUl9SRUM3MDlfVE9fWFlaLFxuXHRcdFx0ZnJvbVhZWjogWFlaX1RPX0xJTkVBUl9SRUM3MDksXG5cdFx0XHRsdW1pbmFuY2VDb2VmZmljaWVudHM6IFJFQzcwOV9MVU1JTkFOQ0VfQ09FRkZJQ0lFTlRTLFxuXHRcdFx0d29ya2luZ0NvbG9yU3BhY2VDb25maWc6IHsgdW5wYWNrQ29sb3JTcGFjZTogU1JHQkNvbG9yU3BhY2UgfSxcblx0XHRcdG91dHB1dENvbG9yU3BhY2VDb25maWc6IHsgZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U6IFNSR0JDb2xvclNwYWNlIH1cblx0XHR9LFxuXG5cdFx0WyBTUkdCQ29sb3JTcGFjZSBdOiB7XG5cdFx0XHRwcmltYXJpZXM6IFJFQzcwOV9QUklNQVJJRVMsXG5cdFx0XHR3aGl0ZVBvaW50OiBENjUsXG5cdFx0XHR0cmFuc2ZlcjogU1JHQlRyYW5zZmVyLFxuXHRcdFx0dG9YWVo6IExJTkVBUl9SRUM3MDlfVE9fWFlaLFxuXHRcdFx0ZnJvbVhZWjogWFlaX1RPX0xJTkVBUl9SRUM3MDksXG5cdFx0XHRsdW1pbmFuY2VDb2VmZmljaWVudHM6IFJFQzcwOV9MVU1JTkFOQ0VfQ09FRkZJQ0lFTlRTLFxuXHRcdFx0b3V0cHV0Q29sb3JTcGFjZUNvbmZpZzogeyBkcmF3aW5nQnVmZmVyQ29sb3JTcGFjZTogU1JHQkNvbG9yU3BhY2UgfVxuXHRcdH0sXG5cblx0fSApO1xuXG5cdHJldHVybiBDb2xvck1hbmFnZW1lbnQ7XG5cbn1cblxuZXhwb3J0IGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29sb3JNYW5hZ2VtZW50KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBTUkdCVG9MaW5lYXIoIGMgKSB7XG5cblx0cmV0dXJuICggYyA8IDAuMDQwNDUgKSA/IGMgKiAwLjA3NzM5OTM4MDggOiBNYXRoLnBvdyggYyAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40ICk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExpbmVhclRvU1JHQiggYyApIHtcblxuXHRyZXR1cm4gKCBjIDwgMC4wMDMxMzA4ICkgPyBjICogMTIuOTIgOiAxLjA1NSAqICggTWF0aC5wb3coIGMsIDAuNDE2NjYgKSApIC0gMC4wNTU7XG5cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnROUyB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IFNSR0JUb0xpbmVhciB9IGZyb20gJy4uL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcblxubGV0IF9jYW52YXM7XG5cbi8qKlxuICogQSBjbGFzcyBjb250YWluaW5nIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBpbWFnZXMuXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBJbWFnZVV0aWxzIHtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRhdGEgVVJJIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gaW1hZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnQpfSBpbWFnZSAtIFRoZSBpbWFnZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0naW1hZ2UvcG5nJ10gLSBJbmRpY2F0ZXMgdGhlIGltYWdlIGZvcm1hdC5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGF0YSBVUkkuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0RGF0YVVSTCggaW1hZ2UsIHR5cGUgPSAnaW1hZ2UvcG5nJyApIHtcblxuXHRcdGlmICggL15kYXRhOi9pLnRlc3QoIGltYWdlLnNyYyApICkge1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNhbnZhcztcblxuXHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcblxuXHRcdFx0Y2FudmFzID0gaW1hZ2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIF9jYW52YXMgPT09IHVuZGVmaW5lZCApIF9jYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XG5cblx0XHRcdF9jYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRjb25zdCBjb250ZXh0ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cblx0XHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEgKSB7XG5cblx0XHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlLCAwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FudmFzID0gX2NhbnZhcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCB0eXBlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc1JHQiBpbWFnZSBkYXRhIHRvIGxpbmVhciBjb2xvciBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHsoSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcHxPYmplY3QpfSBpbWFnZSAtIFRoZSBpbWFnZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fE9iamVjdH0gVGhlIGNvbnZlcnRlZCBpbWFnZS5cblx0ICovXG5cdHN0YXRpYyBzUkdCVG9MaW5lYXIoIGltYWdlICkge1xuXG5cdFx0aWYgKCAoIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB8fFxuXHRcdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB8fFxuXHRcdFx0KCB0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgKSApIHtcblxuXHRcdFx0Y29uc3QgY2FudmFzID0gY3JlYXRlRWxlbWVudE5TKCAnY2FudmFzJyApO1xuXG5cdFx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cdFx0XHRjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGRhdGFbIGkgXSA9IFNSR0JUb0xpbmVhciggZGF0YVsgaSBdIC8gMjU1ICkgKiAyNTU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xuXG5cdFx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdFx0fSBlbHNlIGlmICggaW1hZ2UuZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IGltYWdlLmRhdGEuc2xpY2UoIDAgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB7XG5cblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBNYXRoLmZsb29yKCBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSAvIDI1NSApICogMjU1ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGFzc3VtaW5nIGZsb2F0XG5cblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoKTogVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS4gTm8gY29sb3Igc3BhY2UgY29udmVyc2lvbiBhcHBsaWVkLicgKTtcblx0XHRcdHJldHVybiBpbWFnZTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgSW1hZ2VVdGlscyB9O1xuIiwiaW1wb3J0IHsgSW1hZ2VVdGlscyB9IGZyb20gJy4uL2V4dHJhcy9JbWFnZVV0aWxzLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxubGV0IF9zb3VyY2VJZCA9IDA7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGF0YSBzb3VyY2Ugb2YgYSB0ZXh0dXJlLlxuICpcbiAqIFRoZSBtYWluIHB1cnBvc2Ugb2YgdGhpcyBjbGFzcyBpcyB0byBkZWNvdXBsZSB0aGUgZGF0YSBkZWZpbml0aW9uIGZyb20gdGhlIHRleHR1cmVcbiAqIGRlZmluaXRpb24gc28gdGhlIHNhbWUgZGF0YSBjYW4gYmUgdXNlZCB3aXRoIG11bHRpcGxlIHRleHR1cmUgaW5zdGFuY2VzLlxuICovXG5jbGFzcyBTb3VyY2Uge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHZpZGVvIHRleHR1cmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YW55fSBbZGF0YT1udWxsXSAtIFRoZSBkYXRhIGRlZmluaXRpb24gb2YgYSB0ZXh0dXJlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGRhdGEgPSBudWxsICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NvdXJjZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHNvdXJjZS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lIFNvdXJjZSNpZFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfc291cmNlSWQgKysgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIFVVSUQgb2YgdGhlIHNvdXJjZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGF0YSBkZWZpbml0aW9uIG9mIGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHthbnl9XG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgaXMgb25seSByZWxldmFudCB3aGVuIHtAbGluayBTb3VyY2UjbmVlZHNVcGRhdGV9IGlzIHNldCB0byBgdHJ1ZWAgYW5kXG5cdFx0ICogcHJvdmlkZXMgbW9yZSBjb250cm9sIG9uIGhvdyB0ZXh0dXJlIGRhdGEgc2hvdWxkIGJlIHByb2Nlc3NlZC4gV2hlbiBgZGF0YVJlYWR5YCBpcyBzZXRcblx0XHQgKiB0byBgZmFsc2VgLCB0aGUgZW5naW5lIHBlcmZvcm1zIHRoZSBtZW1vcnkgYWxsb2NhdGlvbiAoaWYgbmVjZXNzYXJ5KSBidXQgZG9lcyBub3QgdHJhbnNmZXJcblx0XHQgKiB0aGUgZGF0YSBpbnRvIHRoZSBHUFUgbWVtb3J5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YVJlYWR5ID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3RhcnRzIGF0IGAwYCBhbmQgY291bnRzIGhvdyBtYW55IHRpbWVzIHtAbGluayBTb3VyY2UjbmVlZHNVcGRhdGV9IGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogV2hlbiB0aGUgcHJvcGVydHkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIGVuZ2luZSBhbGxvY2F0ZXMgdGhlIG1lbW9yeVxuXHQgKiBmb3IgdGhlIHRleHR1cmUgKGlmIG5lY2Vzc2FyeSkgYW5kIHRyaWdnZXJzIHRoZSBhY3R1YWwgdGV4dHVyZSB1cGxvYWRcblx0ICogdG8gdGhlIEdQVSBuZXh0IHRpbWUgdGhlIHNvdXJjZSBpcyB1c2VkLlxuXHQgKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBzb3VyY2UgaW50byBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0gez8oT2JqZWN0fHN0cmluZyl9IG1ldGEgLSBBbiBvcHRpb25hbCB2YWx1ZSBob2xkaW5nIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlcmlhbGl6YXRpb24uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgc291cmNlLlxuXHQgKiBAc2VlIHtAbGluayBPYmplY3RMb2FkZXIjcGFyc2V9XG5cdCAqL1xuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBtZXRhLmltYWdlc1sgdGhpcy51dWlkIF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHR1cmw6ICcnXG5cdFx0fTtcblxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIGRhdGEgIT09IG51bGwgKSB7XG5cblx0XHRcdGxldCB1cmw7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXG5cdFx0XHRcdC8vIGN1YmUgdGV4dHVyZVxuXG5cdFx0XHRcdHVybCA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggZGF0YVsgaSBdLmlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdHVybC5wdXNoKCBzZXJpYWxpemVJbWFnZSggZGF0YVsgaSBdLmltYWdlICkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHVybC5wdXNoKCBzZXJpYWxpemVJbWFnZSggZGF0YVsgaSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdGV4dHVyZVxuXG5cdFx0XHRcdHVybCA9IHNlcmlhbGl6ZUltYWdlKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0LnVybCA9IHVybDtcblxuXHRcdH1cblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdG1ldGEuaW1hZ2VzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUltYWdlKCBpbWFnZSApIHtcblxuXHRpZiAoICggdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XG5cdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB8fFxuXHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkgKSB7XG5cblx0XHQvLyBkZWZhdWx0IGltYWdlc1xuXG5cdFx0cmV0dXJuIEltYWdlVXRpbHMuZ2V0RGF0YVVSTCggaW1hZ2UgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHQvLyBpbWFnZXMgb2YgRGF0YVRleHR1cmVcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogQXJyYXkuZnJvbSggaW1hZ2UuZGF0YSApLFxuXHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxuXHRcdFx0XHR0eXBlOiBpbWFnZS5kYXRhLmNvbnN0cnVjdG9yLm5hbWVcblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UZXh0dXJlOiBVbmFibGUgdG8gc2VyaWFsaXplIFRleHR1cmUuJyApO1xuXHRcdFx0cmV0dXJuIHt9O1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTb3VyY2UgfTtcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7XG5cdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdFJlcGVhdFdyYXBwaW5nLFxuXHRVbnNpZ25lZEJ5dGVUeXBlLFxuXHRSR0JBRm9ybWF0LFxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdExpbmVhckZpbHRlcixcblx0VVZNYXBwaW5nLFxuXHROb0NvbG9yU3BhY2UsXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVVVSUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi9Tb3VyY2UuanMnO1xuXG5sZXQgX3RleHR1cmVJZCA9IDA7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHRleHR1cmVzLlxuICpcbiAqIE5vdGU6IEFmdGVyIHRoZSBpbml0aWFsIHVzZSBvZiBhIHRleHR1cmUsIGl0cyBkaW1lbnNpb25zLCBmb3JtYXQsIGFuZCB0eXBlXG4gKiBjYW5ub3QgYmUgY2hhbmdlZC4gSW5zdGVhZCwgY2FsbCB7QGxpbmsgVGV4dHVyZSNkaXNwb3NlfSBvbiB0aGUgdGV4dHVyZSBhbmQgaW5zdGFudGlhdGUgYSBuZXcgb25lLlxuICpcbiAqIEBhdWdtZW50cyBFdmVudERpc3BhdGNoZXJcbiAqL1xuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHs/T2JqZWN0fSBbaW1hZ2U9VGV4dHVyZS5ERUZBVUxUX0lNQUdFXSAtIFRoZSBpbWFnZSBob2xkaW5nIHRoZSB0ZXh0dXJlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWFwcGluZz1UZXh0dXJlLkRFRkFVTFRfTUFQUElOR10gLSBUaGUgdGV4dHVyZSBtYXBwaW5nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dyYXBTPUNsYW1wVG9FZGdlV3JhcHBpbmddIC0gVGhlIHdyYXBTIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dyYXBUPUNsYW1wVG9FZGdlV3JhcHBpbmddIC0gVGhlIHdyYXBUIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hZ0ZpbHRlcj1MaW5lYXJGaWx0ZXJdIC0gVGhlIG1hZyBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWluRmlsdGVyPUxpbmVhck1pcG1hcExpbmVhckZpbHRlcl0gLSBUaGUgbWluIGZpbHRlciB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmb3JtYXQ9UkdCQUZvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSB0ZXh0dXJlIHR5cGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYW5pc290cm9weT1UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWV0gLSBUaGUgYW5pc290cm9weSB2YWx1ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvclNwYWNlPU5vQ29sb3JTcGFjZV0gLSBUaGUgY29sb3Igc3BhY2UuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggaW1hZ2UgPSBUZXh0dXJlLkRFRkFVTFRfSU1BR0UsIG1hcHBpbmcgPSBUZXh0dXJlLkRFRkFVTFRfTUFQUElORywgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nLCB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIG1hZ0ZpbHRlciA9IExpbmVhckZpbHRlciwgbWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBmb3JtYXQgPSBSR0JBRm9ybWF0LCB0eXBlID0gVW5zaWduZWRCeXRlVHlwZSwgYW5pc290cm9weSA9IFRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZLCBjb2xvclNwYWNlID0gTm9Db2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lIFRleHR1cmUjaWRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX3RleHR1cmVJZCArKyB9ICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgVVVJRCBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkYXRhIGRlZmluaXRpb24gb2YgYSB0ZXh0dXJlLiBBIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBzb3VyY2UgY2FuIGJlXG5cdFx0ICogc2hhcmVkIGFjcm9zcyB0ZXh0dXJlcy4gVGhpcyBpcyBvZnRlbiB1c2VmdWwgaW4gY29udGV4dCBvZiBzcHJpdGVzaGVldHNcblx0XHQgKiB3aGVyZSBtdWx0aXBsZSB0ZXh0dXJlcyByZW5kZXIgdGhlIHNhbWUgZGF0YSBidXQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZVxuXHRcdCAqIHRyYW5zZm9ybWF0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtTb3VyY2V9XG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgaG9sZGluZyB1c2VyLWRlZmluZWQgbWlwbWFwcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuXHRcdCAqL1xuXHRcdHRoaXMubWlwbWFwcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IHRoZSB0ZXh0dXJlIGlzIGFwcGxpZWQgdG8gdGhlIG9iamVjdC4gVGhlIHZhbHVlIGBVVk1hcHBpbmdgXG5cdFx0ICogaXMgdGhlIGRlZmF1bHQsIHdoZXJlIHRleHR1cmUgb3IgdXYgY29vcmRpbmF0ZXMgYXJlIHVzZWQgdG8gYXBwbHkgdGhlIG1hcC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoVVZNYXBwaW5nfEN1YmVSZWZsZWN0aW9uTWFwcGluZ3xDdWJlUmVmcmFjdGlvbk1hcHBpbmd8RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmd8RXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmd8Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcpfVxuXHRcdCAqIEBkZWZhdWx0IFVWTWFwcGluZ1xuXHRcdCovXG5cdFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdC8qKlxuXHRcdCAqIExldHMgeW91IHNlbGVjdCB0aGUgdXYgYXR0cmlidXRlIHRvIG1hcCB0aGUgdGV4dHVyZSB0by4gYDBgIGZvciBgdXZgLFxuXHRcdCAqIGAxYCBmb3IgYHV2MWAsIGAyYCBmb3IgYHV2MmAgYW5kIGAzYCBmb3IgYHV2M2AuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmNoYW5uZWwgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkZWZpbmVzIGhvdyB0aGUgdGV4dHVyZSBpcyB3cmFwcGVkIGhvcml6b250YWxseSBhbmQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiAqVSogaW4gVVYgbWFwcGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoUmVwZWF0V3JhcHBpbmd8Q2xhbXBUb0VkZ2VXcmFwcGluZ3xNaXJyb3JlZFJlcGVhdFdyYXBwaW5nKX1cblx0XHQgKiBAZGVmYXVsdCBDbGFtcFRvRWRnZVdyYXBwaW5nXG5cdFx0ICovXG5cdFx0dGhpcy53cmFwUyA9IHdyYXBTO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkZWZpbmVzIGhvdyB0aGUgdGV4dHVyZSBpcyB3cmFwcGVkIGhvcml6b250YWxseSBhbmQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiAqViogaW4gVVYgbWFwcGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoUmVwZWF0V3JhcHBpbmd8Q2xhbXBUb0VkZ2VXcmFwcGluZ3xNaXJyb3JlZFJlcGVhdFdyYXBwaW5nKX1cblx0XHQgKiBAZGVmYXVsdCBDbGFtcFRvRWRnZVdyYXBwaW5nXG5cdFx0ICovXG5cdFx0dGhpcy53cmFwVCA9IHdyYXBUO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IHRoZSB0ZXh0dXJlIGlzIHNhbXBsZWQgd2hlbiBhIHRleGVsIGNvdmVycyBtb3JlIHRoYW4gb25lIHBpeGVsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXJ8TGluZWFyRmlsdGVyfExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXJ8TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyKX1cblx0XHQgKiBAZGVmYXVsdCBMaW5lYXJGaWx0ZXJcblx0XHQgKi9cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcjtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0aGUgdGV4dHVyZSBpcyBzYW1wbGVkIHdoZW4gYSB0ZXhlbCBjb3ZlcnMgbGVzcyB0aGFuIG9uZSBwaXhlbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoTmVhcmVzdEZpbHRlcnxOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcnxOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyfExpbmVhckZpbHRlcnxMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyfExpbmVhck1pcG1hcExpbmVhckZpbHRlcil9XG5cdFx0ICogQGRlZmF1bHQgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG5cdFx0ICovXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdGFrZW4gYWxvbmcgdGhlIGF4aXMgdGhyb3VnaCB0aGUgcGl4ZWwgdGhhdCBoYXMgdGhlXG5cdFx0ICogaGlnaGVzdCBkZW5zaXR5IG9mIHRleGVscy4gQnkgZGVmYXVsdCwgdGhpcyB2YWx1ZSBpcyBgMWAuIEEgaGlnaGVyIHZhbHVlXG5cdFx0ICogZ2l2ZXMgYSBsZXNzIGJsdXJyeSByZXN1bHQgdGhhbiBhIGJhc2ljIG1pcG1hcCwgYXQgdGhlIGNvc3Qgb2YgbW9yZVxuXHRcdCAqIHRleHR1cmUgc2FtcGxlcyBiZWluZyB1c2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IFJHQkFGb3JtYXRcblx0XHQgKi9cblx0XHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IGludGVybmFsIGZvcm1hdCBpcyBkZXJpdmVkIGZyb20ge0BsaW5rIFRleHR1cmUjZm9ybWF0fSBhbmQge0BsaW5rIFRleHR1cmUjdHlwZX0gYW5kXG5cdFx0ICogZGVmaW5lcyBob3cgdGhlIHRleHR1cmUgZGF0YSBpcyBnb2luZyB0byBiZSBzdG9yZWQgb24gdGhlIEdQVS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgYWxsb3dzIHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBmb3JtYXQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P3N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGF0YSB0eXBlIG9mIHRoZSB0ZXh0dXJlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBVbnNpZ25lZEJ5dGVUeXBlXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIGEgc2luZ2xlIHJlcGV0aXRpb24gb2YgdGhlIHRleHR1cmUgaXMgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyxcblx0XHQgKiBpbiBlYWNoIGRpcmVjdGlvbiBVIGFuZCBWLiBUeXBpY2FsIHJhbmdlIGlzIGAwLjBgIHRvIGAxLjBgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICogQGRlZmF1bHQgKDAsMClcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbWFueSB0aW1lcyB0aGUgdGV4dHVyZSBpcyByZXBlYXRlZCBhY3Jvc3MgdGhlIHN1cmZhY2UsIGluIGVhY2hcblx0XHQgKiBkaXJlY3Rpb24gVSBhbmQgVi4gSWYgcmVwZWF0IGlzIHNldCBncmVhdGVyIHRoYW4gYDFgIGluIGVpdGhlciBkaXJlY3Rpb24sXG5cdFx0ICogdGhlIGNvcnJlc3BvbmRpbmcgd3JhcCBwYXJhbWV0ZXIgc2hvdWxkIGFsc28gYmUgc2V0IHRvIGBSZXBlYXRXcmFwcGluZ2Bcblx0XHQgKiBvciBgTWlycm9yZWRSZXBlYXRXcmFwcGluZ2AgdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCB0aWxpbmcgZWZmZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICogQGRlZmF1bHQgKDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcG9pbnQgYXJvdW5kIHdoaWNoIHJvdGF0aW9uIG9jY3Vycy4gQSB2YWx1ZSBvZiBgKDAuNSwgMC41KWAgY29ycmVzcG9uZHNcblx0XHQgKiB0byB0aGUgY2VudGVyIG9mIHRoZSB0ZXh0dXJlLiBEZWZhdWx0IGlzIGAoMCwgMClgLCB0aGUgbG93ZXIgbGVmdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDApXG5cdFx0ICovXG5cdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIHRleHR1cmUgaXMgcm90YXRlZCBhcm91bmQgdGhlIGNlbnRlciBwb2ludCwgaW4gcmFkaWFucy5cblx0XHQgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGNvdW50ZXItY2xvY2t3aXNlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSdzIHV2LXRyYW5zZm9ybWF0aW9uIHtAbGluayBUZXh0dXJlI21hdHJpeH1cblx0XHQgKiBmcm9tIHRoZSBwcm9wZXJ0aWVzIHtAbGluayBUZXh0dXJlI29mZnNldH0sIHtAbGluayBUZXh0dXJlI3JlcGVhdH0sXG5cdFx0ICoge0BsaW5rIFRleHR1cmUjcm90YXRpb259LCBhbmQge0BsaW5rIFRleHR1cmUjY2VudGVyfS5cblx0XHQgKlxuXHRcdCAqIFNldCB0aGlzIHRvIGBmYWxzZWAgaWYgeW91IGFyZSBzcGVjaWZ5aW5nIHRoZSB1di10cmFuc2Zvcm0gbWF0cml4IGRpcmVjdGx5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdXYtdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSB0ZXh0dXJlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge01hdHJpeDN9XG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBnZW5lcmF0ZSBtaXBtYXBzIChpZiBwb3NzaWJsZSkgZm9yIGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIFNldCB0aGlzIHRvIGBmYWxzZWAgaWYgeW91IGFyZSBjcmVhdGluZyBtaXBtYXBzIG1hbnVhbGx5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBhbHBoYSBjaGFubmVsLCBpZiBwcmVzZW50LCBpcyBtdWx0aXBsaWVkIGludG8gdGhlXG5cdFx0ICogY29sb3IgY2hhbm5lbHMgd2hlbiB0aGUgdGV4dHVyZSBpcyB1cGxvYWRlZCB0byB0aGUgR1BVLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcHJvcGVydHkgaGFzIG5vIGVmZmVjdCB3aGVuIHVzaW5nIGBJbWFnZUJpdG1hcGAuIFlvdSBuZWVkIHRvXG5cdFx0ICogY29uZmlndXJlIHByZW11bHRpcGx5IGFscGhhIG9uIGJpdG1hcCBjcmVhdGlvbiBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0ZXh0dXJlIGlzIGZsaXBwZWQgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgd2hlblxuXHRcdCAqIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBoYXMgbm8gZWZmZWN0IHdoZW4gdXNpbmcgYEltYWdlQml0bWFwYC4gWW91IG5lZWQgdG9cblx0XHQgKiBjb25maWd1cmUgdGhlIGZsaXAgb24gYml0bWFwIGNyZWF0aW9uIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mbGlwWSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGFsaWdubWVudCByZXF1aXJlbWVudHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHBpeGVsIHJvdyBpbiBtZW1vcnkuXG5cdFx0ICogVGhlIGFsbG93YWJsZSB2YWx1ZXMgYXJlIGAxYCAoYnl0ZS1hbGlnbm1lbnQpLCBgMmAgKHJvd3MgYWxpZ25lZCB0byBldmVuLW51bWJlcmVkIGJ5dGVzKSxcblx0XHQgKiBgNGAgKHdvcmQtYWxpZ25tZW50KSwgYW5kIGA4YCAocm93cyBzdGFydCBvbiBkb3VibGUtd29yZCBib3VuZGFyaWVzKS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgNFxuXHRcdCAqL1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDtcdC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdFx0LyoqXG5cdFx0ICogVGV4dHVyZXMgY29udGFpbmluZyBjb2xvciBkYXRhIHNob3VsZCBiZSBhbm5vdGF0ZWQgd2l0aCBgU1JHQkNvbG9yU3BhY2VgIG9yIGBMaW5lYXJTUkdCQ29sb3JTcGFjZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IE5vQ29sb3JTcGFjZVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBjdXN0b20gZGF0YSBhYm91dCB0aGUgdGV4dHVyZS4gSXRcblx0XHQgKiBzaG91bGQgbm90IGhvbGQgcmVmZXJlbmNlcyB0byBmdW5jdGlvbnMgYXMgdGhlc2Ugd2lsbCBub3QgYmUgY2xvbmVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHN0YXJ0cyBhdCBgMGAgYW5kIGNvdW50cyBob3cgbWFueSB0aW1lcyB7QGxpbmsgVGV4dHVyZSNuZWVkc1VwZGF0ZX0gaXMgc2V0IHRvIGB0cnVlYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkIChlLmcuLCB3aGVuXG5cdFx0ICoge0BsaW5rIFRleHR1cmUjbmVlZHNVcGRhdGV9IGhhcyBiZWVuIHNldCB0byB0cnVlIGFuZCB0aGVuIHRoZSB0ZXh0dXJlIGlzIHVzZWQpLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9GdW5jdGlvbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBiYWNrIHJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZXMgcmVuZGVyIHRhcmdldC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/KFJlbmRlclRhcmdldHxXZWJHTFJlbmRlclRhcmdldCl9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIGEgdGV4dHVyZSBiZWxvbmdzIHRvIGEgcmVuZGVyIHRhcmdldCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYSB0ZXh0dXJlIHNob3VsZCBiZSBoYW5kbGVkIGxpa2UgYSB0ZXh0dXJlIGFycmF5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmlzVGV4dHVyZUFycmF5ID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRleHR1cmUgc2hvdWxkIGJlIHByb2Nlc3NlZCBieSBgUE1SRU1HZW5lcmF0b3JgIG9yIG5vdFxuXHRcdCAqIChvbmx5IHJlbGV2YW50IGZvciByZW5kZXIgdGFyZ2V0IHRleHR1cmVzKS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucG1yZW1WZXJzaW9uID0gMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZSBvYmplY3QgaG9sZGluZyB0aGUgdGV4dHVyZSBkYXRhLlxuXHQgKlxuXHQgKiBAdHlwZSB7P09iamVjdH1cblx0ICovXG5cdGdldCBpbWFnZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xuXG5cdH1cblxuXHRzZXQgaW1hZ2UoIHZhbHVlID0gbnVsbCApIHtcblxuXHRcdHRoaXMuc291cmNlLmRhdGEgPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHRleHR1cmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gdGhlIGZyb20gdGhlIHByb3BlcnRpZXMge0BsaW5rIFRleHR1cmUjb2Zmc2V0fSxcblx0ICoge0BsaW5rIFRleHR1cmUjcmVwZWF0fSwge0BsaW5rIFRleHR1cmUjcm90YXRpb259LCBhbmQge0BsaW5rIFRleHR1cmUjY2VudGVyfS5cblx0ICovXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LnNldFV2VHJhbnNmb3JtKCB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55LCB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55LCB0aGlzLnJvdGF0aW9uLCB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHRleHR1cmUgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7VGV4dHVyZX0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdGV4dHVyZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHNvdXJjZSAtIFRoZSB0ZXh0dXJlIHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge1RleHR1cmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMuc291cmNlID0gc291cmNlLnNvdXJjZTtcblx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG5cdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cdFx0dGhpcy5jaGFubmVsID0gc291cmNlLmNoYW5uZWw7XG5cblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cblx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IHNvdXJjZS5pbnRlcm5hbEZvcm1hdDtcblx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcblx0XHR0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cdFx0dGhpcy5jZW50ZXIuY29weSggc291cmNlLmNlbnRlciApO1xuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0dGhpcy5jb2xvclNwYWNlID0gc291cmNlLmNvbG9yU3BhY2U7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHNvdXJjZS5yZW5kZXJUYXJnZXQ7XG5cdFx0dGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSBzb3VyY2UuaXNSZW5kZXJUYXJnZXRUZXh0dXJlO1xuXHRcdHRoaXMuaXNUZXh0dXJlQXJyYXkgPSBzb3VyY2UuaXNUZXh0dXJlQXJyYXk7XG5cblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2VyaWFsaXplcyB0aGUgdGV4dHVyZSBpbnRvIEpTT04uXG5cdCAqXG5cdCAqIEBwYXJhbSB7PyhPYmplY3R8c3RyaW5nKX0gbWV0YSAtIEFuIG9wdGlvbmFsIHZhbHVlIGhvbGRpbmcgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VyaWFsaXphdGlvbi5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXplZCB0ZXh0dXJlLlxuXHQgKiBAc2VlIHtAbGluayBPYmplY3RMb2FkZXIjcGFyc2V9XG5cdCAqL1xuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0cHV0ID0ge1xuXG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG5cdFx0XHR9LFxuXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cblx0XHRcdGltYWdlOiB0aGlzLnNvdXJjZS50b0pTT04oIG1ldGEgKS51dWlkLFxuXG5cdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cdFx0XHRjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG5cblx0XHRcdHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXG5cdFx0XHRvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxuXHRcdFx0Y2VudGVyOiBbIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgXSxcblx0XHRcdHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuXG5cdFx0XHR3cmFwOiBbIHRoaXMud3JhcFMsIHRoaXMud3JhcFQgXSxcblxuXHRcdFx0Zm9ybWF0OiB0aGlzLmZvcm1hdCxcblx0XHRcdGludGVybmFsRm9ybWF0OiB0aGlzLmludGVybmFsRm9ybWF0LFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0Y29sb3JTcGFjZTogdGhpcy5jb2xvclNwYWNlLFxuXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxuXHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcblx0XHRcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcblxuXHRcdFx0ZmxpcFk6IHRoaXMuZmxpcFksXG5cblx0XHRcdGdlbmVyYXRlTWlwbWFwczogdGhpcy5nZW5lcmF0ZU1pcG1hcHMsXG5cdFx0XHRwcmVtdWx0aXBseUFscGhhOiB0aGlzLnByZW11bHRpcGx5QWxwaGEsXG5cdFx0XHR1bnBhY2tBbGlnbm1lbnQ6IHRoaXMudW5wYWNrQWxpZ25tZW50XG5cblx0XHR9O1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBvdXRwdXQudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0aWYgKCAhIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKlxuXHQgKiBAZmlyZXMgVGV4dHVyZSNkaXNwb3NlXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogRmlyZXMgd2hlbiB0aGUgdGV4dHVyZSBoYXMgYmVlbiBkaXNwb3NlZCBvZi5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBUZXh0dXJlI2Rpc3Bvc2Vcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gdXYgdmVjdG9yIHdpdGggdGhlIHRleHR1cmVzIHV2IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB1diAtIFRoZSB1diB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSB0cmFuc2Zvcm1lZCB1diB2ZWN0b3IuXG5cdCAqL1xuXHR0cmFuc2Zvcm1VdiggdXYgKSB7XG5cblx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgcmV0dXJuIHV2O1xuXG5cdFx0dXYuYXBwbHlNYXRyaXgzKCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0aWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuXHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmZsaXBZICkge1xuXG5cdFx0XHR1di55ID0gMSAtIHV2Lnk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdXY7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIGluZGljYXRlcyB0aGUgZW5naW5lIHRoZSB0ZXh0dXJlXG5cdCAqIG11c3QgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCByZW5kZXIuIFRoaXMgdHJpZ2dlcnMgYSB0ZXh0dXJlIHVwbG9hZFxuXHQgKiB0byB0aGUgR1BVIGFuZCBlbnN1cmVzIGNvcnJlY3QgdGV4dHVyZSBwYXJhbWV0ZXIgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcblx0ICovXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cdFx0XHR0aGlzLnNvdXJjZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIGluZGljYXRlcyB0aGUgZW5naW5lIHRoZSBQTVJFTVxuXHQgKiBtdXN0IGJlIHJlZ2VuZXJhdGVkLlxuXHQgKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzUE1SRU1VcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5wbXJlbVZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgaW1hZ2UgZm9yIGFsbCB0ZXh0dXJlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7P0ltYWdlfVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSBudWxsO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1hcHBpbmcgZm9yIGFsbCB0ZXh0dXJlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgVVZNYXBwaW5nXG4gKi9cblRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVVZNYXBwaW5nO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFuaXNvdHJvcHkgdmFsdWUgZm9yIGFsbCB0ZXh0dXJlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMVxuICovXG5UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWSA9IDE7XG5cbmV4cG9ydCB7IFRleHR1cmUgfTtcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIDREIHZlY3Rvci4gQSA0RCB2ZWN0b3IgaXMgYW4gb3JkZXJlZCBxdWFkcnVwbGV0IG9mIG51bWJlcnNcbiAqIChsYWJlbGVkIHgsIHksIHogYW5kIHcpLCB3aGljaCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYSBudW1iZXIgb2YgdGhpbmdzLCBzdWNoIGFzOlxuICpcbiAqIC0gQSBwb2ludCBpbiA0RCBzcGFjZS5cbiAqIC0gQSBkaXJlY3Rpb24gYW5kIGxlbmd0aCBpbiA0RCBzcGFjZS4gSW4gdGhyZWUuanMgdGhlIGxlbmd0aCB3aWxsXG4gKiBhbHdheXMgYmUgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZShzdHJhaWdodC1saW5lIGRpc3RhbmNlKSBmcm9tIGAoMCwgMCwgMCwgMClgIHRvIGAoeCwgeSwgeiwgdylgXG4gKiBhbmQgdGhlIGRpcmVjdGlvbiBpcyBhbHNvIG1lYXN1cmVkIGZyb20gYCgwLCAwLCAwLCAwKWAgdG93YXJkcyBgKHgsIHksIHosIHcpYC5cbiAqIC0gQW55IGFyYml0cmFyeSBvcmRlcmVkIHF1YWRydXBsZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGVyZSBhcmUgb3RoZXIgdGhpbmdzIGEgNEQgdmVjdG9yIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCwgaG93ZXZlciB0aGVzZVxuICogYXJlIHRoZSBtb3N0IGNvbW1vbiB1c2VzIGluICp0aHJlZS5qcyouXG4gKlxuICogSXRlcmF0aW5nIHRocm91Z2ggYSB2ZWN0b3IgaW5zdGFuY2Ugd2lsbCB5aWVsZCBpdHMgY29tcG9uZW50cyBgKHgsIHksIHosIHcpYCBpblxuICogdGhlIGNvcnJlc3BvbmRpbmcgb3JkZXIuXG4gKiBgYGBqc1xuICogY29uc3QgYSA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAxLCAwLCAwICk7XG4gKlxuICogLy9ubyBhcmd1bWVudHM7IHdpbGwgYmUgaW5pdGlhbGlzZWQgdG8gKDAsIDAsIDAsIDEpXG4gKiBjb25zdCBiID0gbmV3IFRIUkVFLlZlY3RvcjQoICk7XG4gKlxuICogY29uc3QgZCA9IGEuZG90KCBiICk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgVmVjdG9yNCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgNEQgdmVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbej0wXSAtIFRoZSB6IHZhbHVlIG9mIHRoaXMgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3c9MV0gLSBUaGUgdyB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFZlY3RvcjQucHJvdG90eXBlLmlzVmVjdG9yNCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgeCB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB5IHZhbHVlIG9mIHRoaXMgdmVjdG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHogdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdyB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy53ID0gdztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGZvciB7QGxpbmsgVmVjdG9yNCN6fS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCB3aWR0aCgpIHtcblxuXHRcdHJldHVybiB0aGlzLno7XG5cblx0fVxuXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnogPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGZvciB7QGxpbmsgVmVjdG9yNCN3fS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBoZWlnaHQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53O1xuXG5cdH1cblxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudyA9IHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yIGNvbXBvbmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHZhbHVlIG9mIHRoZSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmFsdWUgb2YgdGhlIHkgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB2YWx1ZSBvZiB0aGUgeiBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3IC0gVGhlIHZhbHVlIG9mIHRoZSB3IGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyB0byB0aGUgc2FtZSB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSB2YWx1ZSB0byBzZXQgZm9yIGFsbCB2ZWN0b3IgY29tcG9uZW50cy5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdHRoaXMudyA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeCBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeiBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRaKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgdyBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRXKCB3ICkge1xuXG5cdFx0dGhpcy53ID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWxsb3dzIHRvIHNldCBhIHZlY3RvciBjb21wb25lbnQgd2l0aCBhbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGNvbXBvbmVudCBpbmRleC4gYDBgIGVxdWFscyB0byB4LCBgMWAgZXF1YWxzIHRvIHksXG5cdCAqIGAyYCBlcXVhbHMgdG8geiwgYDNgIGVxdWFscyB0byB3LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHZlY3RvciBjb21wb25lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjb21wb25lbnQgaW5kZXguIGAwYCBlcXVhbHMgdG8geCwgYDFgIGVxdWFscyB0byB5LFxuXHQgKiBgMmAgZXF1YWxzIHRvIHosIGAzYCBlcXVhbHMgdG8gdy5cblx0ICogQHJldHVybiB7bnVtYmVyfSBBIHZlY3RvciBjb21wb25lbnQgdmFsdWUuXG5cdCAqL1xuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM3xWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHZhbHVlIHRvIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cdFx0dGhpcy53ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvcnMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yNH0gYSAtIFRoZSBmaXJzdCB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yNH0gYiAtIFRoZSBzZWNvbmQgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHR0aGlzLncgPSBhLncgKyBiLnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIGZhY3RvciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjR9IHYgLSBUaGUgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBmYWN0b3IgdGhhdCBzY2FsZXMgYHZgLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yNH0gdiAtIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0dGhpcy53IC09IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3RzIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUgZnJvbSBhbGwgY29tcG9uZW50cyBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBzY2FsYXIgdG8gc3VidHJhY3QuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c3ViU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cdFx0dGhpcy56IC09IHM7XG5cdFx0dGhpcy53IC09IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9ycyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSBhIC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3I0fSBiIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c3ViVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXHRcdHRoaXMudyA9IGEudyAtIGIudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGUgZ2l2ZW4gdmVjdG9yIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byBtdWx0aXBseS5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXHRcdHRoaXMudyAqPSB2Lnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIHNjYWxhciB2YWx1ZSB3aXRoIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHRvIG11bHRpcGx5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggdGhlIGdpdmVuIDR4NCBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSA0eDQgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XG5cdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGVzIHRoaXMgaW5zdGFuY2UgYnkgdGhlIGdpdmVuIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byBkaXZpZGUuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cdFx0dGhpcy53IC89IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB0byBkaXZpZGUuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCwgeSBhbmQgeiBjb21wb25lbnRzIG9mIHRoaXNcblx0ICogdmVjdG9yIHRvIHRoZSBxdWF0ZXJuaW9uJ3MgYXhpcyBhbmQgdyB0byB0aGUgYW5nbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSAtIFRoZSBRdWF0ZXJuaW9uIHRvIHNldC5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cblxuXHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcblxuXHRcdGNvbnN0IHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcblxuXHRcdFx0dGhpcy54ID0gMTtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLnogPSAwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gcS54IC8gcztcblx0XHRcdHRoaXMueSA9IHEueSAvIHM7XG5cdFx0XHR0aGlzLnogPSBxLnogLyBzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB4LCB5IGFuZCB6IGNvbXBvbmVudHMgb2YgdGhpc1xuXHQgKiB2ZWN0b3IgdG8gdGhlIGF4aXMgb2Ygcm90YXRpb24gYW5kIHcgdG8gdGhlIGFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG0gLSBBIDR4NCBtYXRyaXggb2Ygd2hpY2ggdGhlIHVwcGVyIGxlZnQgM3gzIG1hdHJpeCBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeCggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdGxldCBhbmdsZSwgeCwgeSwgejsgLy8gdmFyaWFibGVzIGZvciByZXN1bHRcblx0XHRjb25zdCBlcHNpbG9uID0gMC4wMSxcdFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xuXG5cdFx0XHR0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApICYmXG5cdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJlxuXHRcdCAgICAgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXG5cdFx0XHQgICAgICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKSAmJlxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblxuXHRcdFx0Y29uc3QgeHggPSAoIG0xMSArIDEgKSAvIDI7XG5cdFx0XHRjb25zdCB5eSA9ICggbTIyICsgMSApIC8gMjtcblx0XHRcdGNvbnN0IHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuXHRcdFx0Y29uc3QgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcblx0XHRcdGNvbnN0IHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XG5cdFx0XHRjb25zdCB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xuXG5cdFx0XHRcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XG5cdFx0XHRcdFx0eiA9IHh6IC8geDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XG5cblx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcblx0XHRcdFx0XHR6ID0geXogLyB5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xuXHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG5cdFx0fVxuXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0bGV0IHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApICtcblx0XHRcdCggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcblx0XHRcdCggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXG5cblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yIGNvbXBvbmVudHMgdG8gdGhlIHBvc2l0aW9uIGVsZW1lbnRzIG9mIHRoZVxuXHQgKiBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSA0eDQgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cdFx0dGhpcy53ID0gZVsgMTUgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhpcyB2ZWN0b3IncyB4LCB5LCB6IG9yIHcgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBnaXZlbiB2ZWN0b3IncyB4LCB5LCB6IG9yIHdcblx0ICogdmFsdWUsIHJlcGxhY2UgdGhhdCB2YWx1ZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG1pbiB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1pbiggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhpcyB2ZWN0b3IncyB4LCB5LCB6IG9yIHcgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBnaXZlbiB2ZWN0b3IncyB4LCB5LCB6IG9yIHdcblx0ICogdmFsdWUsIHJlcGxhY2UgdGhhdCB2YWx1ZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG1heCB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhpcyB2ZWN0b3IncyB4LCB5LCB6IG9yIHcgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggdmVjdG9yJ3MgeCwgeSwgeiBvciB3XG5cdCAqIHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cblx0ICogSWYgdGhpcyB2ZWN0b3IncyB4LCB5LCB6IG9yIHcgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW4gdmVjdG9yJ3MgeCwgeSwgeiBvciB3IHZhbHVlLFxuXHQgKiBpdCBpcyByZXBsYWNlZCBieSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSBtaW4gLSBUaGUgbWluaW11bSB4LCB5IGFuZCB6IHZhbHVlcy5cblx0ICogQHBhcmFtIHtWZWN0b3I0fSBtYXggLSBUaGUgbWF4aW11bSB4LCB5IGFuZCB6IHZhbHVlcyBpbiB0aGUgZGVzaXJlZCByYW5nZS5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluLngsIG1heC54ICk7XG5cdFx0dGhpcy55ID0gY2xhbXAoIHRoaXMueSwgbWluLnksIG1heC55ICk7XG5cdFx0dGhpcy56ID0gY2xhbXAoIHRoaXMueiwgbWluLnosIG1heC56ICk7XG5cdFx0dGhpcy53ID0gY2xhbXAoIHRoaXMudywgbWluLncsIG1heC53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSwgeiBvciB3IHZhbHVlcyBhcmUgZ3JlYXRlciB0aGFuIHRoZSBtYXggdmFsdWUsIHRoZXkgYXJlXG5cdCAqIHJlcGxhY2VkIGJ5IHRoZSBtYXggdmFsdWUuXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSwgeiBvciB3IHZhbHVlcyBhcmUgbGVzcyB0aGFuIHRoZSBtaW4gdmFsdWUsIHRoZXkgYXJlXG5cdCAqIHJlcGxhY2VkIGJ5IHRoZSBtaW4gdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5WYWwgLSBUaGUgbWluaW11bSB2YWx1ZSB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGNsYW1wZWQgdG8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWYWwgLSBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGNsYW1wZWQgdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gY2xhbXAoIHRoaXMueCwgbWluVmFsLCBtYXhWYWwgKTtcblx0XHR0aGlzLnkgPSBjbGFtcCggdGhpcy55LCBtaW5WYWwsIG1heFZhbCApO1xuXHRcdHRoaXMueiA9IGNsYW1wKCB0aGlzLnosIG1pblZhbCwgbWF4VmFsICk7XG5cdFx0dGhpcy53ID0gY2xhbXAoIHRoaXMudywgbWluVmFsLCBtYXhWYWwgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5XG5cdCAqIHRoZSBtYXggdmFsdWUuXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgbWluIHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieSB0aGVcblx0ICogbWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIHZlY3RvciBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIHZlY3RvciBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIGNsYW1wKCBsZW5ndGgsIG1pbiwgbWF4ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhcmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgYXJlIHJvdW5kZWQgdG93YXJkcyB6ZXJvICh1cCBpZiBuZWdhdGl2ZSxcblx0ICogZG93biBpZiBwb3NpdGl2ZSkgdG8gYW4gaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgudHJ1bmMoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGgudHJ1bmMoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoaXMgdmVjdG9yIC0gaS5lLiBzZXRzIHggPSAteCwgeSA9IC15LCB6ID0gLXosIHcgPSAtdy5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhlIGdpdmVuIHZlY3RvciB3aXRoIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yNH0gdiAtIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgd2l0aC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVzdWx0IG9mIHRoZSBkb3QgcHJvZHVjdC5cblx0ICovXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBFdWNsaWRlYW4gbGVuZ3RoIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbVxuXHQgKiAoMCwgMCwgMCwgMCkgdG8gKHgsIHksIHosIHcpLiBJZiB5b3UgYXJlIGNvbXBhcmluZyB0aGUgbGVuZ3RocyBvZiB2ZWN0b3JzLCB5b3Ugc2hvdWxkXG5cdCAqIGNvbXBhcmUgdGhlIGxlbmd0aCBzcXVhcmVkIGluc3RlYWQgYXMgaXQgaXMgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdG8gY2FsY3VsYXRlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlICBFdWNsaWRlYW4gbGVuZ3RoIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbSAoMCwgMCwgMCwgMCkgdG8gKHgsIHksIHosIHcpLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBNYW5oYXR0YW4gbGVuZ3RoIG9mIHRoaXMgdmVjdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhpcyB2ZWN0b3IgdG8gYSB1bml0IHZlY3RvciAtIHRoYXQgaXMsIHNldHMgaXQgZXF1YWwgdG8gYSB2ZWN0b3Jcblx0ICogd2l0aCB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhpcyBvbmUsIGJ1dCB3aXRoIGEgdmVjdG9yIGxlbmd0aCBvZiBgMWAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyB2ZWN0b3IgdG8gYSB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhpcyBvbmUsIGJ1dFxuXHQgKiB3aXRoIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIG5ldyBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdmVjdG9yIGFuZCB0aGlzIGluc3RhbmNlLCB3aGVyZVxuXHQgKiBhbHBoYSBpcyB0aGUgcGVyY2VudCBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSAtIGFscGhhID0gMCB3aWxsIGJlIHRoaXNcblx0ICogdmVjdG9yLCBhbmQgYWxwaGEgPSAxIHdpbGwgYmUgdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IsIHR5cGljYWxseSBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cdFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdGhlIGdpdmVuIHZlY3RvcnMsIHdoZXJlIGFscGhhIGlzIHRoZSBwZXJjZW50XG5cdCAqIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIC0gYWxwaGEgPSAwIHdpbGwgYmUgZmlyc3QgdmVjdG9yLCBhbmQgYWxwaGEgPSAxIHdpbGxcblx0ICogYmUgdGhlIHNlY29uZCBvbmUuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yNH0gdjEgLSBUaGUgZmlyc3QgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjR9IHYyIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciwgdHlwaWNhbGx5IGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcblx0XHR0aGlzLncgPSB2MS53ICsgKCB2Mi53IC0gdjEudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmVjdG9yIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3I0fSB2IC0gVGhlIHZlY3RvciB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZlY3RvciBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqL1xuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyB2ZWN0b3IncyB4IHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0IF1gLCB5IHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0ICsgMSBdYCxcblx0ICogeiB2YWx1ZSB0byBiZSBgYXJyYXlbIG9mZnNldCArIDIgXWAsIHcgdmFsdWUgdG8gYmUgYGFycmF5WyBvZmZzZXQgKyAzIF1gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFycmF5IC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgdmVjdG9yIGNvbXBvbmVudCB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gVGhlIG9mZnNldCBpbnRvIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7VmVjdG9yNH0gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKi9cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IGF0dHJpYnV0ZSAtIFRoZSBidWZmZXIgYXR0cmlidXRlIGhvbGRpbmcgdmVjdG9yIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBhdHRyaWJ1dGUuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGVhY2ggY29tcG9uZW50IG9mIHRoaXMgdmVjdG9yIHRvIGEgcHNldWRvLXJhbmRvbSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmRcblx0ICogYDFgLCBleGNsdWRpbmcgYDFgLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3I0fSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMudyA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblx0XHR5aWVsZCB0aGlzLnc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZlY3RvcjQgfTtcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9UZXh0dXJlLmpzJztcbmltcG9ydCB7IExpbmVhckZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vbWF0aC9WZWN0b3I0LmpzJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4uL3RleHR1cmVzL1NvdXJjZS5qcyc7XG5cbi8qKlxuICogQSByZW5kZXIgdGFyZ2V0IGlzIGEgYnVmZmVyIHdoZXJlIHRoZSB2aWRlbyBjYXJkIGRyYXdzIHBpeGVscyBmb3IgYSBzY2VuZVxuICogdGhhdCBpcyBiZWluZyByZW5kZXJlZCBpbiB0aGUgYmFja2dyb3VuZC4gSXQgaXMgdXNlZCBpbiBkaWZmZXJlbnQgZWZmZWN0cyxcbiAqIHN1Y2ggYXMgYXBwbHlpbmcgcG9zdHByb2Nlc3NpbmcgdG8gYSByZW5kZXJlZCBpbWFnZSBiZWZvcmUgZGlzcGxheWluZyBpdFxuICogb24gdGhlIHNjcmVlbi5cbiAqXG4gKiBAYXVnbWVudHMgRXZlbnREaXNwYXRjaGVyXG4gKi9cbmNsYXNzIFJlbmRlclRhcmdldCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0LyoqXG5cdCAqIFJlbmRlciB0YXJnZXQgb3B0aW9ucy5cblx0ICpcblx0ICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyVGFyZ2V0fk9wdGlvbnNcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZ2VuZXJhdGVNaXBtYXBzPWZhbHNlXSAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgbWlwbWFwcyBvciBub3QuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFnRmlsdGVyPUxpbmVhckZpbHRlcl0gLSBUaGUgbWFnIGZpbHRlci5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5GaWx0ZXI9TGluZWFyRmlsdGVyXSAtIFRoZSBtaW4gZmlsdGVyLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Zvcm1hdD1SR0JBRm9ybWF0XSAtIFRoZSB0ZXh0dXJlIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlPVVuc2lnbmVkQnl0ZVR5cGVdIC0gVGhlIHRleHR1cmUgdHlwZS5cblx0ICogQHByb3BlcnR5IHs/c3RyaW5nfSBbaW50ZXJuYWxGb3JtYXQ9bnVsbF0gLSBUaGUgdGV4dHVyZSdzIGludGVybmFsIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB0ZXh0dXJlJ3MgdXYgd3JhcHBpbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwVD1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB0ZXh0dXJlJ3MgdXYgd3JhcHBpbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmlzb3Ryb3B5PTFdIC0gVGhlIHRleHR1cmUncyBhbmlzb3Ryb3B5IHZhbHVlLlxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yU3BhY2U9Tm9Db2xvclNwYWNlXSAtIFRoZSB0ZXh0dXJlJ3MgY29sb3Igc3BhY2UuXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHRoQnVmZmVyPXRydWVdIC0gV2hldGhlciB0byBhbGxvY2F0ZSBhIGRlcHRoIGJ1ZmZlciBvciBub3QuXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N0ZW5jaWxCdWZmZXI9ZmFsc2VdIC0gV2hldGhlciB0byBhbGxvY2F0ZSBhIHN0ZW5jaWwgYnVmZmVyIG9yIG5vdC5cblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzb2x2ZURlcHRoQnVmZmVyPXRydWVdIC0gV2hldGhlciB0byByZXNvbHZlIHRoZSBkZXB0aCBidWZmZXIgb3Igbm90LlxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXNvbHZlU3RlbmNpbEJ1ZmZlcj10cnVlXSAtIFdoZXRoZXIgIHRvIHJlc29sdmUgdGhlIHN0ZW5jaWwgYnVmZmVyIG9yIG5vdC5cblx0ICogQHByb3BlcnR5IHs/VGV4dHVyZX0gW2RlcHRoVGV4dHVyZT1udWxsXSAtIFJlZmVyZW5jZSB0byBhIGRlcHRoIHRleHR1cmUuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2FtcGxlcz0wXSAtIFRoZSBNU0FBIHNhbXBsZXMgY291bnQuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY291bnQ9MV0gLSBEZWZpbmVzIHRoZSBudW1iZXIgb2YgY29sb3IgYXR0YWNobWVudHMgLiBNdXN0IGJlIGF0IGxlYXN0IGAxYC5cblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGl2aWV3PWZhbHNlXSAtIFdoZXRoZXIgdGhpcyB0YXJnZXQgaXMgdXNlZCBmb3IgbXVsdGl2aWV3IHJlbmRlcmluZy5cblx0ICovXG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcmVuZGVyIHRhcmdldC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH5PcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1JlbmRlclRhcmdldCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGVwdGggb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmRlcHRoID0gb3B0aW9ucy5kZXB0aCA/IG9wdGlvbnMuZGVwdGggOiAxO1xuXG5cdFx0LyoqXG5cdFx0ICogQSByZWN0YW5ndWxhciBhcmVhIGluc2lkZSB0aGUgcmVuZGVyIHRhcmdldCdzIHZpZXdwb3J0LiBGcmFnbWVudHMgdGhhdCBhcmVcblx0XHQgKiBvdXRzaWRlIHRoZSBhcmVhIHdpbGwgYmUgZGlzY2FyZGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjR9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCx3aWR0aCxoZWlnaHQpXG5cdFx0ICovXG5cdFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2lzc29yIHRlc3Qgc2hvdWxkIGJlIGVuYWJsZWQgd2hlbiByZW5kZXJpbmcgaW50b1xuXHRcdCAqIHRoaXMgcmVuZGVyIHRhcmdldCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcmVjdGFuZ3VsYXIgYXJlYSByZXByZXNlbnRpbmcgdGhlIHJlbmRlciB0YXJnZXQncyB2aWV3cG9ydC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3I0fVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsd2lkdGgsaGVpZ2h0KVxuXHRcdCAqL1xuXHRcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGRlcHRoOiB0aGlzLmRlcHRoIH07XG5cblx0XHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge1xuXHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcblx0XHRcdGludGVybmFsRm9ybWF0OiBudWxsLFxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRkZXB0aEJ1ZmZlcjogdHJ1ZSxcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuXHRcdFx0cmVzb2x2ZURlcHRoQnVmZmVyOiB0cnVlLFxuXHRcdFx0cmVzb2x2ZVN0ZW5jaWxCdWZmZXI6IHRydWUsXG5cdFx0XHRkZXB0aFRleHR1cmU6IG51bGwsXG5cdFx0XHRzYW1wbGVzOiAwLFxuXHRcdFx0Y291bnQ6IDEsXG5cdFx0XHRtdWx0aXZpZXc6IGZhbHNlXG5cdFx0fSwgb3B0aW9ucyApO1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZSwgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5jb2xvclNwYWNlICk7XG5cblx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcztcblx0XHR0ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRleHR1cmVzLiBFYWNoIGNvbG9yIGF0dGFjaG1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBzZXBhcmF0ZSB0ZXh0dXJlLlxuXHRcdCAqIEhhcyBhdCBsZWFzdCBhIHNpbmdsZSBlbnRyeSBmb3IgdGhlIGRlZmF1bHQgY29sb3IgYXR0YWNobWVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxUZXh0dXJlPn1cblx0XHQgKi9cblx0XHR0aGlzLnRleHR1cmVzID0gW107XG5cblx0XHRjb25zdCBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXSA9IHRleHR1cmUuY2xvbmUoKTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdLnJlbmRlclRhcmdldCA9IHRoaXM7XG5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIGFsbG9jYXRlIGEgZGVwdGggYnVmZmVyIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlcjtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gYWxsb2NhdGUgYSBzdGVuY2lsIGJ1ZmZlciBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gcmVzb2x2ZSB0aGUgZGVwdGggYnVmZmVyIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlciA9IG9wdGlvbnMucmVzb2x2ZURlcHRoQnVmZmVyO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byByZXNvbHZlIHRoZSBzdGVuY2lsIGJ1ZmZlciBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5yZXNvbHZlU3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMucmVzb2x2ZVN0ZW5jaWxCdWZmZXI7XG5cblx0XHR0aGlzLl9kZXB0aFRleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIE1TQUEgc2FtcGxlcy5cblx0XHQgKlxuXHRcdCAqIEEgdmFsdWUgb2YgYDBgIGRpc2FibGVzIE1TQUEuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXM7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIHRoaXMgdGFyZ2V0IGlzIHVzZWQgaW4gbXVsdGl2aWV3IHJlbmRlcmluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tdWx0aXZpZXcgPSBvcHRpb25zLm11bHRpdmlldztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSB0ZXh0dXJlIHJlcHJlc2VudGluZyB0aGUgZGVmYXVsdCBjb2xvciBhdHRhY2htZW50LlxuXHQgKlxuXHQgKiBAdHlwZSB7VGV4dHVyZX1cblx0ICovXG5cdGdldCB0ZXh0dXJlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZXNbIDAgXTtcblxuXHR9XG5cblx0c2V0IHRleHR1cmUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlc1sgMCBdID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldCBkZXB0aFRleHR1cmUoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2RlcHRoVGV4dHVyZSAhPT0gbnVsbCApIHRoaXMuX2RlcHRoVGV4dHVyZS5yZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdGlmICggY3VycmVudCAhPT0gbnVsbCApIGN1cnJlbnQucmVuZGVyVGFyZ2V0ID0gdGhpcztcblxuXHRcdHRoaXMuX2RlcHRoVGV4dHVyZSA9IGN1cnJlbnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0ZWFkIG9mIHNhdmluZyB0aGUgZGVwdGggaW4gYSByZW5kZXJidWZmZXIsIGEgdGV4dHVyZVxuXHQgKiBjYW4gYmUgdXNlZCBpbnN0ZWFkIHdoaWNoIGlzIHVzZWZ1bCBmb3IgZnVydGhlciBwcm9jZXNzaW5nXG5cdCAqIGUuZy4gaW4gY29udGV4dCBvZiBwb3N0LXByb2Nlc3NpbmcuXG5cdCAqXG5cdCAqIEB0eXBlIHs/RGVwdGhUZXh0dXJlfVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRnZXQgZGVwdGhUZXh0dXJlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2RlcHRoVGV4dHVyZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyByZW5kZXIgdGFyZ2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIC0gVGhlIGRlcHRoLlxuXHQgKi9cblx0c2V0U2l6ZSggd2lkdGgsIGhlaWdodCwgZGVwdGggPSAxICkge1xuXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHRoaXMuZGVwdGggIT09IGRlcHRoICkge1xuXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMudGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy50ZXh0dXJlc1sgaSBdLmltYWdlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pbWFnZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5pbWFnZS5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy52aWV3cG9ydC5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblx0XHR0aGlzLnNjaXNzb3Iuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlbmRlciB0YXJnZXQgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIHJlbmRlciB0YXJnZXQuIFRoaXMgaXMgYSBzdHJ1Y3R1cmFsIGNvcHkgc29cblx0ICogbm8gcmVzb3VyY2VzIGFyZSBzaGFyZWQgYmV0d2VlbiByZW5kZXIgdGFyZ2V0cyBhZnRlciB0aGUgY29weS4gVGhhdCBpbmNsdWRlc1xuXHQgKiBhbGwgTVJUIHRleHR1cmVzIGFuZCB0aGUgZGVwdGggdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtSZW5kZXJUYXJnZXR9IHNvdXJjZSAtIFRoZSByZW5kZXIgdGFyZ2V0IHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG5cblx0XHR0aGlzLnNjaXNzb3IuY29weSggc291cmNlLnNjaXNzb3IgKTtcblx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gc291cmNlLnNjaXNzb3JUZXN0O1xuXG5cdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcblxuXHRcdHRoaXMudGV4dHVyZXMubGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBzb3VyY2UudGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXSA9IHNvdXJjZS50ZXh0dXJlc1sgaSBdLmNsb25lKCk7XG5cdFx0XHR0aGlzLnRleHR1cmVzWyBpIF0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5yZW5kZXJUYXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBlbnN1cmUgaW1hZ2Ugb2JqZWN0IGlzIG5vdCBzaGFyZWQsIHNlZSAjMjAzMjhcblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnRleHR1cmVzWyBpIF0uaW1hZ2UgKTtcblx0XHRcdHRoaXMudGV4dHVyZXNbIGkgXS5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblxuXHRcdHRoaXMucmVzb2x2ZURlcHRoQnVmZmVyID0gc291cmNlLnJlc29sdmVEZXB0aEJ1ZmZlcjtcblx0XHR0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyID0gc291cmNlLnJlc29sdmVTdGVuY2lsQnVmZmVyO1xuXG5cdFx0aWYgKCBzb3VyY2UuZGVwdGhUZXh0dXJlICE9PSBudWxsICkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG5cblx0XHR0aGlzLnNhbXBsZXMgPSBzb3VyY2Uuc2FtcGxlcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKlxuXHQgKiBAZmlyZXMgUmVuZGVyVGFyZ2V0I2Rpc3Bvc2Vcblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUmVuZGVyVGFyZ2V0IH07XG4iLCJpbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi9jb3JlL1JlbmRlclRhcmdldC5qcyc7XG5cbi8qKlxuICogQSByZW5kZXIgdGFyZ2V0IHVzZWQgaW4gY29udGV4dCBvZiB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG4gKlxuICogQGF1Z21lbnRzIFJlbmRlclRhcmdldFxuICovXG5jbGFzcyBXZWJHTFJlbmRlclRhcmdldCBleHRlbmRzIFJlbmRlclRhcmdldCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgM0QgcmVuZGVyIHRhcmdldC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH5PcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlciggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfTtcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0ZXh0dXJlcyBkaXJlY3RseSBmcm9tIHJhdyBidWZmZXIgZGF0YS5cbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBEYXRhQXJyYXlUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGF0YSBhcnJheSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0gez9UeXBlZEFycmF5fSBbZGF0YT1udWxsXSAtIFRoZSBidWZmZXIgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIC0gVGhlIGRlcHRoIG9mIHRoZSB0ZXh0dXJlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSApIHtcblxuXHRcdHN1cGVyKCBudWxsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzRGF0YUFycmF5VGV4dHVyZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgZGVmaW5pdGlvbiBvZiBhIGRhdGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHt7ZGF0YTpUeXBlZEFycmF5LHdpZHRoOm51bWJlcixoZWlnaHQ6bnVtYmVyLGRlcHRoOm51bWJlcn19XG5cdFx0ICovXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0aGUgdGV4dHVyZSBpcyBzYW1wbGVkIHdoZW4gYSB0ZXhlbCBjb3ZlcnMgbW9yZSB0aGFuIG9uZSBwaXhlbC5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYE5lYXJlc3RGaWx0ZXJgIGJ5IGRlZmF1bHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcnxMaW5lYXJGaWx0ZXJ8TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcnxMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIpfVxuXHRcdCAqIEBkZWZhdWx0IE5lYXJlc3RGaWx0ZXJcblx0XHQgKi9cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgdGhlIHRleHR1cmUgaXMgc2FtcGxlZCB3aGVuIGEgdGV4ZWwgY292ZXJzIGxlc3MgdGhhbiBvbmUgcGl4ZWwuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBOZWFyZXN0RmlsdGVyYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXJ8TGluZWFyRmlsdGVyfExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXJ8TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyKX1cblx0XHQgKiBAZGVmYXVsdCBOZWFyZXN0RmlsdGVyXG5cdFx0ICovXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkZWZpbmVzIGhvdyB0aGUgdGV4dHVyZSBpcyB3cmFwcGVkIGluIHRoZSBkZXB0aCBhbmQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiAqVyogaW4gVVZXIG1hcHBpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFJlcGVhdFdyYXBwaW5nfENsYW1wVG9FZGdlV3JhcHBpbmd8TWlycm9yZWRSZXBlYXRXcmFwcGluZyl9XG5cdFx0ICogQGRlZmF1bHQgQ2xhbXBUb0VkZ2VXcmFwcGluZ1xuXHRcdCAqL1xuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBnZW5lcmF0ZSBtaXBtYXBzIChpZiBwb3NzaWJsZSkgZm9yIGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHRleHR1cmUgaXMgZmxpcHBlZCBhbG9uZyB0aGUgdmVydGljYWwgYXhpcyB3aGVuXG5cdFx0ICogdXBsb2FkZWQgdG8gdGhlIEdQVS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGFsaWdubWVudCByZXF1aXJlbWVudHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHBpeGVsIHJvdyBpbiBtZW1vcnkuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGAxYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgc2V0IG9mIGFsbCBsYXllcnMgd2hpY2ggbmVlZCB0byBiZSB1cGRhdGVkIGluIHRoZSB0ZXh0dXJlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1NldDxudW1iZXI+fVxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXJVcGRhdGVzID0gbmV3IFNldCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVzY3JpYmVzIHRoYXQgYSBzcGVjaWZpYyBsYXllciBvZiB0aGUgdGV4dHVyZSBuZWVkcyB0byBiZSB1cGRhdGVkLlxuXHQgKiBOb3JtYWxseSB3aGVuIHtAbGluayBUZXh0dXJlI25lZWRzVXBkYXRlfSBpcyBzZXQgdG8gYHRydWVgLCB0aGVcblx0ICogZW50aXJlIGRhdGEgdGV4dHVyZSBhcnJheSBpcyBzZW50IHRvIHRoZSBHUFUuIE1hcmtpbmcgc3BlY2lmaWNcblx0ICogbGF5ZXJzIHdpbGwgb25seSB0cmFuc21pdCBzdWJzZXRzIG9mIGFsbCBtaXBtYXBzIGFzc29jaWF0ZWQgd2l0aCBhXG5cdCAqIHNwZWNpZmljIGRlcHRoIGluIHRoZSBhcnJheSB3aGljaCBpcyBvZnRlbiBtdWNoIG1vcmUgcGVyZm9ybWFudC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxheWVySW5kZXggLSBUaGUgbGF5ZXIgaW5kZXggdGhhdCBzaG91bGQgYmUgdXBkYXRlZC5cblx0ICovXG5cdGFkZExheWVyVXBkYXRlKCBsYXllckluZGV4ICkge1xuXG5cdFx0dGhpcy5sYXllclVwZGF0ZXMuYWRkKCBsYXllckluZGV4ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGxheWVyIHVwZGF0ZXMgcmVnaXN0cnkuXG5cdCAqL1xuXHRjbGVhckxheWVyVXBkYXRlcygpIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmNsZWFyKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IERhdGFBcnJheVRleHR1cmUgfTtcbiIsImltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9XZWJHTFJlbmRlclRhcmdldC5qcyc7XG5pbXBvcnQgeyBEYXRhQXJyYXlUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YUFycmF5VGV4dHVyZS5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgcmVuZGVyIHRhcmdldCB1c2VkIGluIGNvbnRleHQgb2Yge0BsaW5rIFdlYkdMUmVuZGVyZXJ9LlxuICpcbiAqIEBhdWdtZW50cyBXZWJHTFJlbmRlclRhcmdldFxuICovXG5jbGFzcyBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0IGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFycmF5IHJlbmRlciB0YXJnZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7UmVuZGVyVGFyZ2V0fk9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNXZWJHTEFycmF5UmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJ3cml0dGVuIHdpdGggYSBkaWZmZXJlbnQgdGV4dHVyZSB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0RhdGFBcnJheVRleHR1cmV9XG5cdFx0ICovXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIG51bGwsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XG5cblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgV2ViR0xBcnJheVJlbmRlclRhcmdldCB9O1xuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBDbGFtcFRvRWRnZVdyYXBwaW5nLCBOZWFyZXN0RmlsdGVyIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyZWUtZGltZW5zaW9uYWwgdGV4dHVyZSBmcm9tIHJhdyBkYXRhLCB3aXRoIHBhcmFtZXRlcnMgdG9cbiAqIGRpdmlkZSBpdCBpbnRvIHdpZHRoLCBoZWlnaHQsIGFuZCBkZXB0aC5cbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBEYXRhM0RUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGF0YSBhcnJheSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0gez9UeXBlZEFycmF5fSBbZGF0YT1udWxsXSAtIFRoZSBidWZmZXIgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIC0gVGhlIGRlcHRoIG9mIHRoZSB0ZXh0dXJlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSApIHtcblxuXHRcdC8vIFdlJ3JlIGdvaW5nIHRvIGFkZCAuc2V0WFhYKCkgbWV0aG9kcyBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIGxhdGVyLlxuXHRcdC8vIFVzZXJzIGNhbiBzdGlsbCBzZXQgaW4gRGF0YTNEVGV4dHVyZSBkaXJlY3RseS5cblx0XHQvL1xuXHRcdC8vXHRjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGEzRFRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XG5cdFx0Ly8gXHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSAxNjtcblx0XHQvL1xuXHRcdC8vIFNlZSAjMTQ4MzlcblxuXHRcdHN1cGVyKCBudWxsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzRGF0YTNEVGV4dHVyZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgZGVmaW5pdGlvbiBvZiBhIGRhdGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHt7ZGF0YTpUeXBlZEFycmF5LHdpZHRoOm51bWJlcixoZWlnaHQ6bnVtYmVyLGRlcHRoOm51bWJlcn19XG5cdFx0ICovXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0aGUgdGV4dHVyZSBpcyBzYW1wbGVkIHdoZW4gYSB0ZXhlbCBjb3ZlcnMgbW9yZSB0aGFuIG9uZSBwaXhlbC5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYE5lYXJlc3RGaWx0ZXJgIGJ5IGRlZmF1bHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcnxMaW5lYXJGaWx0ZXJ8TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcnxMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIpfVxuXHRcdCAqIEBkZWZhdWx0IE5lYXJlc3RGaWx0ZXJcblx0XHQgKi9cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgdGhlIHRleHR1cmUgaXMgc2FtcGxlZCB3aGVuIGEgdGV4ZWwgY292ZXJzIGxlc3MgdGhhbiBvbmUgcGl4ZWwuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBOZWFyZXN0RmlsdGVyYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyfE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXJ8TGluZWFyRmlsdGVyfExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXJ8TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyKX1cblx0XHQgKiBAZGVmYXVsdCBOZWFyZXN0RmlsdGVyXG5cdFx0ICovXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkZWZpbmVzIGhvdyB0aGUgdGV4dHVyZSBpcyB3cmFwcGVkIGluIHRoZSBkZXB0aCBhbmQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiAqVyogaW4gVVZXIG1hcHBpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFJlcGVhdFdyYXBwaW5nfENsYW1wVG9FZGdlV3JhcHBpbmd8TWlycm9yZWRSZXBlYXRXcmFwcGluZyl9XG5cdFx0ICogQGRlZmF1bHQgQ2xhbXBUb0VkZ2VXcmFwcGluZ1xuXHRcdCAqL1xuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBnZW5lcmF0ZSBtaXBtYXBzIChpZiBwb3NzaWJsZSkgZm9yIGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHRleHR1cmUgaXMgZmxpcHBlZCBhbG9uZyB0aGUgdmVydGljYWwgYXhpcyB3aGVuXG5cdFx0ICogdXBsb2FkZWQgdG8gdGhlIEdQVS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGFsaWdubWVudCByZXF1aXJlbWVudHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHBpeGVsIHJvdyBpbiBtZW1vcnkuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGAxYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRGF0YTNEVGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL1dlYkdMUmVuZGVyVGFyZ2V0LmpzJztcbmltcG9ydCB7IERhdGEzRFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9EYXRhM0RUZXh0dXJlLmpzJztcblxuLyoqXG4gKiBBIDNEIHJlbmRlciB0YXJnZXQgdXNlZCBpbiBjb250ZXh0IG9mIHtAbGluayBXZWJHTFJlbmRlcmVyfS5cbiAqXG4gKiBAYXVnbWVudHMgV2ViR0xSZW5kZXJUYXJnZXRcbiAqL1xuY2xhc3MgV2ViR0wzRFJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyAzRCByZW5kZXIgdGFyZ2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTFdIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0xXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH5PcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzV2ViR0wzRFJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHQvKipcblx0XHQgKiBPdmVyd3JpdHRlbiB3aXRoIGEgZGlmZmVyZW50IHRleHR1cmUgdHlwZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtEYXRhM0RUZXh0dXJlfVxuXHRcdCAqL1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBEYXRhM0RUZXh0dXJlKCBudWxsLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFdlYkdMM0RSZW5kZXJUYXJnZXQgfTtcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBRdWF0ZXJuaW9uLiBRdWF0ZXJuaW9ucyBhcmUgdXNlZCBpbiB0aHJlZS5qcyB0byByZXByZXNlbnQgcm90YXRpb25zLlxuICpcbiAqIEl0ZXJhdGluZyB0aHJvdWdoIGEgdmVjdG9yIGluc3RhbmNlIHdpbGwgeWllbGQgaXRzIGNvbXBvbmVudHMgYCh4LCB5LCB6LCB3KWAgaW5cbiAqIHRoZSBjb3JyZXNwb25kaW5nIG9yZGVyLlxuICpcbiAqIE5vdGUgdGhhdCB0aHJlZS5qcyBleHBlY3RzIFF1YXRlcm5pb25zIHRvIGJlIG5vcm1hbGl6ZWQuXG4gKiBgYGBqc1xuICogY29uc3QgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gKiBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIE1hdGguUEkgLyAyICk7XG4gKlxuICogY29uc3QgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcbiAqIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcbiAqIGBgYFxuICovXG5jbGFzcyBRdWF0ZXJuaW9uIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBxdWF0ZXJuaW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IHZhbHVlIG9mIHRoaXMgcXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdIC0gVGhlIHogdmFsdWUgb2YgdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3c9MV0gLSBUaGUgdyB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEludGVycG9sYXRlcyBiZXR3ZWVuIHR3byBxdWF0ZXJuaW9ucyB2aWEgU0xFUlAuIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGVcblx0ICogcXVhdGVybmlvbiBkYXRhIGFyZSBtYW5hZ2VkICBpbiBmbGF0IGFycmF5cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkc3QgLSBUaGUgZGVzdGluYXRpb24gYXJyYXkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkc3RPZmZzZXQgLSBBbiBvZmZzZXQgaW50byB0aGUgZGVzdGluYXRpb24gYXJyYXkuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3JjMCAtIFRoZSBzb3VyY2UgYXJyYXkgb2YgdGhlIGZpcnN0IHF1YXRlcm5pb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzcmNPZmZzZXQwIC0gQW4gb2Zmc2V0IGludG8gdGhlIGZpcnN0IHNvdXJjZSBhcnJheS5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzcmMxIC0gIFRoZSBzb3VyY2UgYXJyYXkgb2YgdGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3JjT2Zmc2V0MSAtIEFuIG9mZnNldCBpbnRvIHRoZSBzZWNvbmQgc291cmNlIGFycmF5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICogQHNlZSB7QGxpbmsgUXVhdGVybmlvbiNzbGVycH1cblx0ICovXG5cdHN0YXRpYyBzbGVycEZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0bGV0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcblxuXHRcdGNvbnN0IHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcblx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGlmICggdCA9PT0gMCApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHoxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xuXG5cdFx0XHRsZXQgcyA9IDEgLSB0O1xuXHRcdFx0Y29uc3QgY29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcblxuXHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xuXHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcblx0XHRcdGlmICggcyA9PT0gMSAtIHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcblxuXHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHR5MCAqPSBmO1xuXHRcdFx0XHR6MCAqPSBmO1xuXHRcdFx0XHR3MCAqPSBmO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHR3byBxdWF0ZXJuaW9ucy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoZSBxdWF0ZXJuaW9uIGRhdGEgYXJlIG1hbmFnZWRcblx0ICogaW4gZmxhdCBhcnJheXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZHN0IC0gVGhlIGRlc3RpbmF0aW9uIGFycmF5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHN0T2Zmc2V0IC0gQW4gb2Zmc2V0IGludG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5LlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNyYzAgLSBUaGUgc291cmNlIGFycmF5IG9mIHRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3JjT2Zmc2V0MCAtIEFuIG9mZnNldCBpbnRvIHRoZSBmaXJzdCBzb3VyY2UgYXJyYXkuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3JjMSAtICBUaGUgc291cmNlIGFycmF5IG9mIHRoZSBzZWNvbmQgcXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNyY09mZnNldDEgLSBBbiBvZmZzZXQgaW50byB0aGUgc2Vjb25kIHNvdXJjZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGRlc3RpbmF0aW9uIGFycmF5LlxuXHQgKiBAc2VlIHtAbGluayBRdWF0ZXJuaW9uI211bHRpcGx5UXVhdGVybmlvbnN9LlxuXHQgKi9cblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSApIHtcblxuXHRcdGNvbnN0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCBdO1xuXHRcdGNvbnN0IHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXTtcblx0XHRjb25zdCB6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF07XG5cdFx0Y29uc3QgdzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxIF07XG5cdFx0Y29uc3QgeTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdO1xuXHRcdGNvbnN0IHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXTtcblx0XHRjb25zdCB3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwICogdzEgKyB3MCAqIHkxICsgejAgKiB4MSAtIHgwICogejE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcblxuXHRcdHJldHVybiBkc3Q7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgeCB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgeSB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgeiB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdyB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDFcblx0ICovXG5cdGdldCB3KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3c7XG5cblx0fVxuXG5cdHNldCB3KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBxdWF0ZXJuaW9uIGNvbXBvbmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggdmFsdWUgb2YgdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHZhbHVlIG9mIHRoaXMgcXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiB2YWx1ZSBvZiB0aGlzIHF1YXRlcm5pb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3IC0gVGhlIHcgdmFsdWUgb2YgdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRzZXQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBxdWF0ZXJuaW9uIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gcXVhdGVybmlvbiB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb24gLSBUaGUgcXVhdGVybmlvbiB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRjb3B5KCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1YXRlcm5pb24gZnJvbSB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGJ5IHRoZSBnaXZlblxuXHQgKiBFdWxlciBhbmdsZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXVsZXJ9IGV1bGVyIC0gVGhlIEV1bGVyIGFuZ2xlcy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPXRydWVdIC0gV2hldGhlciB0aGUgaW50ZXJuYWwgYG9uQ2hhbmdlYCBjYWxsYmFjayBzaG91bGQgYmUgZXhlY3V0ZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRzZXRGcm9tRXVsZXIoIGV1bGVyLCB1cGRhdGUgPSB0cnVlICkge1xuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdGNvbnN0IGMxID0gY29zKCB4IC8gMiApO1xuXHRcdGNvbnN0IGMyID0gY29zKCB5IC8gMiApO1xuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0Y29uc3QgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XG5cdFx0Y29uc3QgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGF4aXMgYW5kIGFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGF4aXMgLSBUaGUgbm9ybWFsaXplZCBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0c2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHRjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiByb3RhdGlvbiBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIEEgNHg0IG1hdHJpeCBvZiB3aGljaCB0aGUgdXBwZXIgM3gzIG9mIG1hdHJpeCBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUuIHVuc2NhbGVkKS5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiB0byB0aGUgcm90YXRpb24gcmVxdWlyZWQgdG8gcm90YXRlIHRoZSBkaXJlY3Rpb24gdmVjdG9yXG5cdCAqIGB2RnJvbWAgdG8gdGhlIGRpcmVjdGlvbiB2ZWN0b3IgYHZUb2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdkZyb20gLSBUaGUgZmlyc3QgKG5vcm1hbGl6ZWQpIGRpcmVjdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdlRvIC0gVGhlIHNlY29uZCAobm9ybWFsaXplZCkgZGlyZWN0aW9uIHZlY3Rvci5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0c2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHRsZXQgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG5cdFx0aWYgKCByIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdC8vIHZGcm9tIGFuZCB2VG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuXG5cdFx0XHRyID0gMDtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gLSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl95ID0gdkZyb20ueDtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gLSB2RnJvbS56O1xuXHRcdFx0XHR0aGlzLl96ID0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApOyAvLyBpbmxpbmVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmN5IG9uIFZlY3RvcjNcblxuXHRcdFx0dGhpcy5feCA9IHZGcm9tLnkgKiB2VG8ueiAtIHZGcm9tLnogKiB2VG8ueTtcblx0XHRcdHRoaXMuX3kgPSB2RnJvbS56ICogdlRvLnggLSB2RnJvbS54ICogdlRvLno7XG5cdFx0XHR0aGlzLl96ID0gdkZyb20ueCAqIHZUby55IC0gdkZyb20ueSAqIHZUby54O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBxdWF0ZXJuaW9uIGFuZCB0aGUgZ2l2ZW4gb25lIGluIHJhZGlhbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSAtIFRoZSBxdWF0ZXJuaW9uIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqL1xuXHRhbmdsZVRvKCBxICkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoIE1hdGguYWJzKCBjbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGlzIHF1YXRlcm5pb24gYnkgYSBnaXZlbiBhbmd1bGFyIHN0ZXAgdG8gdGhlIGdpdmVuIHF1YXRlcm5pb24uXG5cdCAqIFRoZSBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSBmaW5hbCBxdWF0ZXJuaW9uIHdpbGwgbm90IG92ZXJzaG9vdCBgcWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSAtIFRoZSB0YXJnZXQgcXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgLSBUaGUgYW5ndWxhciBzdGVwIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdHJvdGF0ZVRvd2FyZHMoIHEsIHN0ZXAgKSB7XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYW5nbGVUbyggcSApO1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gMCApIHJldHVybiB0aGlzO1xuXG5cdFx0Y29uc3QgdCA9IE1hdGgubWluKCAxLCBzdGVwIC8gYW5nbGUgKTtcblxuXHRcdHRoaXMuc2xlcnAoIHEsIHQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb247IHRoYXQgaXMsIHRvIHRoZVxuXHQgKiBxdWF0ZXJuaW9uIHRoYXQgcmVwcmVzZW50cyBcIm5vIHJvdGF0aW9uXCIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdGlkZW50aXR5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAxICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoaXMgcXVhdGVybmlvbiB2aWEge0BsaW5rIFF1YXRlcm5pb24jY29uanVnYXRlfS4gVGhlXG5cdCAqIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRpbnZlcnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJvdGF0aW9uYWwgY29uanVnYXRlIG9mIHRoaXMgcXVhdGVybmlvbi4gVGhlIGNvbmp1Z2F0ZSBvZiBhXG5cdCAqIHF1YXRlcm5pb24gcmVwcmVzZW50cyB0aGUgc2FtZSByb3RhdGlvbiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGFib3V0XG5cdCAqIHRoZSByb3RhdGlvbmFsIGF4aXMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdGNvbmp1Z2F0ZSgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHF1YXRlcm5pb24gYW5kIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdiAtIFRoZSBxdWF0ZXJuaW9uIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc3VsdCBvZiB0aGUgZG90IHByb2R1Y3QuXG5cdCAqL1xuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgc3F1YXJlZCBFdWNsaWRlYW4gbGVuZ3RoIChzdHJhaWdodC1saW5lIGxlbmd0aCkgb2YgdGhpcyBxdWF0ZXJuaW9uLFxuXHQgKiBjb25zaWRlcmVkIGFzIGEgNCBkaW1lbnNpb25hbCB2ZWN0b3IuIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgYXJlIGNvbXBhcmluZyB0aGVcblx0ICogbGVuZ3RocyBvZiB0d28gcXVhdGVybmlvbnMsIGFzIHRoaXMgaXMgYSBzbGlnaHRseSBtb3JlIGVmZmljaWVudCBjYWxjdWxhdGlvbiB0aGFuXG5cdCAqIHtAbGluayBRdWF0ZXJuaW9uI2xlbmd0aH0uXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZWQgRXVjbGlkZWFuIGxlbmd0aC5cblx0ICovXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIEV1Y2xpZGVhbiBsZW5ndGggKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBvZiB0aGlzIHF1YXRlcm5pb24sXG5cdCAqIGNvbnNpZGVyZWQgYXMgYSA0IGRpbWVuc2lvbmFsIHZlY3Rvci5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgRXVjbGlkZWFuIGxlbmd0aC5cblx0ICovXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHRoaXMgcXVhdGVybmlvbiAtIHRoYXQgaXMsIGNhbGN1bGF0ZWQgdGhlIHF1YXRlcm5pb24gdGhhdCBwZXJmb3Jtc1xuXHQgKiB0aGUgc2FtZSByb3RhdGlvbiBhcyB0aGlzIG9uZSwgYnV0IGhhcyBhIGxlbmd0aCBlcXVhbCB0byBgMWAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdGxldCBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGlzIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIC0gVGhlIHF1YXRlcm5pb24uXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdG11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLW11bHRpcGxpZXMgdGhpcyBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSAtIFRoZSBxdWF0ZXJuaW9uLlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRwcmVtdWx0aXBseSggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIHF1YXRlcm5pb25zIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IGEgLSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBiIC0gVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHF1YXRlcm5pb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFiIC0gVGhlIHRhcmdldCBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRzbGVycCggcWIsIHQgKSB7XG5cblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcblx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0bGV0IGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cblx0XHRpZiAoIHNxclNpbkhhbGZUaGV0YSA8PSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDEgLSB0O1xuXHRcdFx0dGhpcy5fdyA9IHMgKiB3ICsgdCAqIHRoaXMuX3c7XG5cdFx0XHR0aGlzLl94ID0gcyAqIHggKyB0ICogdGhpcy5feDtcblx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xuXHRcdFx0dGhpcy5feiA9IHMgKiB6ICsgdCAqIHRoaXMuX3o7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7IC8vIG5vcm1hbGl6ZSBjYWxscyBfb25DaGFuZ2VDYWxsYmFjaygpXG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCBzcXJTaW5IYWxmVGhldGEgKTtcblx0XHRjb25zdCBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuXHRcdGNvbnN0IHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBxdWF0ZXJuaW9uc1xuXHQgKiBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFhIC0gVGhlIHNvdXJjZSBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFiIC0gVGhlIHRhcmdldCBxdWF0ZXJuaW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuXHQgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXG5cdCAqL1xuXHRzbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYSB1bmlmb3JtbHkgcmFuZG9tLCBub3JtYWxpemVkIHF1YXRlcm5pb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge1F1YXRlcm5pb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cblx0ICovXG5cdHJhbmRvbSgpIHtcblxuXHRcdC8vIEtlbiBTaG9lbWFrZVxuXHRcdC8vIFVuaWZvcm0gcmFuZG9tIHJvdGF0aW9uc1xuXHRcdC8vIEQuIEtpcmssIGVkaXRvciwgR3JhcGhpY3MgR2VtcyBJSUksIHBhZ2VzIDEyNC0xMzIuIEFjYWRlbWljIFByZXNzLCBOZXcgWW9yaywgMTk5Mi5cblxuXHRcdGNvbnN0IHRoZXRhMSA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblx0XHRjb25zdCB0aGV0YTIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cblx0XHRjb25zdCB4MCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3QgcjEgPSBNYXRoLnNxcnQoIDEgLSB4MCApO1xuXHRcdGNvbnN0IHIyID0gTWF0aC5zcXJ0KCB4MCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KFxuXHRcdFx0cjEgKiBNYXRoLnNpbiggdGhldGExICksXG5cdFx0XHRyMSAqIE1hdGguY29zKCB0aGV0YTEgKSxcblx0XHRcdHIyICogTWF0aC5zaW4oIHRoZXRhMiApLFxuXHRcdFx0cjIgKiBNYXRoLmNvcyggdGhldGEyICksXG5cdFx0KTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgcXVhdGVybmlvbiBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvbiAtIFRoZSBxdWF0ZXJuaW9uIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgcXVhdGVybmlvbiBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqL1xuXHRlcXVhbHMoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVhdGVybmlvbidzIGNvbXBvbmVudHMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBxdWF0ZXJuaW9uIGNvbXBvbmVudCB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gVGhlIG9mZnNldCBpbnRvIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHF1YXRlcm5pb24gdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIHF1YXRlcm5pb24gY29tcG9uZW50cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBJbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG5cdCAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBxdWF0ZXJuaW9uIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGUgLSBUaGUgYnVmZmVyIGF0dHJpYnV0ZSBob2xkaW5nIHF1YXRlcm5pb24gZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2RzIGRlZmluZXMgdGhlIHNlcmlhbGl6YXRpb24gcmVzdWx0IG9mIHRoaXMgY2xhc3MuIFJldHVybnMgdGhlXG5cdCAqIG51bWVyaWNhbCBlbGVtZW50cyBvZiB0aGlzIHF1YXRlcm5pb24gaW4gYW4gYXJyYXkgb2YgZm9ybWF0IGBbeCwgeSwgeiwgd11gLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc2VyaWFsaXplZCBxdWF0ZXJuaW9uLlxuXHQgKi9cblx0dG9KU09OKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheSgpO1xuXG5cdH1cblxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMuX3g7XG5cdFx0eWllbGQgdGhpcy5feTtcblx0XHR5aWVsZCB0aGlzLl96O1xuXHRcdHlpZWxkIHRoaXMuX3c7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgM0QgdmVjdG9yLiBBIDNEIHZlY3RvciBpcyBhbiBvcmRlcmVkIHRyaXBsZXQgb2YgbnVtYmVyc1xuICogKGxhYmVsZWQgeCwgeSBhbmQgeiksIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhIG51bWJlciBvZiB0aGluZ3MsIHN1Y2ggYXM6XG4gKlxuICogLSBBIHBvaW50IGluIDNEIHNwYWNlLlxuICogLSBBIGRpcmVjdGlvbiBhbmQgbGVuZ3RoIGluIDNEIHNwYWNlLiBJbiB0aHJlZS5qcyB0aGUgbGVuZ3RoIHdpbGxcbiAqIGFsd2F5cyBiZSB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlKHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UpIGZyb20gYCgwLCAwLCAwKWAgdG8gYCh4LCB5LCB6KWBcbiAqIGFuZCB0aGUgZGlyZWN0aW9uIGlzIGFsc28gbWVhc3VyZWQgZnJvbSBgKDAsIDAsIDApYCB0b3dhcmRzIGAoeCwgeSwgeilgLlxuICogLSBBbnkgYXJiaXRyYXJ5IG9yZGVyZWQgdHJpcGxldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoZXJlIGFyZSBvdGhlciB0aGluZ3MgYSAzRCB2ZWN0b3IgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50LCBzdWNoIGFzXG4gKiBtb21lbnR1bSB2ZWN0b3JzIGFuZCBzbyBvbiwgaG93ZXZlciB0aGVzZSBhcmUgdGhlIG1vc3RcbiAqIGNvbW1vbiB1c2VzIGluIHRocmVlLmpzLlxuICpcbiAqIEl0ZXJhdGluZyB0aHJvdWdoIGEgdmVjdG9yIGluc3RhbmNlIHdpbGwgeWllbGQgaXRzIGNvbXBvbmVudHMgYCh4LCB5LCB6KWAgaW5cbiAqIHRoZSBjb3JyZXNwb25kaW5nIG9yZGVyLlxuICogYGBganNcbiAqIGNvbnN0IGEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuICpcbiAqIC8vbm8gYXJndW1lbnRzOyB3aWxsIGJlIGluaXRpYWxpc2VkIHRvICgwLCAwLCAwKVxuICogY29uc3QgYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCApO1xuICpcbiAqIGNvbnN0IGQgPSBhLmRpc3RhbmNlVG8oIGIgKTtcbiAqIGBgYFxuICovXG5jbGFzcyBWZWN0b3IzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyAzRCB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IHZhbHVlIG9mIHRoaXMgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgeSB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdIC0gVGhlIHogdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFZlY3RvcjMucHJvdG90eXBlLmlzVmVjdG9yMyA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgeCB2YWx1ZSBvZiB0aGlzIHZlY3Rvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB5IHZhbHVlIG9mIHRoaXMgdmVjdG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHogdmFsdWUgb2YgdGhpcyB2ZWN0b3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueiA9IHo7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgb2YgdGhlIHggY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2YWx1ZSBvZiB0aGUgeSBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHZhbHVlIG9mIHRoZSB6IGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXQoIHgsIHksIHogKSB7XG5cblx0XHRpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHZhbHVlIHRvIHNldCBmb3IgYWxsIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvcidzIHggY29tcG9uZW50IHRvIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvcidzIHkgY29tcG9uZW50IHRvIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvcidzIHogY29tcG9uZW50IHRvIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0WiggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyB0byBzZXQgYSB2ZWN0b3IgY29tcG9uZW50IHdpdGggYW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjb21wb25lbnQgaW5kZXguIGAwYCBlcXVhbHMgdG8geCwgYDFgIGVxdWFscyB0byB5LCBgMmAgZXF1YWxzIHRvIHouXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHZlY3RvciBjb21wb25lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjb21wb25lbnQgaW5kZXguIGAwYCBlcXVhbHMgdG8geCwgYDFgIGVxdWFscyB0byB5LCBgMmAgZXF1YWxzIHRvIHouXG5cdCAqIEByZXR1cm4ge251bWJlcn0gQSB2ZWN0b3IgY29tcG9uZW50IHZhbHVlLlxuXHQgKi9cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yM30gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFkZCggdiApIHtcblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUgdG8gYWxsIGNvbXBvbmVudHMgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHMgLSBUaGUgc2NhbGFyIHRvIGFkZC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9ycyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBhIC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBiIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3Igc2NhbGVkIGJ5IHRoZSBnaXZlbiBmYWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfFZlY3RvcjR9IHYgLSBUaGUgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBmYWN0b3IgdGhhdCBzY2FsZXMgYHZgLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gc2NhbGFyIHZhbHVlIGZyb20gYWxsIGNvbXBvbmVudHMgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHMgLSBUaGUgc2NhbGFyIHRvIHN1YnRyYWN0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvcnMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYiAtIFRoZSBzZWNvbmQgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGUgZ2l2ZW4gdmVjdG9yIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBtdWx0aXBseS5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUgd2l0aCBhbGwgY29tcG9uZW50cyBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB0byBtdWx0aXBseS5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIHZlY3RvcnMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYiAtIFRoZSBzZWNvbmQgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdG11bHRpcGx5VmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBnaXZlbiBFdWxlciByb3RhdGlvbiB0byB0aGlzIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtFdWxlcn0gZXVsZXIgLSBUaGUgRXVsZXIgYW5nbGVzLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSByb3RhdGlvbiBzcGVjaWZpZWQgYnkgYW4gYXhpcyBhbmQgYW4gYW5nbGUgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyAtIEEgbm9ybWFsaXplZCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbiBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gM3gzIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIDN4MyBtYXRyaXguXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBub3JtYWwgbWF0cml4IGFuZCBub3JtYWxpemVzXG5cdCAqIHRoZSByZXN1bHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4M30gbSAtIFRoZSBub3JtYWwgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFwcGx5Tm9ybWFsTWF0cml4KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKCBtICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yICh3aXRoIGFuIGltcGxpY2l0IDEgaW4gdGhlIDR0aCBkaW1lbnNpb24pIGJ5IG0sIGFuZFxuXHQgKiBkaXZpZGVzIGJ5IHBlcnNwZWN0aXZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG0gLSBUaGUgbWF0cml4IHRvIGFwcGx5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHRjb25zdCB3ID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTtcblxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcblx0XHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIHc7XG5cdFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gUXVhdGVybmlvbiB0byB0aGlzIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIC0gVGhlIFF1YXRlcm5pb24uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBxIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgdnggPSB0aGlzLngsIHZ5ID0gdGhpcy55LCB2eiA9IHRoaXMuejtcblx0XHRjb25zdCBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIHQgPSAyICogY3Jvc3MoIHEueHl6LCB2ICk7XG5cdFx0Y29uc3QgdHggPSAyICogKCBxeSAqIHZ6IC0gcXogKiB2eSApO1xuXHRcdGNvbnN0IHR5ID0gMiAqICggcXogKiB2eCAtIHF4ICogdnogKTtcblx0XHRjb25zdCB0eiA9IDIgKiAoIHF4ICogdnkgLSBxeSAqIHZ4ICk7XG5cblx0XHQvLyB2ICsgcS53ICogdCArIGNyb3NzKCBxLnh5eiwgdCApO1xuXHRcdHRoaXMueCA9IHZ4ICsgcXcgKiB0eCArIHF5ICogdHogLSBxeiAqIHR5O1xuXHRcdHRoaXMueSA9IHZ5ICsgcXcgKiB0eSArIHF6ICogdHggLSBxeCAqIHR6O1xuXHRcdHRoaXMueiA9IHZ6ICsgcXcgKiB0eiArIHF4ICogdHkgLSBxeSAqIHR4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9qZWN0cyB0aGlzIHZlY3RvciBmcm9tIHdvcmxkIHNwYWNlIGludG8gdGhlIGNhbWVyYSdzIG5vcm1hbGl6ZWRcblx0ICogZGV2aWNlIGNvb3JkaW5hdGUgKE5EQykgc3BhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVucHJvamVjdHMgdGhpcyB2ZWN0b3IgZnJvbSB0aGUgY2FtZXJhJ3Mgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSAoTkRDKVxuXHQgKiBzcGFjZSBpbnRvIHdvcmxkIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYS5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHR1bnByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3RvciBieSBhIG1hdHJpeCAodGhlIHVwcGVyIGxlZnQgMyB4IDNcblx0ICogc3Vic2V0IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4IGFuZCB0aGVuIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIG1hdHJpeC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGVzIHRoaXMgaW5zdGFuY2UgYnkgdGhlIGdpdmVuIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBkaXZpZGUuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIHNjYWxhci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdG8gZGl2aWRlLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSBvciB6IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gdmVjdG9yJ3MgeCwgeSBvciB6XG5cdCAqIHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtaW4gdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bWluKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSBvciB6IHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gdmVjdG9yJ3MgeCwgeSBvciB6XG5cdCAqIHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtYXggdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bWF4KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSBvciB6IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IHZlY3RvcidzIHgsIHkgb3IgelxuXHQgKiB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG5cdCAqIElmIHRoaXMgdmVjdG9yJ3MgeCwgeSBvciB6IHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluIHZlY3RvcidzIHgsIHkgb3IgeiB2YWx1ZSxcblx0ICogaXQgaXMgcmVwbGFjZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gbWluIC0gVGhlIG1pbmltdW0geCwgeSBhbmQgeiB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gbWF4IC0gVGhlIG1heGltdW0geCwgeSBhbmQgeiB2YWx1ZXMgaW4gdGhlIGRlc2lyZWQgcmFuZ2UuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y2xhbXAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IGNsYW1wKCB0aGlzLngsIG1pbi54LCBtYXgueCApO1xuXHRcdHRoaXMueSA9IGNsYW1wKCB0aGlzLnksIG1pbi55LCBtYXgueSApO1xuXHRcdHRoaXMueiA9IGNsYW1wKCB0aGlzLnosIG1pbi56LCBtYXgueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGlzIHZlY3RvcidzIHgsIHkgb3IgeiB2YWx1ZXMgYXJlIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IHZhbHVlLCB0aGV5IGFyZVxuXHQgKiByZXBsYWNlZCBieSB0aGUgbWF4IHZhbHVlLlxuXHQgKiBJZiB0aGlzIHZlY3RvcidzIHgsIHkgb3IgeiB2YWx1ZXMgYXJlIGxlc3MgdGhhbiB0aGUgbWluIHZhbHVlLCB0aGV5IGFyZVxuXHQgKiByZXBsYWNlZCBieSB0aGUgbWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluVmFsIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4VmFsIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IGNsYW1wKCB0aGlzLngsIG1pblZhbCwgbWF4VmFsICk7XG5cdFx0dGhpcy55ID0gY2xhbXAoIHRoaXMueSwgbWluVmFsLCBtYXhWYWwgKTtcblx0XHR0aGlzLnogPSBjbGFtcCggdGhpcy56LCBtaW5WYWwsIG1heFZhbCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGlzIHZlY3RvcidzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhlIG1heCB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnlcblx0ICogdGhlIG1heCB2YWx1ZS5cblx0ICogSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBtaW4gdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5IHRoZVxuXHQgKiBtaW4gdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSB0aGUgdmVjdG9yIGxlbmd0aCB3aWxsIGJlIGNsYW1wZWQgdG8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgdmVjdG9yIGxlbmd0aCB3aWxsIGJlIGNsYW1wZWQgdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggY2xhbXAoIGxlbmd0aCwgbWluLCBtYXggKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGZsb29yKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGFyZSByb3VuZGVkIHVwIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y2VpbCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhcmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgYXJlIHJvdW5kZWQgdG93YXJkcyB6ZXJvICh1cCBpZiBuZWdhdGl2ZSxcblx0ICogZG93biBpZiBwb3NpdGl2ZSkgdG8gYW4gaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgudHJ1bmMoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoaXMgdmVjdG9yIC0gaS5lLiBzZXRzIHggPSAteCwgeSA9IC15IGFuZCB6ID0gLXouXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBnaXZlbiB2ZWN0b3Igd2l0aCB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc3VsdCBvZiB0aGUgZG90IHByb2R1Y3QuXG5cdCAqL1xuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH1cblxuXHQvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIEV1Y2xpZGVhbiBsZW5ndGggKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tXG5cdCAqICgwLCAwLCAwKSB0byAoeCwgeSwgeikuIElmIHlvdSBhcmUgY29tcGFyaW5nIHRoZSBsZW5ndGhzIG9mIHZlY3RvcnMsIHlvdSBzaG91bGRcblx0ICogY29tcGFyZSB0aGUgbGVuZ3RoIHNxdWFyZWQgaW5zdGVhZCBhcyBpdCBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRsZW5ndGhTcSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgIEV1Y2xpZGVhbiBsZW5ndGggKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tICgwLCAwLCAwKSB0byAoeCwgeSwgeikuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIE1hbmhhdHRhbiBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICovXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGlzIHZlY3RvciB0byBhIHVuaXQgdmVjdG9yIC0gdGhhdCBpcywgc2V0cyBpdCBlcXVhbCB0byBhIHZlY3RvclxuXHQgKiB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0IHdpdGggYSB2ZWN0b3IgbGVuZ3RoIG9mIGAxYC5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRub3JtYWxpemUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHZlY3RvciB0byBhIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0XG5cdCAqIHdpdGggdGhlIHNwZWNpZmllZCBsZW5ndGguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBUaGUgbmV3IGxlbmd0aCBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRMZW5ndGgoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHRoZSBnaXZlbiB2ZWN0b3IgYW5kIHRoaXMgaW5zdGFuY2UsIHdoZXJlXG5cdCAqIGFscGhhIGlzIHRoZSBwZXJjZW50IGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIC0gYWxwaGEgPSAwIHdpbGwgYmUgdGhpc1xuXHQgKiB2ZWN0b3IsIGFuZCBhbHBoYSA9IDEgd2lsbCBiZSB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYgLSBUaGUgdmVjdG9yIHRvIGludGVycG9sYXRlIHRvd2FyZHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciwgdHlwaWNhbGx5IGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bGVycCggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdGhlIGdpdmVuIHZlY3RvcnMsIHdoZXJlIGFscGhhIGlzIHRoZSBwZXJjZW50XG5cdCAqIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIC0gYWxwaGEgPSAwIHdpbGwgYmUgZmlyc3QgdmVjdG9yLCBhbmQgYWxwaGEgPSAxIHdpbGxcblx0ICogYmUgdGhlIHNlY29uZCBvbmUuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdjEgLSBUaGUgZmlyc3QgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYyIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciwgdHlwaWNhbGx5IGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSByZXN1bHQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXG5cdCAqL1xuXHRjcm9zcyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdGhpcywgdiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgZ2l2ZW4gdmVjdG9ycyBhbmQgc3RvcmVzIHRoZSByZXN1bHRcblx0ICogaW4gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBhIC0gVGhlIGZpcnN0IHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBiIC0gVGhlIHNlY29uZCB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2plY3RzIHRoaXMgdmVjdG9yIG9udG8gdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBwcm9qZWN0IHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHByb2plY3RPblZlY3RvciggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdi5sZW5ndGhTcSgpO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCApO1xuXG5cdFx0Y29uc3Qgc2NhbGFyID0gdi5kb3QoIHRoaXMgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggdiApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2plY3RzIHRoaXMgdmVjdG9yIG9udG8gYSBwbGFuZSBieSBzdWJ0cmFjdGluZyB0aGlzXG5cdCAqIHZlY3RvciBwcm9qZWN0ZWQgb250byB0aGUgcGxhbmUncyBub3JtYWwgZnJvbSB0aGlzIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwbGFuZU5vcm1hbCAtIFRoZSBwbGFuZSBub3JtYWwuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0cHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG5cdFx0X3ZlY3Rvci5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWZsZWN0cyB0aGlzIHZlY3RvciBvZmYgYSBwbGFuZSBvcnRob2dvbmFsIHRvIHRoZSBnaXZlbiBub3JtYWwgdmVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG5vcm1hbCAtIFRoZSAobm9ybWFsaXplZCkgbm9ybWFsIHZlY3Rvci5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyZWZsZWN0KCBub3JtYWwgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdH1cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIGdpdmVuIHZlY3RvciBhbmQgdGhpcyBpbnN0YW5jZSBpbiByYWRpYW5zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHdpdGguXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqL1xuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIGNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UuXG5cdCAqL1xuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICogSWYgeW91IGFyZSBqdXN0IGNvbXBhcmluZyB0aGUgZGlzdGFuY2Ugd2l0aCBhbm90aGVyIGRpc3RhbmNlLCB5b3Ugc2hvdWxkIGNvbXBhcmVcblx0ICogdGhlIGRpc3RhbmNlIHNxdWFyZWQgaW5zdGVhZCBhcyBpdCBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgc3F1YXJlZCBkaXN0YW5jZSB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlZCBkaXN0YW5jZS5cblx0ICovXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgTWFuaGF0dGFuIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIE1hbmhhdHRhbiBkaXN0YW5jZSB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgTWFuaGF0dGFuIGRpc3RhbmNlLlxuXHQgKi9cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBmcm9tIHRoZSBnaXZlbiBzcGhlcmljYWwgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJpY2FsfSBzIC0gVGhlIHNwaGVyaWNhbCBjb29yZGluYXRlcy5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBmcm9tIHRoZSBnaXZlbiBzcGhlcmljYWwgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGhpIC0gVGhlIHBoaSBhbmdsZSBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgLSBUaGUgdGhldGEgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XG5cblx0XHRjb25zdCBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XG5cblx0XHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XG5cdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIGN5bGluZHJpY2FsIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0N5bGluZHJpY2FsfSBjIC0gVGhlIGN5bGluZHJpY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEZyb21DeWxpbmRyaWNhbCggYyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggYy5yYWRpdXMsIGMudGhldGEsIGMueSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yIGNvbXBvbmVudHMgZnJvbSB0aGUgZ2l2ZW4gY3lsaW5kcmljYWwgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgLSBUaGUgdGhldGEgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSB2YWx1ZS5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIHJhZGl1cywgdGhldGEsIHkgKSB7XG5cblx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyB0byB0aGUgcG9zaXRpb24gZWxlbWVudHMgb2YgdGhlXG5cdCAqIGdpdmVuIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIDR4NCBtYXRyaXguXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAxMiBdO1xuXHRcdHRoaXMueSA9IGVbIDEzIF07XG5cdFx0dGhpcy56ID0gZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yIGNvbXBvbmVudHMgdG8gdGhlIHNjYWxlIGVsZW1lbnRzIG9mIHRoZVxuXHQgKiBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSA0eDQgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEZyb21NYXRyaXhTY2FsZSggbSApIHtcblxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBtYXRyaXggY29sdW1uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG0gLSBUaGUgNHg0IG1hdHJpeC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRGcm9tTWF0cml4Q29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgbWF0cml4IGNvbHVtbi5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIDN4MyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjb2x1bW4gaW5kZXguXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0RnJvbU1hdHJpeDNDb2x1bW4oIG0sIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvciBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIEV1bGVyIGFuZ2xlcy5cblx0ICpcblx0ICogQHBhcmFtIHtFdWxlcn0gZSAtIFRoZSBFdWxlciBhbmdsZXMgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEZyb21FdWxlciggZSApIHtcblxuXHRcdHRoaXMueCA9IGUuX3g7XG5cdFx0dGhpcy55ID0gZS5feTtcblx0XHR0aGlzLnogPSBlLl96O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IgY29tcG9uZW50cyBmcm9tIHRoZSBSR0IgY29tcG9uZW50cyBvZiB0aGVcblx0ICogZ2l2ZW4gY29sb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGMgLSBUaGUgY29sb3IgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdHNldEZyb21Db2xvciggYyApIHtcblxuXHRcdHRoaXMueCA9IGMucjtcblx0XHR0aGlzLnkgPSBjLmc7XG5cdFx0dGhpcy56ID0gYy5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHZlY3RvciBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IgdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB2ZWN0b3IgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKi9cblx0ZXF1YWxzKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyB2ZWN0b3IncyB4IHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0IF1gLCB5IHZhbHVlIHRvIGJlIGBhcnJheVsgb2Zmc2V0ICsgMSBdYFxuXHQgKiBhbmQgeiB2YWx1ZSB0byBiZSBgYXJyYXlbIG9mZnNldCArIDIgXWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgLSBBbiBhcnJheSBob2xkaW5nIHRoZSB2ZWN0b3IgY29tcG9uZW50IHZhbHVlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBUaGUgb2Zmc2V0IGludG8gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzLlxuXHQgKi9cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGUgLSBUaGUgYnVmZmVyIGF0dHJpYnV0ZSBob2xkaW5nIHZlY3RvciBkYXRhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYXR0cmlidXRlLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cblx0ICovXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBlYWNoIGNvbXBvbmVudCBvZiB0aGlzIHZlY3RvciB0byBhIHBzZXVkby1yYW5kb20gdmFsdWUgYmV0d2VlbiBgMGAgYW5kXG5cdCAqIGAxYCwgZXhjbHVkaW5nIGAxYC5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyYW5kb20oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIHZlY3RvciB0byBhIHVuaWZvcm1seSByYW5kb20gcG9pbnQgb24gYSB1bml0IHNwaGVyZS5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yM30gQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRyYW5kb21EaXJlY3Rpb24oKSB7XG5cblx0XHQvLyBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXG5cdFx0Y29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgdSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0XHRjb25zdCBjID0gTWF0aC5zcXJ0KCAxIC0gdSAqIHUgKTtcblxuXHRcdHRoaXMueCA9IGMgKiBNYXRoLmNvcyggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB1O1xuXHRcdHRoaXMueiA9IGMgKiBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cdFx0eWllbGQgdGhpcy56O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmV4cG9ydCB7IFZlY3RvcjMgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgaW4gM0Qgc3BhY2UuXG4gKi9cbmNsYXNzIEJveDMge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJvdW5kaW5nIGJveC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbbWluPShJbmZpbml0eSxJbmZpbml0eSxJbmZpbml0eSldIC0gQSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFttYXg9KC1JbmZpbml0eSwtSW5maW5pdHksLUluZmluaXR5KV0gLSBBIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBib3guXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWluID0gbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKSwgbWF4ID0gbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNCb3gzID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5taW4gPSBtaW47XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGJveC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kYXJpZXMgb2YgdGhpcyBib3guXG5cdCAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG1pbiAtIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG1heCAtIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdHNldCggbWluLCBtYXggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiB0aGlzIGJveCBzbyBpdCBlbmNsb3NlcyB0aGUgcG9zaXRpb24gZGF0YVxuXHQgKiBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgLSBBbiBhcnJheSBob2xkaW5nIDNEIHBvc2l0aW9uIGRhdGEuXG5cdCAqIEByZXR1cm4ge0JveDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0c2V0RnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yLmZyb21BcnJheSggYXJyYXksIGkgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYm91bmRzIG9mIHRoaXMgYm94IHNvIGl0IGVuY2xvc2VzIHRoZSBwb3NpdGlvbiBkYXRhXG5cdCAqIGluIHRoZSBnaXZlbiBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIC0gQSBidWZmZXIgYXR0cmlidXRlIGhvbGRpbmcgM0QgcG9zaXRpb24gZGF0YS5cblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiB0aGlzIGJveCBzbyBpdCBlbmNsb3NlcyB0aGUgcG9zaXRpb24gZGF0YVxuXHQgKiBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMz59IHBvaW50cyAtIEFuIGFycmF5IGhvbGRpbmcgM0QgcG9zaXRpb24gZGF0YSBhcyBpbnN0YW5jZXMgb2Yge0BsaW5rIFZlY3RvcjN9LlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENlbnRlcnMgdGhpcyBib3ggb24gdGhlIGdpdmVuIGNlbnRlciB2ZWN0b3IgYW5kIHNldHMgdGhpcyBib3gncyB3aWR0aCwgaGVpZ2h0IGFuZFxuXHQgKiBkZXB0aCB0byB0aGUgZ2l2ZW4gc2l6ZSB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gY2VudGVyIC0gVGhlIGNlbnRlciBvZiB0aGUgYm94LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHNpemUgLSBUaGUgeCwgeSBhbmQgeiBkaW1lbnNpb25zIG9mIHRoZSBib3guXG5cdCAqIEByZXR1cm4ge0JveDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0c2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuXHRcdGNvbnN0IGhhbGZTaXplID0gX3ZlY3Rvci5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBnaXZlbiAzRCBvYmplY3Rcblx0ICogKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLCBhY2NvdW50aW5nIGZvciB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLFxuXHQgKiB3b3JsZCB0cmFuc2Zvcm1zLiBUaGUgZnVuY3Rpb24gbWF5IHJlc3VsdCBpbiBhIGxhcmdlciBib3ggdGhhbiBzdHJpY3RseSBuZWNlc3NhcnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QgdG8gY29tcHV0ZSB0aGUgYm91bmRpbmcgYm94IGZvci5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcHJlY2lzZT1mYWxzZV0gLSBJZiBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kIGNvbXB1dGVzIHRoZSBzbWFsbGVzdFxuXHQgKiB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGF0IHRoZSBleHBlbnNlIG9mIG1vcmUgY29tcHV0YXRpb24uXG5cdCAqIEByZXR1cm4ge0JveDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBib3ggd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7Qm94M30gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gYm94IHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGNvcHkoIGJveCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgYm94IGVtcHR5IHdoaWNoIG1lYW5zIGluIGVuY2xvc2VzIGEgemVybyBzcGFjZSBpbiAzRC5cblx0ICpcblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJveCBpbmNsdWRlcyB6ZXJvIHBvaW50cyB3aXRoaW4gaXRzIGJvdW5kcy5cblx0ICogTm90ZSB0aGF0IGEgYm94IHdpdGggZXF1YWwgbG93ZXIgYW5kIHVwcGVyIGJvdW5kcyBzdGlsbCBpbmNsdWRlcyBvbmVcblx0ICogcG9pbnQsIHRoZSBvbmUgYm90aCBib3VuZHMgc2hhcmUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBib3ggaXMgZW1wdHkgb3Igbm90LlxuXHQgKi9cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhpcyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjZW50ZXIgcG9pbnQuXG5cdCAqL1xuXHRnZXRDZW50ZXIoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAsIDAgKSA6IHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoaXMgYm94LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgc2l6ZS5cblx0ICovXG5cdGdldFNpemUoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAsIDAgKSA6IHRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMgdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyBib3ggdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcG9pbnQgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgYnkgdGhlIGJvdW5kaW5nIGJveC5cblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMgdGhpcyBib3ggZXF1aWxhdGVyYWxseSBieSB0aGUgZ2l2ZW4gdmVjdG9yLiBUaGUgd2lkdGggb2YgdGhpc1xuXHQgKiBib3ggd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBpbiBib3RoXG5cdCAqIGRpcmVjdGlvbnMuIFRoZSBoZWlnaHQgb2YgdGhpcyBib3ggd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgeSBjb21wb25lbnQgb2Zcblx0ICogdGhlIHZlY3RvciBpbiBib3RoIGRpcmVjdGlvbnMuIFRoZSBkZXB0aCBvZiB0aGlzIGJveCB3aWxsIGJlXG5cdCAqIGV4cGFuZGVkIGJ5IHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGluIGJvdGggZGlyZWN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2ZWN0b3IgLSBUaGUgdmVjdG9yIHRoYXQgc2hvdWxkIGV4cGFuZCB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGV4cGFuZEJ5VmVjdG9yKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMgZWFjaCBkaW1lbnNpb24gb2YgdGhlIGJveCBieSB0aGUgZ2l2ZW4gc2NhbGFyLiBJZiBuZWdhdGl2ZSwgdGhlXG5cdCAqIGRpbWVuc2lvbnMgb2YgdGhlIGJveCB3aWxsIGJlIGNvbnRyYWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlIHRoYXQgc2hvdWxkIGV4cGFuZCB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGV4cGFuZEJ5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcyB0aGUgYm91bmRhcmllcyBvZiB0aGlzIGJveCB0byBpbmNsdWRlIHRoZSBnaXZlbiAzRCBvYmplY3QgYW5kXG5cdCAqIGl0cyBjaGlsZHJlbiwgYWNjb3VudGluZyBmb3IgdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGRcblx0ICogdHJhbnNmb3Jtcy4gVGhlIGZ1bmN0aW9uIG1heSByZXN1bHQgaW4gYSBsYXJnZXIgYm94IHRoYW4gc3RyaWN0bHlcblx0ICogbmVjZXNzYXJ5ICh1bmxlc3MgdGhlIHByZWNpc2UgcGFyYW1ldGVyIGlzIHNldCB0byB0cnVlKS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIDNEIG9iamVjdCB0aGF0IHNob3VsZCBleHBhbmQgdGhlIGJvdW5kaW5nIGJveC5cblx0ICogQHBhcmFtIHtib29sZWFufSBwcmVjaXNlIC0gSWYgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZCBleHBhbmRzIHRoZSBib3VuZGluZyBib3hcblx0ICogYXMgbGl0dGxlIGFzIG5lY2Vzc2FyeSBhdCB0aGUgZXhwZW5zZSBvZiBtb3JlIGNvbXB1dGF0aW9uLlxuXHQgKiBAcmV0dXJuIHtCb3gzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QsIHByZWNpc2UgPSBmYWxzZSApIHtcblxuXHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG5cdFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXG5cblx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCBmYWxzZSApO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRcdC8vIHByZWNpc2UgQUFCQiBjb21wdXRhdGlvbiBiYXNlZCBvbiB2ZXJ0ZXggZGF0YSByZXF1aXJlcyBhdCBsZWFzdCBhIHBvc2l0aW9uIGF0dHJpYnV0ZS5cblx0XHRcdC8vIGluc3RhbmNpbmcgaXNuJ3Qgc3VwcG9ydGVkIHNvIGZhciBhbmQgdXNlcyB0aGUgbm9ybWFsIChjb25zZXJ2YXRpdmUpIGNvZGUgcGF0aC5cblxuXHRcdFx0aWYgKCBwcmVjaXNlID09PSB0cnVlICYmIHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc01lc2ggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5nZXRWZXJ0ZXhQb3NpdGlvbiggaSwgX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZlY3Rvci5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gb2JqZWN0LWxldmVsIGJvdW5kaW5nIGJveFxuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9ib3guY29weSggb2JqZWN0LmJvdW5kaW5nQm94ICk7XG5cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZ2VvbWV0cnktbGV2ZWwgYm91bmRpbmcgYm94XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9ib3guY29weSggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2JveC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHRoaXMudW5pb24oIF9ib3ggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBwcmVjaXNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBsaWVzIHdpdGhpbiBvciBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGlzIGJveC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBib3VuZGluZyBib3ggY29udGFpbnMgdGhlIGdpdmVuIHBvaW50IG9yIG5vdC5cblx0ICovXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPj0gdGhpcy5taW4ueCAmJiBwb2ludC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHBvaW50LnkgPj0gdGhpcy5taW4ueSAmJiBwb2ludC55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdHBvaW50LnogPj0gdGhpcy5taW4ueiAmJiBwb2ludC56IDw9IHRoaXMubWF4Lno7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGJvdW5kaW5nIGJveCBpbmNsdWRlcyB0aGUgZW50aXJldHkgb2YgdGhlIGdpdmVuIGJvdW5kaW5nIGJveC5cblx0ICogSWYgdGhpcyBib3ggYW5kIHRoZSBnaXZlbiBvbmUgYXJlIGlkZW50aWNhbCwgdGhpcyBmdW5jdGlvbiBhbHNvIHJldHVybnMgYHRydWVgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDN9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYm91bmRpbmcgYm94IGNvbnRhaW5zIHRoZSBnaXZlbiBib3VuZGluZyBib3ggb3Igbm90LlxuXHQgKi9cblx0Y29udGFpbnNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHBvaW50IGFzIGEgcHJvcG9ydGlvbiBvZiB0aGlzIGJveCdzIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gQSBwb2ludCBpbiAzRCBzcGFjZS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gQSBwb2ludCBhcyBhIHByb3BvcnRpb24gb2YgdGhpcyBib3gncyB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aC5cblx0ICovXG5cdGdldFBhcmFtZXRlciggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdHJldHVybiB0YXJnZXQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG5cdFx0KTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB3aXRoIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDN9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94IGludGVyc2VjdHMgd2l0aCB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXHRcdHJldHVybiBib3gubWF4LnggPj0gdGhpcy5taW4ueCAmJiBib3gubWluLnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0Ym94Lm1heC55ID49IHRoaXMubWluLnkgJiYgYm94Lm1pbi55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdGJveC5tYXgueiA+PSB0aGlzLm1pbi56ICYmIGJveC5taW4ueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGJvdW5kaW5nIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhpcyBib3VuZGluZyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgYm91bmRpbmcgc3BoZXJlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGJvdW5kaW5nIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuXHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgX3ZlY3RvciApO1xuXG5cdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXG5cdFx0cmV0dXJuIF92ZWN0b3IuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcGxhbmUgaW50ZXJzZWN0cyB3aXRoIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSAtIFRoZSBwbGFuZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwbGFuZSBpbnRlcnNlY3RzIHdpdGggdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHRyaWFuZ2xlIGludGVyc2VjdHMgd2l0aCB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICpcblx0ICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpYW5nbGUgLSBUaGUgdHJpYW5nbGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gdHJpYW5nbGUgaW50ZXJzZWN0cyB3aXRoIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0aW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZSApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIGNvbXB1dGUgYm94IGNlbnRlciBhbmQgZXh0ZW50c1xuXHRcdHRoaXMuZ2V0Q2VudGVyKCBfY2VudGVyICk7XG5cdFx0X2V4dGVudHMuc3ViVmVjdG9ycyggdGhpcy5tYXgsIF9jZW50ZXIgKTtcblxuXHRcdC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxuXHRcdF92MC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5hLCBfY2VudGVyICk7XG5cdFx0X3YxLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmIsIF9jZW50ZXIgKTtcblx0XHRfdjIuc3ViVmVjdG9ycyggdHJpYW5nbGUuYywgX2NlbnRlciApO1xuXG5cdFx0Ly8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXG5cdFx0X2YwLnN1YlZlY3RvcnMoIF92MSwgX3YwICk7XG5cdFx0X2YxLnN1YlZlY3RvcnMoIF92MiwgX3YxICk7XG5cdFx0X2YyLnN1YlZlY3RvcnMoIF92MCwgX3YyICk7XG5cblx0XHQvLyB0ZXN0IGFnYWluc3QgYXhlcyB0aGF0IGFyZSBnaXZlbiBieSBjcm9zcyBwcm9kdWN0IGNvbWJpbmF0aW9ucyBvZiB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlIGFuZCB0aGUgZWRnZXMgb2YgdGhlIGFhYmJcblx0XHQvLyBtYWtlIGFuIGF4aXMgdGVzdGluZyBvZiBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSBhYWJiIGFnYWluc3QgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgdHJpYW5nbGUgPSA5IGF4aXMgb2Ygc2VwYXJhdGlvblxuXHRcdC8vIGF4aXNfaWogPSB1X2kgeCBmX2ogKHUwLCB1MSwgdTIgPSBmYWNlIG5vcm1hbHMgb2YgYWFiYiA9IHgseSx6IGF4ZXMgdmVjdG9ycyBzaW5jZSBhYWJiIGlzIGF4aXMgYWxpZ25lZClcblx0XHRsZXQgYXhlcyA9IFtcblx0XHRcdDAsIC0gX2YwLnosIF9mMC55LCAwLCAtIF9mMS56LCBfZjEueSwgMCwgLSBfZjIueiwgX2YyLnksXG5cdFx0XHRfZjAueiwgMCwgLSBfZjAueCwgX2YxLnosIDAsIC0gX2YxLngsIF9mMi56LCAwLCAtIF9mMi54LFxuXHRcdFx0LSBfZjAueSwgX2YwLngsIDAsIC0gX2YxLnksIF9mMS54LCAwLCAtIF9mMi55LCBfZjIueCwgMFxuXHRcdF07XG5cdFx0aWYgKCAhIHNhdEZvckF4ZXMoIGF4ZXMsIF92MCwgX3YxLCBfdjIsIF9leHRlbnRzICkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIHRlc3QgMyBmYWNlIG5vcm1hbHMgZnJvbSB0aGUgYWFiYlxuXHRcdGF4ZXMgPSBbIDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEgXTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZmluYWxseSB0ZXN0aW5nIHRoZSBmYWNlIG5vcm1hbCBvZiB0aGUgdHJpYW5nbGVcblx0XHQvLyB1c2UgYWxyZWFkeSBleGlzdGluZyB0cmlhbmdsZSBlZGdlIHZlY3RvcnMgaGVyZVxuXHRcdF90cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoIF9mMCwgX2YxICk7XG5cdFx0YXhlcyA9IFsgX3RyaWFuZ2xlTm9ybWFsLngsIF90cmlhbmdsZU5vcm1hbC55LCBfdHJpYW5nbGVOb3JtYWwueiBdO1xuXG5cdFx0cmV0dXJuIHNhdEZvckF4ZXMoIGF4ZXMsIF92MCwgX3YxLCBfdjIsIF9leHRlbnRzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDbGFtcHMgdGhlIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoaXMgYm94LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIGNsYW1wLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgY2xhbXBlZCBwb2ludC5cblx0ICovXG5cdGNsYW1wUG9pbnQoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZXVjbGlkZWFuIGRpc3RhbmNlIGZyb20gYW55IGVkZ2Ugb2YgdGhpcyBib3ggdG8gdGhlIHNwZWNpZmllZCBwb2ludC4gSWZcblx0ICogdGhlIGdpdmVuIHBvaW50IGxpZXMgaW5zaWRlIG9mIHRoaXMgYm94LCB0aGUgZGlzdGFuY2Ugd2lsbCBiZSBgMGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8uXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cblx0ICovXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciApLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgYm91bmRpbmcgc3BoZXJlIHRoYXQgZW5jbG9zZXMgdGhpcyBib3VuZGluZyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHNwaGVyZSB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7U3BoZXJlfSBUaGUgYm91bmRpbmcgc3BoZXJlIHRoYXQgZW5jbG9zZXMgdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRnZXRCb3VuZGluZ1NwaGVyZSggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGFyZ2V0Lm1ha2VFbXB0eSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoIHRhcmdldC5jZW50ZXIgKTtcblxuXHRcdFx0dGFyZ2V0LnJhZGl1cyA9IHRoaXMuZ2V0U2l6ZSggX3ZlY3RvciApLmxlbmd0aCgpICogMC41O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBib3VuZGluZyBib3ggYW5kIHRoZSBnaXZlbiBvbmUsIHNldHRpbmcgdGhlIHVwcGVyXG5cdCAqIGJvdW5kIG9mIHRoaXMgYm94IHRvIHRoZSBsZXNzZXIgb2YgdGhlIHR3byBib3hlcycgdXBwZXIgYm91bmRzIGFuZCB0aGVcblx0ICogbG93ZXIgYm91bmQgb2YgdGhpcyBib3ggdG8gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBib3hlcycgbG93ZXIgYm91bmRzLiBJZlxuXHQgKiB0aGVyZSdzIG5vIG92ZXJsYXAsIG1ha2VzIHRoaXMgYm94IGVtcHR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDN9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdG8gaW50ZXJzZWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge0JveDN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoaXMgYm94IGFuZCBhbm90aGVyIGFuZCB0aGUgZ2l2ZW4gb25lLCBzZXR0aW5nIHRoZSB1cHBlclxuXHQgKiBib3VuZCBvZiB0aGlzIGJveCB0byB0aGUgZ3JlYXRlciBvZiB0aGUgdHdvIGJveGVzJyB1cHBlciBib3VuZHMgYW5kIHRoZVxuXHQgKiBsb3dlciBib3VuZCBvZiB0aGlzIGJveCB0byB0aGUgbGVzc2VyIG9mIHRoZSB0d28gYm94ZXMnIGxvd2VyIGJvdW5kcy5cblx0ICpcblx0ICogQHBhcmFtIHtCb3gzfSBib3ggLSBUaGUgYm91bmRpbmcgYm94IHRoYXQgd2lsbCBiZSB1bmlvbmVkIHdpdGggdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHR1bmlvbiggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhpcyBib3VuZGluZyBib3ggYnkgdGhlIGdpdmVuIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuXHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0X3BvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdF9wb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcblx0XHRfcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0X3BvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdF9wb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcblx0XHRfcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0X3BvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdF9wb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcblxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggX3BvaW50cyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBvZmZzZXQgdG8gYm90aCB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiB0aGlzIGJvdW5kaW5nIGJveCxcblx0ICogZWZmZWN0aXZlbHkgbW92aW5nIGl0IGluIDNEIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG9mZnNldCAtIFRoZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byB0cmFuc2xhdGUgdGhlIGJvdW5kaW5nIGJveC5cblx0ICogQHJldHVybiB7Qm94M30gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBib3VuZGluZyBib3ggaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDN9IGJveCAtIFRoZSBib3ggdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBib3VuZGluZyBib3ggaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKi9cblx0ZXF1YWxzKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9wb2ludHMgPSBbXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpXG5dO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG4vLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5jb25zdCBfdjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5jb25zdCBfZjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9jZW50ZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZXN0QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gc2F0Rm9yQXhlcyggYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cyApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzICkge1xuXG5cdFx0X3Rlc3RBeGlzLmZyb21BcnJheSggYXhlcywgaSApO1xuXHRcdC8vIHByb2plY3QgdGhlIGFhYmIgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCBfdGVzdEF4aXMueCApICsgZXh0ZW50cy55ICogTWF0aC5hYnMoIF90ZXN0QXhpcy55ICkgKyBleHRlbnRzLnogKiBNYXRoLmFicyggX3Rlc3RBeGlzLnogKTtcblx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcblx0XHRjb25zdCBwMCA9IHYwLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Y29uc3QgcDEgPSB2MS5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAyID0gdjIuZG90KCBfdGVzdEF4aXMgKTtcblx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcblxuXHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZXhwb3J0IHsgQm94MyB9O1xuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4vQm94My5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBBbiBhbmFseXRpY2FsIDNEIHNwaGVyZSBkZWZpbmVkIGJ5IGEgY2VudGVyIGFuZCByYWRpdXMuIFRoaXMgY2xhc3MgaXMgbWFpbmx5XG4gKiB1c2VkIGFzIGEgQm91bmRpbmcgU3BoZXJlIGZvciAzRCBvYmplY3RzLlxuICovXG5jbGFzcyBTcGhlcmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNwaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbY2VudGVyPSgwLDAsMCldIC0gVGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPS0xXSAtIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpLCByYWRpdXMgPSAtIDEgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzU3BoZXJlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc3BoZXJlJ3MgY29tcG9uZW50cyBieSBjb3B5aW5nIHRoZSBnaXZlbiB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gY2VudGVyIC0gVGhlIGNlbnRlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMuXG5cdCAqIEByZXR1cm4ge1NwaGVyZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmUuXG5cdCAqL1xuXHRzZXQoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIGJvdW5kaW5nIHNwaGVyZSBmb3IgbGlzdCBvZiBwb2ludHMuXG5cdCAqIElmIHRoZSBvcHRpb25hbCBjZW50ZXIgcG9pbnQgaXMgZ2l2ZW4sIGl0IGlzIHVzZWQgYXMgdGhlIHNwaGVyZSdzXG5cdCAqIGNlbnRlci4gT3RoZXJ3aXNlLCB0aGUgY2VudGVyIG9mIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94XG5cdCAqIGVuY29tcGFzc2luZyB0aGUgcG9pbnRzIGlzIGNhbGN1bGF0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMz59IHBvaW50cyAtIEEgbGlzdCBvZiBwb2ludHMgaW4gM0Qgc3BhY2UuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW29wdGlvbmFsQ2VudGVyXSAtIFRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZS5cblx0ICogQHJldHVybiB7U3BoZXJlfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyZS5cblx0ICovXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cblx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHR9XG5cblx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBzcGhlcmUgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gY29weS5cblx0ICogQHJldHVybiB7U3BoZXJlfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyZS5cblx0ICovXG5cdGNvcHkoIHNwaGVyZSApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGhlcmUgaXMgZW1wdHkgKHRoZSByYWRpdXMgc2V0IHRvIGEgbmVnYXRpdmUgbnVtYmVyKS5cblx0ICpcblx0ICogU3BoZXJlcyB3aXRoIGEgcmFkaXVzIG9mIGAwYCBjb250YWluIG9ubHkgdGhlaXIgY2VudGVyIHBvaW50IGFuZCBhcmUgbm90XG5cdCAqIGNvbnNpZGVyZWQgdG8gYmUgZW1wdHkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBzcGhlcmUgaXMgZW1wdHkgb3Igbm90LlxuXHQgKi9cblx0aXNFbXB0eSgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDwgMCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdGhpcyBzcGhlcmUgZW1wdHkgd2hpY2ggbWVhbnMgaW4gZW5jbG9zZXMgYSB6ZXJvIHNwYWNlIGluIDNELlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTcGhlcmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3BoZXJlLlxuXHQgKi9cblx0bWFrZUVtcHR5KCkge1xuXG5cdFx0dGhpcy5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG5cdFx0dGhpcy5yYWRpdXMgPSAtIDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgc3BoZXJlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludCBpbmNsdXNpdmUgb2Zcblx0ICogdGhlIHN1cmZhY2Ugb2YgdGhlIHNwaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVjay5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHNwaGVyZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQgb3Igbm90LlxuXHQgKi9cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2xvc2VzdCBkaXN0YW5jZSBmcm9tIHRoZSBib3VuZGFyeSBvZiB0aGUgc3BoZXJlIHRvIHRoZVxuXHQgKiBnaXZlbiBwb2ludC4gSWYgdGhlIHNwaGVyZSBjb250YWlucyB0aGUgcG9pbnQsIHRoZSBkaXN0YW5jZSB3aWxsXG5cdCAqIGJlIG5lZ2F0aXZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byB0aGUgcG9pbnQuXG5cdCAqL1xuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIG9uZSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRjb25zdCByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBzcGhlcmUgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgc3BoZXJlIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gYm94IG9yIG5vdC5cblx0ICovXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBzcGhlcmUgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBwbGFuZS5cblx0ICpcblx0ICogQHBhcmFtIHtQbGFuZX0gcGxhbmUgLSBUaGUgcGxhbmUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIHBsYW5lIG9yIG5vdC5cblx0ICovXG5cdGludGVyc2VjdHNQbGFuZSggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2xhbXBzIGEgcG9pbnQgd2l0aGluIHRoZSBzcGhlcmUuIElmIHRoZSBwb2ludCBpcyBvdXRzaWRlIHRoZSBzcGhlcmUsIGl0XG5cdCAqIHdpbGwgY2xhbXAgaXQgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGVkZ2Ugb2YgdGhlIHNwaGVyZS4gUG9pbnRzXG5cdCAqIGFscmVhZHkgaW5zaWRlIHRoZSBzcGhlcmUgd2lsbCBub3QgYmUgYWZmZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcGxhbmUgdG8gY2xhbXAuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjbGFtcGVkIHBvaW50LlxuXHQgKi9cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdHRhcmdldC5jb3B5KCBwb2ludCApO1xuXG5cdFx0aWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdHRhcmdldC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG5cdFx0XHR0YXJnZXQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBib3VuZGluZyBib3ggdGhhdCBlbmNsb3NlcyB0aGlzIHNwaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtCb3gzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGJveCB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7Qm94M30gVGhlIGJvdW5kaW5nIGJveCB0aGF0IGVuY2xvc2VzIHRoaXMgc3BoZXJlLlxuXHQgKi9cblx0Z2V0Qm91bmRpbmdCb3goIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdC8vIEVtcHR5IHNwaGVyZSBwcm9kdWNlcyBlbXB0eSBib3VuZGluZyBib3hcblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcblx0XHR0YXJnZXQuZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGlzIHNwaGVyZSB3aXRoIHRoZSBnaXZlbiA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdCAqIEByZXR1cm4ge1NwaGVyZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmUuXG5cdCAqL1xuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGVzIHRoZSBzcGhlcmUncyBjZW50ZXIgYnkgdGhlIGdpdmVuIG9mZnNldC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBvZmZzZXQgLSBUaGUgb2Zmc2V0LlxuXHQgKiBAcmV0dXJuIHtTcGhlcmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3BoZXJlLlxuXHQgKi9cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBhbmRzIHRoZSBib3VuZGFyaWVzIG9mIHRoaXMgc3BoZXJlIHRvIGluY2x1ZGUgdGhlIGdpdmVuIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIGluY2x1ZGUuXG5cdCAqIEByZXR1cm4ge1NwaGVyZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmUuXG5cdCAqL1xuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdHRoaXMucmFkaXVzID0gMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRfdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuY2VudGVyICk7XG5cblx0XHRjb25zdCBsZW5ndGhTcSA9IF92MS5sZW5ndGhTcSgpO1xuXG5cdFx0aWYgKCBsZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIG1pbmltYWwgc3BoZXJlXG5cblx0XHRcdGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCggbGVuZ3RoU3EgKTtcblxuXHRcdFx0Y29uc3QgZGVsdGEgPSAoIGxlbmd0aCAtIHRoaXMucmFkaXVzICkgKiAwLjU7XG5cblx0XHRcdHRoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3RvciggX3YxLCBkZWx0YSAvIGxlbmd0aCApO1xuXG5cdFx0XHR0aGlzLnJhZGl1cyArPSBkZWx0YTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcyB0aGlzIHNwaGVyZSB0byBlbmNsb3NlIGJvdGggdGhlIG9yaWdpbmFsIHNwaGVyZSBhbmQgdGhlIGdpdmVuIHNwaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gaW5jbHVkZS5cblx0ICogQHJldHVybiB7U3BoZXJlfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyZS5cblx0ICovXG5cdHVuaW9uKCBzcGhlcmUgKSB7XG5cblx0XHRpZiAoIHNwaGVyZS5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBzcGhlcmUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY2VudGVyLmVxdWFscyggc3BoZXJlLmNlbnRlciApID09PSB0cnVlICkge1xuXG5cdFx0XHQgdGhpcy5yYWRpdXMgPSBNYXRoLm1heCggdGhpcy5yYWRpdXMsIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF92Mi5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuYWRkKCBfdjIgKSApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHNwaGVyZSBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgc3BoZXJlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgYm91bmRpbmcgc3BoZXJlIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgc3BoZXJlIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NwaGVyZX0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyZSB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfc2VnQ2VudGVyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NlZ0RpciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9kaWZmID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfZWRnZTEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZWRnZTIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEEgcmF5IHRoYXQgZW1pdHMgZnJvbSBhbiBvcmlnaW4gaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gVGhlIGNsYXNzIGlzIHVzZWQgYnlcbiAqIHtAbGluayBSYXljYXN0ZXJ9IHRvIGFzc2lzdCB3aXRoIHJheWNhc3RpbmcuIFJheWNhc3RpbmcgaXMgdXNlZCBmb3JcbiAqIG1vdXNlIHBpY2tpbmcgKHdvcmtpbmcgb3V0IHdoYXQgb2JqZWN0cyBpbiB0aGUgM0Qgc3BhY2UgdGhlIG1vdXNlIGlzIG92ZXIpXG4gKiBhbW9uZ3N0IG90aGVyIHRoaW5ncy5cbiAqL1xuY2xhc3MgUmF5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyByYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW29yaWdpbj0oMCwwLDApXSAtIFRoZSBvcmlnaW4gb2YgdGhlIHJheS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbZGlyZWN0aW9uPSgwLDAsLTEpXSAtIFRoZSAobm9ybWFsaXplZCkgZGlyZWN0aW9uIG9mIHRoZSByYXkuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggb3JpZ2luID0gbmV3IFZlY3RvcjMoKSwgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9yaWdpbiBvZiB0aGUgcmF5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5vcmlnaW4gPSBvcmlnaW47XG5cblx0XHQvKipcblx0XHQgKiBUaGUgKG5vcm1hbGl6ZWQpIGRpcmVjdGlvbiBvZiB0aGUgcmF5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByYXkncyBjb21wb25lbnRzIGJ5IGNvcHlpbmcgdGhlIGdpdmVuIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBvcmlnaW4gLSBUaGUgb3JpZ2luLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24uXG5cdCAqIEByZXR1cm4ge1JheX0gQSByZWZlcmVuY2UgdG8gdGhpcyByYXkuXG5cdCAqL1xuXHRzZXQoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiByYXkgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtSYXl9IHJheSAtIFRoZSByYXkgdG8gY29weS5cblx0ICogQHJldHVybiB7UmF5fSBBIHJlZmVyZW5jZSB0byB0aGlzIHJheS5cblx0ICovXG5cdGNvcHkoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgdGhhdCBpcyBsb2NhdGVkIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgYWxvbmcgdGhpcyByYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGRpc3RhbmNlIGFsb25nIHRoZSByYXkgdG8gcmV0cmlldmUgYSBwb3NpdGlvbiBmb3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IEEgcG9zaXRpb24gb24gdGhlIHJheS5cblx0ICovXG5cdGF0KCB0LCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByYXkgdG8gcG9pbnQgYXQgdGhlIGdpdmVuIHZlY3RvciBpbiB3b3JsZCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHRhcmdldCBwb3NpdGlvbi5cblx0ICogQHJldHVybiB7UmF5fSBBIHJlZmVyZW5jZSB0byB0aGlzIHJheS5cblx0ICovXG5cdGxvb2tBdCggdiApIHtcblxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHYgKS5zdWIoIHRoaXMub3JpZ2luICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNoaWZ0IHRoZSBvcmlnaW4gb2YgdGhpcyByYXkgYWxvbmcgaXRzIGRpcmVjdGlvbiBieSB0aGUgZ2l2ZW4gZGlzdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGRpc3RhbmNlIGFsb25nIHRoZSByYXkgdG8gaW50ZXJwb2xhdGUuXG5cdCAqIEByZXR1cm4ge1JheX0gQSByZWZlcmVuY2UgdG8gdGhpcyByYXkuXG5cdCAqL1xuXHRyZWNhc3QoIHQgKSB7XG5cblx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCBfdmVjdG9yICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcG9pbnQgYWxvbmcgdGhpcyByYXkgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBnaXZlbiBwb2ludC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIEEgcG9pbnQgaW4gM0Qgc3BhY2UgdG8gZ2V0IHRoZSBjbG9zZXQgbG9jYXRpb24gb24gdGhlIHJheSBmb3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoaXMgcmF5LlxuXHQgKi9cblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcblxuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdGFyZ2V0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgZGlyZWN0aW9uRGlzdGFuY2UgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mIHRoZSBjbG9zZXN0IGFwcHJvYWNoIGJldHdlZW4gdGhpcyByYXkgYW5kIHRoZSBnaXZlbiBwb2ludC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIEEgcG9pbnQgaW4gM0Qgc3BhY2UgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8uXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpc3RhbmNlLlxuXHQgKi9cblx0ZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2Ugb2YgdGhlIGNsb3Nlc3QgYXBwcm9hY2ggYmV0d2VlbiB0aGlzIHJheSBhbmQgdGhlIGdpdmVuIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gQSBwb2ludCBpbiAzRCBzcGFjZSB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlZCBkaXN0YW5jZS5cblx0ICovXG5cdGRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gX3ZlY3Rvci5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdH1cblxuXHRcdF92ZWN0b3IuY29weSggdGhpcy5vcmlnaW4gKS5hZGRTY2FsZWRWZWN0b3IoIHRoaXMuZGlyZWN0aW9uLCBkaXJlY3Rpb25EaXN0YW5jZSApO1xuXG5cdFx0cmV0dXJuIF92ZWN0b3IuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyByYXkgYW5kIHRoZSBnaXZlbiBsaW5lIHNlZ21lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdjAgLSBUaGUgc3RhcnQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2MSAtIFRoZSBlbmQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbb3B0aW9uYWxQb2ludE9uUmF5XSAtIFdoZW4gcHJvdmlkZWQsIGl0IHJlY2VpdmVzIHRoZSBwb2ludCBvbiB0aGlzIHJheSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHNlZ21lbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW29wdGlvbmFsUG9pbnRPblNlZ21lbnRdIC0gV2hlbiBwcm92aWRlZCwgaXQgcmVjZWl2ZXMgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnQgdGhhdCBpcyBjbG9zZXN0IHRvIHRoaXMgcmF5LlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIGRpc3RhbmNlLlxuXHQgKi9cblx0ZGlzdGFuY2VTcVRvU2VnbWVudCggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wbWpvbmlhay9HZW9tZXRyaWNUb29scy9ibG9iL21hc3Rlci9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50Lmhcblx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHRfc2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblx0XHRfc2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xuXHRcdF9kaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBfc2VnQ2VudGVyICk7XG5cblx0XHRjb25zdCBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xuXHRcdGNvbnN0IGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBfc2VnRGlyICk7XG5cdFx0Y29uc3QgYjAgPSBfZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cdFx0Y29uc3QgYjEgPSAtIF9kaWZmLmRvdCggX3NlZ0RpciApO1xuXHRcdGNvbnN0IGMgPSBfZGlmZi5sZW5ndGhTcSgpO1xuXHRcdGNvbnN0IGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XG5cdFx0bGV0IHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG5cdFx0aWYgKCBkZXQgPiAwICkge1xuXG5cdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cblx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcblx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcblx0XHRcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcblxuXHRcdFx0aWYgKCBzMCA+PSAwICkge1xuXG5cdFx0XHRcdGlmICggczEgPj0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcblx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuXHRcdFx0XHRcdFx0Y29uc3QgaW52RGV0ID0gMSAvIGRldDtcblx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcblx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG5cdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cblx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG5cdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG5cdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG5cdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cblx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLm9yaWdpbiApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5kaXJlY3Rpb24sIHMwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cblx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggX3NlZ0NlbnRlciApLmFkZFNjYWxlZFZlY3RvciggX3NlZ0RpciwgczEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzcXJEaXN0O1xuXG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJzZWN0cyB0aGlzIHJheSB3aXRoIHRoZSBnaXZlbiBzcGhlcmUsIHJldHVybmluZyB0aGUgaW50ZXJzZWN0aW9uXG5cdCAqIHBvaW50IG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgc3BoZXJlIHRvIGludGVyc2VjdC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7P1ZlY3RvcjN9IFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQuXG5cdCAqL1xuXHRpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgdGFyZ2V0ICkge1xuXG5cdFx0X3ZlY3Rvci5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXHRcdGNvbnN0IHRjYSA9IF92ZWN0b3IuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdGNvbnN0IGQyID0gX3ZlY3Rvci5kb3QoIF92ZWN0b3IgKSAtIHRjYSAqIHRjYTtcblx0XHRjb25zdCByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgdGhjID0gTWF0aC5zcXJ0KCByYWRpdXMyIC0gZDIgKTtcblxuXHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0Y29uc3QgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MSBpcyBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXHRcdGlmICggdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcblx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG5cdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCB0YXJnZXQgKTtcblxuXHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gc3BoZXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlIC0gVGhlIHNwaGVyZSB0byBpbnRlcnNlY3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBzcGhlcmUgb3Igbm90LlxuXHQgKi9cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcmF5J3Mgb3JpZ2luIHRvIHRoZSBnaXZlbiBwbGFuZS4gUmV0dXJucyBgbnVsbGAgaWYgdGhlIHJheVxuXHQgKiBkb2VzIG5vdCBpbnRlcnNlY3Qgd2l0aCB0aGUgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIC0gVGhlIHBsYW5lIHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvLlxuXHQgKiBAcmV0dXJuIHs/bnVtYmVyfSBXaGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gc3BoZXJlIG9yIG5vdC5cblx0ICovXG5cdGRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogbnVsbDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEludGVyc2VjdHMgdGhpcyByYXkgd2l0aCB0aGUgZ2l2ZW4gcGxhbmUsIHJldHVybmluZyB0aGUgaW50ZXJzZWN0aW9uXG5cdCAqIHBvaW50IG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIC0gVGhlIHBsYW5lIHRvIGludGVyc2VjdC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7P1ZlY3RvcjN9IFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQuXG5cdCAqL1xuXHRpbnRlcnNlY3RQbGFuZSggcGxhbmUsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHJheSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIHBsYW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSAtIFRoZSBwbGFuZSB0byBpbnRlcnNlY3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBwbGFuZSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0Y29uc3QgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJzZWN0cyB0aGlzIHJheSB3aXRoIHRoZSBnaXZlbiBib3VuZGluZyBib3gsIHJldHVybmluZyB0aGUgaW50ZXJzZWN0aW9uXG5cdCAqIHBvaW50IG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byBpbnRlcnNlY3QuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4gez9WZWN0b3IzfSBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuXHQgKi9cblx0aW50ZXJzZWN0Qm94KCBib3gsIHRhcmdldCApIHtcblxuXHRcdGxldCB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblxuXHRcdGNvbnN0IGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cblx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCBpc05hTiggdG1pbiApICkgdG1pbiA9IHR5bWluO1xuXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgaXNOYU4oIHRtYXggKSApIHRtYXggPSB0eW1heDtcblxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XG5cblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIHRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byBpbnRlcnNlY3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBib3ggb3Igbm90LlxuXHQgKi9cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIF92ZWN0b3IgKSAhPT0gbnVsbDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEludGVyc2VjdHMgdGhpcyByYXkgd2l0aCB0aGUgZ2l2ZW4gdHJpYW5nbGUsIHJldHVybmluZyB0aGUgaW50ZXJzZWN0aW9uXG5cdCAqIHBvaW50IG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGIgLSBUaGUgc2Vjb25kIHZlcnRleCBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYyAtIFRoZSB0aGlyZCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJhY2tmYWNlQ3VsbGluZyAtIFdoZXRoZXIgdG8gdXNlIGJhY2tmYWNlIGN1bGxpbmcgb3Igbm90LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHs/VmVjdG9yM30gVGhlIGludGVyc2VjdGlvbiBwb2ludC5cblx0ICovXG5cdGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCApIHtcblxuXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cblx0XHRfZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdF9lZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X25vcm1hbC5jcm9zc1ZlY3RvcnMoIF9lZGdlMSwgX2VkZ2UyICk7XG5cblx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcblx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG5cdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXG5cdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG5cdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcblx0XHRsZXQgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBfbm9ybWFsICk7XG5cdFx0bGV0IHNpZ247XG5cblx0XHRpZiAoIERkTiA+IDAgKSB7XG5cblx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRzaWduID0gMTtcblxuXHRcdH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XG5cblx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHREZE4gPSAtIERkTjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0X2RpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcblx0XHRjb25zdCBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBfZWRnZTIuY3Jvc3NWZWN0b3JzKCBfZGlmZiwgX2VkZ2UyICkgKTtcblxuXHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCBEZFF4RTIgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIF9lZGdlMS5jcm9zcyggX2RpZmYgKSApO1xuXG5cdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRpZiAoIERkRTF4USA8IDAgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cblx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuXHRcdGNvbnN0IFFkTiA9IC0gc2lnbiAqIF9kaWZmLmRvdCggX25vcm1hbCApO1xuXG5cdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhpcyByYXkgd2l0aCB0aGUgZ2l2ZW4gNHg0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXg0IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICogQHJldHVybiB7UmF5fSBBIHJlZmVyZW5jZSB0byB0aGlzIHJheS5cblx0ICovXG5cdGFwcGx5TWF0cml4NCggbWF0cml4NCApIHtcblxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4NCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHJheSBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmF5fSByYXkgLSBUaGUgcmF5IHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgcmF5IGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggcmF5ICkge1xuXG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyByYXkgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7UmF5fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUmF5IH07XG4iLCJpbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0sIFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIDR4NCBtYXRyaXguXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIHVzZSBvZiBhIDR4NCBtYXRyaXggaW4gM0QgY29tcHV0ZXIgZ3JhcGhpY3MgaXMgYXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gKiBGb3IgYW4gaW50cm9kdWN0aW9uIHRvIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGFzIHVzZWQgaW4gV2ViR0wsIGNoZWNrIG91dCBbdGhpcyB0dXRvcmlhbF17QGxpbmsgaHR0cHM6Ly93d3cub3BlbmdsLXR1dG9yaWFsLm9yZy9iZWdpbm5lcnMtdHV0b3JpYWxzL3R1dG9yaWFsLTMtbWF0cmljZXN9XG4gKlxuICogVGhpcyBhbGxvd3MgYSAzRCB2ZWN0b3IgcmVwcmVzZW50aW5nIGEgcG9pbnQgaW4gM0Qgc3BhY2UgdG8gdW5kZXJnb1xuICogdHJhbnNmb3JtYXRpb25zIHN1Y2ggYXMgdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzaGVhciwgc2NhbGUsIHJlZmxlY3Rpb24sXG4gKiBvcnRob2dvbmFsIG9yIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gYW5kIHNvIG9uLCBieSBiZWluZyBtdWx0aXBsaWVkIGJ5IHRoZVxuICogbWF0cml4LiBUaGlzIGlzIGtub3duIGFzIGBhcHBseWluZ2AgdGhlIG1hdHJpeCB0byB0aGUgdmVjdG9yLlxuICpcbiAqIEEgTm90ZSBvbiBSb3ctTWFqb3IgYW5kIENvbHVtbi1NYWpvciBPcmRlcmluZzpcbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgYW5kIHtAbGluayBNYXRyaXgzI3NldH0gbWV0aG9kIHRha2UgYXJndW1lbnRzIGluXG4gKiBbcm93LW1ham9yXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctX2FuZF9jb2x1bW4tbWFqb3Jfb3JkZXIjQ29sdW1uLW1ham9yX29yZGVyfVxuICogb3JkZXIsIHdoaWxlIGludGVybmFsbHkgdGhleSBhcmUgc3RvcmVkIGluIHRoZSB7QGxpbmsgTWF0cml4MyNlbGVtZW50c30gYXJyYXkgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuICogVGhpcyBtZWFucyB0aGF0IGNhbGxpbmc6XG4gKiBgYGBqc1xuICogY29uc3QgbSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gKiBtLnNldCggMTEsIDEyLCAxMywgMTQsXG4gKiAgICAgICAgMjEsIDIyLCAyMywgMjQsXG4gKiAgICAgICAgMzEsIDMyLCAzMywgMzQsXG4gKiAgICAgICAgNDEsIDQyLCA0MywgNDQgKTtcbiAqIGBgYFxuICogd2lsbCByZXN1bHQgaW4gdGhlIGVsZW1lbnRzIGFycmF5IGNvbnRhaW5pbmc6XG4gKiBgYGBqc1xuICogbS5lbGVtZW50cyA9IFsgMTEsIDIxLCAzMSwgNDEsXG4gKiAgICAgICAgICAgICAgICAxMiwgMjIsIDMyLCA0MixcbiAqICAgICAgICAgICAgICAgIDEzLCAyMywgMzMsIDQzLFxuICogICAgICAgICAgICAgICAgMTQsIDI0LCAzNCwgNDQgXTtcbiAqIGBgYFxuICogYW5kIGludGVybmFsbHkgYWxsIGNhbGN1bGF0aW9ucyBhcmUgcGVyZm9ybWVkIHVzaW5nIGNvbHVtbi1tYWpvciBvcmRlcmluZy5cbiAqIEhvd2V2ZXIsIGFzIHRoZSBhY3R1YWwgb3JkZXJpbmcgbWFrZXMgbm8gZGlmZmVyZW5jZSBtYXRoZW1hdGljYWxseSBhbmRcbiAqIG1vc3QgcGVvcGxlIGFyZSB1c2VkIHRvIHRoaW5raW5nIGFib3V0IG1hdHJpY2VzIGluIHJvdy1tYWpvciBvcmRlciwgdGhlXG4gKiB0aHJlZS5qcyBkb2N1bWVudGF0aW9uIHNob3dzIG1hdHJpY2VzIGluIHJvdy1tYWpvciBvcmRlci4gSnVzdCBiZWFyIGluXG4gKiBtaW5kIHRoYXQgaWYgeW91IGFyZSByZWFkaW5nIHRoZSBzb3VyY2UgY29kZSwgeW91J2xsIGhhdmUgdG8gdGFrZSB0aGVcbiAqIHRyYW5zcG9zZSBvZiBhbnkgbWF0cmljZXMgb3V0bGluZWQgaGVyZSB0byBtYWtlIHNlbnNlIG9mIHRoZSBjYWxjdWxhdGlvbnMuXG4gKi9cbmNsYXNzIE1hdHJpeDQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IDR4NCBtYXRyaXguIFRoZSBhcmd1bWVudHMgYXJlIHN1cHBvc2VkIHRvIGJlXG5cdCAqIGluIHJvdy1tYWpvciBvcmRlci4gSWYgbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNvbnN0cnVjdG9yXG5cdCAqIGluaXRpYWxpemVzIHRoZSBtYXRyaXggYXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xMV0gLSAxLTEgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjEyXSAtIDEtMiBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTNdIC0gMS0zIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xNF0gLSAxLTQgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjIxXSAtIDItMSBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMjJdIC0gMi0yIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24yM10gLSAyLTMgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjI0XSAtIDItNCBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMzFdIC0gMy0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24zMl0gLSAzLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjMzXSAtIDMtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMzRdIC0gMy00IG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW240MV0gLSA0LTEgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjQyXSAtIDQtMiBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuNDNdIC0gNC0zIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW240NF0gLSA0LTQgbWF0cml4IGVsZW1lbnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgY29sdW1uLW1ham9yIGxpc3Qgb2YgbWF0cml4IHZhbHVlcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuXHRcdCAqL1xuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGUgbWF0cml4LlRoZSBhcmd1bWVudHMgYXJlIHN1cHBvc2VkIHRvIGJlXG5cdCAqIGluIHJvdy1tYWpvciBvcmRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTFdIC0gMS0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xMl0gLSAxLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjEzXSAtIDEtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTRdIC0gMS00IG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24yMV0gLSAyLTEgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjIyXSAtIDItMiBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMjNdIC0gMi0zIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24yNF0gLSAyLTQgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjMxXSAtIDMtMSBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMzJdIC0gMy0yIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24zM10gLSAzLTMgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjM0XSAtIDMtNCBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuNDFdIC0gNC0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW240Ml0gLSA0LTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjQzXSAtIDQtMyBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuNDRdIC0gNC00IG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIG1hdHJpeCB0byB0aGUgNHg0IGlkZW50aXR5IG1hdHJpeC5cblx0ICpcblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbWF0cml4IHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4IHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSBtYXRyaXggdG8gY29weS5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gbWF0cml4XG5cdCAqIGludG8gdGhpcyBtYXRyaXgncyB0cmFuc2xhdGlvbiBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSBtYXRyaXggdG8gY29weSB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdXBwZXIgM3gzIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSB2YWx1ZXMgb2YgZ2l2ZW4gM3gzIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIDN4MyBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sIDAsXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGhlIGJhc2lzIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHRocmVlIGF4aXMgdmVjdG9ycyBwcm92aWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB4QXhpcyAtIFRoZSBiYXNpcydzIHggYXhpcy5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB5QXhpcyAtIFRoZSBiYXNpcydzIHkgYXhpcy5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB6QXhpcyAtIFRoZSBiYXNpcydzIHogYXhpcy5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gYmFzaXMgdmVjdG9ycyB0byB0aGlzIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB4QXhpcyAtIFRoZSBiYXNpcydzIHggYXhpcy5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB5QXhpcyAtIFRoZSBiYXNpcydzIHkgYXhpcy5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB6QXhpcyAtIFRoZSBiYXNpcydzIHogYXhpcy5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgcm90YXRpb24gY29tcG9uZW50IG9mIHRoZSBnaXZlbiBtYXRyaXhcblx0ICogaW50byB0aGlzIG1hdHJpeCdzIHJvdGF0aW9uIGNvbXBvbmVudC5cblx0ICpcblx0ICogTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG0gLSBUaGUgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRjb25zdCBzY2FsZVggPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVogPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuXHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcm90YXRpb24gY29tcG9uZW50ICh0aGUgdXBwZXIgbGVmdCAzeDMgbWF0cml4KSBvZiB0aGlzIG1hdHJpeCB0b1xuXHQgKiB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBFdWxlciBhbmdsZXMuIFRoZSByZXN0IG9mXG5cdCAqIHRoZSBtYXRyaXggaXMgc2V0IHRvIHRoZSBpZGVudGl0eS4gRGVwZW5kaW5nIG9uIHRoZSB7QGxpbmsgRXVsZXIjb3JkZXJ9LFxuXHQgKiB0aGVyZSBhcmUgc2l4IHBvc3NpYmxlIG91dGNvbWVzLiBTZWUgW3RoaXMgcGFnZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzI1JvdGF0aW9uX21hdHJpeH1cblx0ICogZm9yIGEgY29tcGxldGUgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdWxlcn0gZXVsZXIgLSBUaGUgRXVsZXIgYW5nbGVzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuXHRcdGNvbnN0IGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0Y29uc3QgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJvdGF0aW9uIGNvbXBvbmVudCBvZiB0aGlzIG1hdHJpeCB0byB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGJ5XG5cdCAqIHRoZSBnaXZlbiBRdWF0ZXJuaW9uIGFzIG91dGxpbmVkIFtoZXJlXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXgjUXVhdGVybmlvbn1cblx0ICogVGhlIHJlc3Qgb2YgdGhlIG1hdHJpeCBpcyBzZXQgdG8gdGhlIGlkZW50aXR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgLSBUaGUgUXVhdGVybmlvbi5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByb3RhdGlvbiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgbG9va2luZyBmcm9tIGBleWVgIHRvd2FyZHNcblx0ICogYHRhcmdldGAsIGFuZCBvcmllbnRlZCBieSB0aGUgdXAtZGlyZWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGV5ZSAtIFRoZSBleWUgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHVwIC0gVGhlIHVwIHZlY3Rvci5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUG9zdC1tdWx0aXBsaWVzIHRoaXMgbWF0cml4IGJ5IHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG0gLSBUaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcmUtbXVsdGlwbGllcyB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHByZW11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGVzIHRoZSBnaXZlbiA0eDQgbWF0cmljZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIGluIHRoaXMgbWF0cml4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IGEgLSBUaGUgZmlyc3QgbWF0cml4LlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IGIgLSBUaGUgc2Vjb25kIG1hdHJpeC5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtdWx0aXBseU1hdHJpY2VzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgNCBdLCBhMTMgPSBhZVsgOCBdLCBhMTQgPSBhZVsgMTIgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcblx0XHRjb25zdCBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0Y29uc3QgYTQxID0gYWVbIDMgXSwgYTQyID0gYWVbIDcgXSwgYTQzID0gYWVbIDExIF0sIGE0NCA9IGFlWyAxNSBdO1xuXG5cdFx0Y29uc3QgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG5cdFx0Y29uc3QgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xuXHRcdGNvbnN0IGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0Mjtcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuXHRcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcblx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuXHRcdHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG5cdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0dGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cblx0XHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG5cdFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgZXZlcnkgY29tcG9uZW50IG9mIHRoZSBtYXRyaXggYnkgdGhlIGdpdmVuIHNjYWxhci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHMgLSBUaGUgc2NhbGFyLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguXG5cdCAqXG5cdCAqIEJhc2VkIG9uIHRoZSBtZXRob2Qgb3V0bGluZWQgW2hlcmVde0BsaW5rIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bWx9LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkZXRlcm1pbmFudC5cblx0ICovXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0Y29uc3QgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0Y29uc3QgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0bjQxICogKFxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG5cdFx0XHQpICtcblx0XHRcdG40MiAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDMgKiAoXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQ0ICogKFxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG5cdFx0XHQpXG5cblx0XHQpO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNwb3NlcyB0aGlzIG1hdHJpeCBpbiBwbGFjZS5cblx0ICpcblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcG9zaXRpb24gY29tcG9uZW50IGZvciB0aGlzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IsXG5cdCAqIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSByZXN0IG9mIHRoZSBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfFZlY3RvcjN9IHggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBvciBhbHRlcm5hdGl2ZWx5IHRoZSB2ZWN0b3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHNldFBvc2l0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0dGVbIDEyIF0gPSB4Lng7XG5cdFx0XHR0ZVsgMTMgXSA9IHgueTtcblx0XHRcdHRlWyAxNCBdID0geC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGVbIDEyIF0gPSB4O1xuXHRcdFx0dGVbIDEzIF0gPSB5O1xuXHRcdFx0dGVbIDE0IF0gPSB6O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoaXMgbWF0cml4LCB1c2luZyB0aGUgW2FuYWx5dGljIG1ldGhvZF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW52ZXJ0aWJsZV9tYXRyaXgjQW5hbHl0aWNfc29sdXRpb259LlxuXHQgKiBZb3UgY2FuIG5vdCBpbnZlcnQgd2l0aCBhIGRldGVybWluYW50IG9mIHplcm8uIElmIHlvdSBhdHRlbXB0IHRoaXMsIHRoZSBtZXRob2QgcHJvZHVjZXNcblx0ICogYSB6ZXJvIG1hdHJpeCBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGludmVydCgpIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblxuXHRcdFx0bjExID0gdGVbIDAgXSwgbjIxID0gdGVbIDEgXSwgbjMxID0gdGVbIDIgXSwgbjQxID0gdGVbIDMgXSxcblx0XHRcdG4xMiA9IHRlWyA0IF0sIG4yMiA9IHRlWyA1IF0sIG4zMiA9IHRlWyA2IF0sIG40MiA9IHRlWyA3IF0sXG5cdFx0XHRuMTMgPSB0ZVsgOCBdLCBuMjMgPSB0ZVsgOSBdLCBuMzMgPSB0ZVsgMTAgXSwgbjQzID0gdGVbIDExIF0sXG5cdFx0XHRuMTQgPSB0ZVsgMTIgXSwgbjI0ID0gdGVbIDEzIF0sIG4zNCA9IHRlWyAxNCBdLCBuNDQgPSB0ZVsgMTUgXSxcblxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxuXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXG5cdFx0Y29uc3QgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuXHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoZSBjb2x1bW5zIG9mIHRoaXMgbWF0cml4IGJ5IHRoZSBnaXZlbiB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSBzY2FsZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0c2NhbGUoIHYgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbWF4aW11bSBzY2FsZSB2YWx1ZSBvZiB0aGUgdGhyZWUgYXhlcy5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSBzY2FsZS5cblx0ICovXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0gZnJvbSB0aGUgZ2l2ZW4gdmVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcnxWZWN0b3IzfSB4IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIFggYXhpcyBvciBhbHRlcm5hdGl2ZWx5IGEgdHJhbnNsYXRpb24gdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBhbW91bnQgdG8gdHJhbnNsYXRlIGluIHRoZSBZIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHogYXhpcy5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKSB7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCAwLCB4LngsXG5cdFx0XHRcdDAsIDEsIDAsIHgueSxcblx0XHRcdFx0MCwgMCwgMSwgeC56LFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCAwLCB4LFxuXHRcdFx0XHQwLCAxLCAwLCB5LFxuXHRcdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgWCBheGlzIGJ5XG5cdCAqIHRoZSBnaXZlbiBhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVGhlIHJvdGF0aW9uIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bWFrZVJvdGF0aW9uWCggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgWSBheGlzIGJ5XG5cdCAqIHRoZSBnaXZlbiBhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVGhlIHJvdGF0aW9uIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bWFrZVJvdGF0aW9uWSggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQgYywgMCwgcywgMCxcblx0XHRcdCAwLCAxLCAwLCAwLFxuXHRcdFx0LSBzLCAwLCBjLCAwLFxuXHRcdFx0IDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgWiBheGlzIGJ5XG5cdCAqIHRoZSBnaXZlbiBhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVGhlIHJvdGF0aW9uIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bWFrZVJvdGF0aW9uWiggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsIDAsXG5cdFx0XHRzLCBjLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieVxuXHQgKiB0aGUgZ2l2ZW4gYW5nbGUuXG5cdCAqXG5cdCAqIFRoaXMgaXMgYSBzb21ld2hhdCBjb250cm92ZXJzaWFsIGJ1dCBtYXRoZW1hdGljYWxseSBzb3VuZCBhbHRlcm5hdGl2ZSB0b1xuXHQgKiByb3RhdGluZyB2aWEgUXVhdGVybmlvbnMuIFNlZSB0aGUgZGlzY3Vzc2lvbiBbaGVyZV17QGxpbmsgaHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvYXJ0aWNsZXMvcHJvZ3JhbW1pbmcvbWF0aC1hbmQtcGh5c2ljcy9kby13ZS1yZWFsbHktbmVlZC1xdWF0ZXJuaW9ucy1yMTE5OX0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyAtIFRoZSBub3JtYWxpemVkIHJvdGF0aW9uIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSByb3RhdGlvbiBpbiByYWRpYW5zLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBhbW91bnQgdG8gc2NhbGUgaW4gdGhlIFggYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW1vdW50IHRvIHNjYWxlIGluIHRoZSBZIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIGFtb3VudCB0byBzY2FsZSBpbiB0aGUgWiBheGlzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdG1ha2VTY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLCAwLFxuXHRcdFx0MCwgeSwgMCwgMCxcblx0XHRcdDAsIDAsIHosIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgbWF0cml4IGFzIGEgc2hlYXIgdHJhbnNmb3JtYXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4eSAtIFRoZSBhbW91bnQgdG8gc2hlYXIgWCBieSBZLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geHogLSBUaGUgYW1vdW50IHRvIHNoZWFyIFggYnkgWi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHl4IC0gVGhlIGFtb3VudCB0byBzaGVhciBZIGJ5IFguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5eiAtIFRoZSBhbW91bnQgdG8gc2hlYXIgWSBieSBaLlxuXHQgKiBAcGFyYW0ge251bWJlcn0genggLSBUaGUgYW1vdW50IHRvIHNoZWFyIFogYnkgWC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHp5IC0gVGhlIGFtb3VudCB0byBzaGVhciBaIGJ5IFkuXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bWFrZVNoZWFyKCB4eSwgeHosIHl4LCB5eiwgengsIHp5ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHl4LCB6eCwgMCxcblx0XHRcdHh5LCAxLCB6eSwgMCxcblx0XHRcdHh6LCB5eiwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggdG8gdGhlIHRyYW5zZm9ybWF0aW9uIGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBwb3NpdGlvbixcblx0ICogcm90YXRpb24gKFF1YXRlcm5pb24pIGFuZCBzY2FsZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvbiAtIFRoZSByb3RhdGlvbiBhcyBhIFF1YXRlcm5pb24uXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gc2NhbGUgLSBUaGUgc2NhbGUgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBxdWF0ZXJuaW9uLl94LCB5ID0gcXVhdGVybmlvbi5feSwgeiA9IHF1YXRlcm5pb24uX3osIHcgPSBxdWF0ZXJuaW9uLl93O1xuXHRcdGNvbnN0IHgyID0geCArIHgsXHR5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xuXHRcdGNvbnN0IHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0Y29uc3QgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6Mjtcblx0XHRjb25zdCB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xuXG5cdFx0Y29uc3Qgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcblxuXHRcdHRlWyAwIF0gPSAoIDEgLSAoIHl5ICsgenogKSApICogc3g7XG5cdFx0dGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XG5cdFx0dGVbIDIgXSA9ICggeHogLSB3eSApICogc3g7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gKCB4eSAtIHd6ICkgKiBzeTtcblx0XHR0ZVsgNSBdID0gKCAxIC0gKCB4eCArIHp6ICkgKSAqIHN5O1xuXHRcdHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XG5cdFx0dGVbIDkgXSA9ICggeXogLSB3eCApICogc3o7XG5cdFx0dGVbIDEwIF0gPSAoIDEgLSAoIHh4ICsgeXkgKSApICogc3o7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSBwb3NpdGlvbi54O1xuXHRcdHRlWyAxMyBdID0gcG9zaXRpb24ueTtcblx0XHR0ZVsgMTQgXSA9IHBvc2l0aW9uLno7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvbXBvc2VzIHRoaXMgbWF0cml4IGludG8gaXRzIHBvc2l0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGUgY29tcG9uZW50c1xuXHQgKiBhbmQgcHJvdmlkZXMgdGhlIHJlc3VsdCBpbiB0aGUgZ2l2ZW4gb2JqZWN0cy5cblx0ICpcblx0ICogTm90ZTogTm90IGFsbCBtYXRyaWNlcyBhcmUgZGVjb21wb3NhYmxlIGluIHRoaXMgd2F5LiBGb3IgZXhhbXBsZSwgaWYgYW5cblx0ICogb2JqZWN0IGhhcyBhIG5vbi11bmlmb3JtbHkgc2NhbGVkIHBhcmVudCwgdGhlbiB0aGUgb2JqZWN0J3Mgd29ybGQgbWF0cml4XG5cdCAqIG1heSBub3QgYmUgZGVjb21wb3NhYmxlLCBhbmQgdGhpcyBtZXRob2QgbWF5IG5vdCBiZSBhcHByb3ByaWF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvbiAtIFRoZSByb3RhdGlvbiBhcyBhIFF1YXRlcm5pb24uXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gc2NhbGUgLSBUaGUgc2NhbGUgdmVjdG9yLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0bGV0IHN4ID0gX3YxLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gX3YxLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gX3YxLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0Y29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXHRcdGlmICggZGV0IDwgMCApIHN4ID0gLSBzeDtcblxuXHRcdHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcblx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XG5cdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcblx0XHRfbTEuY29weSggdGhpcyApO1xuXG5cdFx0Y29uc3QgaW52U1ggPSAxIC8gc3g7XG5cdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XG5cdFx0Y29uc3QgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRfbTEuZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRfbTEuZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcblx0XHRfbTEuZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdF9tMS5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdF9tMS5lbGVtZW50c1sgNSBdICo9IGludlNZO1xuXHRcdF9tMS5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0X20xLmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XG5cdFx0X20xLmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXG5cdFx0c2NhbGUueCA9IHN4O1xuXHRcdHNjYWxlLnkgPSBzeTtcblx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnlcblx0ICoge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI3VwZGF0ZVByb2plY3Rpb25NYXRyaXh9LlxuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBib3VuZGFyeSBvZiB0aGUgdmlld2luZyBmcnVzdHVtIGF0IHRoZSBuZWFyIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgLSBSaWdodCBib3VuZGFyeSBvZiB0aGUgdmlld2luZyBmcnVzdHVtIGF0IHRoZSBuZWFyIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdG9wIC0gVG9wIGJvdW5kYXJ5IG9mIHRoZSB2aWV3aW5nIGZydXN0dW0gYXQgdGhlIG5lYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gYm91bmRhcnkgb2YgdGhlIHZpZXdpbmcgZnJ1c3R1bSBhdCB0aGUgbmVhciBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhIHRvIHRoZSBuZWFyIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZmFyIC0gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYSB0byB0aGUgZmFyIHBsYW5lLlxuXHQgKiBAcGFyYW0geyhXZWJHTENvb3JkaW5hdGVTeXN0ZW18V2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSl9IFtjb29yZGluYXRlU3lzdGVtPVdlYkdMQ29vcmRpbmF0ZVN5c3RlbV0gLSBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0uXG5cdCAqIEByZXR1cm4ge01hdHJpeDR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0bWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRjb25zdCBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG5cdFx0bGV0IGMsIGQ7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0YyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gMiAqIGZhciAqIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0YyA9IC0gZmFyIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0XHRkID0gKCAtIGZhciAqIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuTWF0cml4NC5tYWtlUGVyc3BlY3RpdmUoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTsgXHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiOyBcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjOyBcdHRlWyAxNCBdID0gZDtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5XG5cdCAqIHtAbGluayBPcnRob2dyYXBoaWNDYW1lcmEjdXBkYXRlUHJvamVjdGlvbk1hdHJpeH0uXG5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGJvdW5kYXJ5IG9mIHRoZSB2aWV3aW5nIGZydXN0dW0gYXQgdGhlIG5lYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGJvdW5kYXJ5IG9mIHRoZSB2aWV3aW5nIGZydXN0dW0gYXQgdGhlIG5lYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUb3AgYm91bmRhcnkgb2YgdGhlIHZpZXdpbmcgZnJ1c3R1bSBhdCB0aGUgbmVhciBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBib3VuZGFyeSBvZiB0aGUgdmlld2luZyBmcnVzdHVtIGF0IHRoZSBuZWFyIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbmVhciAtIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjYW1lcmEgdG8gdGhlIG5lYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhIHRvIHRoZSBmYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7KFdlYkdMQ29vcmRpbmF0ZVN5c3RlbXxXZWJHUFVDb29yZGluYXRlU3lzdGVtKX0gW2Nvb3JkaW5hdGVTeXN0ZW09V2ViR0xDb29yZGluYXRlU3lzdGVtXSAtIFRoZSBjb29yZGluYXRlIHN5c3RlbS5cblx0ICogQHJldHVybiB7TWF0cml4NH0gQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXG5cdCAqL1xuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBtYXRyaXggaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBtYXRyaXggaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKi9cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFycmF5IC0gVGhlIG1hdHJpeCBlbGVtZW50cyBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogV3JpdGVzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gYXJyYXkuIElmIG5vIGFycmF5IGlzIHByb3ZpZGVkLFxuXHQgKiB0aGUgbWV0aG9kIHJldHVybnMgYSBuZXcgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2FycmF5PVtdXSAtIFRoZSB0YXJnZXQgYXJyYXkgaG9sZGluZyB0aGUgbWF0cml4IGVsZW1lbnRzIGluIGNvbHVtbi1tYWpvciBvcmRlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBJbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG5cdCAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBtYXRyaXggZWxlbWVudHMgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuXHQgKi9cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF96ZXJvID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xuY29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcbmNvbnN0IF94ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3kgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZXhwb3J0IHsgTWF0cml4NCB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9NYXRyaXg0LmpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jb25zdCBfbWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgRXVsZXIgYW5nbGVzLlxuICpcbiAqIEV1bGVyIGFuZ2xlcyBkZXNjcmliZSBhIHJvdGF0aW9uYWwgdHJhbnNmb3JtYXRpb24gYnkgcm90YXRpbmcgYW4gb2JqZWN0IG9uXG4gKiBpdHMgdmFyaW91cyBheGVzIGluIHNwZWNpZmllZCBhbW91bnRzIHBlciBheGlzLCBhbmQgYSBzcGVjaWZpZWQgYXhpc1xuICogb3JkZXIuXG4gKlxuICogSXRlcmF0aW5nIHRocm91Z2ggYW4gaW5zdGFuY2Ugd2lsbCB5aWVsZCBpdHMgY29tcG9uZW50cyAoeCwgeSwgeixcbiAqIG9yZGVyKSBpbiB0aGUgY29ycmVzcG9uZGluZyBvcmRlci5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYSA9IG5ldyBUSFJFRS5FdWxlciggMCwgMSwgMS41NywgJ1hZWicgKTtcbiAqIGNvbnN0IGIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMSApO1xuICogYi5hcHBseUV1bGVyKGEpO1xuICogYGBgXG4gKi9cbmNsYXNzIEV1bGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBldWxlciBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIGFuZ2xlIG9mIHRoZSB5IGF4aXMgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdIC0gVGhlIGFuZ2xlIG9mIHRoZSB6IGF4aXMgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcmRlcj1FdWxlci5ERUZBVUxUX09SREVSXSAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgb3JkZXIgdGhhdCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKi9cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBhbmdsZSBvZiB0aGUgeSBheGlzIGluIHJhZGlhbnMuXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYW5nbGUgb2YgdGhlIHogYXhpcyBpbiByYWRpYW5zLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG5cdCAqXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0ICdYWVonXG5cdCAqL1xuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIEV1bGVyIGNvbXBvbmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW5nbGUgb2YgdGhlIHkgYXhpcyBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3JkZXJdIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG5cdCAqIEByZXR1cm4ge0V1bGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIEV1bGVyIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBFdWxlciBpbnN0YW5jZSB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtFdWxlcn0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gRXVsZXIgaW5zdGFuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdWxlcn0gZXVsZXIgLSBUaGUgRXVsZXIgaW5zdGFuY2UgdG8gY29weS5cblx0ICogQHJldHVybiB7RXVsZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgRXVsZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5KCBldWxlciApIHtcblxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhbmdsZXMgb2YgdGhpcyBFdWxlciBpbnN0YW5jZSBmcm9tIGEgcHVyZSByb3RhdGlvbiBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIEEgNHg0IG1hdHJpeCBvZiB3aGljaCB0aGUgdXBwZXIgM3gzIG9mIG1hdHJpeCBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUuIHVuc2NhbGVkKS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcmRlcl0gLSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPXRydWVdIC0gV2hldGhlciB0aGUgaW50ZXJuYWwgYG9uQ2hhbmdlYCBjYWxsYmFjayBzaG91bGQgYmUgZXhlY3V0ZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtFdWxlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBFdWxlciBpbnN0YW5jZS5cblx0ICovXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSwgb3JkZXIgPSB0aGlzLl9vcmRlciwgdXBkYXRlID0gdHJ1ZSApIHtcblxuXHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cztcblx0XHRjb25zdCBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdGNvbnN0IG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG5cdFx0Y29uc3QgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlID09PSB0cnVlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhbmdsZXMgb2YgdGhpcyBFdWxlciBpbnN0YW5jZSBmcm9tIGEgbm9ybWFsaXplZCBxdWF0ZXJuaW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgLSBBIG5vcm1hbGl6ZWQgUXVhdGVybmlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcmRlcl0gLSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPXRydWVdIC0gV2hldGhlciB0aGUgaW50ZXJuYWwgYG9uQ2hhbmdlYCBjYWxsYmFjayBzaG91bGQgYmUgZXhlY3V0ZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtFdWxlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBFdWxlciBpbnN0YW5jZS5cblx0ICovXG5cdHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0X21hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhbmdsZXMgb2YgdGhpcyBFdWxlciBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdiAtIFRoZSB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3JkZXJdIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG5cdCAqIEByZXR1cm4ge0V1bGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIEV1bGVyIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGV1bGVyIGFuZ2xlIHdpdGggYSBuZXcgb3JkZXIgYnkgY3JlYXRpbmcgYSBxdWF0ZXJuaW9uIGZyb20gdGhpc1xuXHQgKiBldWxlciBhbmdsZSBhbmQgdGhlbiBzZXR0aW5nIHRoaXMgZXVsZXIgYW5nbGUgd2l0aCB0aGUgcXVhdGVybmlvbiBhbmQgdGhlXG5cdCAqIG5ldyBvcmRlci5cblx0ICpcblx0ICogV2FybmluZzogVGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25ld09yZGVyXSAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmV3IG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cblx0ICogQHJldHVybiB7RXVsZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgRXVsZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRyZW9yZGVyKCBuZXdPcmRlciApIHtcblxuXHRcdF9xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLCBuZXdPcmRlciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBFdWxlciBpbnN0YW5jZSBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXVsZXJ9IGV1bGVyIC0gVGhlIEV1bGVyIGluc3RhbmNlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgRXVsZXIgaW5zdGFuY2UgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKi9cblx0ZXF1YWxzKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBFdWxlciBpbnN0YW5jZSdzIGNvbXBvbmVudHMgdG8gdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5LiBUaGUgZmlyc3QgdGhyZWVcblx0ICogZW50cmllcyBvZiB0aGUgYXJyYXkgYXJlIGFzc2lnbiB0byB0aGUgeCx5IGFuZCB6IGNvbXBvbmVudHMuIEFuIG9wdGlvbmFsIGZvdXJ0aCBlbnRyeVxuXHQgKiBkZWZpbmVzIHRoZSBFdWxlciBvcmRlci5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXIsbnVtYmVyLG51bWJlciw/c3RyaW5nPn0gYXJyYXkgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBFdWxlciBjb21wb25lbnQgdmFsdWVzLlxuXHQgKiBAcmV0dXJuIHtFdWxlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBFdWxlciBpbnN0YW5jZS5cblx0ICovXG5cdGZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogV3JpdGVzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgRXVsZXIgaW5zdGFuY2UgdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcixudW1iZXIsbnVtYmVyLHN0cmluZz59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIEV1bGVyIGNvbXBvbmVudHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheTxudW1iZXIsbnVtYmVyLG51bWJlcixzdHJpbmc+fSBUaGUgRXVsZXIgY29tcG9uZW50cy5cblx0ICovXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBFdWxlciBhbmdsZSBvcmRlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGRlZmF1bHQgJ1hZWidcbiAqL1xuRXVsZXIuREVGQVVMVF9PUkRFUiA9ICdYWVonO1xuXG5leHBvcnQgeyBFdWxlciB9O1xuIiwiLyoqXG4gKiBBIGxheWVycyBvYmplY3QgYXNzaWducyBhbiAzRCBvYmplY3QgdG8gMSBvciBtb3JlIG9mIDMyXG4gKiBsYXllcnMgbnVtYmVyZWQgYDBgIHRvIGAzMWAgLSBpbnRlcm5hbGx5IHRoZSBsYXllcnMgYXJlIHN0b3JlZCBhcyBhXG4gKiBiaXQgbWFza10sIGFuZCBieSBkZWZhdWx0IGFsbCAzRCBvYmplY3RzIGFyZSBhIG1lbWJlciBvZiBsYXllciBgMGAuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHZpc2liaWxpdHkgLSBhbiBvYmplY3QgbXVzdCBzaGFyZSBhIGxheWVyIHdpdGhcbiAqIGEgY2FtZXJhIHRvIGJlIHZpc2libGUgd2hlbiB0aGF0IGNhbWVyYSdzIHZpZXcgaXNcbiAqIHJlbmRlcmVkLlxuICpcbiAqIEFsbCBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIHtAbGluayBPYmplY3QzRH0gaGF2ZSBhbiBgbGF5ZXJzYCBwcm9wZXJ0eSB3aGljaFxuICogaXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgTGF5ZXJzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsYXllcnMgaW5zdGFuY2UsIHdpdGggbWVtYmVyc2hpcFxuXHQgKiBpbml0aWFsbHkgc2V0IHRvIGxheWVyIGAwYC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogQSBiaXQgbWFzayBzdG9yaW5nIHdoaWNoIG9mIHRoZSAzMiBsYXllcnMgdGhpcyBsYXllcnMgb2JqZWN0IGlzIGN1cnJlbnRseVxuXHRcdCAqIGEgbWVtYmVyIG9mLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLm1hc2sgPSAxIHwgMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgbWVtYmVyc2hpcCB0byB0aGUgZ2l2ZW4gbGF5ZXIsIGFuZCByZW1vdmUgbWVtYmVyc2hpcCBhbGwgb3RoZXIgbGF5ZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gc2V0LlxuXHQgKi9cblx0c2V0KCBsYXllciApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBsYXllciB8IDAgKSA+Pj4gMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgbWVtYmVyc2hpcCBvZiB0aGUgZ2l2ZW4gbGF5ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXllciAtIFRoZSBsYXllciB0byBlbmFibGUuXG5cdCAqL1xuXHRlbmFibGUoIGxheWVyICkge1xuXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgbGF5ZXIgfCAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBtZW1iZXJzaGlwIHRvIGFsbCBsYXllcnMuXG5cdCAqL1xuXHRlbmFibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAweGZmZmZmZmZmIHwgMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgdGhlIG1lbWJlcnNoaXAgb2YgdGhlIGdpdmVuIGxheWVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gdG9nZ2xlLlxuXHQgKi9cblx0dG9nZ2xlKCBsYXllciApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGxheWVyIHwgMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgbWVtYmVyc2hpcCBvZiB0aGUgZ2l2ZW4gbGF5ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXllciAtIFRoZSBsYXllciB0byBlbmFibGUuXG5cdCAqL1xuXHRkaXNhYmxlKCBsYXllciApIHtcblxuXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBsYXllciB8IDAgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIG1lbWJlcnNoaXAgZnJvbSBhbGwgbGF5ZXJzLlxuXHQgKi9cblx0ZGlzYWJsZUFsbCgpIHtcblxuXHRcdHRoaXMubWFzayA9IDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gbGF5ZXJzIG9iamVjdCBoYXZlIGF0IGxlYXN0IG9uZVxuXHQgKiBsYXllciBpbiBjb21tb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJzfSBsYXllcnMgLSBUaGUgbGF5ZXJzIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW4gfSBXaGV0aGVyIHRoaXMgYW5kIHRoZSBnaXZlbiBsYXllcnMgb2JqZWN0IGhhdmUgYXQgbGVhc3Qgb25lIGxheWVyIGluIGNvbW1vbiBvciBub3QuXG5cdCAqL1xuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGVuYWJsZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXllciAtIFRoZSBsYXllciB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFuIH0gV2hldGhlciB0aGUgZ2l2ZW4gbGF5ZXIgaXMgZW5hYmxlZCBvciBub3QuXG5cdCAqL1xuXHRpc0VuYWJsZWQoIGxheWVyICkge1xuXG5cdFx0cmV0dXJuICggdGhpcy5tYXNrICYgKCAxIDw8IGxheWVyIHwgMCApICkgIT09IDA7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgTGF5ZXJzIH07XG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVVVSUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbmxldCBfb2JqZWN0M0RJZCA9IDA7XG5cbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF90YXJnZXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9wb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9zY2FsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jb25zdCBfeEF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5jb25zdCBfeUF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5jb25zdCBfekF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgb2JqZWN0IGhhcyBiZWVuIGFkZGVkIHRvIGl0cyBwYXJlbnQgb2JqZWN0LlxuICpcbiAqIEBldmVudCBPYmplY3QzRCNhZGRlZFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBvYmplY3QgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgb2JqZWN0LlxuICpcbiAqIEBldmVudCBPYmplY3QzRCNyZW1vdmVkXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBfcmVtb3ZlZEV2ZW50ID0geyB0eXBlOiAncmVtb3ZlZCcgfTtcblxuLyoqXG4gKiBGaXJlcyB3aGVuIGEgbmV3IGNoaWxkIG9iamVjdCBoYXMgYmVlbiBhZGRlZC5cbiAqXG4gKiBAZXZlbnQgT2JqZWN0M0QjY2hpbGRhZGRlZFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgX2NoaWxkYWRkZWRFdmVudCA9IHsgdHlwZTogJ2NoaWxkYWRkZWQnLCBjaGlsZDogbnVsbCB9O1xuXG4vKipcbiAqIEZpcmVzIHdoZW4gYSBuZXcgY2hpbGQgb2JqZWN0IGhhcyBiZWVuIGFkZGVkLlxuICpcbiAqIEBldmVudCBPYmplY3QzRCNjaGlsZHJlbW92ZWRcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IF9jaGlsZHJlbW92ZWRFdmVudCA9IHsgdHlwZTogJ2NoaWxkcmVtb3ZlZCcsIGNoaWxkOiBudWxsIH07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbW9zdCBvYmplY3RzIGluIHRocmVlLmpzIGFuZCBwcm92aWRlcyBhIHNldCBvZlxuICogcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIG9iamVjdHMgaW4gM0Qgc3BhY2UuXG4gKlxuICogQGF1Z21lbnRzIEV2ZW50RGlzcGF0Y2hlclxuICovXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgM0Qgb2JqZWN0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgM0Qgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQG5hbWUgT2JqZWN0M0QjaWRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIFVVSUQgb2YgdGhlIDNEIG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgM0Qgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIHByb3BlcnR5IGlzIHVzZWQgZm9yIGRldGVjdGluZyB0aGUgb2JqZWN0IHR5cGVcblx0XHQgKiBpbiBjb250ZXh0IG9mIHNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBvYmplY3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P09iamVjdDNEfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBob2xkaW5nIHRoZSBjaGlsZCAzRCBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8T2JqZWN0M0Q+fVxuXHRcdCAqL1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGB1cGAgZGlyZWN0aW9uIG9mIHRoZSAzRCBvYmplY3Qgd2hpY2ggaW5mbHVlbmNlc1xuXHRcdCAqIHRoZSBvcmllbnRhdGlvbiB2aWEgbWV0aG9kcyBsaWtlIHtAbGluayBPYmplY3QzRCNsb29rQXR9LlxuXHRcdCAqXG5cdFx0ICogVGhlIGRlZmF1bHQgdmFsdWVzIGZvciBhbGwgM0Qgb2JqZWN0cyBpcyBkZWZpbmVkIGJ5IGBPYmplY3QzRC5ERUZBVUxUX1VQYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5ERUZBVUxUX1VQLmNsb25lKCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0XHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cblx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRyb3RhdGlvbi5fb25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0XHRxdWF0ZXJuaW9uLl9vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXByZXNlbnRzIHRoZSBvYmplY3QncyBsb2NhbCBwb3NpdGlvbi5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbmFtZSBPYmplY3QzRCNwb3NpdGlvblxuXHRcdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0XHQgKiBAZGVmYXVsdCAoMCwwLDApXG5cdFx0XHQgKi9cblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXByZXNlbnRzIHRoZSBvYmplY3QncyBsb2NhbCByb3RhdGlvbiBhcyBFdWxlciBhbmdsZXMsIGluIHJhZGlhbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG5hbWUgT2JqZWN0M0Qjcm90YXRpb25cblx0XHRcdCAqIEB0eXBlIHtFdWxlcn1cblx0XHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHRcdCAqL1xuXHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlcHJlc2VudHMgdGhlIG9iamVjdCdzIGxvY2FsIHJvdGF0aW9uIGFzIFF1YXRlcm5pb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBuYW1lIE9iamVjdDNEI3F1YXRlcm5pb25cblx0XHRcdCAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxuXHRcdFx0ICovXG5cdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlcHJlc2VudHMgdGhlIG9iamVjdCdzIGxvY2FsIHNjYWxlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBuYW1lIE9iamVjdDNEI3NjYWxlXG5cdFx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHRcdCAqIEBkZWZhdWx0ICgxLDEsMSlcblx0XHRcdCAqL1xuXHRcdFx0c2NhbGU6IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogc2NhbGVcblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlcHJlc2VudHMgdGhlIG9iamVjdCdzIG1vZGVsLXZpZXcgbWF0cml4LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBuYW1lIE9iamVjdDNEI21vZGVsVmlld01hdHJpeFxuXHRcdFx0ICogQHR5cGUge01hdHJpeDR9XG5cdFx0XHQgKi9cblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVwcmVzZW50cyB0aGUgb2JqZWN0J3Mgbm9ybWFsIG1hdHJpeC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbmFtZSBPYmplY3QzRCNub3JtYWxNYXRyaXhcblx0XHRcdCAqIEB0eXBlIHtNYXRyaXgzfVxuXHRcdFx0ICovXG5cdFx0XHRub3JtYWxNYXRyaXg6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvKipcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gbG9jYWwgc3BhY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TWF0cml4NH1cblx0XHQgKi9cblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHQvKipcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gd29ybGQgc3BhY2UuXG5cdFx0ICogSWYgdGhlIDNEIG9iamVjdCBoYXMgbm8gcGFyZW50LCB0aGVuIGl0J3MgaWRlbnRpY2FsIHRvIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtNYXRyaXg0fVxuXHRcdCAqL1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZW5naW5lIGF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgdGhlIGxvY2FsIG1hdHJpeCBmcm9tIHBvc2l0aW9uLFxuXHRcdCAqIHJvdGF0aW9uIGFuZCBzY2FsZSBldmVyeSBmcmFtZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgYWxsIDNEIG9iamVjdHMgaXMgZGVmaW5lZCBieSBgT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEVgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZW5naW5lIGF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgdGhlIHdvcmxkIG1hdHJpeCBmcm9tIHRoZSBjdXJyZW50IGxvY2FsXG5cdFx0ICogbWF0cml4IGFuZCB0aGUgb2JqZWN0J3MgdHJhbnNmb3JtYXRpb24gaGllcmFyY2h5LlxuXHRcdCAqXG5cdFx0ICogVGhlIGRlZmF1bHQgdmFsdWVzIGZvciBhbGwgM0Qgb2JqZWN0cyBpcyBkZWZpbmVkIGJ5IGBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgaXQgY2FsY3VsYXRlcyB0aGUgd29ybGQgbWF0cml4IGluIHRoYXQgZnJhbWUgYW5kIHJlc2V0cyB0aGlzIHByb3BlcnR5XG5cdFx0ICogdG8gYGZhbHNlYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGF5ZXIgbWVtYmVyc2hpcCBvZiB0aGUgM0Qgb2JqZWN0LiBUaGUgM0Qgb2JqZWN0IGlzIG9ubHkgdmlzaWJsZSBpZiBpdCBoYXNcblx0XHQgKiBhdCBsZWFzdCBvbmUgbGF5ZXIgaW4gY29tbW9uIHdpdGggdGhlIGNhbWVyYSBpbiB1c2UuIFRoaXMgcHJvcGVydHkgY2FuIGFsc28gYmVcblx0XHQgKiB1c2VkIHRvIGZpbHRlciBvdXQgdW53YW50ZWQgb2JqZWN0cyBpbiByYXktaW50ZXJzZWN0aW9uIHRlc3RzIHdoZW4gdXNpbmcge0BsaW5rIFJheWNhc3Rlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TGF5ZXJzfVxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgM0Qgb2JqZWN0IGdldHMgcmVuZGVyZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIDNEIG9iamVjdCBnZXRzIHJlbmRlcmVkIGludG8gc2hhZG93IG1hcHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgM0Qgb2JqZWN0IGlzIGFmZmVjdGVkIGJ5IHNoYWRvd3MgaW4gdGhlIHNjZW5lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIDNEIG9iamVjdCBpcyBob25vcmVkIGJ5IHZpZXcgZnJ1c3R1bSBjdWxsaW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHZhbHVlIGFsbG93cyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb3JkZXIgb2Ygc2NlbmUgZ3JhcGggb2JqZWN0cyB0byBiZVxuXHRcdCAqIG92ZXJyaWRkZW4gYWx0aG91Z2ggb3BhcXVlIGFuZCB0cmFuc3BhcmVudCBvYmplY3RzIHJlbWFpbiBzb3J0ZWQgaW5kZXBlbmRlbnRseS5cblx0XHQgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGZvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgR3JvdXB9LGFsbCBkZXNjZW5kYW50c1xuXHRcdCAqIG9iamVjdHMgd2lsbCBiZSBzb3J0ZWQgYW5kIHJlbmRlcmVkIHRvZ2V0aGVyLiBTb3J0aW5nIGlzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3Rcblx0XHQgKiByZW5kZXIgb3JkZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGhvbGRpbmcgdGhlIGFuaW1hdGlvbiBjbGlwcyBvZiB0aGUgM0Qgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PEFuaW1hdGlvbkNsaXA+fVxuXHRcdCAqL1xuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VzdG9tIGRlcHRoIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdG8gdGhlIGRlcHRoIG1hcC4gQ2FuIG9ubHkgYmUgdXNlZFxuXHRcdCAqIGluIGNvbnRleHQgb2YgbWVzaGVzLiBXaGVuIHNoYWRvdy1jYXN0aW5nIHdpdGggYSB7QGxpbmsgRGlyZWN0aW9uYWxMaWdodH0gb3Ige0BsaW5rIFNwb3RMaWdodH0sXG5cdFx0ICogaWYgeW91IGFyZSBtb2RpZnlpbmcgdmVydGV4IHBvc2l0aW9ucyBpbiB0aGUgdmVydGV4IHNoYWRlciB5b3UgbXVzdCBzcGVjaWZ5IGEgY3VzdG9tIGRlcHRoXG5cdFx0ICogbWF0ZXJpYWwgZm9yIHByb3BlciBzaGFkb3dzLlxuXHRcdCAqXG5cdFx0ICogT25seSByZWxldmFudCBpbiBjb250ZXh0IG9mIHtAbGluayBXZWJHTFJlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoTWF0ZXJpYWx8dW5kZWZpbmVkKX1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLmN1c3RvbURlcHRoTWF0ZXJpYWwgPSB1bmRlZmluZWQ7XG5cblx0XHQvKipcblx0XHQgKiBTYW1lIGFzIHtAbGluayBPYmplY3QzRCNjdXN0b21EZXB0aE1hdGVyaWFsfSwgYnV0IHVzZWQgd2l0aCB7QGxpbmsgUG9pbnRMaWdodH0uXG5cdFx0ICpcblx0XHQgKiBPbmx5IHJlbGV2YW50IGluIGNvbnRleHQgb2Yge0BsaW5rIFdlYkdMUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhNYXRlcmlhbHx1bmRlZmluZWQpfVxuXHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdHRoaXMuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGN1c3RvbSBkYXRhIGFib3V0IHRoZSAzRCBvYmplY3QuIEl0XG5cdFx0ICogc2hvdWxkIG5vdCBob2xkIHJlZmVyZW5jZXMgdG8gZnVuY3Rpb25zIGFzIHRoZXNlIHdpbGwgbm90IGJlIGNsb25lZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIDNEIG9iamVjdCBpcyByZW5kZXJlZCB0byBhIHNoYWRvdyBtYXAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ8V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIHNjZW5lLlxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gc2hhZG93Q2FtZXJhIC0gVGhlIHNoYWRvdyBjYW1lcmEuXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5IC0gVGhlIDNEIG9iamVjdCdzIGdlb21ldHJ5LlxuXHQgKiBAcGFyYW0ge01hdGVyaWFsfSBkZXB0aE1hdGVyaWFsIC0gVGhlIGRlcHRoIG1hdGVyaWFsLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZ3JvdXAgLSBUaGUgZ2VvbWV0cnkgZ3JvdXAgZGF0YS5cblx0ICovXG5cdG9uQmVmb3JlU2hhZG93KCAvKiByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHQvKipcblx0ICogQSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgM0Qgb2JqZWN0IGlzIHJlbmRlcmVkIHRvIGEgc2hhZG93IG1hcC5cblx0ICpcblx0ICogQHBhcmFtIHtSZW5kZXJlcnxXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIDNEIG9iamVjdC5cblx0ICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgc2NlbmUuXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBzaGFkb3dDYW1lcmEgLSBUaGUgc2hhZG93IGNhbWVyYS5cblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnkgLSBUaGUgM0Qgb2JqZWN0J3MgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx9IGRlcHRoTWF0ZXJpYWwgLSBUaGUgZGVwdGggbWF0ZXJpYWwuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBncm91cCAtIFRoZSBnZW9tZXRyeSBncm91cCBkYXRhLlxuXHQgKi9cblx0b25BZnRlclNoYWRvdyggLyogcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0LyoqXG5cdCAqIEEgY2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSAzRCBvYmplY3QgaXMgcmVuZGVyZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ8V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIHNjZW5lLlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeSAtIFRoZSAzRCBvYmplY3QncyBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWwgLSBUaGUgM0Qgb2JqZWN0J3MgbWF0ZXJpYWwuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBncm91cCAtIFRoZSBnZW9tZXRyeSBncm91cCBkYXRhLlxuXHQgKi9cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHQvKipcblx0ICogQSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgM0Qgb2JqZWN0IGlzIHJlbmRlcmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1JlbmRlcmVyfFdlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBzY2VuZS5cblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnkgLSBUaGUgM0Qgb2JqZWN0J3MgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsIC0gVGhlIDNEIG9iamVjdCdzIG1hdGVyaWFsLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZ3JvdXAgLSBUaGUgZ2VvbWV0cnkgZ3JvdXAgZGF0YS5cblx0ICovXG5cdG9uQWZ0ZXJSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHRoZSBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIG9iamVjdCdzIHBvc2l0aW9uLFxuXHQgKiByb3RhdGlvbiBhbmQgc2NhbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICovXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tYXRyaXgucHJlbXVsdGlwbHkoIG1hdHJpeCApO1xuXG5cdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSByb3RhdGlvbiByZXByZXNlbnRlZCBieSBnaXZlbiB0aGUgcXVhdGVybmlvbiB0byB0aGUgM0Qgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgLSBUaGUgcXVhdGVybmlvbi5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gcm90YXRpb24gcmVwcmVzZW50ZWQgYXMgYW4gYXhpcy9hbmdsZSBjb3VwbGUgdG8gdGhlIDNEIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBheGlzIC0gVGhlIChub3JtYWxpemVkKSBheGlzIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqL1xuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gcm90YXRpb24gcmVwcmVzZW50ZWQgYXMgRXVsZXIgYW5nbGVzIHRvIHRoZSAzRCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXVsZXJ9IGV1bGVyIC0gVGhlIEV1bGVyIGFuZ2xlcy5cblx0ICovXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiByb3RhdGlvbiByZXByZXNlbnRlZCBhcyByb3RhdGlvbiBtYXRyaXggdG8gdGhlIDNEIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gQWx0aG91Z2ggYSA0eDQgbWF0cml4IGlzIGV4cGVjdGVkLCB0aGUgdXBwZXIgM3gzIHBvcnRpb24gbXVzdCBiZVxuXHQgKiBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKS5cblx0ICovXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeCggbSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiByb3RhdGlvbiByZXByZXNlbnRlZCBhcyBhIFF1YXRlcm5pb24gdG8gdGhlIDNEIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIC0gVGhlIFF1YXRlcm5pb25cblx0ICovXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIDNEIG9iamVjdCBhbG9uZyBhbiBheGlzIGluIGxvY2FsIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGF4aXMgLSBUaGUgKG5vcm1hbGl6ZWQpIGF4aXMgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRyb3RhdGVPbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIDNEIG9iamVjdCBhbG9uZyBhbiBheGlzIGluIHdvcmxkIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGF4aXMgLSBUaGUgKG5vcm1hbGl6ZWQpIGF4aXMgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIDNEIG9iamVjdCBhcm91bmQgaXRzIFggYXhpcyBpbiBsb2NhbCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIDNEIG9iamVjdCBhcm91bmQgaXRzIFkgYXhpcyBpbiBsb2NhbCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIDNEIG9iamVjdCBhcm91bmQgaXRzIFogYXhpcyBpbiBsb2NhbCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZSB0aGUgM0Qgb2JqZWN0IGJ5IGEgZGlzdGFuY2UgYWxvbmcgdGhlIGdpdmVuIGF4aXMgaW4gbG9jYWwgc3BhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyAtIFRoZSAobm9ybWFsaXplZCkgYXhpcyB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHR0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRfdjEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmFkZCggX3YxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZSB0aGUgM0Qgb2JqZWN0IGJ5IGEgZGlzdGFuY2UgYWxvbmcgaXRzIFgtYXhpcyBpbiBsb2NhbCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIC0gVGhlIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuXHQgKiBAcmV0dXJuIHtPYmplY3QzRH0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGUgdGhlIDNEIG9iamVjdCBieSBhIGRpc3RhbmNlIGFsb25nIGl0cyBZLWF4aXMgaW4gbG9jYWwgc3BhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHR0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3lBeGlzLCBkaXN0YW5jZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNsYXRlIHRoZSAzRCBvYmplY3QgYnkgYSBkaXN0YW5jZSBhbG9uZyBpdHMgWi1heGlzIGluIGxvY2FsIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgLSBUaGUgZGlzdGFuY2UgaW4gd29ybGQgdW5pdHMuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0dHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIF96QXhpcywgZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzIDNEIG9iamVjdCdzIGxvY2FsIHNwYWNlIHRvIHdvcmxkIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHZlY3RvciAtIFRoZSB2ZWN0b3IgdG8gY29udmVydC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIGNvbnZlcnRlZCB2ZWN0b3IuXG5cdCAqL1xuXHRsb2NhbFRvV29ybGQoIHZlY3RvciApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXMgM0Qgb2JqZWN0J3Mgd29yZCBzcGFjZSB0byBsb2NhbCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2ZWN0b3IgLSBUaGUgdmVjdG9yIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjb252ZXJ0ZWQgdmVjdG9yLlxuXHQgKi9cblx0d29ybGRUb0xvY2FsKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIF9tMS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIG9iamVjdCB0byBmYWNlIGEgcG9pbnQgaW4gd29ybGQgc3BhY2UuXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcnxWZWN0b3IzfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBpbiB3b3JsZCBzcGFjZS4gQWx0ZXJuYXRpdmVseSwgYSB2ZWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gaW4gd29ybGQgc3BhY2Vcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIFRoZSB5IGNvb3JkaW5hdGUgaW4gd29ybGQgc3BhY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbel0gLSBUaGUgeiBjb29yZGluYXRlIGluIHdvcmxkIHNwYWNlLlxuXHQgKi9cblx0bG9va0F0KCB4LCB5LCB6ICkge1xuXG5cdFx0Ly8gVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBwYXJlbnQocylcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdF90YXJnZXQuY29weSggeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X3RhcmdldC5zZXQoIHgsIHksIHogKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF9wb3NpdGlvbiwgX3RhcmdldCwgdGhpcy51cCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X20xLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRfbTEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEuaW52ZXJ0KCkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIDNEIG9iamVjdCBhcyBhIGNoaWxkIHRvIHRoaXMgM0Qgb2JqZWN0LiBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mXG5cdCAqIG9iamVjdHMgbWF5IGJlIGFkZGVkLiBBbnkgY3VycmVudCBwYXJlbnQgb24gYW4gb2JqZWN0IHBhc3NlZCBpbiBoZXJlIHdpbGwgYmVcblx0ICogcmVtb3ZlZCwgc2luY2UgYW4gb2JqZWN0IGNhbiBoYXZlIGF0IG1vc3Qgb25lIHBhcmVudC5cblx0ICpcblx0ICogQGZpcmVzIE9iamVjdDNEI2FkZGVkXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNjaGlsZGFkZGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3QzRH0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGFkZCggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSB7XG5cblx0XHRcdG9iamVjdC5yZW1vdmVGcm9tUGFyZW50KCk7XG5cdFx0XHRvYmplY3QucGFyZW50ID0gdGhpcztcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCBfYWRkZWRFdmVudCApO1xuXG5cdFx0XHRfY2hpbGRhZGRlZEV2ZW50LmNoaWxkID0gb2JqZWN0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hpbGRhZGRlZEV2ZW50ICk7XG5cdFx0XHRfY2hpbGRhZGRlZEV2ZW50LmNoaWxkID0gbnVsbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGdpdmVuIDNEIG9iamVjdCBhcyBjaGlsZCBmcm9tIHRoaXMgM0Qgb2JqZWN0LlxuXHQgKiBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG9iamVjdHMgbWF5IGJlIHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNyZW1vdmVkXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNjaGlsZHJlbW92ZWRcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIDNEIG9iamVjdCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cmVtb3ZlKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX3JlbW92ZWRFdmVudCApO1xuXG5cdFx0XHRfY2hpbGRyZW1vdmVkRXZlbnQuY2hpbGQgPSBvYmplY3Q7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9jaGlsZHJlbW92ZWRFdmVudCApO1xuXHRcdFx0X2NoaWxkcmVtb3ZlZEV2ZW50LmNoaWxkID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGlzIDNEIG9iamVjdCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudC5cblx0ICpcblx0ICogQGZpcmVzIE9iamVjdDNEI3JlbW92ZWRcblx0ICogQGZpcmVzIE9iamVjdDNEI2NoaWxkcmVtb3ZlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3QzRH0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHJlbW92ZUZyb21QYXJlbnQoKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRwYXJlbnQucmVtb3ZlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGNoaWxkIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNyZW1vdmVkXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNjaGlsZHJlbW92ZWRcblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbGVhcigpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggLi4uIHRoaXMuY2hpbGRyZW4gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIDNEIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMgM0Qgb2JqZWN0LCB3aGlsZSBtYWludGFpbmluZyB0aGUgb2JqZWN0J3Mgd29ybGRcblx0ICogdHJhbnNmb3JtLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHNjZW5lIGdyYXBocyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgbm9kZXMocykuXG5cdCAqXG5cdCAqIEBmaXJlcyBPYmplY3QzRCNhZGRlZFxuXHQgKiBAZmlyZXMgT2JqZWN0M0QjY2hpbGRhZGRlZFxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0IHRvIGF0dGFjaC5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhdHRhY2goIG9iamVjdCApIHtcblxuXHRcdC8vIGFkZHMgb2JqZWN0IGFzIGEgY2hpbGQgb2YgdGhpcywgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9iamVjdCdzIHdvcmxkIHRyYW5zZm9ybVxuXG5cdFx0Ly8gTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBzY2VuZSBncmFwaHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIG5vZGVzKHMpXG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0X20xLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0X20xLm11bHRpcGx5KCBvYmplY3QucGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHRvYmplY3QuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdG9iamVjdC5yZW1vdmVGcm9tUGFyZW50KCk7XG5cdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIHRydWUgKTtcblxuXHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCBfYWRkZWRFdmVudCApO1xuXG5cdFx0X2NoaWxkYWRkZWRFdmVudC5jaGlsZCA9IG9iamVjdDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9jaGlsZGFkZGVkRXZlbnQgKTtcblx0XHRfY2hpbGRhZGRlZEV2ZW50LmNoaWxkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoZXMgdGhyb3VnaCB0aGUgM0Qgb2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4sIHN0YXJ0aW5nIHdpdGggdGhlIDNEIG9iamVjdFxuXHQgKiBpdHNlbGYsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCB3aXRoIGEgbWF0Y2hpbmcgSUQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoZSBpZC5cblx0ICogQHJldHVybiB7T2JqZWN0M0R8dW5kZWZpbmVkfSBUaGUgZm91bmQgM0Qgb2JqZWN0LiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIG5vIDNEIG9iamVjdCBoYXMgYmVlbiBmb3VuZC5cblx0ICovXG5cdGdldE9iamVjdEJ5SWQoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIHRocm91Z2ggdGhlIDNEIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuLCBzdGFydGluZyB3aXRoIHRoZSAzRCBvYmplY3Rcblx0ICogaXRzZWxmLCBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgd2l0aCBhIG1hdGNoaW5nIG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfHVuZGVmaW5lZH0gVGhlIGZvdW5kIDNEIG9iamVjdC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBubyAzRCBvYmplY3QgaGFzIGJlZW4gZm91bmQuXG5cdCAqL1xuXHRnZXRPYmplY3RCeU5hbWUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIHRocm91Z2ggdGhlIDNEIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuLCBzdGFydGluZyB3aXRoIHRoZSAzRCBvYmplY3Rcblx0ICogaXRzZWxmLCBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgd2l0aCBhIG1hdGNoaW5nIHByb3BlcnR5IHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3QzRHx1bmRlZmluZWR9IFRoZSBmb3VuZCAzRCBvYmplY3QuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gM0Qgb2JqZWN0IGhhcyBiZWVuIGZvdW5kLlxuXHQgKi9cblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hlcyB0aHJvdWdoIHRoZSAzRCBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiwgc3RhcnRpbmcgd2l0aCB0aGUgM0Qgb2JqZWN0XG5cdCAqIGl0c2VsZiwgYW5kIHJldHVybnMgYWxsIDNEIG9iamVjdHMgd2l0aCBhIG1hdGNoaW5nIHByb3BlcnR5IHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdDNEPn0gcmVzdWx0IC0gVGhlIG1ldGhvZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGlzIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheTxPYmplY3QzRD59IFRoZSBmb3VuZCAzRCBvYmplY3RzLlxuXHQgKi9cblx0Z2V0T2JqZWN0c0J5UHJvcGVydHkoIG5hbWUsIHZhbHVlLCByZXN1bHQgPSBbXSApIHtcblxuXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJlc3VsdC5wdXNoKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLmdldE9iamVjdHNCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSwgcmVzdWx0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSAzRCBvYmplY3QgaW4gd29ybGQgc3BhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhlIHJlc3VsdCBpcyBzdG9yZWQgdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSAzRCBvYmplY3QncyBwb3NpdGlvbiBpbiB3b3JsZCBzcGFjZS5cblx0ICovXG5cdGdldFdvcmxkUG9zaXRpb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIFF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgM0Qgb2JqZWN0IGluIHdvcmxkIHNwYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldCAtIFRoZSB0YXJnZXQgUXVhdGVybmlvbiB0aGUgcmVzdWx0IGlzIHN0b3JlZCB0by5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIDNEIG9iamVjdCdzIHJvdGF0aW9uIGluIHdvcmxkIHNwYWNlLlxuXHQgKi9cblx0Z2V0V29ybGRRdWF0ZXJuaW9uKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIF9wb3NpdGlvbiwgdGFyZ2V0LCBfc2NhbGUgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgc2NhbGUgb2YgdGhlIDNEIG9iamVjdCBpbiB3b3JsZCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHN0b3JlZCB0by5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIDNEIG9iamVjdCdzIHNjYWxlIGluIHdvcmxkIHNwYWNlLlxuXHQgKi9cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgKFwibG9va1wiKSBkaXJlY3Rpb24gb2YgdGhlIDNEIG9iamVjdCBpbiB3b3JsZCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHN0b3JlZCB0by5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIDNEIG9iamVjdCdzIGRpcmVjdGlvbiBpbiB3b3JsZCBzcGFjZS5cblx0ICovXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggZVsgOCBdLCBlWyA5IF0sIGVbIDEwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFic3RyYWN0IG1ldGhvZCB0byBnZXQgaW50ZXJzZWN0aW9ucyBiZXR3ZWVuIGEgY2FzdGVkIHJheSBhbmQgdGhpc1xuXHQgKiAzRCBvYmplY3QuIFJlbmRlcmFibGUgM0Qgb2JqZWN0cyBzdWNoIGFzIHtAbGluayBNZXNofSwge0BsaW5rIExpbmV9IG9yIHtAbGluayBQb2ludHN9XG5cdCAqIGltcGxlbWVudCB0aGlzIG1ldGhvZCBpbiBvcmRlciB0byB1c2UgcmF5Y2FzdGluZy5cblx0ICpcblx0ICogQGFic3RyYWN0XG5cdCAqIEBwYXJhbSB7UmF5Y2FzdGVyfSByYXljYXN0ZXIgLSBUaGUgcmF5Y2FzdGVyLlxuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGludGVyc2VjdHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZC5cblx0ICovXG5cdHJheWNhc3QoIC8qIHJheWNhc3RlciwgaW50ZXJzZWN0cyAqLyApIHt9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiB0aGlzIDNEIG9iamVjdCBhbmQgYWxsIGRlc2NlbmRhbnRzLlxuXHQgKlxuXHQgKiBOb3RlOiBNb2RpZnlpbmcgdGhlIHNjZW5lIGdyYXBoIGluc2lkZSB0aGUgY2FsbGJhY2sgaXMgZGlzY291cmFnZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyB0byBwcm9jZXNzIHRoZSBjdXJyZW50IDNEIG9iamVjdC5cblx0ICovXG5cdHRyYXZlcnNlKCBjYWxsYmFjayApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogTGlrZSB7QGxpbmsgT2JqZWN0M0QjdHJhdmVyc2V9LCBidXQgdGhlIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBmb3IgdmlzaWJsZSAzRCBvYmplY3RzLlxuXHQgKiBEZXNjZW5kYW50cyBvZiBpbnZpc2libGUgM0Qgb2JqZWN0cyBhcmUgbm90IHRyYXZlcnNlZC5cblx0ICpcblx0ICogTm90ZTogTW9kaWZ5aW5nIHRoZSBzY2VuZSBncmFwaCBpbnNpZGUgdGhlIGNhbGxiYWNrIGlzIGRpc2NvdXJhZ2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdG8gcHJvY2VzcyB0aGUgY3VycmVudCAzRCBvYmplY3QuXG5cdCAqL1xuXHR0cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogTGlrZSB7QGxpbmsgT2JqZWN0M0QjdHJhdmVyc2V9LCBidXQgdGhlIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBmb3IgYWxsIGFuY2VzdG9ycy5cblx0ICpcblx0ICogTm90ZTogTW9kaWZ5aW5nIHRoZSBzY2VuZSBncmFwaCBpbnNpZGUgdGhlIGNhbGxiYWNrIGlzIGRpc2NvdXJhZ2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdG8gcHJvY2VzcyB0aGUgY3VycmVudCAzRCBvYmplY3QuXG5cdCAqL1xuXHR0cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBpbiBsb2NhbCBzcGFjZSBieSBjb21wdXRpbmcgaXQgZnJvbSB0aGUgY3VycmVudFxuXHQgKiBwb3NpdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlIHZhbHVlcy5cblx0ICovXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBpbiB3b3JsZCBzcGFjZSBvZiB0aGlzIDNEIG9iamVjdHMgYW5kIGl0cyBkZXNjZW5kYW50cy5cblx0ICpcblx0ICogVG8gZW5zdXJlIGNvcnJlY3QgcmVzdWx0cywgdGhpcyBtZXRob2QgYWxzbyByZWNvbXB1dGVzIHRoZSAzRCBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW5cblx0ICogbG9jYWwgc3BhY2UuIFRoZSBjb21wdXRhdGlvbiBvZiB0aGUgbG9jYWwgYW5kIHdvcmxkIG1hdHJpeCBjYW4gYmUgY29udHJvbGxlZCB3aXRoIHRoZVxuXHQgKiB7QGxpbmsgT2JqZWN0M0QjbWF0cml4QXV0b1VwZGF0ZX0gYW5kIHtAbGluayBPYmplY3QzRCNtYXRyaXhXb3JsZEF1dG9VcGRhdGV9IGZsYWdzIHdoaWNoIGFyZSBib3RoXG5cdCAqIGB0cnVlYCBieSBkZWZhdWx0LiAgU2V0IHRoZXNlIGZsYWdzIHRvIGBmYWxzZWAgaWYgeW91IG5lZWQgbW9yZSBjb250cm9sIG92ZXIgdGhlIHVwZGF0ZSBtYXRyaXggcHJvY2Vzcy5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBhIHJlY29tcHV0YXRpb24gb2Ygd29ybGQgbWF0cmljZXMgaXMgZm9yY2VkIGV2ZW5cblx0ICogd2hlbiB7QGxpbmsgT2JqZWN0M0QjbWF0cml4V29ybGRBdXRvVXBkYXRlfSBpcyBzZXQgdG8gYGZhbHNlYC5cblx0ICovXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyBtYWtlIHN1cmUgZGVzY2VuZGFudHMgYXJlIHVwZGF0ZWQgaWYgcmVxdWlyZWRcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBhbHRlcm5hdGl2ZSB2ZXJzaW9uIG9mIHtAbGluayBPYmplY3QzRCN1cGRhdGVNYXRyaXhXb3JsZH0gd2l0aCBtb3JlIGNvbnRyb2wgb3ZlciB0aGVcblx0ICogdXBkYXRlIG9mIGFuY2VzdG9yIGFuZCBkZXNjZW5kYW50IG5vZGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVQYXJlbnRzPWZhbHNlXSBXaGV0aGVyIGFuY2VzdG9yIG5vZGVzIHNob3VsZCBiZSB1cGRhdGVkIG9yIG5vdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlQ2hpbGRyZW49ZmFsc2VdIFdoZXRoZXIgZGVzY2VuZGFudCBub2RlcyBzaG91bGQgYmUgdXBkYXRlZCBvciBub3QuXG5cdCAqL1xuXHR1cGRhdGVXb3JsZE1hdHJpeCggdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4gKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggdXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG1ha2Ugc3VyZSBkZXNjZW5kYW50cyBhcmUgdXBkYXRlZFxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRjaGlsZC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU2VyaWFsaXplcyB0aGUgM0Qgb2JqZWN0IGludG8gSlNPTi5cblx0ICpcblx0ICogQHBhcmFtIHs/KE9iamVjdHxzdHJpbmcpfSBtZXRhIC0gQW4gb3B0aW9uYWwgdmFsdWUgaG9sZGluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJpYWxpemF0aW9uLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIDNEIG9iamVjdC5cblx0ICogQHNlZSB7QGxpbmsgT2JqZWN0TG9hZGVyI3BhcnNlfVxuXHQgKi9cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Ly8gbWV0YSBpcyBhIHN0cmluZyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XG5cdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRjb25zdCBvdXRwdXQgPSB7fTtcblxuXHRcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRzaGFwZXM6IHt9LFxuXHRcdFx0XHRza2VsZXRvbnM6IHt9LFxuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdFx0bm9kZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cblx0XHRjb25zdCBvYmplY3QgPSB7fTtcblxuXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCB0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUgKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5yZW5kZXJPcmRlciAhPT0gMCApIG9iamVjdC5yZW5kZXJPcmRlciA9IHRoaXMucmVuZGVyT3JkZXI7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0b2JqZWN0LmxheWVycyA9IHRoaXMubGF5ZXJzLm1hc2s7XG5cdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblx0XHRvYmplY3QudXAgPSB0aGlzLnVwLnRvQXJyYXkoKTtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSBmYWxzZSApIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHQvLyBvYmplY3Qgc3BlY2lmaWMgcHJvcGVydGllc1xuXG5cdFx0aWYgKCB0aGlzLmlzSW5zdGFuY2VkTWVzaCApIHtcblxuXHRcdFx0b2JqZWN0LnR5cGUgPSAnSW5zdGFuY2VkTWVzaCc7XG5cdFx0XHRvYmplY3QuY291bnQgPSB0aGlzLmNvdW50O1xuXHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKTtcblx0XHRcdGlmICggdGhpcy5pbnN0YW5jZUNvbG9yICE9PSBudWxsICkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSB0aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0b2JqZWN0LnR5cGUgPSAnQmF0Y2hlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0XHRvYmplY3Quc29ydE9iamVjdHMgPSB0aGlzLnNvcnRPYmplY3RzO1xuXG5cdFx0XHRvYmplY3QuZHJhd1JhbmdlcyA9IHRoaXMuX2RyYXdSYW5nZXM7XG5cdFx0XHRvYmplY3QucmVzZXJ2ZWRSYW5nZXMgPSB0aGlzLl9yZXNlcnZlZFJhbmdlcztcblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5SW5mbyA9IHRoaXMuX2dlb21ldHJ5SW5mby5tYXAoIGluZm8gPT4gKCB7XG5cdFx0XHRcdC4uLmluZm8sXG5cdFx0XHRcdGJvdW5kaW5nQm94OiBpbmZvLmJvdW5kaW5nQm94ID8ge1xuXHRcdFx0XHRcdG1pbjogaW5mby5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLFxuXHRcdFx0XHRcdG1heDogaW5mby5ib3VuZGluZ0JveC5tYXgudG9BcnJheSgpXG5cdFx0XHRcdH0gOiB1bmRlZmluZWQsXG5cdFx0XHRcdGJvdW5kaW5nU3BoZXJlOiBpbmZvLmJvdW5kaW5nU3BoZXJlID8ge1xuXHRcdFx0XHRcdHJhZGl1czogaW5mby5ib3VuZGluZ1NwaGVyZS5yYWRpdXMsXG5cdFx0XHRcdFx0Y2VudGVyOiBpbmZvLmJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KClcblx0XHRcdFx0fSA6IHVuZGVmaW5lZFxuXHRcdFx0fSApICk7XG5cdFx0XHRvYmplY3QuaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvLm1hcCggaW5mbyA9PiAoIHsgLi4uaW5mbyB9ICkgKTtcblxuXHRcdFx0b2JqZWN0LmF2YWlsYWJsZUluc3RhbmNlSWRzID0gdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMuc2xpY2UoKTtcblx0XHRcdG9iamVjdC5hdmFpbGFibGVHZW9tZXRyeUlkcyA9IHRoaXMuX2F2YWlsYWJsZUdlb21ldHJ5SWRzLnNsaWNlKCk7XG5cblx0XHRcdG9iamVjdC5uZXh0SW5kZXhTdGFydCA9IHRoaXMuX25leHRJbmRleFN0YXJ0O1xuXHRcdFx0b2JqZWN0Lm5leHRWZXJ0ZXhTdGFydCA9IHRoaXMuX25leHRWZXJ0ZXhTdGFydDtcblx0XHRcdG9iamVjdC5nZW9tZXRyeUNvdW50ID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblxuXHRcdFx0b2JqZWN0Lm1heEluc3RhbmNlQ291bnQgPSB0aGlzLl9tYXhJbnN0YW5jZUNvdW50O1xuXHRcdFx0b2JqZWN0Lm1heFZlcnRleENvdW50ID0gdGhpcy5fbWF4VmVydGV4Q291bnQ7XG5cdFx0XHRvYmplY3QubWF4SW5kZXhDb3VudCA9IHRoaXMuX21heEluZGV4Q291bnQ7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeUluaXRpYWxpemVkID0gdGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZDtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpY2VzVGV4dHVyZSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0b2JqZWN0LmluZGlyZWN0VGV4dHVyZSA9IHRoaXMuX2luZGlyZWN0VGV4dHVyZS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0aWYgKCB0aGlzLl9jb2xvcnNUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5jb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmJvdW5kaW5nU3BoZXJlID0ge1xuXHRcdFx0XHRcdGNlbnRlcjogdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRcdHJhZGl1czogdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmJvdW5kaW5nQm94ID0ge1xuXHRcdFx0XHRcdG1pbjogdGhpcy5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLFxuXHRcdFx0XHRcdG1heDogdGhpcy5ib3VuZGluZ0JveC5tYXgudG9BcnJheSgpXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSAmJiB0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uICk7XG5cblx0XHRcdFx0b2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuYW5pbWF0aW9ucyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdGlmICggYW5pbWF0aW9ucy5sZW5ndGggPiAwICkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgM0Qgb2JqZWN0IHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT10cnVlXSAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgZGVzY2VuZGFudHMgb2YgdGhlIDNEIG9iamVjdCBhcmUgYWxzbyBjbG9uZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gM0Qgb2JqZWN0IHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IHNvdXJjZSAtIFRoZSAzRCBvYmplY3QgdG8gY29weS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPXRydWVdIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBkZXNjZW5kYW50cyBvZiB0aGUgM0Qgb2JqZWN0IGFyZSBjbG9uZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgPSB0cnVlICkge1xuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBzb3VyY2UucG9zaXRpb24gKTtcblx0XHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gc291cmNlLnJvdGF0aW9uLm9yZGVyO1xuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGRBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG5cdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IHNvdXJjZS5hbmltYXRpb25zLnNsaWNlKCk7XG5cblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB1cCBkaXJlY3Rpb24gZm9yIG9iamVjdHMsIGFsc28gdXNlZCBhcyB0aGUgZGVmYXVsdFxuICogcG9zaXRpb24gZm9yIHtAbGluayBEaXJlY3Rpb25hbExpZ2h0fSBhbmQge0BsaW5rIEhlbWlzcGhlcmVMaWdodH0uXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge1ZlY3RvcjN9XG4gKiBAZGVmYXVsdCAoMCwxLDApXG4gKi9cbk9iamVjdDNELkRFRkFVTFRfVVAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2V0dGluZyBmb3Ige0BsaW5rIE9iamVjdDNEI21hdHJpeEF1dG9VcGRhdGV9IGZvclxuICogbmV3bHkgY3JlYXRlZCAzRCBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSA9IHRydWU7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2V0dGluZyBmb3Ige0BsaW5rIE9iamVjdDNEI21hdHJpeFdvcmxkQXV0b1VwZGF0ZX0gZm9yXG4gKiBuZXdseSBjcmVhdGVkIDNEIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB0cnVlXG4gKi9cbk9iamVjdDNELkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFID0gdHJ1ZTtcblxuZXhwb3J0IHsgT2JqZWN0M0QgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4vVmVjdG9yNC5qcyc7XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YWMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmJjID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YnAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmNwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdjQwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuY29uc3QgX3Y0MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF92NDIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3I0KCk7XG5cbi8qKlxuICogQSBnZW9tZXRyaWMgdHJpYW5nbGUgYXMgZGVmaW5lZCBieSB0aHJlZSB2ZWN0b3JzIHJlcHJlc2VudGluZyBpdHMgdGhyZWUgY29ybmVycy5cbiAqL1xuY2xhc3MgVHJpYW5nbGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHRyaWFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFthPSgwLDAsMCldIC0gVGhlIGZpcnN0IGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW2I9KDAsMCwwKV0gLSBUaGUgc2Vjb25kIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW2M9KDAsMCwwKV0gLSBUaGUgdGhpcmQgY29ybmVyIG9mIHRoZSB0cmlhbmdsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhID0gbmV3IFZlY3RvcjMoKSwgYiA9IG5ldyBWZWN0b3IzKCksIGMgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZpcnN0IGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHQgKi9cblx0XHR0aGlzLmEgPSBhO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNlY29uZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5iID0gYjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5jID0gYztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBub3JtYWwgdmVjdG9yIG9mIGEgdHJpYW5nbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGIgLSBUaGUgc2Vjb25kIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYyAtIFRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgdHJpYW5nbGUncyBub3JtYWwuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0Tm9ybWFsKCBhLCBiLCBjLCB0YXJnZXQgKSB7XG5cblx0XHR0YXJnZXQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdF92MC5zdWJWZWN0b3JzKCBhLCBiICk7XG5cdFx0dGFyZ2V0LmNyb3NzKCBfdjAgKTtcblxuXHRcdGNvbnN0IHRhcmdldExlbmd0aFNxID0gdGFyZ2V0Lmxlbmd0aFNxKCk7XG5cdFx0aWYgKCB0YXJnZXRMZW5ndGhTcSA+IDAgKSB7XG5cblx0XHRcdHJldHVybiB0YXJnZXQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHRhcmdldExlbmd0aFNxICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCAwLCAwLCAwICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBhIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGZyb20gdGhlIGdpdmVuIHZlY3Rvci5cblx0ICogUmV0dXJucyBgbnVsbGAgaWYgdGhlIHRyaWFuZ2xlIGlzIGRlZ2VuZXJhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBBIHBvaW50IGluIDNEIHNwYWNlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGEgLSBUaGUgZmlyc3QgY29ybmVyIG9mIHRoZSB0cmlhbmdsZS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBiIC0gVGhlIHNlY29uZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGMgLSBUaGUgdGhpcmQgY29ybmVyIG9mIHRoZSB0cmlhbmdsZS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7P1ZlY3RvcjN9IFRoZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIHBvaW50XG5cdCAqL1xuXHRzdGF0aWMgZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblxuXHRcdF92MC5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X3YxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRfdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdGNvbnN0IGRvdDAwID0gX3YwLmRvdCggX3YwICk7XG5cdFx0Y29uc3QgZG90MDEgPSBfdjAuZG90KCBfdjEgKTtcblx0XHRjb25zdCBkb3QwMiA9IF92MC5kb3QoIF92MiApO1xuXHRcdGNvbnN0IGRvdDExID0gX3YxLmRvdCggX3YxICk7XG5cdFx0Y29uc3QgZG90MTIgPSBfdjEuZG90KCBfdjIgKTtcblxuXHRcdGNvbnN0IGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xuXG5cdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcblxuXHRcdFx0dGFyZ2V0LnNldCggMCwgMCwgMCApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHRjb25zdCB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG5cdFx0Y29uc3QgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG5cdFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQsIHdoZW4gcHJvamVjdGVkIG9udG8gdGhlIHBsYW5lIG9mIHRoZVxuXHQgKiB0cmlhbmdsZSwgbGllcyB3aXRoaW4gdGhlIHRyaWFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IGluIDNEIHNwYWNlIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGIgLSBUaGUgc2Vjb25kIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYyAtIFRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCwgd2hlbiBwcm9qZWN0ZWQgb250byB0aGUgcGxhbmUgb2YgdGhlXG5cdCAqIHRyaWFuZ2xlLCBsaWVzIHdpdGhpbiB0aGUgdHJpYW5nbGUgb3Igbm90LlxuXHQgKi9cblx0c3RhdGljIGNvbnRhaW5zUG9pbnQoIHBvaW50LCBhLCBiLCBjICkge1xuXG5cdFx0Ly8gaWYgdGhlIHRyaWFuZ2xlIGlzIGRlZ2VuZXJhdGUgdGhlbiB3ZSBjYW4ndCBjb250YWluIGEgcG9pbnRcblx0XHRpZiAoIHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgX3YzICkgPT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiAoIF92My54ID49IDAgKSAmJiAoIF92My55ID49IDAgKSAmJiAoICggX3YzLnggKyBfdjMueSApIDw9IDEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSB2YWx1ZSBiYXJ5Y2VudHJpY2FsbHkgaW50ZXJwb2xhdGVkIGZvciB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlXG5cdCAqIHRyaWFuZ2xlLiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgdHJpYW5nbGUgaXMgZGVnZW5lcmF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIFBvc2l0aW9uIG9mIGludGVycG9sYXRlZCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwMSAtIFRoZSBmaXJzdCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHAyIC0gVGhlIHNlY29uZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHAzIC0gVGhlIHRoaXJkIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdjEgLSBWYWx1ZSB0byBpbnRlcnBvbGF0ZSBvZiBmaXJzdCB2ZXJ0ZXguXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdjIgLSBWYWx1ZSB0byBpbnRlcnBvbGF0ZSBvZiBzZWNvbmQgdmVydGV4LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYzIC0gVmFsdWUgdG8gaW50ZXJwb2xhdGUgb2YgdGhpcmQgdmVydGV4LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHs/VmVjdG9yM30gVGhlIGludGVycG9sYXRlZCB2YWx1ZS5cblx0ICovXG5cdHN0YXRpYyBnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmdldEJhcnljb29yZCggcG9pbnQsIHAxLCBwMiwgcDMsIF92MyApID09PSBudWxsICkge1xuXG5cdFx0XHR0YXJnZXQueCA9IDA7XG5cdFx0XHR0YXJnZXQueSA9IDA7XG5cdFx0XHRpZiAoICd6JyBpbiB0YXJnZXQgKSB0YXJnZXQueiA9IDA7XG5cdFx0XHRpZiAoICd3JyBpbiB0YXJnZXQgKSB0YXJnZXQudyA9IDA7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5zZXRTY2FsYXIoIDAgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MSwgX3YzLnggKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MiwgX3YzLnkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MywgX3YzLnogKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgdmFsdWUgYmFyeWNlbnRyaWNhbGx5IGludGVycG9sYXRlZCBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZSBhbmQgaW5kaWNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IGF0dHIgLSBUaGUgYXR0cmlidXRlIHRvIGludGVycG9sYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaTEgLSBJbmRleCBvZiBmaXJzdCB2ZXJ0ZXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMiAtIEluZGV4IG9mIHNlY29uZCB2ZXJ0ZXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMyAtIEluZGV4IG9mIHRoaXJkIHZlcnRleC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBiYXJ5Y29vcmQgLSBUaGUgYmFyeWNvb3JkaW5hdGUgdmFsdWUgdG8gdXNlIHRvIGludGVycG9sYXRlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgaW50ZXJwb2xhdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cblx0ICovXG5cdHN0YXRpYyBnZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoIGF0dHIsIGkxLCBpMiwgaTMsIGJhcnljb29yZCwgdGFyZ2V0ICkge1xuXG5cdFx0X3Y0MC5zZXRTY2FsYXIoIDAgKTtcblx0XHRfdjQxLnNldFNjYWxhciggMCApO1xuXHRcdF92NDIuc2V0U2NhbGFyKCAwICk7XG5cblx0XHRfdjQwLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHIsIGkxICk7XG5cdFx0X3Y0MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyLCBpMiApO1xuXHRcdF92NDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0ciwgaTMgKTtcblxuXHRcdHRhcmdldC5zZXRTY2FsYXIoIDAgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBfdjQwLCBiYXJ5Y29vcmQueCApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIF92NDEsIGJhcnljb29yZC55ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggX3Y0MiwgYmFyeWNvb3JkLnogKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHJpYW5nbGUgaXMgb3JpZW50ZWQgdG93YXJkcyB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGEgLSBUaGUgZmlyc3QgY29ybmVyIG9mIHRoZSB0cmlhbmdsZS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBiIC0gVGhlIHNlY29uZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGMgLSBUaGUgdGhpcmQgY29ybmVyIG9mIHRoZSB0cmlhbmdsZS5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBkaXJlY3Rpb24gLSBUaGUgKG5vcm1hbGl6ZWQpIGRpcmVjdGlvbiB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyaWFuZ2xlIGlzIG9yaWVudGVkIHRvd2FyZHMgdGhlIGdpdmVuIGRpcmVjdGlvbiBvciBub3QuXG5cdCAqL1xuXHRzdGF0aWMgaXNGcm9udEZhY2luZyggYSwgYiwgYywgZGlyZWN0aW9uICkge1xuXG5cdFx0X3YwLnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggYSwgYiApO1xuXG5cdFx0Ly8gc3RyaWN0bHkgZnJvbnQgZmFjaW5nXG5cdFx0cmV0dXJuICggX3YwLmNyb3NzKCBfdjEgKS5kb3QoIGRpcmVjdGlvbiApIDwgMCApID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdHJpYW5nbGUncyB2ZXJ0aWNlcyBieSBjb3B5aW5nIHRoZSBnaXZlbiB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYSAtIFRoZSBmaXJzdCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGIgLSBUaGUgc2Vjb25kIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYyAtIFRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtUcmlhbmdsZX0gQSByZWZlcmVuY2UgdG8gdGhpcyB0cmlhbmdsZS5cblx0ICovXG5cdHNldCggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHR0aGlzLmMuY29weSggYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0cmlhbmdsZSdzIHZlcnRpY2VzIGJ5IGNvcHlpbmcgdGhlIGdpdmVuIGFycmF5IHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IzPn0gcG9pbnRzIC0gQW4gYXJyYXkgd2l0aCAzRCBwb2ludHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMCAtIFRoZSBhcnJheSBpbmRleCByZXByZXNlbnRpbmcgdGhlIGZpcnN0IGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMSAtIFRoZSBhcnJheSBpbmRleCByZXByZXNlbnRpbmcgdGhlIHNlY29uZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaTIgLSBUaGUgYXJyYXkgaW5kZXggcmVwcmVzZW50aW5nIHRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtUcmlhbmdsZX0gQSByZWZlcmVuY2UgdG8gdGhpcyB0cmlhbmdsZS5cblx0ICovXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdHJpYW5nbGUncyB2ZXJ0aWNlcyBieSBjb3B5aW5nIHRoZSBnaXZlbiBhdHRyaWJ1dGUgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIC0gQSBidWZmZXIgYXR0cmlidXRlIHdpdGggM0QgcG9pbnRzIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMCAtIFRoZSBhdHRyaWJ1dGUgaW5kZXggcmVwcmVzZW50aW5nIHRoZSBmaXJzdCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaTEgLSBUaGUgYXR0cmlidXRlIGluZGV4IHJlcHJlc2VudGluZyB0aGUgc2Vjb25kIGNvcm5lciBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMiAtIFRoZSBhdHRyaWJ1dGUgaW5kZXggcmVwcmVzZW50aW5nIHRoZSB0aGlyZCBjb3JuZXIgb2YgdGhlIHRyaWFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtUcmlhbmdsZX0gQSByZWZlcmVuY2UgdG8gdGhpcyB0cmlhbmdsZS5cblx0ICovXG5cdHNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKCBhdHRyaWJ1dGUsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMCApO1xuXHRcdHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkxICk7XG5cdFx0dGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB0cmlhbmdsZSB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtUcmlhbmdsZX0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdHJpYW5nbGUgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtUcmlhbmdsZX0gdHJpYW5nbGUgLSBUaGUgdHJpYW5nbGUgdG8gY29weS5cblx0ICogQHJldHVybiB7VHJpYW5nbGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdHJpYW5nbGUuXG5cdCAqL1xuXHRjb3B5KCB0cmlhbmdsZSApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcblx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRyaWFuZ2xlJ3MgYXJlYS5cblx0ICovXG5cdGdldEFyZWEoKSB7XG5cblx0XHRfdjAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuXHRcdHJldHVybiBfdjAuY3Jvc3MoIF92MSApLmxlbmd0aCgpICogMC41O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIG1pZHBvaW50IG9mIHRoZSB0cmlhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIHRyaWFuZ2xlJ3MgbWlkcG9pbnQuXG5cdCAqL1xuXHRnZXRNaWRwb2ludCggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgbm9ybWFsIG9mIHRoZSB0cmlhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIHRyaWFuZ2xlJ3Mgbm9ybWFsLlxuXHQgKi9cblx0Z2V0Tm9ybWFsKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0Tm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIGEgcGxhbmUgdGhlIHRyaWFuZ2xlIGxpZXMgd2l0aGluLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1BsYW5lfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7UGxhbmV9IFRoZSBwbGFuZSB0aGUgdHJpYW5nbGUgbGllcyB3aXRoaW4uXG5cdCAqL1xuXHRnZXRQbGFuZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIGEgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVjdG9yLlxuXHQgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgdHJpYW5nbGUgaXMgZGVnZW5lcmF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBwb2ludCAtIEEgcG9pbnQgaW4gM0Qgc3BhY2UuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4gez9WZWN0b3IzfSBUaGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgZm9yIHRoZSBnaXZlbiBwb2ludFxuXHQgKi9cblx0Z2V0QmFyeWNvb3JkKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIHZhbHVlIGJhcnljZW50cmljYWxseSBpbnRlcnBvbGF0ZWQgZm9yIHRoZSBnaXZlbiBwb2ludCBvbiB0aGVcblx0ICogdHJpYW5nbGUuIFJldHVybnMgYG51bGxgIGlmIHRoZSB0cmlhbmdsZSBpcyBkZWdlbmVyYXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gUG9zaXRpb24gb2YgaW50ZXJwb2xhdGVkIHBvaW50LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYxIC0gVmFsdWUgdG8gaW50ZXJwb2xhdGUgb2YgZmlyc3QgdmVydGV4LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYyIC0gVmFsdWUgdG8gaW50ZXJwb2xhdGUgb2Ygc2Vjb25kIHZlcnRleC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2MyAtIFZhbHVlIHRvIGludGVycG9sYXRlIG9mIHRoaXJkIHZlcnRleC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7P1ZlY3RvcjN9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG5cdCAqL1xuXHRnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB2MSwgdjIsIHYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCwgd2hlbiBwcm9qZWN0ZWQgb250byB0aGUgcGxhbmUgb2YgdGhlXG5cdCAqIHRyaWFuZ2xlLCBsaWVzIHdpdGhpbiB0aGUgdHJpYW5nbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcG9pbnQgaW4gM0Qgc3BhY2UgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQsIHdoZW4gcHJvamVjdGVkIG9udG8gdGhlIHBsYW5lIG9mIHRoZVxuXHQgKiB0cmlhbmdsZSwgbGllcyB3aXRoaW4gdGhlIHRyaWFuZ2xlIG9yIG5vdC5cblx0ICovXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHJpYW5nbGUgaXMgb3JpZW50ZWQgdG93YXJkcyB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGRpcmVjdGlvbiAtIFRoZSAobm9ybWFsaXplZCkgZGlyZWN0aW9uIHZlY3Rvci5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdHJpYW5nbGUgaXMgb3JpZW50ZWQgdG93YXJkcyB0aGUgZ2l2ZW4gZGlyZWN0aW9uIG9yIG5vdC5cblx0ICovXG5cdGlzRnJvbnRGYWNpbmcoIGRpcmVjdGlvbiApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5pc0Zyb250RmFjaW5nKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBkaXJlY3Rpb24gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdHJpYW5nbGUgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byBpbnRlcnNlY3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB0cmlhbmdsZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIGJveCBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgdHJpYW5nbGUgdG8gdGhlIGdpdmVuIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHAgLSBUaGUgcG9pbnQgdG8gY29tcHV0ZSB0aGUgY2xvc2VzdCBwb2ludCBmb3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSB0cmlhbmdsZS5cblx0ICovXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQoIHAsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGEgPSB0aGlzLmEsIGIgPSB0aGlzLmIsIGMgPSB0aGlzLmM7XG5cdFx0bGV0IHYsIHc7XG5cblx0XHQvLyBhbGdvcml0aG0gdGhhbmtzIHRvIFJlYWwtVGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uIGJ5IENocmlzdGVyIEVyaWNzb24sXG5cdFx0Ly8gcHVibGlzaGVkIGJ5IE1vcmdhbiBLYXVmbWFubiBQdWJsaXNoZXJzLCAoYykgMjAwNSBFbHNldmllciBJbmMuLFxuXHRcdC8vIHVuZGVyIHRoZSBhY2NvbXBhbnlpbmcgbGljZW5zZTsgc2VlIGNoYXB0ZXIgNS4xLjUgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuXHRcdC8vIGJhc2ljYWxseSwgd2UncmUgZGlzdGluZ3Vpc2hpbmcgd2hpY2ggb2YgdGhlIHZvcm9ub2kgcmVnaW9ucyBvZiB0aGUgdHJpYW5nbGVcblx0XHQvLyB0aGUgcG9pbnQgbGllcyBpbiB3aXRoIHRoZSBtaW5pbXVtIGFtb3VudCBvZiByZWR1bmRhbnQgY29tcHV0YXRpb24uXG5cblx0XHRfdmFiLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRfdmFjLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRfdmFwLnN1YlZlY3RvcnMoIHAsIGEgKTtcblx0XHRjb25zdCBkMSA9IF92YWIuZG90KCBfdmFwICk7XG5cdFx0Y29uc3QgZDIgPSBfdmFjLmRvdCggX3ZhcCApO1xuXHRcdGlmICggZDEgPD0gMCAmJiBkMiA8PSAwICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEE7IGJhcnljZW50cmljIGNvb3JkcyAoMSwgMCwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApO1xuXG5cdFx0fVxuXG5cdFx0X3ZicC5zdWJWZWN0b3JzKCBwLCBiICk7XG5cdFx0Y29uc3QgZDMgPSBfdmFiLmRvdCggX3ZicCApO1xuXHRcdGNvbnN0IGQ0ID0gX3ZhYy5kb3QoIF92YnAgKTtcblx0XHRpZiAoIGQzID49IDAgJiYgZDQgPD0gZDMgKSB7XG5cblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBiICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YyA9IGQxICogZDQgLSBkMyAqIGQyO1xuXHRcdGlmICggdmMgPD0gMCAmJiBkMSA+PSAwICYmIGQzIDw9IDAgKSB7XG5cblx0XHRcdHYgPSBkMSAvICggZDEgLSBkMyApO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUI7IGJhcnljZW50cmljIGNvb3JkcyAoMS12LCB2LCAwKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFiLCB2ICk7XG5cblx0XHR9XG5cblx0XHRfdmNwLnN1YlZlY3RvcnMoIHAsIGMgKTtcblx0XHRjb25zdCBkNSA9IF92YWIuZG90KCBfdmNwICk7XG5cdFx0Y29uc3QgZDYgPSBfdmFjLmRvdCggX3ZjcCApO1xuXHRcdGlmICggZDYgPj0gMCAmJiBkNSA8PSBkNiApIHtcblxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDAsIDEpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZiID0gZDUgKiBkMiAtIGQxICogZDY7XG5cdFx0aWYgKCB2YiA8PSAwICYmIGQyID49IDAgJiYgZDYgPD0gMCApIHtcblxuXHRcdFx0dyA9IGQyIC8gKCBkMiAtIGQ2ICk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBBQzsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXcsIDAsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKS5hZGRTY2FsZWRWZWN0b3IoIF92YWMsIHcgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZhID0gZDMgKiBkNiAtIGQ1ICogZDQ7XG5cdFx0aWYgKCB2YSA8PSAwICYmICggZDQgLSBkMyApID49IDAgJiYgKCBkNSAtIGQ2ICkgPj0gMCApIHtcblxuXHRcdFx0X3ZiYy5zdWJWZWN0b3JzKCBjLCBiICk7XG5cdFx0XHR3ID0gKCBkNCAtIGQzICkgLyAoICggZDQgLSBkMyApICsgKCBkNSAtIGQ2ICkgKTtcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEJDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDEtdywgdylcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYiApLmFkZFNjYWxlZFZlY3RvciggX3ZiYywgdyApOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQ1xuXG5cdFx0fVxuXG5cdFx0Ly8gZmFjZSByZWdpb25cblx0XHRjb25zdCBkZW5vbSA9IDEgLyAoIHZhICsgdmIgKyB2YyApO1xuXHRcdC8vIHUgPSB2YSAqIGRlbm9tXG5cdFx0diA9IHZiICogZGVub207XG5cdFx0dyA9IHZjICogZGVub207XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKS5hZGRTY2FsZWRWZWN0b3IoIF92YWIsIHYgKS5hZGRTY2FsZWRWZWN0b3IoIF92YWMsIHcgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdHJpYW5nbGUgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RyaWFuZ2xlfSB0cmlhbmdsZSAtIFRoZSB0cmlhbmdsZSB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHRyaWFuZ2xlIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggdHJpYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRyaWFuZ2xlIH07XG4iLCJpbXBvcnQgeyBjbGFtcCwgZXVjbGlkZWFuTW9kdWxvLCBsZXJwIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuaW1wb3J0IHsgQ29sb3JNYW5hZ2VtZW50LCBTUkdCVG9MaW5lYXIsIExpbmVhclRvU1JHQiB9IGZyb20gJy4vQ29sb3JNYW5hZ2VtZW50LmpzJztcbmltcG9ydCB7IFNSR0JDb2xvclNwYWNlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgX2NvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcblx0J2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuXHQnYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXG5cdCdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuXHQnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4Qixcblx0J2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4Rixcblx0J2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcblx0J2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG5cdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxuXHQnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG5cdCdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG5cdCdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXG5cdCdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuXHQnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuXHQnbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXG5cdCdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcblx0J21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG5cdCduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXG5cdCdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuXHQncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWJlY2NhcHVycGxlJzogMHg2NjMzOTksICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuXHQncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcblx0J3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG5cdCdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXG5cdCd2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XG5cbmNvbnN0IF9oc2xBID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XG5jb25zdCBfaHNsQiA9IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5mdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xuXG5cdGlmICggdCA8IDAgKSB0ICs9IDE7XG5cdGlmICggdCA+IDEgKSB0IC09IDE7XG5cdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcblx0aWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcblx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuXHRyZXR1cm4gcDtcblxufVxuXG4vKipcbiAqIEEgQ29sb3IgaW5zdGFuY2UgaXMgcmVwcmVzZW50ZWQgYnkgUkdCIGNvbXBvbmVudHMgaW4gdGhlIGxpbmVhciA8aT53b3JraW5nXG4gKiBjb2xvciBzcGFjZTwvaT4sIHdoaWNoIGRlZmF1bHRzIHRvIGBMaW5lYXJTUkdCQ29sb3JTcGFjZWAuIElucHV0c1xuICogY29udmVudGlvbmFsbHkgdXNpbmcgYFNSR0JDb2xvclNwYWNlYCAoc3VjaCBhcyBoZXhhZGVjaW1hbHMgYW5kIENTU1xuICogc3RyaW5ncykgYXJlIGNvbnZlcnRlZCB0byB0aGUgd29ya2luZyBjb2xvciBzcGFjZSBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjb252ZXJ0ZWQgYXV0b21hdGljYWxseSBmcm9tIFNSR0JDb2xvclNwYWNlIHRvIExpbmVhclNSR0JDb2xvclNwYWNlXG4gKiBjb25zdCBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldEhleCggMHgxMTIyMzMgKTtcbiAqIGBgYFxuICogU291cmNlIGNvbG9yIHNwYWNlcyBtYXkgYmUgc3BlY2lmaWVkIGV4cGxpY2l0bHksIHRvIGVuc3VyZSBjb3JyZWN0IGNvbnZlcnNpb25zLlxuICogYGBganNcbiAqIC8vIGFzc3VtZWQgYWxyZWFkeSBMaW5lYXJTUkdCQ29sb3JTcGFjZTsgbm8gY29udmVyc2lvblxuICogY29uc3QgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIDAuNSwgMC41LCAwLjUgKTtcbiAqXG4gKiAvLyBjb252ZXJ0ZWQgZXhwbGljaXRseSBmcm9tIFNSR0JDb2xvclNwYWNlIHRvIExpbmVhclNSR0JDb2xvclNwYWNlXG4gKiBjb25zdCBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQiggMC41LCAwLjUsIDAuNSwgU1JHQkNvbG9yU3BhY2UgKTtcbiAqIGBgYFxuICogSWYgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGlzIGRpc2FibGVkLCBubyBjb252ZXJzaW9ucyBvY2N1ci4gRm9yIGRldGFpbHMsXG4gKiBzZWUgPGk+Q29sb3IgbWFuYWdlbWVudDwvaT4uIEl0ZXJhdGluZyB0aHJvdWdoIGEgQ29sb3IgaW5zdGFuY2Ugd2lsbCB5aWVsZFxuICogaXRzIGNvbXBvbmVudHMgKHIsIGcsIGIpIGluIHRoZSBjb3JyZXNwb25kaW5nIG9yZGVyLiBBIENvbG9yIGNhbiBiZSBpbml0aWFsaXNlZFxuICogaW4gYW55IG9mIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIGBgYGpzXG4gKiAvL2VtcHR5IGNvbnN0cnVjdG9yIC0gd2lsbCBkZWZhdWx0IHdoaXRlXG4gKiBjb25zdCBjb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAqXG4gKiAvL0hleGFkZWNpbWFsIGNvbG9yIChyZWNvbW1lbmRlZClcbiAqIGNvbnN0IGNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHhmZjAwMDAgKTtcbiAqXG4gKiAvL1JHQiBzdHJpbmdcbiAqIGNvbnN0IGNvbG9yMyA9IG5ldyBUSFJFRS5Db2xvcihcInJnYigyNTUsIDAsIDApXCIpO1xuICogY29uc3QgY29sb3I0ID0gbmV3IFRIUkVFLkNvbG9yKFwicmdiKDEwMCUsIDAlLCAwJSlcIik7XG4gKlxuICogLy9YMTEgY29sb3IgbmFtZSAtIGFsbCAxNDAgY29sb3IgbmFtZXMgYXJlIHN1cHBvcnRlZC5cbiAqIC8vTm90ZSB0aGUgbGFjayBvZiBDYW1lbENhc2UgaW4gdGhlIG5hbWVcbiAqIGNvbnN0IGNvbG9yNSA9IG5ldyBUSFJFRS5Db2xvciggJ3NreWJsdWUnICk7XG4gKiAvL0hTTCBzdHJpbmdcbiAqIGNvbnN0IGNvbG9yNiA9IG5ldyBUSFJFRS5Db2xvcihcImhzbCgwLCAxMDAlLCA1MCUpXCIpO1xuICpcbiAqIC8vU2VwYXJhdGUgUkdCIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDFcbiAqIGNvbnN0IGNvbG9yNyA9IG5ldyBUSFJFRS5Db2xvciggMSwgMCwgMCApO1xuICogYGBgXG4gKi9cbmNsYXNzIENvbG9yIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb2xvci5cblx0ICpcblx0ICogTm90ZSB0aGF0IHN0YW5kYXJkIG1ldGhvZCBvZiBzcGVjaWZ5aW5nIGNvbG9yIGluIHRocmVlLmpzIGlzIHdpdGggYSBoZXhhZGVjaW1hbCB0cmlwbGV0LFxuXHQgKiBhbmQgdGhhdCBtZXRob2QgaXMgdXNlZCB0aHJvdWdob3V0IHRoZSByZXN0IG9mIHRoZSBkb2N1bWVudGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfENvbG9yKX0gW3JdIC0gVGhlIHJlZCBjb21wb25lbnQgb2YgdGhlIGNvbG9yLiBJZiBgZ2AgYW5kIGBiYCBhcmVcblx0ICogbm90IHByb3ZpZGVkLCBpdCBjYW4gYmUgaGV4YWRlY2ltYWwgdHJpcGxldCwgYSBDU1Mtc3R5bGUgc3RyaW5nIG9yIGFub3RoZXIgYENvbG9yYCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtnXSAtIFRoZSBncmVlbiBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYl0gLSBUaGUgYmx1ZSBjb21wb25lbnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggciwgZywgYiApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNDb2xvciA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVkIGNvbXBvbmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuciA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZ3JlZW4gY29tcG9uZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5nID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBibHVlIGNvbXBvbmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYiA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHIsIGcsIGIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbG9ycydzIGNvbXBvbmVudHMgZnJvbSB0aGUgZ2l2ZW4gdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfENvbG9yKX0gW3JdIC0gVGhlIHJlZCBjb21wb25lbnQgb2YgdGhlIGNvbG9yLiBJZiBgZ2AgYW5kIGBiYCBhcmVcblx0ICogbm90IHByb3ZpZGVkLCBpdCBjYW4gYmUgaGV4YWRlY2ltYWwgdHJpcGxldCwgYSBDU1Mtc3R5bGUgc3RyaW5nIG9yIGFub3RoZXIgYENvbG9yYCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtnXSAtIFRoZSBncmVlbiBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYl0gLSBUaGUgYmx1ZSBjb21wb25lbnQuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0c2V0KCByLCBnLCBiICkge1xuXG5cdFx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyByIGlzIFRIUkVFLkNvbG9yLCBoZXggb3Igc3RyaW5nXG5cblx0XHRcdGNvbnN0IHZhbHVlID0gcjtcblxuXHRcdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHR0aGlzLnNldEhleCggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNldFJHQiggciwgZywgYiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xvcnMncyBjb21wb25lbnRzIHRvIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5yID0gc2NhbGFyO1xuXHRcdHRoaXMuZyA9IHNjYWxhcjtcblx0XHR0aGlzLmIgPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBjb2xvciBmcm9tIGEgaGV4YWRlY2ltYWwgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZXggLSBUaGUgaGV4YWRlY2ltYWwgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1TUkdCQ29sb3JTcGFjZV0gLSBUaGUgY29sb3Igc3BhY2UuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0c2V0SGV4KCBoZXgsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG5cdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuXHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKCB0aGlzLCBjb2xvclNwYWNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBjb2xvciBmcm9tIFJHQiB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByIC0gUmVkIGNoYW5uZWwgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBnIC0gR3JlZW4gY2hhbm5lbCB2YWx1ZSBiZXR3ZWVuIGAwLjBgIGFuZCBgMS4wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGIgLSBCbHVlIGNoYW5uZWwgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1Db2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdHNldFJHQiggciwgZywgYiwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UoIHRoaXMsIGNvbG9yU3BhY2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGlzIGNvbG9yIGZyb20gUkdCIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGggLSBIdWUgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gU2F0dXJhdGlvbiB2YWx1ZSBiZXR3ZWVuIGAwLjBgIGFuZCBgMS4wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGwgLSBMaWdodG5lc3MgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1Db2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdHNldEhTTCggaCwgcywgbCwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcblxuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cdFx0aCA9IGV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xuXHRcdHMgPSBjbGFtcCggcywgMCwgMSApO1xuXHRcdGwgPSBjbGFtcCggbCwgMCwgMSApO1xuXG5cdFx0aWYgKCBzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuXHRcdFx0Y29uc3QgcSA9ICggMiAqIGwgKSAtIHA7XG5cblx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuXHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xuXHRcdFx0dGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XG5cblx0XHR9XG5cblx0XHRDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSggdGhpcywgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSBhIENTUy1zdHlsZSBzdHJpbmcuIEZvciBleGFtcGxlLCBgcmdiKDI1MCwgMCwwKWAsXG5cdCAqIGByZ2IoMTAwJSwgMCUsIDAlKWAsIGBoc2woMCwgMTAwJSwgNTAlKWAsIGAjZmYwMDAwYCwgYCNmMDBgLCBvciBgcmVkYCAoIG9yXG5cdCAqIGFueSBbWDExIGNvbG9yIG5hbWVde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1gxMV9jb2xvcl9uYW1lcyNDb2xvcl9uYW1lX2NoYXJ0fSAtXG5cdCAqIGFsbCAxNDAgY29sb3IgbmFtZXMgYXJlIHN1cHBvcnRlZCkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtIENvbG9yIGFzIGEgQ1NTLXN0eWxlIHN0cmluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvclNwYWNlPVNSR0JDb2xvclNwYWNlXSAtIFRoZSBjb2xvciBzcGFjZS5cblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRzZXRTdHlsZSggc3R5bGUsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XG5cblx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGxldCBtO1xuXG5cdFx0aWYgKCBtID0gL14oXFx3KylcXCgoW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XG5cblx0XHRcdC8vIHJnYiAvIGhzbFxuXG5cdFx0XHRsZXQgY29sb3I7XG5cdFx0XHRjb25zdCBuYW1lID0gbVsgMSBdO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuXHRcdFx0c3dpdGNoICggbmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdyZ2InOlxuXHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NSxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXlxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMCxcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHRcdGNhc2UgJ2hzbGEnOlxuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eXFxzKihcXGQqXFwuP1xcZCspXFxzKixcXHMqKFxcZCpcXC4/XFxkKylcXCVcXHMqLFxccyooXFxkKlxcLj9cXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDQgXSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MCxcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggY29sb3JbIDIgXSApIC8gMTAwLFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBjb2xvclsgMyBdICkgLyAxMDAsXG5cdFx0XHRcdFx0XHRcdGNvbG9yU3BhY2Vcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgbW9kZWwgJyArIHN0eWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0Ly8gaGV4IGNvbG9yXG5cblx0XHRcdGNvbnN0IGhleCA9IG1bIDEgXTtcblx0XHRcdGNvbnN0IHNpemUgPSBoZXgubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDE1LFxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAxICksIDE2ICkgLyAxNSxcblx0XHRcdFx0XHRwYXJzZUludCggaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMTUsXG5cdFx0XHRcdFx0Y29sb3JTcGFjZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG5cdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SGV4KCBwYXJzZUludCggaGV4LCAxNiApLCBjb2xvclNwYWNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUoIHN0eWxlLCBjb2xvclNwYWNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBjb2xvciBmcm9tIGEgY29sb3IgbmFtZS4gRmFzdGVyIHRoYW4ge0BsaW5rIENvbG9yI3NldFN0eWxlfSBpZlxuXHQgKiB5b3UgZG9uJ3QgbmVlZCB0aGUgb3RoZXIgQ1NTLXN0eWxlIGZvcm1hdHMuXG5cdCAqXG5cdCAqIEZvciBjb252ZW5pZW5jZSwgdGhlIGxpc3Qgb2YgbmFtZXMgaXMgZXhwb3NlZCBpbiBgQ29sb3IuTkFNRVNgIGFzIGEgaGFzaC5cblx0ICogYGBganNcblx0ICogQ29sb3IuTkFNRVMuYWxpY2VibHVlIC8vIHJldHVybnMgMHhGMEY4RkZcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtIFRoZSBjb2xvciBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yU3BhY2U9U1JHQkNvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdHNldENvbG9yTmFtZSggc3R5bGUsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdC8vIGNvbG9yIGtleXdvcmRzXG5cdFx0Y29uc3QgaGV4ID0gX2NvbG9yS2V5d29yZHNbIHN0eWxlLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIHJlZFxuXHRcdFx0dGhpcy5zZXRIZXgoIGhleCwgY29sb3JTcGFjZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gdW5rbm93biBjb2xvclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7Q29sb3J9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gY29sb3IgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgY29sb3IgdG8gY29weS5cblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRjb3B5KCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIGdpdmVuIGNvbG9yIGludG8gdGhpcyBjb2xvciwgYW5kIHRoZW4gY29udmVydHMgdGhpcyBjb2xvciBmcm9tXG5cdCAqIGBTUkdCQ29sb3JTcGFjZWAgdG8gYExpbmVhclNSR0JDb2xvclNwYWNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgY29sb3IgdG8gY29weS9jb252ZXJ0LlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdGNvcHlTUkdCVG9MaW5lYXIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gU1JHQlRvTGluZWFyKCBjb2xvci5yICk7XG5cdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XG5cdFx0dGhpcy5iID0gU1JHQlRvTGluZWFyKCBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgZ2l2ZW4gY29sb3IgaW50byB0aGlzIGNvbG9yLCBhbmQgdGhlbiBjb252ZXJ0cyB0aGlzIGNvbG9yIGZyb21cblx0ICogYExpbmVhclNSR0JDb2xvclNwYWNlYCB0byBgU1JHQkNvbG9yU3BhY2VgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjb2xvciAtIFRoZSBjb2xvciB0byBjb3B5L2NvbnZlcnQuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0Y29weUxpbmVhclRvU1JHQiggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmcgKTtcblx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhpcyBjb2xvciBmcm9tIGBTUkdCQ29sb3JTcGFjZWAgdG8gYExpbmVhclNSR0JDb2xvclNwYWNlYC5cblx0ICpcblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuXG5cdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoaXMgY29sb3IgZnJvbSBgTGluZWFyU1JHQkNvbG9yU3BhY2VgIHRvIGBTUkdCQ29sb3JTcGFjZWAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblxuXHRcdHRoaXMuY29weUxpbmVhclRvU1JHQiggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiB0aGlzIGNvbG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yU3BhY2U9U1JHQkNvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZXhhZGVjaW1hbCB2YWx1ZS5cblx0ICovXG5cdGdldEhleCggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGNsYW1wKCBfY29sb3IuciAqIDI1NSwgMCwgMjU1ICkgKSAqIDY1NTM2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5nICogMjU1LCAwLCAyNTUgKSApICogMjU2ICsgTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5iICogMjU1LCAwLCAyNTUgKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgb2YgdGhpcyBjb2xvciBhcyBhIHN0cmluZyAoZm9yIGV4YW1wbGUsICdGRkZGRkYnKS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvclNwYWNlPVNSR0JDb2xvclNwYWNlXSAtIFRoZSBjb2xvciBzcGFjZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWwgdmFsdWUgYXMgYSBzdHJpbmcuXG5cdCAqL1xuXHRnZXRIZXhTdHJpbmcoIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoIGNvbG9yU3BhY2UgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBjb2xvcnMgUkdCIHZhbHVlcyBpbnRvIHRoZSBIU0wgZm9ybWF0IGFuZCBzdG9yZXMgdGhlbSBpbnRvIHRoZVxuXHQgKiBnaXZlbiB0YXJnZXQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3toOm51bWJlcixzOm51bWJlcixsOm51bWJlcn19IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yU3BhY2U9Q29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlXSAtIFRoZSBjb2xvciBzcGFjZS5cblx0ICogQHJldHVybiB7e2g6bnVtYmVyLHM6bnVtYmVyLGw6bnVtYmVyfX0gVGhlIEhTTCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yLlxuXHQgKi9cblx0Z2V0SFNMKCB0YXJnZXQsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xuXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcblxuXHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG5cdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdGxldCBodWUsIHNhdHVyYXRpb247XG5cdFx0Y29uc3QgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuXHRcdGlmICggbWluID09PSBtYXggKSB7XG5cblx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuXG5cdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cblx0XHRcdHN3aXRjaCAoIG1heCApIHtcblxuXHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRodWUgLz0gNjtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5oID0gaHVlO1xuXHRcdHRhcmdldC5zID0gc2F0dXJhdGlvbjtcblx0XHR0YXJnZXQubCA9IGxpZ2h0bmVzcztcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBSR0IgdmFsdWVzIG9mIHRoaXMgY29sb3IgYW5kIHN0b3JlcyB0aGVtIGludG8gdGhlIGdpdmVuIHRhcmdldCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29sb3J9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29sb3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1Db2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gVGhlIFJHQiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yLlxuXHQgKi9cblx0Z2V0UkdCKCB0YXJnZXQsIGNvbG9yU3BhY2UgPSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XG5cblx0XHRDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKCBfY29sb3IuY29weSggdGhpcyApLCBjb2xvclNwYWNlICk7XG5cblx0XHR0YXJnZXQuciA9IF9jb2xvci5yO1xuXHRcdHRhcmdldC5nID0gX2NvbG9yLmc7XG5cdFx0dGFyZ2V0LmIgPSBfY29sb3IuYjtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGNvbG9yIGFzIGEgQ1NTIHN0eWxlIHN0cmluZy4gRXhhbXBsZTogYHJnYigyNTUsMCwwKWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1TUkdCQ29sb3JTcGFjZV0gLSBUaGUgY29sb3Igc3BhY2UuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIENTUyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yLlxuXHQgKi9cblx0Z2V0U3R5bGUoIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcblxuXHRcdENvbG9yTWFuYWdlbWVudC5mcm9tV29ya2luZ0NvbG9yU3BhY2UoIF9jb2xvci5jb3B5KCB0aGlzICksIGNvbG9yU3BhY2UgKTtcblxuXHRcdGNvbnN0IHIgPSBfY29sb3IuciwgZyA9IF9jb2xvci5nLCBiID0gX2NvbG9yLmI7XG5cblx0XHRpZiAoIGNvbG9yU3BhY2UgIT09IFNSR0JDb2xvclNwYWNlICkge1xuXG5cdFx0XHQvLyBSZXF1aXJlcyBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8pLlxuXHRcdFx0cmV0dXJuIGBjb2xvcigkeyBjb2xvclNwYWNlIH0gJHsgci50b0ZpeGVkKCAzICkgfSAkeyBnLnRvRml4ZWQoIDMgKSB9ICR7IGIudG9GaXhlZCggMyApIH0pYDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBgcmdiKCR7IE1hdGgucm91bmQoIHIgKiAyNTUgKSB9LCR7IE1hdGgucm91bmQoIGcgKiAyNTUgKSB9LCR7IE1hdGgucm91bmQoIGIgKiAyNTUgKSB9KWA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBIU0wgdmFsdWVzIHRvIHRoaXMgY29sb3IncyB2YWx1ZXMuXG5cdCAqIEludGVybmFsbHksIHRoaXMgY29udmVydHMgdGhlIGNvbG9yJ3MgUkdCIHZhbHVlcyB0byBIU0wsIGFkZHMgSFNMXG5cdCAqIGFuZCB0aGVuIGNvbnZlcnRzIHRoZSBjb2xvciBiYWNrIHRvIFJHQi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGggLSBIdWUgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gU2F0dXJhdGlvbiB2YWx1ZSBiZXR3ZWVuIGAwLjBgIGFuZCBgMS4wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGwgLSBMaWdodG5lc3MgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0b2Zmc2V0SFNMKCBoLCBzLCBsICkge1xuXG5cdFx0dGhpcy5nZXRIU0woIF9oc2xBICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIF9oc2xBLmggKyBoLCBfaHNsQS5zICsgcywgX2hzbEEubCArIGwgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIFJHQiB2YWx1ZXMgb2YgdGhlIGdpdmVuIGNvbG9yIHRvIHRoZSBSR0IgdmFsdWVzIG9mIHRoaXMgY29sb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIC0gVGhlIGNvbG9yIHRvIGFkZC5cblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRhZGQoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICs9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICs9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIFJHQiB2YWx1ZXMgb2YgdGhlIGdpdmVuIGNvbG9ycyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IxIC0gVGhlIGZpcnN0IGNvbG9yLlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjb2xvcjIgLSBUaGUgc2Vjb25kIGNvbG9yLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdGFkZENvbG9ycyggY29sb3IxLCBjb2xvcjIgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHZhbHVlIHRvIHRoZSBSR0IgdmFsdWVzIG9mIHRoaXMgY29sb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBhZGQuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy5yICs9IHM7XG5cdFx0dGhpcy5nICs9IHM7XG5cdFx0dGhpcy5iICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0cyB0aGUgUkdCIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gY29sb3IgZnJvbSB0aGUgUkdCIHZhbHVlcyBvZiB0aGlzIGNvbG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjb2xvciAtIFRoZSBjb2xvciB0byBzdWJ0cmFjdC5cblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRzdWIoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIFJHQiB2YWx1ZXMgb2YgdGhlIGdpdmVuIGNvbG9yIHdpdGggdGhlIFJHQiB2YWx1ZXMgb2YgdGhpcyBjb2xvci5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgY29sb3IgdG8gbXVsdGlwbHkuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0bXVsdGlwbHkoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIHNjYWxhciB2YWx1ZSB3aXRoIHRoZSBSR0IgdmFsdWVzIG9mIHRoaXMgY29sb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBtdWx0aXBseS5cblx0ICogQHJldHVybiB7Q29sb3J9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXG5cdCAqL1xuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdHRoaXMuciAqPSBzO1xuXHRcdHRoaXMuZyAqPSBzO1xuXHRcdHRoaXMuYiAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhpcyBjb2xvcidzIFJHQiB2YWx1ZXMgdG93YXJkIHRoZSBSR0IgdmFsdWVzIG9mIHRoZVxuXHQgKiBnaXZlbiBjb2xvci4gVGhlIGFscGhhIGFyZ3VtZW50IGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByYXRpbyBiZXR3ZWVuXG5cdCAqIHRoZSB0d28gY29sb3JzLCB3aGVyZSBgMC4wYCBpcyB0aGlzIGNvbG9yIGFuZCBgMS4wYCBpcyB0aGUgZmlyc3QgYXJndW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIC0gVGhlIGNvbG9yIHRvIGNvbnZlcmdlIG9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsMV1gLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdGxlcnAoIGNvbG9yLCBhbHBoYSApIHtcblxuXHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuXHRcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gY29sb3JzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBUaGUgYWxwaGEgYXJndW1lbnQgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIHR3byBjb2xvcnMsIHdoZXJlIGAwLjBgXG5cdCAqIGlzIHRoZSBmaXJzdCBhbmQgYDEuMGAgaXMgdGhlIHNlY29uZCBjb2xvci5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IxIC0gVGhlIGZpcnN0IGNvbG9yLlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjb2xvcjIgLSBUaGUgc2Vjb25kIGNvbG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsMV1gLlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdGxlcnBDb2xvcnMoIGNvbG9yMSwgY29sb3IyLCBhbHBoYSApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yMS5yICsgKCBjb2xvcjIuciAtIGNvbG9yMS5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArICggY29sb3IyLmcgLSBjb2xvcjEuZyApICogYWxwaGE7XG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyAoIGNvbG9yMi5iIC0gY29sb3IxLmIgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhpcyBjb2xvcidzIEhTTCB2YWx1ZXMgdG93YXJkIHRoZSBIU0wgdmFsdWVzIG9mIHRoZVxuXHQgKiBnaXZlbiBjb2xvci4gSXQgZGlmZmVycyBmcm9tIHtAbGluayBDb2xvciNsZXJwfSBieSBub3QgaW50ZXJwb2xhdGluZyBzdHJhaWdodFxuXHQgKiBmcm9tIG9uZSBjb2xvciB0byB0aGUgb3RoZXIsIGJ1dCBpbnN0ZWFkIGdvaW5nIHRocm91Z2ggYWxsIHRoZSBodWVzIGluIGJldHdlZW5cblx0ICogdGhvc2UgdHdvIGNvbG9ycy4gVGhlIGFscGhhIGFyZ3VtZW50IGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByYXRpbyBiZXR3ZWVuXG5cdCAqIHRoZSB0d28gY29sb3JzLCB3aGVyZSAwLjAgaXMgdGhpcyBjb2xvciBhbmQgMS4wIGlzIHRoZSBmaXJzdCBhcmd1bWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgY29sb3IgdG8gY29udmVyZ2Ugb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwxXWAuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0bGVycEhTTCggY29sb3IsIGFscGhhICkge1xuXG5cdFx0dGhpcy5nZXRIU0woIF9oc2xBICk7XG5cdFx0Y29sb3IuZ2V0SFNMKCBfaHNsQiApO1xuXG5cdFx0Y29uc3QgaCA9IGxlcnAoIF9oc2xBLmgsIF9oc2xCLmgsIGFscGhhICk7XG5cdFx0Y29uc3QgcyA9IGxlcnAoIF9oc2xBLnMsIF9oc2xCLnMsIGFscGhhICk7XG5cdFx0Y29uc3QgbCA9IGxlcnAoIF9oc2xBLmwsIF9oc2xCLmwsIGFscGhhICk7XG5cblx0XHR0aGlzLnNldEhTTCggaCwgcywgbCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xvcidzIFJHQiBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIDNEIHZlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XG5cblx0XHR0aGlzLnIgPSB2Lng7XG5cdFx0dGhpcy5nID0gdi55O1xuXHRcdHRoaXMuYiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGlzIGNvbG9yIHdpdGggdGhlIGdpdmVuIDN4MyBtYXRyaXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4M30gbSAtIFRoZSBtYXRyaXguXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuciA9IGVbIDAgXSAqIHIgKyBlWyAzIF0gKiBnICsgZVsgNiBdICogYjtcblx0XHR0aGlzLmcgPSBlWyAxIF0gKiByICsgZVsgNCBdICogZyArIGVbIDcgXSAqIGI7XG5cdFx0dGhpcy5iID0gZVsgMiBdICogciArIGVbIDUgXSAqIGcgKyBlWyA4IF0gKiBiO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGNvbG9yIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtDb2xvcn0gYyAtIFRoZSBjb2xvciB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGJvdW5kaW5nIGNvbG9yIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggYyApIHtcblxuXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBjb2xvcidzIFJHQiBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFycmF5IC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgUkdCIHZhbHVlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBUaGUgb2Zmc2V0IGludG8gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtDb2xvcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cblx0ICovXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnIgPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgdGhlIFJHQiBjb21wb25lbnRzIG9mIHRoaXMgY29sb3IgdG8gdGhlIGdpdmVuIGFycmF5LiBJZiBubyBhcnJheSBpcyBwcm92aWRlZCxcblx0ICogdGhlIG1ldGhvZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5IGhvbGRpbmcgdGhlIGNvbG9yIGNvbXBvbmVudHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgY29sb3IgY29tcG9uZW50cy5cblx0ICovXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLnI7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIGNvbG9yIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGUgLSBUaGUgYnVmZmVyIGF0dHJpYnV0ZSBob2xkaW5nIGNvbG9yIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBhdHRyaWJ1dGUuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxuXHQgKi9cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuciA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMuZyA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuYiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZHMgZGVmaW5lcyB0aGUgc2VyaWFsaXphdGlvbiByZXN1bHQgb2YgdGhpcyBjbGFzcy4gUmV0dXJucyB0aGUgY29sb3Jcblx0ICogYXMgYSBoZXhhZGVjaW1hbCB2YWx1ZS5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGV4YWRlY2ltYWwgdmFsdWUuXG5cdCAqL1xuXHR0b0pTT04oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLnI7XG5cdFx0eWllbGQgdGhpcy5nO1xuXHRcdHlpZWxkIHRoaXMuYjtcblxuXHR9XG5cbn1cblxuY29uc3QgX2NvbG9yID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcblxuLyoqXG4gKiBBIGRpY3Rpb25hcnkgd2l0aCBYMTEgY29sb3IgbmFtZXMuXG4gKlxuICogTm90ZSB0aGF0IG11bHRpcGxlIHdvcmRzIHN1Y2ggYXMgRGFyayBPcmFuZ2UgYmVjb21lIHRoZSBzdHJpbmcgJ2RhcmtvcmFuZ2UnLlxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbG9yLk5BTUVTID0gX2NvbG9yS2V5d29yZHM7XG5cbmV4cG9ydCB7IENvbG9yIH07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vY29yZS9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgRnJvbnRTaWRlLCBOb3JtYWxCbGVuZGluZywgTGVzc0VxdWFsRGVwdGgsIEFkZEVxdWF0aW9uLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBTcmNBbHBoYUZhY3RvciwgQWx3YXlzU3RlbmNpbEZ1bmMsIEtlZXBTdGVuY2lsT3AgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVVVUlEIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG5sZXQgX21hdGVyaWFsSWQgPSAwO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIG1hdGVyaWFscy5cbiAqXG4gKiBNYXRlcmlhbHMgZGVmaW5lIHRoZSBhcHBlYXJhbmNlIG9mIHJlbmRlcmFibGUgM0Qgb2JqZWN0cy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyBFdmVudERpc3BhdGNoZXJcbiAqL1xuY2xhc3MgTWF0ZXJpYWwgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hdGVyaWFsLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAbmFtZSBNYXRlcmlhbCNpZFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfbWF0ZXJpYWxJZCArKyB9ICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgVVVJRCBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIHByb3BlcnR5IGlzIHVzZWQgZm9yIGRldGVjdGluZyB0aGUgb2JqZWN0IHR5cGVcblx0XHQgKiBpbiBjb250ZXh0IG9mIHNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgYmxlbmRpbmcgdHlwZSBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBJdCBtdXN0IGJlIHNldCB0byBgQ3VzdG9tQmxlbmRpbmdgIGlmIGN1c3RvbSBibGVuZGluZyBwcm9wZXJ0aWVzIGxpa2Vcblx0XHQgKiB7QGxpbmsgTWF0ZXJpYWwjYmxlbmRTcmN9LCB7QGxpbmsgTWF0ZXJpYWwjYmxlbmREc3R9IG9yIHtAbGluayBNYXRlcmlhbCNibGVuZEVxdWF0aW9ufVxuXHRcdCAqIHNob3VsZCBoYXZlIGFueSBlZmZlY3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5vQmxlbmRpbmd8Tm9ybWFsQmxlbmRpbmd8QWRkaXRpdmVCbGVuZGluZ3xTdWJ0cmFjdGl2ZUJsZW5kaW5nfE11bHRpcGx5QmxlbmRpbmd8Q3VzdG9tQmxlbmRpbmcpfVxuXHRcdCAqIEBkZWZhdWx0IE5vcm1hbEJsZW5kaW5nXG5cdFx0ICovXG5cdFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB3aGljaCBzaWRlIG9mIGZhY2VzIHdpbGwgYmUgcmVuZGVyZWQgLSBmcm9udCwgYmFjayBvciBib3RoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhGcm9udFNpZGV8QmFja1NpZGV8RG91YmxlU2lkZSl9XG5cdFx0ICogQGRlZmF1bHQgRnJvbnRTaWRlXG5cdFx0ICovXG5cdFx0dGhpcy5zaWRlID0gRnJvbnRTaWRlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdmVydGV4IGNvbG9ycyBzaG91bGQgYmUgdXNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBlbmdpbmUgc3VwcG9ydHMgUkdCIGFuZCBSR0JBIHZlcnRleCBjb2xvcnMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSB0aHJlZSAoUkdCKSBvclxuXHRcdCAqIGZvdXIgKFJHQkEpIGNvbXBvbmVudCBjb2xvciBidWZmZXIgYXR0cmlidXRlIGlzIHVzZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGhvdyB0cmFuc3BhcmVudCB0aGUgbWF0ZXJpYWwgaXMuXG5cdFx0ICogQSB2YWx1ZSBvZiBgMC4wYCBpbmRpY2F0ZXMgZnVsbHkgdHJhbnNwYXJlbnQsIGAxLjBgIGlzIGZ1bGx5IG9wYXF1ZS5cblx0XHQgKlxuXHRcdCAqIElmIHRoZSB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IGlzIG5vdCBzZXQgdG8gYHRydWVgLFxuXHRcdCAqIHRoZSBtYXRlcmlhbCB3aWxsIHJlbWFpbiBmdWxseSBvcGFxdWUgYW5kIHRoaXMgdmFsdWUgd2lsbCBvbmx5IGFmZmVjdCBpdHMgY29sb3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLm9wYWNpdHkgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgbWF0ZXJpYWwgaXMgdHJhbnNwYXJlbnQuIFRoaXMgaGFzIGFuIGVmZmVjdCBvblxuXHRcdCAqIHJlbmRlcmluZyBhcyB0cmFuc3BhcmVudCBvYmplY3RzIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGFyZSByZW5kZXJlZFxuXHRcdCAqIGFmdGVyIG5vbi10cmFuc3BhcmVudCBvYmplY3RzLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIGV4dGVudCB0byB3aGljaCB0aGUgbWF0ZXJpYWwgaXMgdHJhbnNwYXJlbnQgaXNcblx0XHQgKiBjb250cm9sbGVkIGJ5IHtAbGluayBNYXRlcmlhbCNvcGFjaXR5fS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlcyBhbHBoYSBoYXNoZWQgdHJhbnNwYXJlbmN5LCBhbiBhbHRlcm5hdGl2ZSB0byB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yXG5cdFx0ICoge0BsaW5rIE1hdGVyaWFsI2FscGhhVGVzdH0uIFRoZSBtYXRlcmlhbCB3aWxsIG5vdCBiZSByZW5kZXJlZCBpZiBvcGFjaXR5IGlzIGxvd2VyIHRoYW5cblx0XHQgKiBhIHJhbmRvbSB0aHJlc2hvbGQuIFJhbmRvbWl6YXRpb24gaW50cm9kdWNlcyBzb21lIGdyYWluIG9yIG5vaXNlLCBidXQgYXBwcm94aW1hdGVzIGFscGhhXG5cdFx0ICogYmxlbmRpbmcgd2l0aG91dCB0aGUgYXNzb2NpYXRlZCBwcm9ibGVtcyBvZiBzb3J0aW5nLiBVc2luZyBUQUEgY2FuIHJlZHVjZSB0aGUgcmVzdWx0aW5nIG5vaXNlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhSGFzaCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgYmxlbmRpbmcgc291cmNlIGZhY3Rvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoWmVyb0ZhY3RvcnxPbmVGYWN0b3J8U3JjQ29sb3JGYWN0b3J8T25lTWludXNTcmNDb2xvckZhY3RvcnxTcmNBbHBoYUZhY3RvcnxPbmVNaW51c1NyY0FscGhhRmFjdG9yfERzdEFscGhhRmFjdG9yfE9uZU1pbnVzRHN0QWxwaGFGYWN0b3J8RHN0Q29sb3JGYWN0b3J8T25lTWludXNEc3RDb2xvckZhY3RvcnxTcmNBbHBoYVNhdHVyYXRlRmFjdG9yfENvbnN0YW50Q29sb3JGYWN0b3J8T25lTWludXNDb25zdGFudENvbG9yRmFjdG9yfENvbnN0YW50QWxwaGFGYWN0b3J8T25lTWludXNDb25zdGFudEFscGhhRmFjdG9yKX1cblx0XHQgKiBAZGVmYXVsdCBTcmNBbHBoYUZhY3RvclxuXHRcdCAqL1xuXHRcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3Rvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoWmVyb0ZhY3RvcnxPbmVGYWN0b3J8U3JjQ29sb3JGYWN0b3J8T25lTWludXNTcmNDb2xvckZhY3RvcnxTcmNBbHBoYUZhY3RvcnxPbmVNaW51c1NyY0FscGhhRmFjdG9yfERzdEFscGhhRmFjdG9yfE9uZU1pbnVzRHN0QWxwaGFGYWN0b3J8RHN0Q29sb3JGYWN0b3J8T25lTWludXNEc3RDb2xvckZhY3RvcnxTcmNBbHBoYVNhdHVyYXRlRmFjdG9yfENvbnN0YW50Q29sb3JGYWN0b3J8T25lTWludXNDb25zdGFudENvbG9yRmFjdG9yfENvbnN0YW50QWxwaGFGYWN0b3J8T25lTWludXNDb25zdGFudEFscGhhRmFjdG9yKX1cblx0XHQgKiBAZGVmYXVsdCBPbmVNaW51c1NyY0FscGhhRmFjdG9yXG5cdFx0ICovXG5cdFx0dGhpcy5ibGVuZERzdCA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIHRoZSBibGVuZGluZyBlcXVhdGlvbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoQWRkRXF1YXRpb258U3VidHJhY3RFcXVhdGlvbnxSZXZlcnNlU3VidHJhY3RFcXVhdGlvbnxNaW5FcXVhdGlvbnxNYXhFcXVhdGlvbil9XG5cdFx0ICogQGRlZmF1bHQgQWRkRXF1YXRpb25cblx0XHQgKi9cblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGJsZW5kaW5nIHNvdXJjZSBhbHBoYSBmYWN0b3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7PyhaZXJvRmFjdG9yfE9uZUZhY3RvcnxTcmNDb2xvckZhY3RvcnxPbmVNaW51c1NyY0NvbG9yRmFjdG9yfFNyY0FscGhhRmFjdG9yfE9uZU1pbnVzU3JjQWxwaGFGYWN0b3J8RHN0QWxwaGFGYWN0b3J8T25lTWludXNEc3RBbHBoYUZhY3RvcnxEc3RDb2xvckZhY3RvcnxPbmVNaW51c0RzdENvbG9yRmFjdG9yfFNyY0FscGhhU2F0dXJhdGVGYWN0b3J8Q29uc3RhbnRDb2xvckZhY3RvcnxPbmVNaW51c0NvbnN0YW50Q29sb3JGYWN0b3J8Q29uc3RhbnRBbHBoYUZhY3RvcnxPbmVNaW51c0NvbnN0YW50QWxwaGFGYWN0b3IpfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgYmxlbmRpbmcgZGVzdGluYXRpb24gYWxwaGEgZmFjdG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez8oWmVyb0ZhY3RvcnxPbmVGYWN0b3J8U3JjQ29sb3JGYWN0b3J8T25lTWludXNTcmNDb2xvckZhY3RvcnxTcmNBbHBoYUZhY3RvcnxPbmVNaW51c1NyY0FscGhhRmFjdG9yfERzdEFscGhhRmFjdG9yfE9uZU1pbnVzRHN0QWxwaGFGYWN0b3J8RHN0Q29sb3JGYWN0b3J8T25lTWludXNEc3RDb2xvckZhY3RvcnxTcmNBbHBoYVNhdHVyYXRlRmFjdG9yfENvbnN0YW50Q29sb3JGYWN0b3J8T25lTWludXNDb25zdGFudENvbG9yRmFjdG9yfENvbnN0YW50QWxwaGFGYWN0b3J8T25lTWludXNDb25zdGFudEFscGhhRmFjdG9yKX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGJsZW5kaW5nIGVxdWF0aW9uIG9mIHRoZSBhbHBoYSBjaGFubmVsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez8oQWRkRXF1YXRpb258U3VidHJhY3RFcXVhdGlvbnxSZXZlcnNlU3VidHJhY3RFcXVhdGlvbnxNaW5FcXVhdGlvbnxNYXhFcXVhdGlvbil9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlcHJlc2VudHMgdGhlIFJHQiB2YWx1ZXMgb2YgdGhlIGNvbnN0YW50IGJsZW5kIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBoYXMgb25seSBhbiBlZmZlY3Qgd2hlbiB1c2luZyBjdXN0b20gYmxlbmRpbmcgd2l0aCBgQ29uc3RhbnRDb2xvcmAgb3IgYE9uZU1pbnVzQ29uc3RhbnRDb2xvcmAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCwwKVxuXHRcdCAqL1xuXHRcdHRoaXMuYmxlbmRDb2xvciA9IG5ldyBDb2xvciggMCwgMCwgMCApO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVwcmVzZW50cyB0aGUgYWxwaGEgdmFsdWUgb2YgdGhlIGNvbnN0YW50IGJsZW5kIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBoYXMgb25seSBhbiBlZmZlY3Qgd2hlbiB1c2luZyBjdXN0b20gYmxlbmRpbmcgd2l0aCBgQ29uc3RhbnRBbHBoYWAgb3IgYE9uZU1pbnVzQ29uc3RhbnRBbHBoYWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmJsZW5kQWxwaGEgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgZGVwdGggZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5ldmVyRGVwdGh8QWx3YXlzRGVwdGh8TGVzc0RlcHRofExlc3NFcXVhbERlcHRofEVxdWFsRGVwdGh8R3JlYXRlckVxdWFsRGVwdGh8R3JlYXRlckRlcHRofE5vdEVxdWFsRGVwdGgpfVxuXHRcdCAqIEBkZWZhdWx0IExlc3NFcXVhbERlcHRoXG5cdFx0ICovXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gaGF2ZSBkZXB0aCB0ZXN0IGVuYWJsZWQgd2hlbiByZW5kZXJpbmcgdGhpcyBtYXRlcmlhbC5cblx0XHQgKiBXaGVuIHRoZSBkZXB0aCB0ZXN0IGlzIGRpc2FibGVkLCB0aGUgZGVwdGggd3JpdGUgd2lsbCBhbHNvIGJlIGltcGxpY2l0bHkgZGlzYWJsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciByZW5kZXJpbmcgdGhpcyBtYXRlcmlhbCBoYXMgYW55IGVmZmVjdCBvbiB0aGUgZGVwdGggYnVmZmVyLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBkcmF3aW5nIDJEIG92ZXJsYXlzIGl0IGNhbiBiZSB1c2VmdWwgdG8gZGlzYWJsZSB0aGUgZGVwdGggd3JpdGluZyBpblxuXHRcdCAqIG9yZGVyIHRvIGxheWVyIHNldmVyYWwgdGhpbmdzIHRvZ2V0aGVyIHdpdGhvdXQgY3JlYXRpbmcgei1pbmRleCBhcnRpZmFjdHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBiaXQgbWFzayB0byB1c2Ugd2hlbiB3cml0aW5nIHRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMHhmZlxuXHRcdCAqL1xuXHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3RlbmNpbCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtOZXZlclN0ZW5jaWxGdW5jfExlc3NTdGVuY2lsRnVuY3xFcXVhbFN0ZW5jaWxGdW5jfExlc3NFcXVhbFN0ZW5jaWxGdW5jfEdyZWF0ZXJTdGVuY2lsRnVuY3xOb3RFcXVhbFN0ZW5jaWxGdW5jfEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jfEFsd2F5c1N0ZW5jaWxGdW5jfVxuXHRcdCAqIEBkZWZhdWx0IEFsd2F5c1N0ZW5jaWxGdW5jXG5cdFx0ICovXG5cdFx0dGhpcy5zdGVuY2lsRnVuYyA9IEFsd2F5c1N0ZW5jaWxGdW5jO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZhbHVlIHRvIHVzZSB3aGVuIHBlcmZvcm1pbmcgc3RlbmNpbCBjb21wYXJpc29ucyBvciBzdGVuY2lsIG9wZXJhdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnN0ZW5jaWxSZWYgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJpdCBtYXNrIHRvIHVzZSB3aGVuIGNvbXBhcmluZyBhZ2FpbnN0IHRoZSBzdGVuY2lsIGJ1ZmZlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMHhmZlxuXHRcdCAqL1xuXHRcdHRoaXMuc3RlbmNpbEZ1bmNNYXNrID0gMHhmZjtcblxuXHRcdC8qKlxuXHRcdCAqIFdoaWNoIHN0ZW5jaWwgb3BlcmF0aW9uIHRvIHBlcmZvcm0gd2hlbiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7WmVyb1N0ZW5jaWxPcHxLZWVwU3RlbmNpbE9wfFJlcGxhY2VTdGVuY2lsT3B8SW5jcmVtZW50U3RlbmNpbE9wfERlY3JlbWVudFN0ZW5jaWxPcHxJbmNyZW1lbnRXcmFwU3RlbmNpbE9wfERlY3JlbWVudFdyYXBTdGVuY2lsT3B8SW52ZXJ0U3RlbmNpbE9wfVxuXHRcdCAqIEBkZWZhdWx0IEtlZXBTdGVuY2lsT3Bcblx0XHQgKi9cblx0XHR0aGlzLnN0ZW5jaWxGYWlsID0gS2VlcFN0ZW5jaWxPcDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoaWNoIHN0ZW5jaWwgb3BlcmF0aW9uIHRvIHBlcmZvcm0gd2hlbiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiByZXR1cm5zXG5cdFx0ICogYHRydWVgIGJ1dCB0aGUgZGVwdGggdGVzdCBmYWlscy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtaZXJvU3RlbmNpbE9wfEtlZXBTdGVuY2lsT3B8UmVwbGFjZVN0ZW5jaWxPcHxJbmNyZW1lbnRTdGVuY2lsT3B8RGVjcmVtZW50U3RlbmNpbE9wfEluY3JlbWVudFdyYXBTdGVuY2lsT3B8RGVjcmVtZW50V3JhcFN0ZW5jaWxPcHxJbnZlcnRTdGVuY2lsT3B9XG5cdFx0ICogQGRlZmF1bHQgS2VlcFN0ZW5jaWxPcFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RlbmNpbFpGYWlsID0gS2VlcFN0ZW5jaWxPcDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoaWNoIHN0ZW5jaWwgb3BlcmF0aW9uIHRvIHBlcmZvcm0gd2hlbiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiByZXR1cm5zXG5cdFx0ICogYHRydWVgIGFuZCB0aGUgZGVwdGggdGVzdCBwYXNzZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7WmVyb1N0ZW5jaWxPcHxLZWVwU3RlbmNpbE9wfFJlcGxhY2VTdGVuY2lsT3B8SW5jcmVtZW50U3RlbmNpbE9wfERlY3JlbWVudFN0ZW5jaWxPcHxJbmNyZW1lbnRXcmFwU3RlbmNpbE9wfERlY3JlbWVudFdyYXBTdGVuY2lsT3B8SW52ZXJ0U3RlbmNpbE9wfVxuXHRcdCAqIEBkZWZhdWx0IEtlZXBTdGVuY2lsT3Bcblx0XHQgKi9cblx0XHR0aGlzLnN0ZW5jaWxaUGFzcyA9IEtlZXBTdGVuY2lsT3A7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHN0ZW5jaWwgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIHN0ZW5jaWwgYnVmZmVyLiBJblxuXHRcdCAqIG9yZGVyIHRvIHBlcmZvcm0gd3JpdGVzIG9yIGNvbXBhcmlzb25zIGFnYWluc3QgdGhlIHN0ZW5jaWwgYnVmZmVyIHRoaXNcblx0XHQgKiB2YWx1ZSBtdXN0IGJlIGB0cnVlYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXMgc3BlY2lmaWVkIGFzIFRIUkVFLlBsYW5lIG9iamVjdHMgaW4gd29ybGRcblx0XHQgKiBzcGFjZS4gVGhlc2UgcGxhbmVzIGFwcGx5IHRvIHRoZSBvYmplY3RzIHRoaXMgbWF0ZXJpYWwgaXMgYXR0YWNoZWQgdG8uXG5cdFx0ICogUG9pbnRzIGluIHNwYWNlIHdob3NlIHNpZ25lZCBkaXN0YW5jZSB0byB0aGUgcGxhbmUgaXMgbmVnYXRpdmUgYXJlIGNsaXBwZWRcblx0XHQgKiAobm90IHJlbmRlcmVkKS4gVGhpcyByZXF1aXJlcyB7QGxpbmsgV2ViR0xSZW5kZXJlciNsb2NhbENsaXBwaW5nRW5hYmxlZH0gdG9cblx0XHQgKiBiZSBgdHJ1ZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0FycmF5PFBsYW5lPn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBDaGFuZ2VzIHRoZSBiZWhhdmlvciBvZiBjbGlwcGluZyBwbGFuZXMgc28gdGhhdCBvbmx5IHRoZWlyIGludGVyc2VjdGlvbiBpc1xuXHRcdCAqIGNsaXBwZWQsIHJhdGhlciB0aGFuIHRoZWlyIHVuaW9uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgd2hldGhlciB0byBjbGlwIHNoYWRvd3MgYWNjb3JkaW5nIHRvIHRoZSBjbGlwcGluZyBwbGFuZXMgc3BlY2lmaWVkXG5cdFx0ICogb24gdGhpcyBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB3aGljaCBzaWRlIG9mIGZhY2VzIGNhc3Qgc2hhZG93cy4gSWYgYG51bGxgLCB0aGUgc2lkZSBjYXN0aW5nIHNoYWRvd3Ncblx0XHQgKiBpcyBkZXRlcm1pbmVkIGFzIGZvbGxvd3M6XG5cdFx0ICpcblx0XHQgKiAtIFdoZW4ge0BsaW5rIE1hdGVyaWFsI3NpZGV9IGlzIHNldCB0byBgRnJvbnRTaWRlYCwgdGhlIGJhY2sgc2lkZSBjYXN0IHNoYWRvd3MuXG5cdFx0ICogLSBXaGVuIHtAbGluayBNYXRlcmlhbCNzaWRlfSBpcyBzZXQgdG8gYEJhY2tTaWRlYCwgdGhlIGZyb250IHNpZGUgY2FzdCBzaGFkb3dzLlxuXHRcdCAqIC0gV2hlbiB7QGxpbmsgTWF0ZXJpYWwjc2lkZX0gaXMgc2V0IHRvIGBEb3VibGVTaWRlYCwgYm90aCBzaWRlcyBjYXN0IHNoYWRvd3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7PyhGcm9udFNpZGV8QmFja1NpZGV8RG91YmxlU2lkZSl9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc2hhZG93U2lkZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIHJlbmRlciB0aGUgbWF0ZXJpYWwncyBjb2xvci5cblx0XHQgKlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgT2JqZWN0M0QjcmVuZGVyT2Rlcn0gdG8gY3JlYXRlIGludmlzaWJsZVxuXHRcdCAqIG9iamVjdHMgdGhhdCBvY2NsdWRlIG90aGVyIG9iamVjdHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez8oJ2hpZ2hwJ3wnbWVkaXVtcCd8J2xvd3AnKX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byB1c2UgcG9seWdvbiBvZmZzZXQgb3Igbm90LiBXaGVuIGVuYWJsZWQsIGVhY2ggZnJhZ21lbnQncyBkZXB0aCB2YWx1ZSB3aWxsXG5cdFx0ICogYmUgb2Zmc2V0IGFmdGVyIGl0IGlzIGludGVycG9sYXRlZCBmcm9tIHRoZSBkZXB0aCB2YWx1ZXMgb2YgdGhlIGFwcHJvcHJpYXRlIHZlcnRpY2VzLlxuXHRcdCAqIFRoZSBvZmZzZXQgaXMgYWRkZWQgYmVmb3JlIHRoZSBkZXB0aCB0ZXN0IGlzIHBlcmZvcm1lZCBhbmQgYmVmb3JlIHRoZSB2YWx1ZSBpcyB3cml0dGVuXG5cdFx0ICogaW50byB0aGUgZGVwdGggYnVmZmVyLlxuXHRcdCAqXG5cdFx0ICogQ2FuIGJlIHVzZWZ1bCBmb3IgcmVuZGVyaW5nIGhpZGRlbi1saW5lIGltYWdlcywgZm9yIGFwcGx5aW5nIGRlY2FscyB0byBzdXJmYWNlcywgYW5kIGZvclxuXHRcdCAqIHJlbmRlcmluZyBzb2xpZHMgd2l0aCBoaWdobGlnaHRlZCBlZGdlcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgYSBzY2FsZSBmYWN0b3IgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHZhcmlhYmxlIGRlcHRoIG9mZnNldCBmb3IgZWFjaCBwb2x5Z29uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIElzIG11bHRpcGxpZWQgYnkgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgdmFsdWUgdG8gY3JlYXRlIGEgY29uc3RhbnQgZGVwdGggb2Zmc2V0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBhcHBseSBkaXRoZXJpbmcgdG8gdGhlIGNvbG9yIHRvIHJlbW92ZSB0aGUgYXBwZWFyYW5jZSBvZiBiYW5kaW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmRpdGhlcmluZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhbHBoYSB0byBjb3ZlcmFnZSBzaG91bGQgYmUgZW5hYmxlZCBvciBub3QuIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBNU0FBLWVuYWJsZWQgY29udGV4dHNcblx0XHQgKiAobWVhbmluZyB3aGVuIHRoZSByZW5kZXJlciB3YXMgY3JlYXRlZCB3aXRoICphbnRpYWxpYXMqIHBhcmFtZXRlciBzZXQgdG8gYHRydWVgKS4gRW5hYmxpbmcgdGhpc1xuXHRcdCAqIHdpbGwgc21vb3RoIGFsaWFzaW5nIG9uIGNsaXAgcGxhbmUgZWRnZXMgYW5kIGFscGhhVGVzdC1jbGlwcGVkIGVkZ2VzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBwcmVtdWx0aXBseSB0aGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIGRvdWJsZS1zaWRlZCwgdHJhbnNwYXJlbnQgb2JqZWN0cyBzaG91bGQgYmUgcmVuZGVyZWQgd2l0aCBhIHNpbmdsZSBwYXNzIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFRoZSBlbmdpbmUgcmVuZGVycyBkb3VibGUtc2lkZWQsIHRyYW5zcGFyZW50IG9iamVjdHMgd2l0aCB0d28gZHJhdyBjYWxscyAoYmFjayBmYWNlcyBmaXJzdCxcblx0XHQgKiB0aGVuIGZyb250IGZhY2VzKSB0byBtaXRpZ2F0ZSB0cmFuc3BhcmVuY3kgYXJ0aWZhY3RzLiBUaGVyZSBhcmUgc2NlbmFyaW9zIGhvd2V2ZXIgd2hlcmUgdGhpc1xuXHRcdCAqIGFwcHJvYWNoIHByb2R1Y2VzIG5vIHF1YWxpdHkgZ2FpbnMgYnV0IHN0aWxsIGRvdWJsZXMgZHJhdyBjYWxscyBlLmcuIHdoZW4gcmVuZGVyaW5nIGZsYXRcblx0XHQgKiB2ZWdldGF0aW9uIGxpa2UgZ3Jhc3Mgc3ByaXRlcy4gSW4gdGhlc2UgY2FzZXMsIHNldCB0aGUgYGZvcmNlU2luZ2xlUGFzc2AgZmxhZyB0byBgdHJ1ZWAgdG9cblx0XHQgKiBkaXNhYmxlIHRoZSB0d28gcGFzcyByZW5kZXJpbmcgdG8gYXZvaWQgcGVyZm9ybWFuY2UgaXNzdWVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBpdCdzIHBvc3NpYmxlIHRvIG92ZXJyaWRlIHRoZSBtYXRlcmlhbCB3aXRoIHtAbGluayBTY2VuZSNvdmVycmlkZU1hdGVyaWFsfSBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hbGxvd092ZXJyaWRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgd2hldGhlciAzRCBvYmplY3RzIHVzaW5nIHRoaXMgbWF0ZXJpYWwgYXJlIHZpc2libGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgd2hldGhlciB0aGlzIG1hdGVyaWFsIGlzIHRvbmUgbWFwcGVkIGFjY29yZGluZyB0byB0aGUgcmVuZGVyZXIncyB0b25lIG1hcHBpbmcgc2V0dGluZy5cblx0XHQgKlxuXHRcdCAqIEl0IGlzIGlnbm9yZWQgd2hlbiByZW5kZXJpbmcgdG8gYSByZW5kZXIgdGFyZ2V0IG9yIHVzaW5nIHBvc3QgcHJvY2Vzc2luZyBvciB3aGVuIHVzaW5nXG5cdFx0ICogYFdlYkdQVVJlbmRlcmVyYC4gSW4gYWxsIHRoZXNlIGNhc2VzLCBhbGwgbWF0ZXJpYWxzIGFyZSBob25vcmVkIGJ5IHRvbmUgbWFwcGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLnRvbmVNYXBwZWQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgY3VzdG9tIGRhdGEgYWJvdXQgdGhlIE1hdGVyaWFsLiBJdFxuXHRcdCAqIHNob3VsZCBub3QgaG9sZCByZWZlcmVuY2VzIHRvIGZ1bmN0aW9ucyBhcyB0aGVzZSB3aWxsIG5vdCBiZSBjbG9uZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3RhcnRzIGF0IGAwYCBhbmQgY291bnRzIGhvdyBtYW55IHRpbWVzIHtAbGluayBNYXRlcmlhbCNuZWVkc1VwZGF0ZX0gaXMgc2V0IHRvIGB0cnVlYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0XHR0aGlzLl9hbHBoYVRlc3QgPSAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgYWxwaGEgdmFsdWUgdG8gYmUgdXNlZCB3aGVuIHJ1bm5pbmcgYW4gYWxwaGEgdGVzdC4gVGhlIG1hdGVyaWFsXG5cdCAqIHdpbGwgbm90IGJlIHJlbmRlcmVkIGlmIHRoZSBvcGFjaXR5IGlzIGxvd2VyIHRoYW4gdGhpcyB2YWx1ZS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdGdldCBhbHBoYVRlc3QoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fYWxwaGFUZXN0O1xuXG5cdH1cblxuXHRzZXQgYWxwaGFUZXN0KCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fYWxwaGFUZXN0ID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hbHBoYVRlc3QgPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBtYXRlcmlhbCBpcyB1c2VkIHRvIHJlbmRlciBhIDNEIG9iamVjdC5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHJlbmRlcmluZyB3aXRoIHtAbGluayBXZWJHTFJlbmRlcmVyfS5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cblx0ICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUuXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIHNjZW5lLlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeSAtIFRoZSAzRCBvYmplY3QncyBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIDNEIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGdyb3VwIC0gVGhlIGdlb21ldHJ5IGdyb3VwIGRhdGEuXG5cdCAqL1xuXHRvbkJlZm9yZVJlbmRlciggLyogcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBvYmplY3QsIGdyb3VwICovICkge31cblxuXHQvKipcblx0ICogQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHNoYWRlclxuXHQgKiBwcm9ncmFtIGlzIGNvbXBpbGVkLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzaGFkZXIgc291cmNlIGNvZGVcblx0ICogYXMgYSBwYXJhbWV0ZXIuIFVzZWZ1bCBmb3IgdGhlIG1vZGlmaWNhdGlvbiBvZiBidWlsdC1pbiBtYXRlcmlhbHMuXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgd2l0aCB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uIFRoZVxuXHQgKiByZWNvbW1lbmRlZCBhcHByb2FjaCB3aGVuIGN1c3RvbWl6aW5nIG1hdGVyaWFscyBpcyB0byB1c2UgYFdlYkdQVVJlbmRlcmVyYCB3aXRoIHRoZSBuZXdcblx0ICogTm9kZSBNYXRlcmlhbCBzeXN0ZW0gYW5kIFtUU0xde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvd2lraS9UaHJlZS5qcy1TaGFkaW5nLUxhbmd1YWdlfS5cblx0ICpcblx0ICogQHBhcmFtIHt7dmVydGV4U2hhZGVyOnN0cmluZyxmcmFnbWVudFNoYWRlcjpzdHJpbmcsdW5pZm9ybXM6T2JqZWN0fX0gc2hhZGVyb2JqZWN0IC0gVGhlIG9iamVjdCBob2xkcyB0aGUgdW5pZm9ybXMgYW5kIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG5cdCAqL1xuXHRvbkJlZm9yZUNvbXBpbGUoIC8qIHNoYWRlcm9iamVjdCwgcmVuZGVyZXIgKi8gKSB7fVxuXG5cdC8qKlxuXHQgKiBJbiBjYXNlIHtAbGluayBNYXRlcmlhbCNvbkJlZm9yZUNvbXBpbGV9IGlzIHVzZWQsIHRoaXMgY2FsbGJhY2sgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnlcblx0ICogdmFsdWVzIG9mIHNldHRpbmdzIHVzZWQgaW4gYG9uQmVmb3JlQ29tcGlsZSgpYCwgc28gdGhyZWUuanMgY2FuIHJldXNlIGEgY2FjaGVkXG5cdCAqIHNoYWRlciBvciByZWNvbXBpbGUgdGhlIHNoYWRlciBmb3IgdGhpcyBtYXRlcmlhbCBhcyBuZWVkZWQuXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgd2l0aCB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGN1c3RvbSBwcm9ncmFtIGNhY2hlIGtleS5cblx0ICovXG5cdGN1c3RvbVByb2dyYW1DYWNoZUtleSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm9uQmVmb3JlQ29tcGlsZS50b1N0cmluZygpO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gc2V0IGRlZmF1bHQgdmFsdWVzIGZyb20gcGFyYW1ldGVyIG9iamVjdHMuXG5cdCAqIEl0IGlzIGEgZ2VuZXJpYyBpbXBsZW1lbnRhdGlvbiBzbyBpdCBjYW4gYmUgdXNlZCB3aXRoIGRpZmZlcmVudCB0eXBlc1xuXHQgKiBvZiBtYXRlcmlhbHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzXSAtIFRoZSBtYXRlcmlhbCB2YWx1ZXMgdG8gc2V0LlxuXHQgKi9cblx0c2V0VmFsdWVzKCB2YWx1ZXMgKSB7XG5cblx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0Y29uc3QgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBgVEhSRUUuTWF0ZXJpYWw6IHBhcmFtZXRlciAnJHsga2V5IH0nIGhhcyB2YWx1ZSBvZiB1bmRlZmluZWQuYCApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5NYXRlcmlhbDogJyR7IGtleSB9JyBpcyBub3QgYSBwcm9wZXJ0eSBvZiBUSFJFRS4keyB0aGlzLnR5cGUgfS5gICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgKSAmJiAoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMyApICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIG1hdGVyaWFsIGludG8gSlNPTi5cblx0ICpcblx0ICogQHBhcmFtIHs/KE9iamVjdHxzdHJpbmcpfSBtZXRhIC0gQW4gb3B0aW9uYWwgdmFsdWUgaG9sZGluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJpYWxpemF0aW9uLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIG1hdGVyaWFsLlxuXHQgKiBAc2VlIHtAbGluayBPYmplY3RMb2FkZXIjcGFyc2V9XG5cdCAqL1xuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge31cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICYmIHRoaXMuY29sb3IuaXNDb2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG5cdFx0aWYgKCB0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcztcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXG5cdFx0aWYgKCB0aGlzLnNoZWVuICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoZWVuID0gdGhpcy5zaGVlbjtcblx0XHRpZiAoIHRoaXMuc2hlZW5Db2xvciAmJiB0aGlzLnNoZWVuQ29sb3IuaXNDb2xvciApIGRhdGEuc2hlZW5Db2xvciA9IHRoaXMuc2hlZW5Db2xvci5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuc2hlZW5Sb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hlZW5Sb3VnaG5lc3MgPSB0aGlzLnNoZWVuUm91Z2huZXNzO1xuXHRcdGlmICggdGhpcy5lbWlzc2l2ZSAmJiB0aGlzLmVtaXNzaXZlLmlzQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSAxICkgZGF0YS5lbWlzc2l2ZUludGVuc2l0eSA9IHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFySW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLnNwZWN1bGFySW50ZW5zaXR5ID0gdGhpcy5zcGVjdWxhckludGVuc2l0eTtcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJDb2xvciAmJiB0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvciApIGRhdGEuc3BlY3VsYXJDb2xvciA9IHRoaXMuc3BlY3VsYXJDb2xvci5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJjb2F0ID0gdGhpcy5jbGVhcmNvYXQ7XG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhcmNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzcztcblxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXRNYXAgJiYgdGhpcy5jbGVhcmNvYXRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmNsZWFyY29hdE1hcCA9IHRoaXMuY2xlYXJjb2F0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwICYmIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCAmJiB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsTWFwID0gdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSB0aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXNwZXJzaW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLmRpc3BlcnNpb24gPSB0aGlzLmRpc3BlcnNpb247XG5cblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEuaXJpZGVzY2VuY2UgPSB0aGlzLmlyaWRlc2NlbmNlO1xuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZUlPUiAhPT0gdW5kZWZpbmVkICkgZGF0YS5pcmlkZXNjZW5jZUlPUiA9IHRoaXMuaXJpZGVzY2VuY2VJT1I7XG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCApIGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZTtcblxuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZU1hcCAmJiB0aGlzLmlyaWRlc2NlbmNlTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5pcmlkZXNjZW5jZU1hcCA9IHRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCAmJiB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSBkYXRhLmFuaXNvdHJvcHkgPSB0aGlzLmFuaXNvdHJvcHk7XG5cdFx0aWYgKCB0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5hbmlzb3Ryb3B5Um90YXRpb24gPSB0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbjtcblxuXHRcdGlmICggdGhpcy5hbmlzb3Ryb3B5TWFwICYmIHRoaXMuYW5pc290cm9weU1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuYW5pc290cm9weU1hcCA9IHRoaXMuYW5pc290cm9weU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hcCAmJiB0aGlzLm1hcC5pc1RleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLm1hdGNhcCAmJiB0aGlzLm1hdGNhcC5pc1RleHR1cmUgKSBkYXRhLm1hdGNhcCA9IHRoaXMubWF0Y2FwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdGlmICggdGhpcy5saWdodE1hcCAmJiB0aGlzLmxpZ2h0TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEubGlnaHRNYXBJbnRlbnNpdHkgPSB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmFvTWFwICYmIHRoaXMuYW9NYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmFvTWFwID0gdGhpcy5hb01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5hb01hcEludGVuc2l0eSA9IHRoaXMuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsTWFwICYmIHRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5ub3JtYWxNYXBUeXBlID0gdGhpcy5ub3JtYWxNYXBUeXBlO1xuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwICYmIHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAuaXNUZXh0dXJlICkgZGF0YS5zcGVjdWxhckludGVuc2l0eU1hcCA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJDb2xvck1hcCAmJiB0aGlzLnNwZWN1bGFyQ29sb3JNYXAuaXNUZXh0dXJlICkgZGF0YS5zcGVjdWxhckNvbG9yTWFwID0gdGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRpZiAoIHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0XHRpZiAoIHRoaXMuY29tYmluZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmVudk1hcFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLmVudk1hcFJvdGF0aW9uID0gdGhpcy5lbnZNYXBSb3RhdGlvbi50b0FycmF5KCk7XG5cdFx0aWYgKCB0aGlzLmVudk1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5lbnZNYXBJbnRlbnNpdHkgPSB0aGlzLmVudk1hcEludGVuc2l0eTtcblx0XHRpZiAoIHRoaXMucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuXHRcdGlmICggdGhpcy5yZWZyYWN0aW9uUmF0aW8gIT09IHVuZGVmaW5lZCApIGRhdGEucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHRpZiAoIHRoaXMuZ3JhZGllbnRNYXAgJiYgdGhpcy5ncmFkaWVudE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuZ3JhZGllbnRNYXAgPSB0aGlzLmdyYWRpZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnRyYW5zbWlzc2lvbiA9IHRoaXMudHJhbnNtaXNzaW9uO1xuXHRcdGlmICggdGhpcy50cmFuc21pc3Npb25NYXAgJiYgdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlICkgZGF0YS50cmFuc21pc3Npb25NYXAgPSB0aGlzLnRyYW5zbWlzc2lvbk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy50aGlja25lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEudGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG5cdFx0aWYgKCB0aGlzLnRoaWNrbmVzc01hcCAmJiB0aGlzLnRoaWNrbmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnRoaWNrbmVzc01hcCA9IHRoaXMudGhpY2tuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0aWYgKCB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IEluZmluaXR5ICkgZGF0YS5hdHRlbnVhdGlvbkRpc3RhbmNlID0gdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdGlmICggdGhpcy5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLmF0dGVudWF0aW9uQ29sb3IgPSB0aGlzLmF0dGVudWF0aW9uQ29sb3IuZ2V0SGV4KCk7XG5cblx0XHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuXHRcdGlmICggdGhpcy5zaGFkb3dTaWRlICE9PSBudWxsICkgZGF0YS5zaGFkb3dTaWRlID0gdGhpcy5zaGFkb3dTaWRlO1xuXHRcdGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cblx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IE5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0aWYgKCB0aGlzLnNpZGUgIT09IEZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcblx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzID09PSB0cnVlICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0aWYgKCB0aGlzLmJsZW5kU3JjICE9PSBTcmNBbHBoYUZhY3RvciApIGRhdGEuYmxlbmRTcmMgPSB0aGlzLmJsZW5kU3JjO1xuXHRcdGlmICggdGhpcy5ibGVuZERzdCAhPT0gT25lTWludXNTcmNBbHBoYUZhY3RvciApIGRhdGEuYmxlbmREc3QgPSB0aGlzLmJsZW5kRHN0O1xuXHRcdGlmICggdGhpcy5ibGVuZEVxdWF0aW9uICE9PSBBZGRFcXVhdGlvbiApIGRhdGEuYmxlbmRFcXVhdGlvbiA9IHRoaXMuYmxlbmRFcXVhdGlvbjtcblx0XHRpZiAoIHRoaXMuYmxlbmRTcmNBbHBoYSAhPT0gbnVsbCApIGRhdGEuYmxlbmRTcmNBbHBoYSA9IHRoaXMuYmxlbmRTcmNBbHBoYTtcblx0XHRpZiAoIHRoaXMuYmxlbmREc3RBbHBoYSAhPT0gbnVsbCApIGRhdGEuYmxlbmREc3RBbHBoYSA9IHRoaXMuYmxlbmREc3RBbHBoYTtcblx0XHRpZiAoIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhICE9PSBudWxsICkgZGF0YS5ibGVuZEVxdWF0aW9uQWxwaGEgPSB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYTtcblx0XHRpZiAoIHRoaXMuYmxlbmRDb2xvciAmJiB0aGlzLmJsZW5kQ29sb3IuaXNDb2xvciApIGRhdGEuYmxlbmRDb2xvciA9IHRoaXMuYmxlbmRDb2xvci5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuYmxlbmRBbHBoYSAhPT0gMCApIGRhdGEuYmxlbmRBbHBoYSA9IHRoaXMuYmxlbmRBbHBoYTtcblxuXHRcdGlmICggdGhpcy5kZXB0aEZ1bmMgIT09IExlc3NFcXVhbERlcHRoICkgZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcblx0XHRpZiAoIHRoaXMuZGVwdGhUZXN0ID09PSBmYWxzZSApIGRhdGEuZGVwdGhUZXN0ID0gdGhpcy5kZXB0aFRlc3Q7XG5cdFx0aWYgKCB0aGlzLmRlcHRoV3JpdGUgPT09IGZhbHNlICkgZGF0YS5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xuXHRcdGlmICggdGhpcy5jb2xvcldyaXRlID09PSBmYWxzZSApIGRhdGEuY29sb3JXcml0ZSA9IHRoaXMuY29sb3JXcml0ZTtcblxuXHRcdGlmICggdGhpcy5zdGVuY2lsV3JpdGVNYXNrICE9PSAweGZmICkgZGF0YS5zdGVuY2lsV3JpdGVNYXNrID0gdGhpcy5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdGlmICggdGhpcy5zdGVuY2lsRnVuYyAhPT0gQWx3YXlzU3RlbmNpbEZ1bmMgKSBkYXRhLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYztcblx0XHRpZiAoIHRoaXMuc3RlbmNpbFJlZiAhPT0gMCApIGRhdGEuc3RlbmNpbFJlZiA9IHRoaXMuc3RlbmNpbFJlZjtcblx0XHRpZiAoIHRoaXMuc3RlbmNpbEZ1bmNNYXNrICE9PSAweGZmICkgZGF0YS5zdGVuY2lsRnVuY01hc2sgPSB0aGlzLnN0ZW5jaWxGdW5jTWFzaztcblx0XHRpZiAoIHRoaXMuc3RlbmNpbEZhaWwgIT09IEtlZXBTdGVuY2lsT3AgKSBkYXRhLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbDtcblx0XHRpZiAoIHRoaXMuc3RlbmNpbFpGYWlsICE9PSBLZWVwU3RlbmNpbE9wICkgZGF0YS5zdGVuY2lsWkZhaWwgPSB0aGlzLnN0ZW5jaWxaRmFpbDtcblx0XHRpZiAoIHRoaXMuc3RlbmNpbFpQYXNzICE9PSBLZWVwU3RlbmNpbE9wICkgZGF0YS5zdGVuY2lsWlBhc3MgPSB0aGlzLnN0ZW5jaWxaUGFzcztcblx0XHRpZiAoIHRoaXMuc3RlbmNpbFdyaXRlID09PSB0cnVlICkgZGF0YS5zdGVuY2lsV3JpdGUgPSB0aGlzLnN0ZW5jaWxXcml0ZTtcblxuXHRcdC8vIHJvdGF0aW9uIChTcHJpdGVNYXRlcmlhbClcblx0XHRpZiAoIHRoaXMucm90YXRpb24gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJvdGF0aW9uICE9PSAwICkgZGF0YS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cblx0XHRpZiAoIHRoaXMucG9seWdvbk9mZnNldCA9PT0gdHJ1ZSApIGRhdGEucG9seWdvbk9mZnNldCA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IDAgKSBkYXRhLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0aWYgKCB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gMCApIGRhdGEucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHRpZiAoIHRoaXMubGluZXdpZHRoICE9PSB1bmRlZmluZWQgJiYgdGhpcy5saW5ld2lkdGggIT09IDEgKSBkYXRhLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xuXHRcdGlmICggdGhpcy5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XG5cdFx0aWYgKCB0aGlzLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZ2FwU2l6ZSA9IHRoaXMuZ2FwU2l6ZTtcblx0XHRpZiAoIHRoaXMuc2NhbGUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG5cdFx0aWYgKCB0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSApIGRhdGEuZGl0aGVyaW5nID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblx0XHRpZiAoIHRoaXMuYWxwaGFIYXNoID09PSB0cnVlICkgZGF0YS5hbHBoYUhhc2ggPSB0cnVlO1xuXHRcdGlmICggdGhpcy5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWUgKSBkYXRhLmFscGhhVG9Db3ZlcmFnZSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuZm9yY2VTaW5nbGVQYXNzID09PSB0cnVlICkgZGF0YS5mb3JjZVNpbmdsZVBhc3MgPSB0cnVlO1xuXG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVjYXAgIT09ICdyb3VuZCcgKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHRpZiAoIHRoaXMuZmxhdFNoYWRpbmcgPT09IHRydWUgKSBkYXRhLmZsYXRTaGFkaW5nID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIGRhdGEudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0aGlzLnRvbmVNYXBwZWQgPT09IGZhbHNlICkgZGF0YS50b25lTWFwcGVkID0gZmFsc2U7XG5cblx0XHRpZiAoIHRoaXMuZm9nID09PSBmYWxzZSApIGRhdGEuZm9nID0gZmFsc2U7XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXG5cblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IG1hdGVyaWFsIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hdGVyaWFsfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRlcmlhbCB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdGVyaWFsfSBzb3VyY2UgLSBUaGUgbWF0ZXJpYWwgdG8gY29weS5cblx0ICogQHJldHVybiB7TWF0ZXJpYWx9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuXHRcdHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XG5cdFx0dGhpcy5ibGVuZERzdCA9IHNvdXJjZS5ibGVuZERzdDtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcblx0XHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBzb3VyY2UuYmxlbmREc3RBbHBoYTtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0dGhpcy5ibGVuZENvbG9yLmNvcHkoIHNvdXJjZS5ibGVuZENvbG9yICk7XG5cdFx0dGhpcy5ibGVuZEFscGhhID0gc291cmNlLmJsZW5kQWxwaGE7XG5cblx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xuXHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gc291cmNlLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0dGhpcy5zdGVuY2lsRnVuYyA9IHNvdXJjZS5zdGVuY2lsRnVuYztcblx0XHR0aGlzLnN0ZW5jaWxSZWYgPSBzb3VyY2Uuc3RlbmNpbFJlZjtcblx0XHR0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IHNvdXJjZS5zdGVuY2lsRnVuY01hc2s7XG5cdFx0dGhpcy5zdGVuY2lsRmFpbCA9IHNvdXJjZS5zdGVuY2lsRmFpbDtcblx0XHR0aGlzLnN0ZW5jaWxaRmFpbCA9IHNvdXJjZS5zdGVuY2lsWkZhaWw7XG5cdFx0dGhpcy5zdGVuY2lsWlBhc3MgPSBzb3VyY2Uuc3RlbmNpbFpQYXNzO1xuXHRcdHRoaXMuc3RlbmNpbFdyaXRlID0gc291cmNlLnN0ZW5jaWxXcml0ZTtcblxuXHRcdGNvbnN0IHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcztcblx0XHRsZXQgZHN0UGxhbmVzID0gbnVsbDtcblxuXHRcdGlmICggc3JjUGxhbmVzICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBuID0gc3JjUGxhbmVzLmxlbmd0aDtcblx0XHRcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0ZHN0UGxhbmVzWyBpIF0gPSBzcmNQbGFuZXNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xuXHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IHNvdXJjZS5jbGlwSW50ZXJzZWN0aW9uO1xuXHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XG5cblx0XHR0aGlzLnNoYWRvd1NpZGUgPSBzb3VyY2Uuc2hhZG93U2lkZTtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0dGhpcy5kaXRoZXJpbmcgPSBzb3VyY2UuZGl0aGVyaW5nO1xuXG5cdFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xuXHRcdHRoaXMuYWxwaGFIYXNoID0gc291cmNlLmFscGhhSGFzaDtcblx0XHR0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IHNvdXJjZS5hbHBoYVRvQ292ZXJhZ2U7XG5cdFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdHRoaXMuZm9yY2VTaW5nbGVQYXNzID0gc291cmNlLmZvcmNlU2luZ2xlUGFzcztcblxuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0dGhpcy50b25lTWFwcGVkID0gc291cmNlLnRvbmVNYXBwZWQ7XG5cblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZyZWVzIHRoZSBHUFUtcmVsYXRlZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpc1xuXHQgKiBtZXRob2Qgd2hlbmV2ZXIgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgdXNlZCBpbiB5b3VyIGFwcC5cblx0ICpcblx0ICogQGZpcmVzIE1hdGVyaWFsI2Rpc3Bvc2Vcblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHQvKipcblx0XHQgKiBGaXJlcyB3aGVuIHRoZSBtYXRlcmlhbCBoYXMgYmVlbiBkaXNwb3NlZCBvZi5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBNYXRlcmlhbCNkaXNwb3NlXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBgdHJ1ZWAgaW5kaWNhdGVzIHRoZSBlbmdpbmUgdGhlIG1hdGVyaWFsXG5cdCAqIG5lZWRzIHRvIGJlIHJlY29tcGlsZWQuXG5cdCAqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG5cdCAqL1xuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBNdWx0aXBseU9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcblxuLyoqXG4gKiBBIG1hdGVyaWFsIGZvciBkcmF3aW5nIGdlb21ldHJpZXMgaW4gYSBzaW1wbGUgc2hhZGVkIChmbGF0IG9yIHdpcmVmcmFtZSkgd2F5LlxuICpcbiAqIFRoaXMgbWF0ZXJpYWwgaXMgbm90IGFmZmVjdGVkIGJ5IGxpZ2h0cy5cbiAqXG4gKiBAYXVnbWVudHMgTWF0ZXJpYWxcbiAqL1xuY2xhc3MgTWVzaEJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbWVzaCBiYXNpYyBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIENvbG9yIG9mIHRoZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBtYXAuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYW4gYWxwaGEgY2hhbm5lbCwgdHlwaWNhbGx5IGNvbWJpbmVkXG5cdFx0ICogd2l0aCB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yIHtAbGluayBNYXRlcmlhbCNhbHBoYVRlc3R9LiBUaGUgdGV4dHVyZSBtYXBcblx0XHQgKiBjb2xvciBpcyBtb2R1bGF0ZWQgYnkgdGhlIGRpZmZ1c2UgYGNvbG9yYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpZ2h0IG1hcC4gUmVxdWlyZXMgYSBzZWNvbmQgc2V0IG9mIFVWcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGJha2VkIGxpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZWQgY2hhbm5lbCBvZiB0aGlzIHRleHR1cmUgaXMgdXNlZCBhcyB0aGUgYW1iaWVudCBvY2NsdXNpb24gbWFwLlxuXHRcdCAqIFJlcXVpcmVzIGEgc2Vjb25kIHNldCBvZiBVVnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZW5zaXR5IG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbiBlZmZlY3QuIFJhbmdlIGlzIGBbMCwxXWAsIHdoZXJlIGAwYFxuXHRcdCAqIGRpc2FibGVzIGFtYmllbnQgb2NjbHVzaW9uLiBXaGVyZSBpbnRlbnNpdHkgaXMgYDFgIGFuZCB0aGUgQU8gbWFwJ3Ncblx0XHQgKiByZWQgY2hhbm5lbCBpcyBhbHNvIGAxYCwgYW1iaWVudCBsaWdodCBpcyBmdWxseSBvY2NsdWRlZCBvbiBhIHN1cmZhY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY3VsYXIgbWFwIHVzZWQgYnkgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbHBoYSBtYXAgaXMgYSBncmF5c2NhbGUgdGV4dHVyZSB0aGF0IGNvbnRyb2xzIHRoZSBvcGFjaXR5IGFjcm9zcyB0aGVcblx0XHQgKiBzdXJmYWNlIChibGFjazogZnVsbHkgdHJhbnNwYXJlbnQ7IHdoaXRlOiBmdWxseSBvcGFxdWUpLlxuXHRcdCAqXG5cdFx0ICogT25seSB0aGUgY29sb3Igb2YgdGhlIHRleHR1cmUgaXMgdXNlZCwgaWdub3JpbmcgdGhlIGFscGhhIGNoYW5uZWwgaWYgb25lXG5cdFx0ICogZXhpc3RzLiBGb3IgUkdCIGFuZCBSR0JBIHRleHR1cmVzLCB0aGUgcmVuZGVyZXIgd2lsbCB1c2UgdGhlIGdyZWVuIGNoYW5uZWxcblx0XHQgKiB3aGVuIHNhbXBsaW5nIHRoaXMgdGV4dHVyZSBkdWUgdG8gdGhlIGV4dHJhIGJpdCBvZiBwcmVjaXNpb24gcHJvdmlkZWQgZm9yXG5cdFx0ICogZ3JlZW4gaW4gRFhULWNvbXByZXNzZWQgYW5kIHVuY29tcHJlc3NlZCBSR0IgNTY1IGZvcm1hdHMuIEx1bWluYW5jZS1vbmx5IGFuZFxuXHRcdCAqIGx1bWluYW5jZS9hbHBoYSB0ZXh0dXJlcyB3aWxsIGFsc28gc3RpbGwgd29yayBhcyBleHBlY3RlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZW52aXJvbm1lbnQgbWFwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcm90YXRpb24gb2YgdGhlIGVudmlyb25tZW50IG1hcCBpbiByYWRpYW5zLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0V1bGVyfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHQgKi9cblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgdG8gY29tYmluZSB0aGUgcmVzdWx0IG9mIHRoZSBzdXJmYWNlJ3MgY29sb3Igd2l0aCB0aGUgZW52aXJvbm1lbnQgbWFwLCBpZiBhbnkuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHNldCB0byBgTWl4T3BlcmF0aW9uYCwgdGhlIHtAbGluayBNZXNoQmFzaWNNYXRlcmlhbCNyZWZsZWN0aXZpdHl9IGlzIHVzZWQgdG9cblx0XHQgKiBibGVuZCBiZXR3ZWVuIHRoZSB0d28gY29sb3JzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhNdWx0aXBseU9wZXJhdGlvbnxNaXhPcGVyYXRpb258QWRkT3BlcmF0aW9uKX1cblx0XHQgKiBAZGVmYXVsdCBNdWx0aXBseU9wZXJhdGlvblxuXHRcdCAqL1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIGVudmlyb25tZW50IG1hcCBhZmZlY3RzIHRoZSBzdXJmYWNlLlxuXHRcdCAqIFRoZSB2YWxpZCByYW5nZSBpcyBiZXR3ZWVuIGAwYCAobm8gcmVmbGVjdGlvbnMpIGFuZCBgMWAgKGZ1bGwgcmVmbGVjdGlvbnMpLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGluZGV4IG9mIHJlZnJhY3Rpb24gKElPUikgb2YgYWlyIChhcHByb3hpbWF0ZWx5IDEpIGRpdmlkZWQgYnkgdGhlXG5cdFx0ICogaW5kZXggb2YgcmVmcmFjdGlvbiBvZiB0aGUgbWF0ZXJpYWwuIEl0IGlzIHVzZWQgd2l0aCBlbnZpcm9ubWVudCBtYXBwaW5nXG5cdFx0ICogbW9kZXMge0BsaW5rIEN1YmVSZWZyYWN0aW9uTWFwcGluZ30gYW5kIHtAbGluayBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZ30uXG5cdFx0ICogVGhlIHJlZnJhY3Rpb24gcmF0aW8gc2hvdWxkIG5vdCBleGNlZWQgYDFgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwLjk4XG5cdFx0ICovXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVycyB0aGUgZ2VvbWV0cnkgYXMgYSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBDb250cm9scyB0aGUgdGhpY2tuZXNzIG9mIHRoZSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGgge0BsaW5rIFNWR1JlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgYXBwZWFyYW5jZSBvZiB3aXJlZnJhbWUgZW5kcy5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgU1ZHUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeygncm91bmQnfCdiZXZlbCd8J21pdGVyJyl9XG5cdFx0ICogQGRlZmF1bHQgJ3JvdW5kJ1xuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGFwcGVhcmFuY2Ugb2Ygd2lyZWZyYW1lIGpvaW50cy5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgU1ZHUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeygncm91bmQnfCdiZXZlbCd8J21pdGVyJyl9XG5cdFx0ICogQGRlZmF1bHQgJ3JvdW5kJ1xuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgYWZmZWN0ZWQgYnkgZm9nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmVudk1hcFJvdGF0aW9uLmNvcHkoIHNvdXJjZS5lbnZNYXBSb3RhdGlvbiApO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTWVzaEJhc2ljTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG4vLyBGYXN0IEhhbGYgRmxvYXQgQ29udmVyc2lvbnMsIGh0dHA6Ly93d3cuZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcblxuY29uc3QgX3RhYmxlcyA9IC8qQF9fUFVSRV9fKi8gX2dlbmVyYXRlVGFibGVzKCk7XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZVRhYmxlcygpIHtcblxuXHQvLyBmbG9hdDMyIHRvIGZsb2F0MTYgaGVscGVyc1xuXG5cdGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlciggNCApO1xuXHRjb25zdCBmbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0Y29uc3QgdWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cblx0Y29uc3QgYmFzZVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA1MTIgKTtcblx0Y29uc3Qgc2hpZnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNTEyICk7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMjU2OyArKyBpICkge1xuXG5cdFx0Y29uc3QgZSA9IGkgLSAxMjc7XG5cblx0XHQvLyB2ZXJ5IHNtYWxsIG51bWJlciAoMCwgLTApXG5cblx0XHRpZiAoIGUgPCAtIDI3ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4MDAwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XG5cblx0XHRcdC8vIHNtYWxsIG51bWJlciAoZGVub3JtKVxuXG5cdFx0fSBlbHNlIGlmICggZSA8IC0gMTQgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwNDAwID4+ICggLSBlIC0gMTQgKTtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAoIDB4MDQwMCA+PiAoIC0gZSAtIDE0ICkgKSB8IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IC0gZSAtIDE7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IC0gZSAtIDE7XG5cblx0XHRcdC8vIG5vcm1hbCBudW1iZXJcblxuXHRcdH0gZWxzZSBpZiAoIGUgPD0gMTUgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gKCBlICsgMTUgKSA8PCAxMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAoICggZSArIDE1ICkgPDwgMTAgKSB8IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcblxuXHRcdFx0Ly8gbGFyZ2UgbnVtYmVyIChJbmZpbml0eSwgLUluZmluaXR5KVxuXG5cdFx0fSBlbHNlIGlmICggZSA8IDEyOCApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDdjMDA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHhmYzAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMjQ7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDI0O1xuXG5cdFx0XHQvLyBzdGF5IChOYU4sIEluZmluaXR5LCAtSW5maW5pdHkpXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAxMztcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMTM7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGZsb2F0MTYgdG8gZmxvYXQzMiBoZWxwZXJzXG5cblx0Y29uc3QgbWFudGlzc2FUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggMjA0OCApO1xuXHRjb25zdCBleHBvbmVudFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA2NCApO1xuXHRjb25zdCBvZmZzZXRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNjQgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCAxMDI0OyArKyBpICkge1xuXG5cdFx0bGV0IG0gPSBpIDw8IDEzOyAvLyB6ZXJvIHBhZCBtYW50aXNzYSBiaXRzXG5cdFx0bGV0IGUgPSAwOyAvLyB6ZXJvIGV4cG9uZW50XG5cblx0XHQvLyBub3JtYWxpemVkXG5cdFx0d2hpbGUgKCAoIG0gJiAweDAwODAwMDAwICkgPT09IDAgKSB7XG5cblx0XHRcdG0gPDw9IDE7XG5cdFx0XHRlIC09IDB4MDA4MDAwMDA7IC8vIGRlY3JlbWVudCBleHBvbmVudFxuXG5cdFx0fVxuXG5cdFx0bSAmPSB+IDB4MDA4MDAwMDA7IC8vIGNsZWFyIGxlYWRpbmcgMSBiaXRcblx0XHRlICs9IDB4Mzg4MDAwMDA7IC8vIGFkanVzdCBiaWFzXG5cblx0XHRtYW50aXNzYVRhYmxlWyBpIF0gPSBtIHwgZTtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgKysgaSApIHtcblxuXHRcdG1hbnRpc3NhVGFibGVbIGkgXSA9IDB4MzgwMDAwMDAgKyAoICggaSAtIDEwMjQgKSA8PCAxMyApO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCAzMTsgKysgaSApIHtcblxuXHRcdGV4cG9uZW50VGFibGVbIGkgXSA9IGkgPDwgMjM7XG5cblx0fVxuXG5cdGV4cG9uZW50VGFibGVbIDMxIF0gPSAweDQ3ODAwMDAwO1xuXHRleHBvbmVudFRhYmxlWyAzMiBdID0gMHg4MDAwMDAwMDtcblxuXHRmb3IgKCBsZXQgaSA9IDMzOyBpIDwgNjM7ICsrIGkgKSB7XG5cblx0XHRleHBvbmVudFRhYmxlWyBpIF0gPSAweDgwMDAwMDAwICsgKCAoIGkgLSAzMiApIDw8IDIzICk7XG5cblx0fVxuXG5cdGV4cG9uZW50VGFibGVbIDYzIF0gPSAweGM3ODAwMDAwO1xuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDY0OyArKyBpICkge1xuXG5cdFx0aWYgKCBpICE9PSAzMiApIHtcblxuXHRcdFx0b2Zmc2V0VGFibGVbIGkgXSA9IDEwMjQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZmxvYXRWaWV3OiBmbG9hdFZpZXcsXG5cdFx0dWludDMyVmlldzogdWludDMyVmlldyxcblx0XHRiYXNlVGFibGU6IGJhc2VUYWJsZSxcblx0XHRzaGlmdFRhYmxlOiBzaGlmdFRhYmxlLFxuXHRcdG1hbnRpc3NhVGFibGU6IG1hbnRpc3NhVGFibGUsXG5cdFx0ZXhwb25lbnRUYWJsZTogZXhwb25lbnRUYWJsZSxcblx0XHRvZmZzZXRUYWJsZTogb2Zmc2V0VGFibGVcblx0fTtcblxufVxuXG4vKipcbiAqIFJldHVybnMgYSBoYWxmIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCB2YWx1ZSAoRlAxNikgZnJvbSB0aGUgZ2l2ZW4gc2luZ2xlXG4gKiBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgdmFsdWUgKEZQMzIpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBBIHNpbmdsZSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBGUDE2IHZhbHVlLlxuICovXG5mdW5jdGlvbiB0b0hhbGZGbG9hdCggdmFsICkge1xuXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcblxuXHR2YWwgPSBjbGFtcCggdmFsLCAtIDY1NTA0LCA2NTUwNCApO1xuXG5cdF90YWJsZXMuZmxvYXRWaWV3WyAwIF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbIDAgXTtcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVsgZSBdICsgKCAoIGYgJiAweDAwN2ZmZmZmICkgPj4gX3RhYmxlcy5zaGlmdFRhYmxlWyBlIF0gKTtcblxufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgcHJlY2lzaW9uIGZsb2F0aW5nIHBvaW50IHZhbHVlIChGUDMyKSBmcm9tIHRoZSBnaXZlbiBoYWxmXG4gKiBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgdmFsdWUgKEZQMTYpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBBIGhhbGYgcHJlY2lzaW9uIGZsb2F0aW5nIHBvaW50IHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgRlAzMiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZnJvbUhhbGZGbG9hdCggdmFsICkge1xuXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XG5cdF90YWJsZXMudWludDMyVmlld1sgMCBdID0gX3RhYmxlcy5tYW50aXNzYVRhYmxlWyBfdGFibGVzLm9mZnNldFRhYmxlWyBtIF0gKyAoIHZhbCAmIDB4M2ZmICkgXSArIF90YWJsZXMuZXhwb25lbnRUYWJsZVsgbSBdO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbIDAgXTtcblxufVxuXG4vKipcbiAqIEEgY2xhc3MgY29udGFpbmluZyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGF0YS5cbiAqXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIERhdGFVdGlscyB7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBoYWxmIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCB2YWx1ZSAoRlAxNikgZnJvbSB0aGUgZ2l2ZW4gc2luZ2xlXG5cdCAqIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCB2YWx1ZSAoRlAzMikuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBBIHNpbmdsZSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIEZQMTYgdmFsdWUuXG5cdCAqL1xuXHRzdGF0aWMgdG9IYWxmRmxvYXQoIHZhbCApIHtcblxuXHRcdHJldHVybiB0b0hhbGZGbG9hdCggdmFsICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc2luZ2xlIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCB2YWx1ZSAoRlAzMikgZnJvbSB0aGUgZ2l2ZW4gaGFsZlxuXHQgKiBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgdmFsdWUgKEZQMTYpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gQSBoYWxmIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgRlAzMiB2YWx1ZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSGFsZkZsb2F0KCB2YWwgKSB7XG5cblx0XHRyZXR1cm4gZnJvbUhhbGZGbG9hdCggdmFsICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7XG5cdHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0LFxuXHREYXRhVXRpbHNcbn07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgZGVub3JtYWxpemUsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IFN0YXRpY0RyYXdVc2FnZSwgRmxvYXRUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGZyb21IYWxmRmxvYXQsIHRvSGFsZkZsb2F0IH0gZnJvbSAnLi4vZXh0cmFzL0RhdGFVdGlscy5qcyc7XG5cbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmVjdG9yMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxubGV0IF9pZCA9IDA7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBzdG9yZXMgZGF0YSBmb3IgYW4gYXR0cmlidXRlIChzdWNoIGFzIHZlcnRleCBwb3NpdGlvbnMsIGZhY2VcbiAqIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmQgYW55IGN1c3RvbSBhdHRyaWJ1dGVzICkgYXNzb2NpYXRlZCB3aXRoXG4gKiBhIGdlb21ldHJ5LCB3aGljaCBhbGxvd3MgZm9yIG1vcmUgZWZmaWNpZW50IHBhc3Npbmcgb2YgZGF0YSB0byB0aGUgR1BVLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIHZlY3Rvci1saWtlIGRhdGEsIHRoZSBgZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApYFxuICogaGVscGVyIG1ldGhvZHMgb24gdmVjdG9yIGFuZCBjb2xvciBjbGFzcyBtaWdodCBiZSBoZWxwZnVsLiBFLmcuIHtAbGluayBWZWN0b3IzI2Zyb21CdWZmZXJBdHRyaWJ1dGV9LlxuICovXG5jbGFzcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkID0gZmFsc2UgKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIElEIG9mIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHRcdCAqXG5cdFx0ICogQG5hbWUgQnVmZmVyQXR0cmlidXRlI2lkXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IF9pZCArKyB9ICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuIEl0IHNob3VsZCBoYXZlIGBpdGVtU2l6ZSAqIG51bVZlcnRpY2VzYFxuXHRcdCAqIGVsZW1lbnRzLCB3aGVyZSBgbnVtVmVydGljZXNgIGlzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGFzc29jaWF0ZWQgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgYXJyYXkgdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciB2ZXJ0ZXguXG5cdFx0ICogRm9yIGluc3RhbmNlLCBpZiB0aGlzIGF0dHJpYnV0ZSBpcyBzdG9yaW5nIGEgMy1jb21wb25lbnQgdmVjdG9yIChzdWNoIGFzIGEgcG9zaXRpb24sXG5cdFx0ICogbm9ybWFsLCBvciBjb2xvciksIHRoZW4gdGhlIHZhbHVlIHNob3VsZCBiZSBgM2AuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBpdGVtcyB0aGlzIGJ1ZmZlciBhdHRyaWJ1dGUgc3RvcmVzLiBJdCBpcyBpbnRlcm5hbGx5IGNvbXB1dGVkXG5cdFx0ICogYnkgZGl2aWRpbmcgdGhlIGBhcnJheWAgbGVuZ3RoIGJ5IHRoZSBgaXRlbVNpemVgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGxpZXMgdG8gaW50ZWdlciBkYXRhIG9ubHkuIEluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBpbiB0aGUgYnVmZmVyIG1hcHMgdG9cblx0XHQgKiB0aGUgdmFsdWVzIGluIHRoZSBHTFNMIGNvZGUuIEZvciBpbnN0YW5jZSwgaWYgYGFycmF5YCBpcyBhbiBpbnN0YW5jZSBvZiBgVUludDE2QXJyYXlgLFxuXHRcdCAqIGFuZCBgbm9ybWFsaXplZGAgaXMgYHRydWVgLCB0aGUgdmFsdWVzIGAwIC0rNjU1MzVgIGluIHRoZSBhcnJheSBkYXRhIHdpbGwgYmUgbWFwcGVkIHRvXG5cdFx0ICogYDAuMGYgLSArMS4wZmAgaW4gdGhlIEdMU0wgYXR0cmlidXRlLiBJZiBgbm9ybWFsaXplZGAgaXMgYGZhbHNlYCwgdGhlIHZhbHVlcyB3aWxsIGJlIGNvbnZlcnRlZFxuXHRcdCAqIHRvIGZsb2F0cyB1bm1vZGlmaWVkLCBpLmUuIGA2NTUzNWAgYmVjb21lcyBgNjU1MzUuMGZgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGludGVuZGVkIHVzYWdlIHBhdHRlcm4gb2YgdGhlIGRhdGEgc3RvcmUgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IEFmdGVyIHRoZSBpbml0aWFsIHVzZSBvZiBhIGJ1ZmZlciwgaXRzIHVzYWdlIGNhbm5vdCBiZSBjaGFuZ2VkLiBJbnN0ZWFkLFxuXHRcdCAqIGluc3RhbnRpYXRlIGEgbmV3IG9uZSBhbmQgc2V0IHRoZSBkZXNpcmVkIHVzYWdlIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFN0YXRpY0RyYXdVc2FnZXxEeW5hbWljRHJhd1VzYWdlfFN0cmVhbURyYXdVc2FnZXxTdGF0aWNSZWFkVXNhZ2V8RHluYW1pY1JlYWRVc2FnZXxTdHJlYW1SZWFkVXNhZ2V8U3RhdGljQ29weVVzYWdlfER5bmFtaWNDb3B5VXNhZ2V8U3RyZWFtQ29weVVzYWdlKX1cblx0XHQgKiBAZGVmYXVsdCBTdGF0aWNEcmF3VXNhZ2Vcblx0XHQgKi9cblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBvbmx5IHVwZGF0ZSBzb21lIGNvbXBvbmVudHMgb2Ygc3RvcmVkIHZlY3RvcnMgKGZvciBleGFtcGxlLCBqdXN0IHRoZVxuXHRcdCAqIGNvbXBvbmVudCByZWxhdGVkIHRvIGNvbG9yKS4gVXNlIHRoZSBgYWRkVXBkYXRlUmFuZ2UoKWAgZnVuY3Rpb24gdG8gYWRkIHJhbmdlcyB0byB0aGlzIGFycmF5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PE9iamVjdD59XG5cdFx0ICovXG5cdFx0dGhpcy51cGRhdGVSYW5nZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIENvbmZpZ3VyZXMgdGhlIGJvdW5kIEdQVSB0eXBlIGZvciB1c2UgaW4gc2hhZGVycy5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IHRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGZvciBpbnRlZ2VyIGFycmF5cyBhbmQgaXMgbm90IGNvbmZpZ3VyYWJsZSBmb3IgZmxvYXQgYXJyYXlzLlxuXHRcdCAqIEZvciBsb3dlciBwcmVjaXNpb24gZmxvYXQgdHlwZXMsIHVzZSBgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KEZsb2F0VHlwZXxJbnRUeXBlKX1cblx0XHQgKiBAZGVmYXVsdCBGbG9hdFR5cGVcblx0XHQgKi9cblx0XHR0aGlzLmdwdVR5cGUgPSBGbG9hdFR5cGU7XG5cblx0XHQvKipcblx0XHQgKiBBIHZlcnNpb24gbnVtYmVyLCBpbmNyZW1lbnRlZCBldmVyeSB0aW1lIHRoZSBgbmVlZHNVcGRhdGVgIGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlbmRlcmVyIGhhcyB0cmFuc2ZlcnJlZCB0aGUgYXR0cmlidXRlXG5cdCAqIGFycmF5IGRhdGEgdG8gdGhlIEdQVS5cblx0ICovXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIHRoYXQgdGhpcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgYW5kIHNob3VsZCBiZSByZS1zZW50IHRvXG5cdCAqIHRoZSBHUFUuIFNldCB0aGlzIHRvIGB0cnVlYCB3aGVuIHlvdSBtb2RpZnkgdGhlIHZhbHVlIG9mIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1c2FnZSBvZiB0aGlzIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0YXRpY0RyYXdVc2FnZXxEeW5hbWljRHJhd1VzYWdlfFN0cmVhbURyYXdVc2FnZXxTdGF0aWNSZWFkVXNhZ2V8RHluYW1pY1JlYWRVc2FnZXxTdHJlYW1SZWFkVXNhZ2V8U3RhdGljQ29weVVzYWdlfER5bmFtaWNDb3B5VXNhZ2V8U3RyZWFtQ29weVVzYWdlKX0gdmFsdWUgLSBUaGUgdXNhZ2UgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICovXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIG9mIGRhdGEgaW4gdGhlIGRhdGEgYXJyYXkgdG8gYmUgdXBkYXRlZCBvbiB0aGUgR1BVLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBQb3NpdGlvbiBhdCB3aGljaCB0byBzdGFydCB1cGRhdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyB0byB1cGRhdGUuXG5cdCAqL1xuXHRhZGRVcGRhdGVSYW5nZSggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0dGhpcy51cGRhdGVSYW5nZXMucHVzaCggeyBzdGFydCwgY291bnQgfSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSB1cGRhdGUgcmFuZ2VzLlxuXHQgKi9cblx0Y2xlYXJVcGRhdGVSYW5nZXMoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGJ1ZmZlciBhdHRyaWJ1dGUgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IHNvdXJjZSAtIFRoZSBidWZmZXIgYXR0cmlidXRlIHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IHNvdXJjZS5ncHVUeXBlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgYSB2ZWN0b3IgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIGF0dHJpYnV0ZSB0byB0aGlzIG9uZS4gVGhlIHN0YXJ0XG5cdCAqIGFuZCBkZXN0aW5hdGlvbiBwb3NpdGlvbiBpbiB0aGUgYXR0cmlidXRlIGJ1ZmZlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHRoZVxuXHQgKiBnaXZlbiBpbmRpY2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgxIC0gVGhlIGRlc3RpbmF0aW9uIGluZGV4IGludG8gdGhpcyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIC0gVGhlIGJ1ZmZlciBhdHRyaWJ1dGUgdG8gY29weSBmcm9tLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgyIC0gVGhlIHNvdXJjZSBpbmRleCBpbnRvIHRoZSBnaXZlbiBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5QXQoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIGdpdmVuIGFycmF5IGRhdGEgaW50byB0aGlzIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFR5cGVkQXJyYXl8QXJyYXkpfSBhcnJheSAtIFRoZSBhcnJheSB0byBjb3B5LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5QXJyYXkoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGdpdmVuIDN4MyBtYXRyaXggdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZS4gV29ya3Mgd2l0aFxuXHQgKiBpdGVtIHNpemUgYDJgIGFuZCBgM2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4M30gbSAtIFRoZSBtYXRyaXggdG8gYXBwbHkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGlmICggdGhpcy5pdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3RvcjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMi5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZKCBpLCBfdmVjdG9yMi54LCBfdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gNHg0IG1hdHJpeCB0byB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBPbmx5IHdvcmtzIHdpdGhcblx0ICogaXRlbSBzaXplIGAzYC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIG1hdHJpeCB0byBhcHBseS5cblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4NCggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBnaXZlbiAzeDMgbm9ybWFsIG1hdHJpeCB0byB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBPbmx5IHdvcmtzIHdpdGhcblx0ICogaXRlbSBzaXplIGAzYC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXgzfSBtIC0gVGhlIG5vcm1hbCBtYXRyaXggdG8gYXBwbHkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGFwcGx5Tm9ybWFsTWF0cml4KCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yLmFwcGx5Tm9ybWFsTWF0cml4KCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXggdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZS4gT25seSB3b3JrcyB3aXRoXG5cdCAqIGl0ZW0gc2l6ZSBgM2AgYW5kIHdpdGggZGlyZWN0aW9uIHZlY3RvcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSBtYXRyaXggdG8gYXBwbHkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci50cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gYXJyYXkgZGF0YSBpbiB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHsoVHlwZWRBcnJheXxBcnJheSl9IHZhbHVlIC0gVGhlIGFycmF5IGRhdGEgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIFRoZSBvZmZzZXQgaW4gdGhpcyBidWZmZXIgYXR0cmlidXRlJ3MgYXJyYXkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldCggdmFsdWUsIG9mZnNldCA9IDAgKSB7XG5cblx0XHQvLyBNYXRjaGluZyBCdWZmZXJBdHRyaWJ1dGUgY29uc3RydWN0b3IsIGRvIG5vdCBub3JtYWxpemUgdGhlIGFycmF5LlxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGdpdmVuIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb21wb25lbnQgLSBUaGUgY29tcG9uZW50IGluZGV4LlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZXR1cm5lZCB2YWx1ZS5cblx0ICovXG5cdGdldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCApIHtcblxuXHRcdGxldCB2YWx1ZSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIGNvbXBvbmVudCBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB2YWx1ZSA9IGRlbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGdpdmVuIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb21wb25lbnQgLSBUaGUgY29tcG9uZW50IGluZGV4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB2YWx1ZSA9IG5vcm1hbGl6ZSggdmFsdWUsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIGNvbXBvbmVudCBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgeCBjb21wb25lbnQuXG5cdCAqL1xuXHRnZXRYKCBpbmRleCApIHtcblxuXHRcdGxldCB4ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB5IGNvbXBvbmVudC5cblx0ICovXG5cdGdldFkoIGluZGV4ICkge1xuXG5cdFx0bGV0IHkgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgeiBjb21wb25lbnQuXG5cdCAqL1xuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB3IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHcgY29tcG9uZW50LlxuXHQgKi9cblx0Z2V0VyggaW5kZXggKSB7XG5cblx0XHRsZXQgdyA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHcgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHcgLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCBhbmQgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBmb3IgdGhlIHggY29tcG9uZW50IHRvIHNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmFsdWUgZm9yIHRoZSB5IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCwgeSBhbmQgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBmb3IgdGhlIHggY29tcG9uZW50IHRvIHNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmFsdWUgZm9yIHRoZSB5IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHZhbHVlIGZvciB0aGUgeiBjb21wb25lbnQgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCwgeSwgeiBhbmQgdyBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBmb3IgdGhlIHggY29tcG9uZW50IHRvIHNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmFsdWUgZm9yIHRoZSB5IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHZhbHVlIGZvciB0aGUgeiBjb21wb25lbnQgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB2YWx1ZSBmb3IgdGhlIHcgY29tcG9uZW50IHRvIHNldC5cblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0WFlaVyggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblx0XHRcdHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBhZnRlciB0aGUgUmVuZGVyZXIgaGFzIHRyYW5zZmVycmVkXG5cdCAqIHRoZSBhdHRyaWJ1dGUgYXJyYXkgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgdXNlZCB0byBwZXJmb3JtIGNsZWFuLXVwIG9wZXJhdGlvbnMgYWZ0ZXJcblx0ICogdGhlIHVwbG9hZCB3aGVuIGF0dHJpYnV0ZSBkYXRhIGFyZSBub3QgbmVlZGVkIGFueW1vcmUgb24gdGhlIENQVSBzaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBgb25VcGxvYWQoKWAgY2FsbGJhY2suXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdG9uVXBsb2FkKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGJ1ZmZlciBhdHRyaWJ1dGUgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIGJ1ZmZlciBhdHRyaWJ1dGUgaW50byBKU09OLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqL1xuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRhcnJheTogQXJyYXkuZnJvbSggdGhpcy5hcnJheSApLFxuXHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIHRoaXMudXNhZ2UgIT09IFN0YXRpY0RyYXdVc2FnZSApIGRhdGEudXNhZ2UgPSB0aGlzLnVzYWdlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ29udmVuaWVudCBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgYSBgSW50OGAgYnVmZmVyIGF0dHJpYnV0ZSB3aXRoXG4gKiBhIHBsYWluIGBBcnJheWAgaW5zdGFuY2UuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckF0dHJpYnV0ZVxuICovXG5jbGFzcyBJbnQ4QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhBcnJheTxudW1iZXI+fEludDhBcnJheSl9IGFycmF5IC0gVGhlIGFycmF5IGhvbGRpbmcgdGhlIGF0dHJpYnV0ZSBkYXRhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaXRlbVNpemUgLSBUaGUgaXRlbSBzaXplLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3JtYWxpemVkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGRhdGEgYXJlIG5vcm1hbGl6ZWQgb3Igbm90LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENvbnZlbmllbnQgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgYFVJbnQ4YCBidWZmZXIgYXR0cmlidXRlIHdpdGhcbiAqIGEgcGxhaW4gYEFycmF5YCBpbnN0YW5jZS5cbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyQXR0cmlidXRlXG4gKi9cbmNsYXNzIFVpbnQ4QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhBcnJheTxudW1iZXI+fFVpbnQ4QXJyYXkpfSBhcnJheSAtIFRoZSBhcnJheSBob2xkaW5nIHRoZSBhdHRyaWJ1dGUgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1TaXplIC0gVGhlIGl0ZW0gc2l6ZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbbm9ybWFsaXplZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBkYXRhIGFyZSBub3JtYWxpemVkIG9yIG5vdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ29udmVuaWVudCBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgYSBgVUludDhDbGFtcGVkYCBidWZmZXIgYXR0cmlidXRlIHdpdGhcbiAqIGEgcGxhaW4gYEFycmF5YCBpbnN0YW5jZS5cbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyQXR0cmlidXRlXG4gKi9cbmNsYXNzIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHsoQXJyYXk8bnVtYmVyPnxVaW50OENsYW1wZWRBcnJheSl9IGFycmF5IC0gVGhlIGFycmF5IGhvbGRpbmcgdGhlIGF0dHJpYnV0ZSBkYXRhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaXRlbVNpemUgLSBUaGUgaXRlbSBzaXplLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3JtYWxpemVkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGRhdGEgYXJlIG5vcm1hbGl6ZWQgb3Igbm90LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ29udmVuaWVudCBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgYSBgSW50MTZgIGJ1ZmZlciBhdHRyaWJ1dGUgd2l0aFxuICogYSBwbGFpbiBgQXJyYXlgIGluc3RhbmNlLlxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJBdHRyaWJ1dGVcbiAqL1xuY2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KEFycmF5PG51bWJlcj58SW50MTZBcnJheSl9IGFycmF5IC0gVGhlIGFycmF5IGhvbGRpbmcgdGhlIGF0dHJpYnV0ZSBkYXRhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaXRlbVNpemUgLSBUaGUgaXRlbSBzaXplLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3JtYWxpemVkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGRhdGEgYXJlIG5vcm1hbGl6ZWQgb3Igbm90LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIGBVSW50MTZgIGJ1ZmZlciBhdHRyaWJ1dGUgd2l0aFxuICogYSBwbGFpbiBgQXJyYXlgIGluc3RhbmNlLlxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJBdHRyaWJ1dGVcbiAqL1xuY2xhc3MgVWludDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhBcnJheTxudW1iZXI+fFVpbnQxNkFycmF5KX0gYXJyYXkgLSBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIGBJbnQzMmAgYnVmZmVyIGF0dHJpYnV0ZSB3aXRoXG4gKiBhIHBsYWluIGBBcnJheWAgaW5zdGFuY2UuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckF0dHJpYnV0ZVxuICovXG5jbGFzcyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHsoQXJyYXk8bnVtYmVyPnxJbnQzMkFycmF5KX0gYXJyYXkgLSBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENvbnZlbmllbnQgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgYFVJbnQzMmAgYnVmZmVyIGF0dHJpYnV0ZSB3aXRoXG4gKiBhIHBsYWluIGBBcnJheWAgaW5zdGFuY2UuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckF0dHJpYnV0ZVxuICovXG5jbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KEFycmF5PG51bWJlcj58VWludDMyQXJyYXkpfSBhcnJheSAtIFRoZSBhcnJheSBob2xkaW5nIHRoZSBhdHRyaWJ1dGUgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1TaXplIC0gVGhlIGl0ZW0gc2l6ZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbbm9ybWFsaXplZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBkYXRhIGFyZSBub3JtYWxpemVkIG9yIG5vdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENvbnZlbmllbnQgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgYEZsb2F0MTZgIGJ1ZmZlciBhdHRyaWJ1dGUgd2l0aFxuICogYSBwbGFpbiBgQXJyYXlgIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgY2xhc3MgYXV0b21hdGljYWxseSBjb252ZXJ0cyB0byBhbmQgZnJvbSBGUDE2IHNpbmNlIGBGbG9hdDE2QXJyYXlgIGlzIG5vdFxuICogbmF0aXZlbHkgc3VwcG9ydGVkIGluIEphdmFTY3JpcHQuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckF0dHJpYnV0ZVxuICovXG5jbGFzcyBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhBcnJheTxudW1iZXI+fFVpbnQxNkFycmF5KX0gYXJyYXkgLSBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdHRoaXMuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHo7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFcoIGluZGV4ICkge1xuXG5cdFx0bGV0IHcgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0gdG9IYWxmRmxvYXQoIHggKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIGBGbG9hdDMyYCBidWZmZXIgYXR0cmlidXRlIHdpdGhcbiAqIGEgcGxhaW4gYEFycmF5YCBpbnN0YW5jZS5cbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyQXR0cmlidXRlXG4gKi9cbmNsYXNzIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KEFycmF5PG51bWJlcj58RmxvYXQzMkFycmF5KX0gYXJyYXkgLSBUaGUgYXJyYXkgaG9sZGluZyB0aGUgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8vXG5cbmV4cG9ydCB7XG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckF0dHJpYnV0ZVxufTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4vT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IGFycmF5TmVlZHNVaW50MzIgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmxldCBfaWQgPSAwO1xuXG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfb2JqID0gLypAX19QVVJFX18qLyBuZXcgT2JqZWN0M0QoKTtcbmNvbnN0IF9vZmZzZXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX2JveE1vcnBoVGFyZ2V0cyA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBtZXNoLCBsaW5lLCBvciBwb2ludCBnZW9tZXRyeS4gSW5jbHVkZXMgdmVydGV4XG4gKiBwb3NpdGlvbnMsIGZhY2UgaW5kaWNlcywgbm9ybWFscywgY29sb3JzLCBVVnMsIGFuZCBjdXN0b20gYXR0cmlidXRlc1xuICogd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsIHRoaXMgZGF0YSB0byB0aGUgR1BVLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICogLy8gY3JlYXRlIGEgc2ltcGxlIHNxdWFyZSBzaGFwZS4gV2UgZHVwbGljYXRlIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0XG4gKiAvLyB2ZXJ0aWNlcyBiZWNhdXNlIGVhY2ggdmVydGV4IG5lZWRzIHRvIGFwcGVhciBvbmNlIHBlciB0cmlhbmdsZS5cbiAqIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuICogXHQtMS4wLCAtMS4wLCAgMS4wLCAvLyB2MFxuICogXHQgMS4wLCAtMS4wLCAgMS4wLCAvLyB2MVxuICogXHQgMS4wLCAgMS4wLCAgMS4wLCAvLyB2MlxuICpcbiAqIFx0IDEuMCwgIDEuMCwgIDEuMCwgLy8gdjNcbiAqIFx0LTEuMCwgIDEuMCwgIDEuMCwgLy8gdjRcbiAqIFx0LTEuMCwgLTEuMCwgIDEuMCAgLy8gdjVcbiAqIF0gKTtcbiAqIC8vIGl0ZW1TaXplID0gMyBiZWNhdXNlIHRoZXJlIGFyZSAzIHZhbHVlcyAoY29tcG9uZW50cykgcGVyIHZlcnRleFxuICogZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwMDAgfSApO1xuICogY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBFdmVudERpc3BhdGNoZXJcbiAqL1xuY2xhc3MgQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGdlb21ldHJ5LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0J1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAbmFtZSBCdWZmZXJHZW9tZXRyeSNpZFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQgKysgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIFVVSUQgb2YgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBmb3IgdmVydGljZXMgdG8gYmUgcmUtdXNlZCBhY3Jvc3MgbXVsdGlwbGUgdHJpYW5nbGVzOyB0aGlzIGlzXG5cdFx0ICogY2FsbGVkIHVzaW5nIFwiaW5kZXhlZCB0cmlhbmdsZXNcIi4gRWFjaCB0cmlhbmdsZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhlXG5cdFx0ICogaW5kaWNlcyBvZiB0aHJlZSB2ZXJ0aWNlcy4gVGhpcyBhdHRyaWJ1dGUgdGhlcmVmb3JlIHN0b3JlcyB0aGUgaW5kZXggb2Zcblx0XHQgKiBlYWNoIHZlcnRleCBmb3IgZWFjaCB0cmlhbmd1bGFyIGZhY2UuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBzZXQsIHRoZVxuXHRcdCAqIHJlbmRlcmVyIGFzc3VtZXMgdGhhdCBlYWNoIHRocmVlIGNvbnRpZ3VvdXMgcG9zaXRpb25zIHJlcHJlc2VudCBhIHNpbmdsZSB0cmlhbmdsZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/QnVmZmVyQXR0cmlidXRlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgKHN0b3JhZ2UpIGJ1ZmZlciBhdHRyaWJ1dGUgd2hpY2ggd2FzIGdlbmVyYXRlZCB3aXRoIGEgY29tcHV0ZSBzaGFkZXIgYW5kXG5cdFx0ICogbm93IGRlZmluZXMgaW5kaXJlY3QgZHJhdyBjYWxscy5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgV2ViR1BVUmVuZGVyZXJ9IGFuZCBhIFdlYkdQVSBiYWNrZW5kLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9CdWZmZXJBdHRyaWJ1dGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaW5kaXJlY3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkaWN0aW9uYXJ5IGhhcyBhcyBpZCB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGJlIHNldCBhbmQgYXMgdmFsdWVcblx0XHQgKiB0aGUgYnVmZmVyIGF0dHJpYnV0ZSB0byBzZXQgaXQgdG8uIFJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5LFxuXHRcdCAqIHVzZSBgc2V0QXR0cmlidXRlKClgIGFuZCBgZ2V0QXR0cmlidXRlKClgIHRvIGFjY2VzcyBhdHRyaWJ1dGVzIG9mIHRoaXMgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywoQnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKT59XG5cdFx0ICovXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGRpY3Rpb25hcnkgaG9sZHMgdGhlIG1vcnBoIHRhcmdldHMgb2YgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogTm90ZTogT25jZSB0aGUgZ2VvbWV0cnkgaGFzIGJlZW4gcmVuZGVyZWQsIHRoZSBtb3JwaCBhdHRyaWJ1dGUgZGF0YSBjYW5ub3Rcblx0XHQgKiBiZSBjaGFuZ2VkLiBZb3Ugd2lsbCBoYXZlIHRvIGNhbGwgYGRpc3Bvc2UoKT8sIGFuZCBjcmVhdGUgYSBuZXcgZ2VvbWV0cnkgaW5zdGFuY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGNvbnRyb2wgdGhlIG1vcnBoIHRhcmdldCBiZWhhdmlvcjsgd2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgbW9ycGhcblx0XHQgKiB0YXJnZXQgZGF0YSBpcyB0cmVhdGVkIGFzIHJlbGF0aXZlIG9mZnNldHMsIHJhdGhlciB0aGFuIGFzIGFic29sdXRlXG5cdFx0ICogcG9zaXRpb25zL25vcm1hbHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFNwbGl0IHRoZSBnZW9tZXRyeSBpbnRvIGdyb3VwcywgZWFjaCBvZiB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGluIGFcblx0XHQgKiBzZXBhcmF0ZSBkcmF3IGNhbGwuIFRoaXMgYWxsb3dzIGFuIGFycmF5IG9mIG1hdGVyaWFscyB0byBiZSB1c2VkIHdpdGggdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogVXNlIGBhZGRHcm91cCgpYCBhbmQgYGNsZWFyR3JvdXBzKClgIHRvIGVkaXQgZ3JvdXBzLCByYXRoZXIgdGhhbiBtb2RpZnlpbmcgdGhpcyBhcnJheSBkaXJlY3RseS5cblx0XHQgKlxuXHRcdCAqIEV2ZXJ5IHZlcnRleCBhbmQgaW5kZXggbXVzdCBiZWxvbmcgdG8gZXhhY3RseSBvbmUgZ3JvdXAg4oCUIGdyb3VwcyBtdXN0IG5vdCBzaGFyZSB2ZXJ0aWNlcyBvclxuXHRcdCAqIGluZGljZXMsIGFuZCBtdXN0IG5vdCBsZWF2ZSB2ZXJ0aWNlcyBvciBpbmRpY2VzIHVudXNlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuXHRcdCAqL1xuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBCb3VuZGluZyBib3ggZm9yIHRoZSBnZW9tZXRyeSB3aGljaCBjYW4gYmUgY2FsY3VsYXRlZCB3aXRoIGBjb21wdXRlQm91bmRpbmdCb3goKWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Qm94M31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBCb3VuZGluZyBzcGhlcmUgZm9yIHRoZSBnZW9tZXRyeSB3aGljaCBjYW4gYmUgY2FsY3VsYXRlZCB3aXRoIGBjb21wdXRlQm91bmRpbmdTcGhlcmUoKWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7U3BoZXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgdGhlIHBhcnQgb2YgdGhlIGdlb21ldHJ5IHRvIHJlbmRlci4gVGhpcyBzaG91bGQgbm90IGJlIHNldCBkaXJlY3RseSxcblx0XHQgKiBpbnN0ZWFkIHVzZSBgc2V0RHJhd1JhbmdlKClgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3tzdGFydDpudW1iZXIsY291bnQ6bnVtYmVyfX1cblx0XHQgKi9cblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgY3VzdG9tIGRhdGEgYWJvdXQgdGhlIGdlb21ldHJ5LlxuXHRcdCAqIEl0IHNob3VsZCBub3QgaG9sZCByZWZlcmVuY2VzIHRvIGZ1bmN0aW9ucyBhcyB0aGVzZSB3aWxsIG5vdCBiZSBjbG9uZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoaXMgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEByZXR1cm4gez9CdWZmZXJBdHRyaWJ1dGV9IFRoZSBpbmRleC4gUmV0dXJucyBgbnVsbGAgaWYgbm8gaW5kZXggaXMgZGVmaW5lZC5cblx0ICovXG5cdGdldEluZGV4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBpbmRleCB0byB0aGlzIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58QnVmZmVyQXR0cmlidXRlfSBpbmRleCAtIFRoZSBpbmRleCB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0SW5kZXgoIGluZGV4ICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kZXggKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBpbmRpcmVjdCBhdHRyaWJ1dGUgdG8gdGhpcyBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IGluZGlyZWN0IC0gVGhlIGF0dHJpYnV0ZSBob2xkaW5nIGluZGlyZWN0IGRyYXcgY2FsbHMuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0SW5kaXJlY3QoIGluZGlyZWN0ICkge1xuXG5cdFx0dGhpcy5pbmRpcmVjdCA9IGluZGlyZWN0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRpcmVjdCBhdHRyaWJ1dGUgb2YgdGhpcyBnZW9tZXRyeS5cblx0ICpcblx0ICogQHJldHVybiB7P0J1ZmZlckF0dHJpYnV0ZX0gVGhlIGluZGlyZWN0IGF0dHJpYnV0ZS4gUmV0dXJucyBgbnVsbGAgaWYgbm8gaW5kaXJlY3QgYXR0cmlidXRlIGlzIGRlZmluZWQuXG5cdCAqL1xuXHRnZXRJbmRpcmVjdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmluZGlyZWN0O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYnVmZmVyIGF0dHJpYnV0ZSBmb3IgdGhlIGdpdmVuIG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lLlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV8dW5kZWZpbmVkfSBUaGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBub3QgYXR0cmlidXRlIGhhcyBiZWVuIGZvdW5kLlxuXHQgKi9cblx0Z2V0QXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gbmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGUgLSBUaGUgYXR0cmlidXRlIHRvIHNldC5cblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoZSBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBuYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBkZWxldGUuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0ZGVsZXRlQXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGdlb21ldHJ5IGhhcyBhbiBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBuYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBhdHRyaWJ1dGUgbmFtZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGdlb21ldHJ5IGhhcyBhbiBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIG5vdC5cblx0ICovXG5cdGhhc0F0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGdyb3VwIHRvIHRoaXMgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgZHJhdyBjYWxsLiBUaGF0IGlzIHRoZSBmaXJzdFxuXHQgKiB2ZXJ0ZXggZm9yIG5vbi1pbmRleGVkIGdlb21ldHJ5LCBvdGhlcndpc2UgdGhlIGZpcnN0IHRyaWFuZ2xlIGluZGV4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBTcGVjaWZpZXMgaG93IG1hbnkgdmVydGljZXMgKG9yIGluZGljZXMpIGFyZSBwYXJ0IG9mIHRoaXMgZ3JvdXAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWF0ZXJpYWxJbmRleD0wXSAtIFRoZSBtYXRlcmlhbCBhcnJheSBpbmRleCB0byB1c2UuXG5cdCAqL1xuXHRhZGRHcm91cCggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ID0gMCApIHtcblxuXHRcdHRoaXMuZ3JvdXBzLnB1c2goIHtcblxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0Y291bnQ6IGNvdW50LFxuXHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBncm91cHMuXG5cdCAqL1xuXHRjbGVhckdyb3VwcygpIHtcblxuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkcmF3IHJhbmdlIGZvciB0aGlzIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgZmlyc3QgdmVydGV4IGZvciBub24taW5kZXhlZCBnZW9tZXRyeSwgb3RoZXJ3aXNlIHRoZSBmaXJzdCB0cmlhbmdsZSBpbmRleC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gRm9yIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LCBgY291bnRgIGlzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgdG8gcmVuZGVyLlxuXHQgKiBGb3IgaW5kZXhlZCBCdWZmZXJHZW9tZXRyeSwgYGNvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGluZGljZXMgdG8gcmVuZGVyLlxuXHQgKi9cblx0c2V0RHJhd1JhbmdlKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBnaXZlbiA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHRoZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGFwcGx5LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvc2l0aW9uLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0YW5nZW50ID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cblx0XHRpZiAoIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGFuZ2VudC50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR0YW5nZW50Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgcm90YXRpb24gcmVwcmVzZW50ZWQgYnkgdGhlIFF1YXRlcm5pb24gdG8gdGhlIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgLSBUaGUgUXVhdGVybmlvbiB0byBhcHBseS5cblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGUgZ2VvbWV0cnkgYWJvdXQgdGhlIFggYXhpcy4gVGhpcyBpcyB0eXBpY2FsbHkgZG9uZSBhcyBhIG9uZSB0aW1lXG5cdCAqIG9wZXJhdGlvbiwgYW5kIG5vdCBkdXJpbmcgYSBsb29wLiBVc2Uge0BsaW5rIE9iamVjdDNEI3JvdGF0aW9ufSBmb3IgdHlwaWNhbFxuXHQgKiByZWFsLXRpbWUgbWVzaCByb3RhdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXG5cdFx0X20xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIGdlb21ldHJ5IGFib3V0IHRoZSBZIGF4aXMuIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgYXMgYSBvbmUgdGltZVxuXHQgKiBvcGVyYXRpb24sIGFuZCBub3QgZHVyaW5nIGEgbG9vcC4gVXNlIHtAbGluayBPYmplY3QzRCNyb3RhdGlvbn0gZm9yIHR5cGljYWxcblx0ICogcmVhbC10aW1lIG1lc2ggcm90YXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuXHRcdF9tMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSb3RhdGVzIHRoZSBnZW9tZXRyeSBhYm91dCB0aGUgWiBheGlzLiBUaGlzIGlzIHR5cGljYWxseSBkb25lIGFzIGEgb25lIHRpbWVcblx0ICogb3BlcmF0aW9uLCBhbmQgbm90IGR1cmluZyBhIGxvb3AuIFVzZSB7QGxpbmsgT2JqZWN0M0Qjcm90YXRpb259IGZvciB0eXBpY2FsXG5cdCAqIHJlYWwtdGltZSBtZXNoIHJvdGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRyb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgZ2VvbWV0cnkuIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgYXMgYSBvbmUgdGltZVxuXHQgKiBvcGVyYXRpb24sIGFuZCBub3QgZHVyaW5nIGEgbG9vcC4gVXNlIHtAbGluayBPYmplY3QzRCNwb3NpdGlvbn0gZm9yIHR5cGljYWxcblx0ICogcmVhbC10aW1lIG1lc2ggcm90YXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggb2Zmc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiBvZmZzZXQuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0dHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cblx0XHRfbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNjYWxlcyB0aGUgZ2VvbWV0cnkuIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgYXMgYSBvbmUgdGltZVxuXHQgKiBvcGVyYXRpb24sIGFuZCBub3QgZHVyaW5nIGEgbG9vcC4gVXNlIHtAbGluayBPYmplY3QzRCNzY2FsZX0gZm9yIHR5cGljYWxcblx0ICogcmVhbC10aW1lIG1lc2ggcm90YXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggc2NhbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgc2NhbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHogc2NhbGUuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG5cdFx0X20xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSb3RhdGVzIHRoZSBnZW9tZXRyeSB0byBmYWNlIGEgcG9pbnQgaW4gM0Qgc3BhY2UuIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgYXMgYSBvbmUgdGltZVxuXHQgKiBvcGVyYXRpb24sIGFuZCBub3QgZHVyaW5nIGEgbG9vcC4gVXNlIHtAbGluayBPYmplY3QzRCNsb29rQXR9IGZvciB0eXBpY2FsXG5cdCAqIHJlYWwtdGltZSBtZXNoIHJvdGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHZlY3RvciAtIFRoZSB0YXJnZXQgcG9pbnQuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0bG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRfb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9vYmoubWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENlbnRlciB0aGUgZ2VvbWV0cnkgYmFzZWQgb24gaXRzIGJvdW5kaW5nIGJveC5cblx0ICpcblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjZW50ZXIoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIF9vZmZzZXQgKS5uZWdhdGUoKTtcblxuXHRcdHRoaXMudHJhbnNsYXRlKCBfb2Zmc2V0LngsIF9vZmZzZXQueSwgX29mZnNldC56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBnZW9tZXRyeSBieSBjcmVhdGluZyBhIGBwb3NpdGlvbmAgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuIFRoZSBhcnJheVxuXHQgKiBjYW4gaG9sZCAyRCBvciAzRCB2ZWN0b3JzLiBXaGVuIHVzaW5nIHR3by1kaW1lbnNpb25hbCBkYXRhLCB0aGUgYHpgIGNvb3JkaW5hdGUgZm9yIGFsbCB2ZXJ0aWNlcyBpc1xuXHQgKiBzZXQgdG8gYDBgLlxuXHQgKlxuXHQgKiBJZiB0aGUgbWV0aG9kIGlzIHVzZWQgd2l0aCBhbiBleGlzdGluZyBgcG9zaXRpb25gIGF0dHJpYnV0ZSwgdGhlIHZlcnRleCBkYXRhIGFyZSBvdmVyd3JpdHRlbiB3aXRoIHRoZVxuXHQgKiBkYXRhIGZyb20gdGhlIGFycmF5LiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBtdXN0IG1hdGNoIHRoZSB2ZXJ0ZXggY291bnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMj58QXJyYXk8VmVjdG9yMz59IHBvaW50cyAtIFRoZSBwb2ludHMuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0aWYgKCBwb3NpdGlvbkF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGwgPSBNYXRoLm1pbiggcG9pbnRzLmxlbmd0aCwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKTsgLy8gbWFrZSBzdXJlIGRhdGEgZG8gbm90IGV4Y2VlZCBidWZmZXIgc2l6ZVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLnNldFhZWiggaSwgcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IEJ1ZmZlciBzaXplIHRvbyBzbWFsbCBmb3IgcG9pbnRzIGRhdGEuIFVzZSAuZGlzcG9zZSgpIGFuZCBjcmVhdGUgYSBuZXcgZ2VvbWV0cnkuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZ2VvbWV0cnksIGFuZCB1cGRhdGVzIHRoZSBgYm91bmRpbmdCb3hgIG1lbWJlci5cblx0ICogVGhlIGJvdW5kaW5nIGJveCBpcyBub3QgY29tcHV0ZWQgYnkgdGhlIGVuZ2luZTsgaXQgbXVzdCBiZSBjb21wdXRlZCBieSB5b3VyIGFwcC5cblx0ICogWW91IG1heSBuZWVkIHRvIHJlY29tcHV0ZSB0aGUgYm91bmRpbmcgYm94IGlmIHRoZSBnZW9tZXRyeSB2ZXJ0aWNlcyBhcmUgbW9kaWZpZWQuXG5cdCAqL1xuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guJywgdGhpcyApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldChcblx0XHRcdFx0bmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSxcblx0XHRcdFx0bmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdF9ib3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCB0aGlzLmJvdW5kaW5nQm94Lm1pbiwgX2JveC5taW4gKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWF4LCBfYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF9ib3gubWluICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF9ib3gubWF4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgc3BoZXJlIG9mIHRoZSBnZW9tZXRyeSwgYW5kIHVwZGF0ZXMgdGhlIGBib3VuZGluZ1NwaGVyZWAgbWVtYmVyLlxuXHQgKiBUaGUgZW5naW5lIGF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSB3aGVuIGl0IGlzIG5lZWRlZCwgZS5nLiwgZm9yIHJheSBjYXN0aW5nIG9yIHZpZXcgZnJ1c3R1bSBjdWxsaW5nLlxuXHQgKiBZb3UgbWF5IG5lZWQgdG8gcmVjb21wdXRlIHRoZSBib3VuZGluZyBzcGhlcmUgaWYgdGhlIGdlb21ldHJ5IHZlcnRpY2VzIGFyZSBtb2RpZmllZC5cblx0ICovXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQoIG5ldyBWZWN0b3IzKCksIEluZmluaXR5ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRfYm94TW9ycGhUYXJnZXRzLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggX2JveC5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCBfYm94Lm1heCwgX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1pbiApO1xuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94LmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaiApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yLmFkZCggX29mZnNldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIGFuZCBhZGRzIGEgdGFuZ2VudCBhdHRyaWJ1dGUgdG8gdGhpcyBnZW9tZXRyeS5cblx0ICpcblx0ICogVGhlIGNvbXB1dGF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBpbmRleGVkIGdlb21ldHJpZXMgYW5kIGlmIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB1diBhdHRyaWJ1dGVzXG5cdCAqIGFyZSBkZWZpbmVkLiBXaGVuIHVzaW5nIGEgdGFuZ2VudCBzcGFjZSBub3JtYWwgbWFwLCBwcmVmZXIgdGhlIE1pa2tUU3BhY2UgYWxnb3JpdGhtIHByb3ZpZGVkIGJ5XG5cdCAqIHtAbGluayBCdWZmZXJHZW9tZXRyeVV0aWxzI2NvbXB1dGVNaWtrVFNwYWNlVGFuZ2VudHN9IGluc3RlYWQuXG5cdCAqL1xuXHRjb21wdXRlVGFuZ2VudHMoKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cblx0XHRpZiAoIGluZGV4ID09PSBudWxsIHx8XG5cdFx0XHQgYXR0cmlidXRlcy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0IGF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgZmFpbGVkLiBNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KScgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRjb25zdCB1dkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudXY7XG5cblx0XHRpZiAoIHRoaXMuaGFzQXR0cmlidXRlKCAndGFuZ2VudCcgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCApLCA0ICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnRBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3RhbmdlbnQnICk7XG5cblx0XHRjb25zdCB0YW4xID0gW10sIHRhbjIgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0YW4xWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGFuMlsgaSBdID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZBID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHZCID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHZDID0gbmV3IFZlY3RvcjMoKSxcblxuXHRcdFx0dXZBID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QiA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHR1dkMgPSBuZXcgVmVjdG9yMigpLFxuXG5cdFx0XHRzZGlyID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdHRkaXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBhICk7XG5cdFx0XHR2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYiApO1xuXHRcdFx0dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGMgKTtcblxuXHRcdFx0dXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2QXR0cmlidXRlLCBhICk7XG5cdFx0XHR1dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZBdHRyaWJ1dGUsIGIgKTtcblx0XHRcdHV2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dkF0dHJpYnV0ZSwgYyApO1xuXG5cdFx0XHR2Qi5zdWIoIHZBICk7XG5cdFx0XHR2Qy5zdWIoIHZBICk7XG5cblx0XHRcdHV2Qi5zdWIoIHV2QSApO1xuXHRcdFx0dXZDLnN1YiggdXZBICk7XG5cblx0XHRcdGNvbnN0IHIgPSAxLjAgLyAoIHV2Qi54ICogdXZDLnkgLSB1dkMueCAqIHV2Qi55ICk7XG5cblx0XHRcdC8vIHNpbGVudGx5IGlnbm9yZSBkZWdlbmVyYXRlIHV2IHRyaWFuZ2xlcyBoYXZpbmcgY29pbmNpZGVudCBvciBjb2xpbmVhciB2ZXJ0aWNlc1xuXG5cdFx0XHRpZiAoICEgaXNGaW5pdGUoIHIgKSApIHJldHVybjtcblxuXHRcdFx0c2Rpci5jb3B5KCB2QiApLm11bHRpcGx5U2NhbGFyKCB1dkMueSApLmFkZFNjYWxlZFZlY3RvciggdkMsIC0gdXZCLnkgKS5tdWx0aXBseVNjYWxhciggciApO1xuXHRcdFx0dGRpci5jb3B5KCB2QyApLm11bHRpcGx5U2NhbGFyKCB1dkIueCApLmFkZFNjYWxlZFZlY3RvciggdkIsIC0gdXZDLnggKS5tdWx0aXBseVNjYWxhciggciApO1xuXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBiIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XG5cblx0XHRcdHRhbjJbIGEgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcblxuXHRcdH1cblxuXHRcdGxldCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Z3JvdXBzID0gWyB7XG5cdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRjb3VudDogaW5kZXguY291bnRcblx0XHRcdH0gXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKFxuXHRcdFx0XHRcdGluZGV4LmdldFgoIGogKyAwICksXG5cdFx0XHRcdFx0aW5kZXguZ2V0WCggaiArIDEgKSxcblx0XHRcdFx0XHRpbmRleC5nZXRYKCBqICsgMiApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHRtcCA9IG5ldyBWZWN0b3IzKCksIHRtcDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG4gPSBuZXcgVmVjdG9yMygpLCBuMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgoIHYgKSB7XG5cblx0XHRcdG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2ICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdGNvbnN0IHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0Y29uc3QgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRBdHRyaWJ1dGUuc2V0WFlaVyggdiwgdG1wLngsIHRtcC55LCB0bXAueiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRleC5nZXRYKCBqICsgMCApICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kZXguZ2V0WCggaiArIDEgKSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGV4LmdldFgoIGogKyAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdmVydGV4IG5vcm1hbHMgZm9yIHRoZSBnaXZlbiB2ZXJ0ZXggZGF0YS4gRm9yIGluZGV4ZWQgZ2VvbWV0cmllcywgdGhlIG1ldGhvZCBzZXRzXG5cdCAqIGVhY2ggdmVydGV4IG5vcm1hbCB0byBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBmYWNlcyB0aGF0IHNoYXJlIHRoYXQgdmVydGV4LlxuXHQgKiBGb3Igbm9uLWluZGV4ZWQgZ2VvbWV0cmllcywgdmVydGljZXMgYXJlIG5vdCBzaGFyZWQsIGFuZCB0aGUgbWV0aG9kIHNldHMgZWFjaCB2ZXJ0ZXggbm9ybWFsXG5cdCAqIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBmYWNlIG5vcm1hbC5cblx0ICovXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGlmICggcG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IG5vcm1hbEF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnbm9ybWFsJyApO1xuXG5cdFx0XHRpZiAoIG5vcm1hbEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogMyApLCAzICk7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbEF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbkEgPSBuZXcgVmVjdG9yMygpLCBuQiA9IG5ldyBWZWN0b3IzKCksIG5DID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGluZGV4LmNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZBID0gaW5kZXguZ2V0WCggaSArIDAgKTtcblx0XHRcdFx0XHRjb25zdCB2QiA9IGluZGV4LmdldFgoIGkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgdkMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xuXG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZBICk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZCICk7XG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZDICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5BLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkEgKTtcblx0XHRcdFx0XHRuQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZCICk7XG5cdFx0XHRcdFx0bkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QyApO1xuXG5cdFx0XHRcdFx0bkEuYWRkKCBjYiApO1xuXHRcdFx0XHRcdG5CLmFkZCggY2IgKTtcblx0XHRcdFx0XHRuQy5hZGQoIGNiICk7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QSwgbkEueCwgbkEueSwgbkEueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZCLCBuQi54LCBuQi55LCBuQi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkMsIG5DLngsIG5DLnksIG5DLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMCApO1xuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSApO1xuXHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMiApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMCwgY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAxLCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDIsIGNiLngsIGNiLnksIGNiLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XG5cblx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmVzIGV2ZXJ5IG5vcm1hbCB2ZWN0b3IgaW4gYSBnZW9tZXRyeSB3aWxsIGhhdmUgYSBtYWduaXR1ZGUgb2YgYDFgLiBUaGlzIHdpbGxcblx0ICogY29ycmVjdCBsaWdodGluZyBvbiB0aGUgZ2VvbWV0cnkgc3VyZmFjZXMuXG5cdCAqL1xuXHRub3JtYWxpemVOb3JtYWxzKCkge1xuXG5cdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFscy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIG5ldyBub24taW5kZXggdmVyc2lvbiBvZiB0aGlzIGluZGV4ZWQgZ2VvbWV0cnkuIElmIHRoZSBnZW9tZXRyeVxuXHQgKiBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLCB0aGUgbWV0aG9kIGlzIGEgTk9PUC5cblx0ICpcblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IFRoZSBub24taW5kZXhlZCB2ZXJzaW9uIG9mIHRoaXMgaW5kZXhlZCBnZW9tZXRyeS5cblx0ICovXG5cdHRvTm9uSW5kZXhlZCgpIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRcdFx0Y29uc3QgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGljZXMgKTtcblxuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2goIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG1vcnBoQXJyYXk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBnZW9tZXRyeSBpbnRvIEpTT04uXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqL1xuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZm9yIHNpbXBsaWNpdHkgdGhlIGNvZGUgYXNzdW1lcyBhdHRyaWJ1dGVzIGFyZSBub3Qgc2hhcmVkIGFjcm9zcyBnZW9tZXRyaWVzLCBzZWUgIzE1ODExXG5cblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XG5cdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggaW5kZXguYXJyYXkgKVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IGF0dHJpYnV0ZS50b0pTT04oIGRhdGEuZGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0bGV0IGhhc01vcnBoQXR0cmlidXRlcyA9IGZhbHNlO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHRoaXMubW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheSA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZUFycmF5WyBpIF07XG5cblx0XHRcdFx0YXJyYXkucHVzaCggYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0bW9ycGhBdHRyaWJ1dGVzWyBrZXkgXSA9IGFycmF5O1xuXG5cdFx0XHRcdGhhc01vcnBoQXR0cmlidXRlcyA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaGFzTW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRkYXRhLmRhdGEubW9ycGhBdHRyaWJ1dGVzID0gbW9ycGhBdHRyaWJ1dGVzO1xuXHRcdFx0ZGF0YS5kYXRhLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xuXHRcdFx0XHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGdlb21ldHJ5IHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBnZW9tZXRyeSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBzb3VyY2UgLSBUaGUgZ2VvbWV0cnkgdG8gY29weS5cblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHQvLyByZXNldFxuXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0Ly8gdXNlZCBmb3Igc3RvcmluZyBjbG9uZWQsIHNoYXJlZCBkYXRhXG5cblx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHQvLyBuYW1lXG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdC8vIGluZGV4XG5cblx0XHRjb25zdCBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSggZGF0YSApICk7XG5cblx0XHR9XG5cblx0XHQvLyBtb3JwaCBhdHRyaWJ1dGVzXG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBzb3VyY2UubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBtb3JwaEF0dHJpYnV0ZVsgaSBdLmNsb25lKCBkYXRhICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gc291cmNlLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdC8vIGJvdW5kaW5nIGJveFxuXG5cdFx0Y29uc3QgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XG5cblx0XHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdC8vIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdC8vIGRyYXcgcmFuZ2VcblxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IHNvdXJjZS5kcmF3UmFuZ2UuY291bnQ7XG5cblx0XHQvLyB1c2VyIGRhdGFcblxuXHRcdHRoaXMudXNlckRhdGEgPSBzb3VyY2UudXNlckRhdGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZyZWVzIHRoZSBHUFUtcmVsYXRlZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpc1xuXHQgKiBtZXRob2Qgd2hlbmV2ZXIgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgdXNlZCBpbiB5b3VyIGFwcC5cblx0ICpcblx0ICogQGZpcmVzIEJ1ZmZlckdlb21ldHJ5I2Rpc3Bvc2Vcblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgQmFja1NpZGUsIEZyb250U2lkZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcbmNvbnN0IF9zcGhlcmVIaXRBdCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3ZBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZCID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZDID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdGVtcEEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbW9ycGhBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdHJpYW5ndWxhciBwb2x5Z29uIG1lc2ggYmFzZWQgb2JqZWN0cy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIDEsIDEsIDEgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gKiBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBtZXNoICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgTWVzaCBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtZXNoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBbZ2VvbWV0cnldIC0gVGhlIG1lc2ggZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx8QXJyYXk8TWF0ZXJpYWw+fSBbbWF0ZXJpYWxdIC0gVGhlIG1lc2ggbWF0ZXJpYWwuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaCc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWVzaCBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtCdWZmZXJHZW9tZXRyeX1cblx0XHQgKi9cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWVzaCBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtNYXRlcmlhbHxBcnJheTxNYXRlcmlhbD59XG5cdFx0ICogQGRlZmF1bHQgTWVzaEJhc2ljTWF0ZXJpYWxcblx0XHQgKi9cblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHQvKipcblx0XHQgKiBBIGRpY3Rpb25hcnkgcmVwcmVzZW50aW5nIHRoZSBtb3JwaCB0YXJnZXRzIGluIHRoZSBnZW9tZXRyeS4gVGhlIGtleSBpcyB0aGVcblx0XHQgKiBtb3JwaCB0YXJnZXRzIG5hbWUsIHRoZSB2YWx1ZSBpdHMgYXR0cmlidXRlIGluZGV4LiBUaGlzIG1lbWJlciBpcyBgdW5kZWZpbmVkYFxuXHRcdCAqIGJ5IGRlZmF1bHQgYW5kIG9ubHkgc2V0IHdoZW4gbW9ycGggdGFyZ2V0cyBhcmUgZGV0ZWN0ZWQgaW4gdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsbnVtYmVyPnx1bmRlZmluZWR9XG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB1bmRlZmluZWQ7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB3ZWlnaHRzIHR5cGljYWxseSBpbiB0aGUgcmFuZ2UgYFswLDFdYCB0aGF0IHNwZWNpZnkgaG93IG11Y2ggb2YgdGhlIG1vcnBoXG5cdFx0ICogaXMgYXBwbGllZC4gVGhpcyBtZW1iZXIgaXMgYHVuZGVmaW5lZGAgYnkgZGVmYXVsdCBhbmQgb25seSBzZXQgd2hlbiBtb3JwaCB0YXJnZXRzIGFyZVxuXHRcdCAqIGRldGVjdGVkIGluIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggc291cmNlLm1hdGVyaWFsICkgPyBzb3VyY2UubWF0ZXJpYWwuc2xpY2UoKSA6IHNvdXJjZS5tYXRlcmlhbDtcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZXMgb2Yge0BsaW5rIE1lc2gjbW9ycGhUYXJnZXREaWN0aW9uYXJ5fSBhbmQge0BsaW5rIE1lc2gjbW9ycGhUYXJnZXRJbmZsdWVuY2VzfVxuXHQgKiB0byBtYWtlIHN1cmUgZXhpc3RpbmcgbW9ycGggdGFyZ2V0cyBjYW4gaW5mbHVlbmNlIHRoaXMgM0Qgb2JqZWN0LlxuXHQgKi9cblx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XG5cblx0XHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIGtleXNbIDAgXSBdO1xuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xuXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gPSBtO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYWwtc3BhY2UgcG9zaXRpb24gb2YgdGhlIHZlcnRleCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIHRha2luZyBpbnRvXG5cdCAqIGFjY291bnQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIG9mIGJvdGggbW9ycGggdGFyZ2V0cyBhbmQgc2tpbm5pbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSB2ZXJ0ZXggaW5kZXguXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSB2ZXJ0ZXggcG9zaXRpb24gaW4gbG9jYWwgc3BhY2UuXG5cdCAqL1xuXHRnZXRWZXJ0ZXhQb3NpdGlvbiggaW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0dGFyZ2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleCApO1xuXG5cdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRpZiAoIG1vcnBoUG9zaXRpb24gJiYgbW9ycGhJbmZsdWVuY2VzICkge1xuXG5cdFx0XHRfbW9ycGhBLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIGkgXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaFBvc2l0aW9uWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGluZGV4ICk7XG5cblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcEEsIGluZmx1ZW5jZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLnN1YiggdGFyZ2V0ICksIGluZmx1ZW5jZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQuYWRkKCBfbW9ycGhBICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIGEgY2FzdGVkIHJheSBhbmQgdGhpcyBsaW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1JheWNhc3Rlcn0gcmF5Y2FzdGVyIC0gVGhlIHJheWNhc3Rlci5cblx0ICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBpbnRlcnNlY3RzIC0gVGhlIHRhcmdldCBhcnJheSB0aGF0IGhvbGRzIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuXHQgKi9cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHQvLyB0ZXN0IHdpdGggYm91bmRpbmcgc3BoZXJlIGluIHdvcmxkIHNwYWNlXG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHQvLyBjaGVjayBkaXN0YW5jZSBmcm9tIHJheSBvcmlnaW4gdG8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRfcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5yZWNhc3QoIHJheWNhc3Rlci5uZWFyICk7XG5cblx0XHRpZiAoIF9zcGhlcmUuY29udGFpbnNQb2ludCggX3JheS5vcmlnaW4gKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggX3JheS5pbnRlcnNlY3RTcGhlcmUoIF9zcGhlcmUsIF9zcGhlcmVIaXRBdCApID09PSBudWxsICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIF9yYXkub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBfc3BoZXJlSGl0QXQgKSA+ICggcmF5Y2FzdGVyLmZhciAtIHJheWNhc3Rlci5uZWFyICkgKiogMiApIHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgcmF5IHRvIGxvY2FsIHNwYWNlIG9mIG1lc2hcblxuXHRcdF9pbnZlcnNlTWF0cml4LmNvcHkoIG1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIGJveCBpbiBsb2NhbCBzcGFjZVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBfcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGdlb21ldHJ5XG5cblx0XHR0aGlzLl9jb21wdXRlSW50ZXJzZWN0aW9ucyggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBfcmF5ICk7XG5cblx0fVxuXG5cdF9jb21wdXRlSW50ZXJzZWN0aW9ucyggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByYXlMb2NhbFNwYWNlICkge1xuXG5cdFx0bGV0IGludGVyc2VjdGlvbjtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XG5cdFx0Y29uc3QgdXYxID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djE7XG5cdFx0Y29uc3Qgbm9ybWFsID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggaW5kZXguY291bnQsIE1hdGgubWluKCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApICk7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBqICk7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaiArIDEgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleC5nZXRYKCBqICsgMiApO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIHJheUxvY2FsU3BhY2UsIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaiAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXAubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoIGkgKTtcblx0XHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheUxvY2FsU3BhY2UsIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggcG9zaXRpb24uY291bnQsIE1hdGgubWluKCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApICk7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBqO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGogKyAxO1xuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IGogKyAyO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIHJheUxvY2FsU3BhY2UsIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaiAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIG5vbi1pbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbi5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSBpO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpICsgMTtcblx0XHRcdFx0XHRjb25zdCBjID0gaSArIDI7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXlMb2NhbFNwYWNlLCB1diwgdXYxLCBub3JtYWwsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIG5vbi1pbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKSB7XG5cblx0bGV0IGludGVyc2VjdDtcblxuXHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xuXG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsICggbWF0ZXJpYWwuc2lkZSA9PT0gRnJvbnRTaWRlICksIHBvaW50ICk7XG5cblx0fVxuXG5cdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0X2ludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcblx0X2ludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cblx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xuXG5cdHJldHVybiB7XG5cdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdHBvaW50OiBfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuXHRcdG9iamVjdDogb2JqZWN0XG5cdH07XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApIHtcblxuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGEsIF92QSApO1xuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGIsIF92QiApO1xuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGMsIF92QyApO1xuXG5cdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgX3ZBLCBfdkIsIF92QywgX2ludGVyc2VjdGlvblBvaW50ICk7XG5cblx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRjb25zdCBiYXJ5Y29vcmQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFRyaWFuZ2xlLmdldEJhcnljb29yZCggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBiYXJ5Y29vcmQgKTtcblxuXHRcdGlmICggdXYgKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRlZEF0dHJpYnV0ZSggdXYsIGEsIGIsIGMsIGJhcnljb29yZCwgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1djEgKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi51djEgPSBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0ZWRBdHRyaWJ1dGUoIHV2MSwgYSwgYiwgYywgYmFyeWNvb3JkLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRlZEF0dHJpYnV0ZSggbm9ybWFsLCBhLCBiLCBjLCBiYXJ5Y29vcmQsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubm9ybWFsLmRvdCggcmF5LmRpcmVjdGlvbiApID4gMCApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmFjZSA9IHtcblx0XHRcdGE6IGEsXG5cdFx0XHRiOiBiLFxuXHRcdFx0YzogYyxcblx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IDBcblx0XHR9O1xuXG5cdFx0VHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEsIF92QiwgX3ZDLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xuXHRcdGludGVyc2VjdGlvbi5iYXJ5Y29vcmQgPSBiYXJ5Y29vcmQ7XG5cblx0fVxuXG5cdHJldHVybiBpbnRlcnNlY3Rpb247XG5cbn1cblxuZXhwb3J0IHsgTWVzaCB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBBIGdlb21ldHJ5IGNsYXNzIGZvciBhIHJlY3Rhbmd1bGFyIGN1Ym9pZCB3aXRoIGEgZ2l2ZW4gd2lkdGgsIGhlaWdodCwgYW5kIGRlcHRoLlxuICogT24gY3JlYXRpb24sIHRoZSBjdWJvaWQgaXMgY2VudHJlZCBvbiB0aGUgb3JpZ2luLCB3aXRoIGVhY2ggZWRnZSBwYXJhbGxlbCB0byBvbmVcbiAqIG9mIHRoZSBheGVzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MDBmZjAwIH0gKTtcbiAqIGNvbnN0IGN1YmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBzY2VuZS5hZGQoIGN1YmUgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJHZW9tZXRyeVxuICovXG5jbGFzcyBCb3hHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBib3ggZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgd2lkdGguIFRoYXQgaXMsIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2VzIHBhcmFsbGVsIHRvIHRoZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodC4gVGhhdCBpcywgdGhlIGxlbmd0aCBvZiB0aGUgZWRnZXMgcGFyYWxsZWwgdG8gdGhlIFkgYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSAtIFRoZSBkZXB0aC4gVGhhdCBpcywgdGhlIGxlbmd0aCBvZiB0aGUgZWRnZXMgcGFyYWxsZWwgdG8gdGhlIFogYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aFNlZ21lbnRzPTFdIC0gTnVtYmVyIG9mIHNlZ21lbnRlZCByZWN0YW5ndWxhciBmYWNlcyBhbG9uZyB0aGUgd2lkdGggb2YgdGhlIHNpZGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodFNlZ21lbnRzPTFdIC0gTnVtYmVyIG9mIHNlZ21lbnRlZCByZWN0YW5ndWxhciBmYWNlcyBhbG9uZyB0aGUgaGVpZ2h0IG9mIHRoZSBzaWRlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aFNlZ21lbnRzPTFdIC0gTnVtYmVyIG9mIHNlZ21lbnRlZCByZWN0YW5ndWxhciBmYWNlcyBhbG9uZyB0aGUgZGVwdGggb2YgdGhlIHNpZGVzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxLCBkZXB0aFNlZ21lbnRzID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRkZXB0aDogZGVwdGgsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuXHRcdH07XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHQvLyBzZWdtZW50c1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cdFx0ZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIGRlcHRoU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCBudW1iZXJPZlZlcnRpY2VzID0gMDtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEgKTsgLy8gbnhcblx0XHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMiApOyAvLyBweVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMyApOyAvLyBueVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1ICk7IC8vIG56XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0XHRjb25zdCBzZWdtZW50SGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHRcdGNvbnN0IHdpZHRoSGFsZiA9IHdpZHRoIC8gMjtcblx0XHRcdGNvbnN0IGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXHRcdFx0Y29uc3QgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuXG5cdFx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cblx0XHRcdGxldCB2ZXJ0ZXhDb3VudGVyID0gMDtcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cblx0XHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudFdpZHRoIC0gd2lkdGhIYWxmO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHRcdHZlY3RvclsgdSBdID0geCAqIHVkaXI7XG5cdFx0XHRcdFx0dmVjdG9yWyB2IF0gPSB5ICogdmRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcblxuXHRcdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gdmVydGV4IGJ1ZmZlclxuXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuXHRcdFx0XHRcdHZlY3RvclsgdSBdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IDA7XG5cdFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcblxuXHRcdFx0XHRcdC8vIHV2c1xuXG5cdFx0XHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcblx0XHRcdFx0XHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XG5cblx0XHRcdFx0XHQvLyBjb3VudGVyc1xuXG5cdFx0XHRcdFx0dmVydGV4Q291bnRlciArPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXG5cdFx0XHQvLyAyLiBhIHNpbmdsZSBzZWdtZW50IGNvbnNpc3RzIG9mIHR3byBmYWNlc1xuXHRcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG5cdFx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0XHRjb25zdCBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0Ly8gaW5jcmVhc2UgY291bnRlclxuXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG5cdFx0XHQvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXG5cblx0XHRcdG51bWJlck9mVmVydGljZXMgKz0gdmVydGV4Q291bnRlcjtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge0JveEdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQm94R2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBCb3hHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQ29sb3JNYW5hZ2VtZW50IH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvck1hbmFnZW1lbnQuanMnO1xuXG4vLyBVbmlmb3JtIFV0aWxpdGllc1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVVbmlmb3Jtcyggc3JjICkge1xuXG5cdGNvbnN0IGRzdCA9IHt9O1xuXG5cdGZvciAoIGNvbnN0IHUgaW4gc3JjICkge1xuXG5cdFx0ZHN0WyB1IF0gPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IHAgaW4gc3JjWyB1IF0gKSB7XG5cblx0XHRcdGNvbnN0IHByb3BlcnR5ID0gc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eSAmJiAoIHByb3BlcnR5LmlzQ29sb3IgfHxcblx0XHRcdFx0cHJvcGVydHkuaXNNYXRyaXgzIHx8IHByb3BlcnR5LmlzTWF0cml4NCB8fFxuXHRcdFx0XHRwcm9wZXJ0eS5pc1ZlY3RvcjIgfHwgcHJvcGVydHkuaXNWZWN0b3IzIHx8IHByb3BlcnR5LmlzVmVjdG9yNCB8fFxuXHRcdFx0XHRwcm9wZXJ0eS5pc1RleHR1cmUgfHwgcHJvcGVydHkuaXNRdWF0ZXJuaW9uICkgKSB7XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eS5pc1JlbmRlclRhcmdldFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdVbmlmb3Jtc1V0aWxzOiBUZXh0dXJlcyBvZiByZW5kZXIgdGFyZ2V0cyBjYW5ub3QgYmUgY2xvbmVkIHZpYSBjbG9uZVVuaWZvcm1zKCkgb3IgbWVyZ2VVbmlmb3JtcygpLicgKTtcblx0XHRcdFx0XHRkc3RbIHUgXVsgcCBdID0gbnVsbDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IHByb3BlcnR5LmNsb25lKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwcm9wZXJ0eSApICkge1xuXG5cdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eS5zbGljZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZHN0O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVVuaWZvcm1zKCB1bmlmb3JtcyApIHtcblxuXHRjb25zdCBtZXJnZWQgPSB7fTtcblxuXHRmb3IgKCBsZXQgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XG5cblx0XHRjb25zdCB0bXAgPSBjbG9uZVVuaWZvcm1zKCB1bmlmb3Jtc1sgdSBdICk7XG5cblx0XHRmb3IgKCBjb25zdCBwIGluIHRtcCApIHtcblxuXHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIG1lcmdlZDtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVVbmlmb3Jtc0dyb3Vwcyggc3JjICkge1xuXG5cdGNvbnN0IGRzdCA9IFtdO1xuXG5cdGZvciAoIGxldCB1ID0gMDsgdSA8IHNyYy5sZW5ndGg7IHUgKysgKSB7XG5cblx0XHRkc3QucHVzaCggc3JjWyB1IF0uY2xvbmUoKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gZHN0O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmxpdFVuaWZvcm1Db2xvclNwYWNlKCByZW5kZXJlciApIHtcblxuXHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0aWYgKCBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsICkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzOTM3I2lzc3VlY29tbWVudC0xMTExMDY3Mzk4XG5cdFx0cmV0dXJuIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzI3ODY4XG5cdGlmICggY3VycmVudFJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlICkge1xuXG5cdFx0cmV0dXJuIGN1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlO1xuXG5cdH1cblxuXHRyZXR1cm4gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlO1xuXG59XG5cbi8vIExlZ2FjeVxuXG5jb25zdCBVbmlmb3Jtc1V0aWxzID0geyBjbG9uZTogY2xvbmVVbmlmb3JtcywgbWVyZ2U6IG1lcmdlVW5pZm9ybXMgfTtcblxuZXhwb3J0IHsgVW5pZm9ybXNVdGlscyB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcbnZvaWQgbWFpbigpIHtcblx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXG52b2lkIG1haW4oKSB7XG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xufVxuYDtcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBjbG9uZVVuaWZvcm1zLCBjbG9uZVVuaWZvcm1zR3JvdXBzIH0gZnJvbSAnLi4vcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qcyc7XG5cbmltcG9ydCBkZWZhdWx0X3ZlcnRleCBmcm9tICcuLi9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0X3ZlcnRleC5nbHNsLmpzJztcbmltcG9ydCBkZWZhdWx0X2ZyYWdtZW50IGZyb20gJy4uL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRfZnJhZ21lbnQuZ2xzbC5qcyc7XG5cbi8qKlxuICogQSBtYXRlcmlhbCByZW5kZXJlZCB3aXRoIGN1c3RvbSBzaGFkZXJzLiBBIHNoYWRlciBpcyBhIHNtYWxsIHByb2dyYW0gd3JpdHRlbiBpbiBHTFNMLlxuICogdGhhdCBydW5zIG9uIHRoZSBHUFUuIFlvdSBtYXkgd2FudCB0byB1c2UgYSBjdXN0b20gc2hhZGVyIGlmIHlvdSBuZWVkIHRvIGltcGxlbWVudCBhblxuICogZWZmZWN0IG5vdCBpbmNsdWRlZCB3aXRoIGFueSBvZiB0aGUgYnVpbHQtaW4gbWF0ZXJpYWxzLlxuICpcbiAqIFRoZXJlIGFyZSB0aGUgZm9sbG93aW5nIG5vdGVzIHRvIGJlYXIgaW4gbWluZCB3aGVuIHVzaW5nIGEgYFNoYWRlck1hdGVyaWFsYDpcbiAqXG4gKiAtIGBTaGFkZXJNYXRlcmlhbGAgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBXZWJHTFJlbmRlcmVyfS5cbiAqIC0gQnVpbHQgaW4gYXR0cmlidXRlcyBhbmQgdW5pZm9ybXMgYXJlIHBhc3NlZCB0byB0aGUgc2hhZGVycyBhbG9uZyB3aXRoIHlvdXIgY29kZS4gSWZcbiAqIHlvdSBkb24ndCB3YW50IHRoYXQsIHVzZSB7QGxpbmsgUmF3U2hhZGVyTWF0ZXJpYWx9IGluc3RlYWQuXG4gKiAtIFlvdSBjYW4gdXNlIHRoZSBkaXJlY3RpdmUgYCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRgIGFuZCBgI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRgXG4gKiBpbiBvcmRlciB0byB1bnJvbGwgYSBgZm9yYCBsb29wIGluIEdMU0wgYnkgdGhlIHNoYWRlciBwcmVwcm9jZXNzb3IuIFRoZSBkaXJlY3RpdmUgaGFzXG4gKiB0byBiZSBwbGFjZWQgcmlnaHQgYWJvdmUgdGhlIGxvb3AuIFRoZSBsb29wIGZvcm1hdHRpbmcgaGFzIHRvIGNvcnJlc3BvbmQgdG8gYSBkZWZpbmVkIHN0YW5kYXJkLlxuICogICAtIFRoZSBsb29wIGhhcyB0byBiZSBbbm9ybWFsaXplZF17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsaXplZF9sb29wfS5cbiAqICAgLSBUaGUgbG9vcCB2YXJpYWJsZSBoYXMgdG8gYmUgKmkqLlxuICogICAtIFRoZSB2YWx1ZSBgVU5ST0xMRURfTE9PUF9JTkRFWGAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBleHBsaWNpdGx5XG4gKiB2YWx1ZSBvZiAqaSogZm9yIHRoZSBnaXZlbiBpdGVyYXRpb24gYW5kIGNhbiBiZSB1c2VkIGluIHByZXByb2Nlc3NvclxuICogc3RhdGVtZW50cy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAqIFx0dW5pZm9ybXM6IHtcbiAqIFx0XHR0aW1lOiB7IHZhbHVlOiAxLjAgfSxcbiAqIFx0XHRyZXNvbHV0aW9uOiB7IHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpIH1cbiAqIFx0fSxcbiAqIFx0dmVydGV4U2hhZGVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggJ3ZlcnRleFNoYWRlcicgKS50ZXh0Q29udGVudCxcbiAqIFx0ZnJhZ21lbnRTaGFkZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnZnJhZ21lbnRTaGFkZXInICkudGV4dENvbnRlbnRcbiAqIH0gKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBTaGFkZXJNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFkZXIgbWF0ZXJpYWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBBbiBvYmplY3Qgd2l0aCBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzXG5cdCAqIGRlZmluaW5nIHRoZSBtYXRlcmlhbCdzIGFwcGVhcmFuY2UuIEFueSBwcm9wZXJ0eSBvZiB0aGUgbWF0ZXJpYWxcblx0ICogKGluY2x1ZGluZyBhbnkgcHJvcGVydHkgZnJvbSBpbmhlcml0ZWQgbWF0ZXJpYWxzKSBjYW4gYmUgcGFzc2VkXG5cdCAqIGluIGhlcmUuIENvbG9yIHZhbHVlcyBjYW4gYmUgcGFzc2VkIGFueSB0eXBlIG9mIHZhbHVlIGFjY2VwdGVkXG5cdCAqIGJ5IHtAbGluayBDb2xvciNzZXR9LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGN1c3RvbSBjb25zdGFudHMgdXNpbmcgYCNkZWZpbmVgIGRpcmVjdGl2ZXMgd2l0aGluIHRoZSBHTFNMIGNvZGVcblx0XHQgKiBmb3IgYm90aCB0aGUgdmVydGV4IHNoYWRlciBhbmQgdGhlIGZyYWdtZW50IHNoYWRlcjsgZWFjaCBrZXkvdmFsdWUgcGFpclxuXHRcdCAqIHlpZWxkcyBhbm90aGVyIGRpcmVjdGl2ZS5cblx0XHQgKiBgYGBqc1xuXHRcdCAqIGRlZmluZXM6IHtcblx0XHQgKiBcdEZPTzogMTUsXG5cdFx0ICogXHRCQVI6IHRydWVcblx0XHQgKiB9XG5cdFx0ICogYGBgXG5cdFx0ICogWWllbGRzIHRoZSBsaW5lczpcblx0XHQgKiBgYGBcblx0XHQgKiAjZGVmaW5lIEZPTyAxNVxuXHRcdCAqICNkZWZpbmUgQkFSIHRydWVcblx0XHQgKiBgYGBcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5kZWZpbmVzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgdGhlIGZvcm06XG5cdFx0ICogYGBganNcblx0XHQgKiB7XG5cdFx0ICogXHRcInVuaWZvcm0xXCI6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdCAqIFx0XCJ1bmlmb3JtMlwiOiB7IHZhbHVlOiAyIH1cblx0XHQgKiB9XG5cdFx0ICogYGBgXG5cdFx0ICogc3BlY2lmeWluZyB0aGUgdW5pZm9ybXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBzaGFkZXIgY29kZTsga2V5cyBhcmUgdW5pZm9ybVxuXHRcdCAqIG5hbWVzLCB2YWx1ZXMgYXJlIGRlZmluaXRpb25zIG9mIHRoZSBmb3JtXG5cdFx0ICogYGBgXG5cdFx0ICoge1xuXHRcdCAqIFx0dmFsdWU6IDEuMFxuXHRcdCAqIH1cblx0XHQgKiBgYGBcblx0XHQgKiB3aGVyZSBgdmFsdWVgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdW5pZm9ybS4gTmFtZXMgbXVzdCBtYXRjaCB0aGUgbmFtZSBvZlxuXHRcdCAqIHRoZSB1bmlmb3JtLCBhcyBkZWZpbmVkIGluIHRoZSBHTFNMIGNvZGUuIE5vdGUgdGhhdCB1bmlmb3JtcyBhcmUgcmVmcmVzaGVkXG5cdFx0ICogb24gZXZlcnkgZnJhbWUsIHNvIHVwZGF0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgdW5pZm9ybSB3aWxsIGltbWVkaWF0ZWx5XG5cdFx0ICogdXBkYXRlIHRoZSB2YWx1ZSBhdmFpbGFibGUgdG8gdGhlIEdMU0wgY29kZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy51bmlmb3JtcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgaG9sZGluZyB1bmlmb3JtcyBncm91cHMgZm9yIGNvbmZpZ3VyaW5nIFVCT3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8VW5pZm9ybXNHcm91cD59XG5cdFx0ICovXG5cdFx0dGhpcy51bmlmb3Jtc0dyb3VwcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVmVydGV4IHNoYWRlciBHTFNMIGNvZGUuIFRoaXMgaXMgdGhlIGFjdHVhbCBjb2RlIGZvciB0aGUgc2hhZGVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGRlZmF1bHRfdmVydGV4O1xuXG5cdFx0LyoqXG5cdFx0ICogRnJhZ21lbnQgc2hhZGVyIEdMU0wgY29kZS4gVGhpcyBpcyB0aGUgYWN0dWFsIGNvZGUgZm9yIHRoZSBzaGFkZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBkZWZhdWx0X2ZyYWdtZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgbGluZSB0aGlja25lc3Mgb3IgbGluZXMuXG5cdFx0ICpcblx0XHQgKiBXZWJHTCBhbmQgV2ViR1BVIGlnbm9yZSB0aGlzIHNldHRpbmcgYW5kIGFsd2F5cyByZW5kZXIgbGluZSBwcmltaXRpdmVzIHdpdGggYVxuXHRcdCAqIHdpZHRoIG9mIG9uZSBwaXhlbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlcnMgdGhlIGdlb21ldHJ5IGFzIGEgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogV2ViR0wgYW5kIFdlYkdQVSBpZ25vcmUgdGhpcyBwcm9wZXJ0eSBhbmQgYWx3YXlzIHJlbmRlclxuXHRcdCAqIDEgcGl4ZWwgd2lkZSBsaW5lcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSB3aGV0aGVyIHRoZSBtYXRlcmlhbCBjb2xvciBpcyBhZmZlY3RlZCBieSBnbG9iYWwgZm9nIHNldHRpbmdzOyBgdHJ1ZWBcblx0XHQgKiB0byBwYXNzIGZvZyB1bmlmb3JtcyB0byB0aGUgc2hhZGVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgbWF0ZXJpYWwgdXNlcyBsaWdodGluZzsgYHRydWVgIHRvIHBhc3MgdW5pZm9ybSBkYXRhXG5cdFx0ICogcmVsYXRlZCB0byBsaWdodGluZyB0byB0aGlzIHNoYWRlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgd2hldGhlciB0aGlzIG1hdGVyaWFsIHN1cHBvcnRzIGNsaXBwaW5nOyBgdHJ1ZWAgdG8gbGV0IHRoZSByZW5kZXJlclxuXHRcdCAqIHBhc3MgdGhlIGNsaXBwaW5nUGxhbmVzIHVuaWZvcm0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuY2xpcHBpbmcgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYHRydWVgIGJ5IGRlZmF1bHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb3JjZVNpbmdsZVBhc3MgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBvYmplY3QgYWxsb3dzIHRvIGVuYWJsZSBjZXJ0YWluIFdlYkdMIDIgZXh0ZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIC0gY2xpcEN1bGxEaXN0YW5jZTogc2V0IHRvIGB0cnVlYCB0byB1c2UgdmVydGV4IHNoYWRlciBjbGlwcGluZ1xuXHRcdCAqIC0gbXVsdGlEcmF3OiBzZXQgdG8gYHRydWVgIHRvIHVzZSB2ZXJ0ZXggc2hhZGVyIG11bHRpX2RyYXcgLyBlbmFibGUgZ2xfRHJhd0lEXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7e2NsaXBDdWxsRGlzdGFuY2U6ZmFsc2UsbXVsdGlEcmF3OmZhbHNlfX1cblx0XHQgKi9cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7XG5cdFx0XHRjbGlwQ3VsbERpc3RhbmNlOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSB2ZXJ0ZXggc2hhZGVyIGNsaXBwaW5nXG5cdFx0XHRtdWx0aURyYXc6IGZhbHNlIC8vIHNldCB0byB1c2UgdmVydGV4IHNoYWRlciBtdWx0aV9kcmF3IC8gZW5hYmxlIGdsX0RyYXdJRFxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBXaGVuIHRoZSByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlXG5cdFx0ICogbWF0ZXJpYWwgZG9lcywgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHNoYWRlcnMuIFRoaXNcblx0XHQgKiBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblx0XHQgKlxuXHRcdCAqIC0gY29sb3I6IFsgMSwgMSwgMSBdXG5cdFx0ICogLSB1djogWyAwLCAwIF1cblx0XHQgKiAtIHV2MTogWyAwLCAwIF1cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXG5cdFx0XHQndXYnOiBbIDAsIDAgXSxcblx0XHRcdCd1djEnOiBbIDAsIDAgXVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJZiBzZXQsIHRoaXMgY2FsbHMgW2dsLmJpbmRBdHRyaWJMb2NhdGlvbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9iaW5kQXR0cmliTG9jYXRpb259XG5cdFx0ICogdG8gYmluZCBhIGdlbmVyaWMgdmVydGV4IGluZGV4IHRvIGFuIGF0dHJpYnV0ZSB2YXJpYWJsZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuXHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIENhbiBiZSB1c2VkIHRvIGZvcmNlIGEgdW5pZm9ybSB1cGRhdGUgd2hpbGUgY2hhbmdpbmcgdW5pZm9ybXMgaW5cblx0XHQgKiB7QGxpbmsgT2JqZWN0M0Qjb25CZWZvcmVSZW5kZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgR0xTTCB2ZXJzaW9uIG9mIGN1c3RvbSBzaGFkZXIgY29kZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/KEdMU0wxfEdMU0wzKX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5nbHNsVmVyc2lvbiA9IG51bGw7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuXHRcdHRoaXMudW5pZm9ybXMgPSBjbG9uZVVuaWZvcm1zKCBzb3VyY2UudW5pZm9ybXMgKTtcblx0XHR0aGlzLnVuaWZvcm1zR3JvdXBzID0gY2xvbmVVbmlmb3Jtc0dyb3Vwcyggc291cmNlLnVuaWZvcm1zR3JvdXBzICk7XG5cblx0XHR0aGlzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmRlZmluZXMgKTtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xuXHRcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmV4dGVuc2lvbnMgKTtcblxuXHRcdHRoaXMuZ2xzbFZlcnNpb24gPSBzb3VyY2UuZ2xzbFZlcnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5nbHNsVmVyc2lvbiA9IHRoaXMuZ2xzbFZlcnNpb247XG5cdFx0ZGF0YS51bmlmb3JtcyA9IHt9O1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiB0aGlzLnVuaWZvcm1zICkge1xuXG5cdFx0XHRjb25zdCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1sgbmFtZSBdO1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXG5cdFx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XG5cdFx0XHRcdFx0dHlwZTogJ3QnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0pTT04oIG1ldGEgKS51dWlkXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xuXHRcdFx0XHRcdHR5cGU6ICdjJyxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUuZ2V0SGV4KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IyICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjInLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IzICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjMnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3I0ICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAndjQnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNNYXRyaXgzICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAnbTMnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNNYXRyaXg0ICkge1xuXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcblx0XHRcdFx0XHR0eXBlOiAnbTQnLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMuZGVmaW5lcyApLmxlbmd0aCA+IDAgKSBkYXRhLmRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG5cblx0XHRkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xuXHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0ZGF0YS5saWdodHMgPSB0aGlzLmxpZ2h0cztcblx0XHRkYXRhLmNsaXBwaW5nID0gdGhpcy5jbGlwcGluZztcblxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiB0aGlzLmV4dGVuc2lvbnMgKSB7XG5cblx0XHRcdGlmICggdGhpcy5leHRlbnNpb25zWyBrZXkgXSA9PT0gdHJ1ZSApIGV4dGVuc2lvbnNbIGtleSBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggT2JqZWN0LmtleXMoIGV4dGVuc2lvbnMgKS5sZW5ndGggPiAwICkgZGF0YS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIHRoZSBmaWVsZHMgcmVxdWlyZWQgdG8gc3RvcmUgYW5kIHJ1biB0aGUgc2hhZGVyIGNvZGUuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU2hhZGVyTWF0ZXJpYWx+U2hhZGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzaGFkZXIuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIFVuaWZvcm0+fSB1bmlmb3JtcyAtIFRoZSB1bmlmb3JtcyBvZiB0aGUgc2hhZGVyLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBkZWZpbmVzIC0gVGhlIGRlZmluZXMgb2YgdGhlIHNoYWRlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJ0ZXhTaGFkZXIgLSBUaGUgdmVydGV4IHNoYWRlciBjb2RlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZyYWdtZW50U2hhZGVyIC0gVGhlIGZyYWdtZW50IHNoYWRlciBjb2RlLlxuICoqL1xuXG5leHBvcnQgeyBTaGFkZXJNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjYW1lcmFzLiBUaGlzIGNsYXNzIHNob3VsZCBhbHdheXMgYmUgaW5oZXJpdGVkXG4gKiB3aGVuIHlvdSBidWlsZCBhIG5ldyBjYW1lcmEuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgQ2FtZXJhIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNhbWVyYS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNDYW1lcmEgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW52ZXJzZSBvZiB0aGUgY2FtZXJhJ3Mgd29ybGQgbWF0cml4LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge01hdHJpeDR9XG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbWVyYSdzIHByb2plY3Rpb24gbWF0cml4LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge01hdHJpeDR9XG5cdFx0ICovXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbnZlcnNlIG9mIHRoZSBjYW1lcmEncyBwcm9qZWN0aW9uIG1hdHJpeC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtNYXRyaXg0fVxuXHRcdCAqL1xuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvb3JkaW5hdGUgc3lzdGVtIGluIHdoaWNoIHRoZSBjYW1lcmEgaXMgdXNlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoV2ViR0xDb29yZGluYXRlU3lzdGVtfFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0pfVxuXHRcdCAqL1xuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IHNvdXJjZS5jb29yZGluYXRlU3lzdGVtO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgKFwibG9va1wiKSBkaXJlY3Rpb24gb2YgdGhlIDNEIG9iamVjdCBpbiB3b3JsZCBzcGFjZS5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgb3ZlcndyaXR0ZW4gc2luY2UgY2FtZXJhcyBoYXZlIGEgZGlmZmVyZW50IGZvcndhcmQgdmVjdG9yIGNvbXBhcmVkIHRvIG90aGVyXG5cdCAqIDNEIG9iamVjdHMuIEEgY2FtZXJhIGxvb2tzIGRvd24gaXRzIGxvY2FsLCBuZWdhdGl2ZSB6LWF4aXMgYnkgZGVmYXVsdC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHN0b3JlZCB0by5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIDNEIG9iamVjdCdzIGRpcmVjdGlvbiBpbiB3b3JsZCBzcGFjZS5cblx0ICovXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gc3VwZXIuZ2V0V29ybGREaXJlY3Rpb24oIHRhcmdldCApLm5lZ2F0ZSgpO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xuXG5cdFx0c3VwZXIudXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDYW1lcmEgfTtcbiIsImltcG9ydCB7IENhbWVyYSB9IGZyb20gJy4vQ2FtZXJhLmpzJztcbmltcG9ydCB7IFJBRDJERUcsIERFRzJSQUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jb25zdCBfdjMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbWluVGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX21heFRhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuLyoqXG4gKiBDYW1lcmEgdGhhdCB1c2VzIFtwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZXJzcGVjdGl2ZV8oZ3JhcGhpY2FsKX0uXG4gKlxuICogVGhpcyBwcm9qZWN0aW9uIG1vZGUgaXMgZGVzaWduZWQgdG8gbWltaWMgdGhlIHdheSB0aGUgaHVtYW4gZXllIHNlZXMuIEl0XG4gKiBpcyB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBtb2RlIHVzZWQgZm9yIHJlbmRlcmluZyBhIDNEIHNjZW5lLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDQ1LCB3aWR0aCAvIGhlaWdodCwgMSwgMTAwMCApO1xuICogc2NlbmUuYWRkKCBjYW1lcmEgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBDYW1lcmFcbiAqL1xuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBlcnNwZWN0aXZlIGNhbWVyYS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmb3Y9NTBdIC0gVGhlIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0PTFdIC0gVGhlIGFzcGVjdCByYXRpby5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuZWFyPTAuMV0gLSBUaGUgY2FtZXJhJ3MgbmVhciBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmYXI9MjAwMF0gLSBUaGUgY2FtZXJhJ3MgZmFyIHBsYW5lLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGZvdiA9IDUwLCBhc3BlY3QgPSAxLCBuZWFyID0gMC4xLCBmYXIgPSAyMDAwICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcsIGZyb20gYm90dG9tIHRvIHRvcCBvZiB2aWV3LFxuXHRcdCAqIGluIGRlZ3JlZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDUwXG5cdFx0ICovXG5cdFx0dGhpcy5mb3YgPSBmb3Y7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgem9vbSBmYWN0b3Igb2YgdGhlIGNhbWVyYS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuem9vbSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY2FtZXJhJ3MgbmVhciBwbGFuZS4gVGhlIHZhbGlkIHJhbmdlIGlzIGdyZWF0ZXIgdGhhbiBgMGBcblx0XHQgKiBhbmQgbGVzcyB0aGFuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmYXJ9LlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0LCB1bmxpa2UgZm9yIHRoZSB7QGxpbmsgT3J0aG9ncmFwaGljQ2FtZXJhfSwgYDBgIGlzIDxlbT5ub3Q8L2VtPiBhXG5cdFx0ICogdmFsaWQgdmFsdWUgZm9yIGEgcGVyc3BlY3RpdmUgY2FtZXJhJ3MgbmVhciBwbGFuZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMC4xXG5cdFx0ICovXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW1lcmEncyBmYXIgcGxhbmUuIE11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZVxuXHRcdCAqIGN1cnJlbnQgdmFsdWUgb2Yge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI25lYXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAyMDAwXG5cdFx0ICovXG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgZGlzdGFuY2UgdXNlZCBmb3Igc3RlcmVvc2NvcHkgYW5kIGRlcHRoLW9mLWZpZWxkIGVmZmVjdHMuIFRoaXNcblx0XHQgKiBwYXJhbWV0ZXIgZG9lcyBub3QgaW5mbHVlbmNlIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCB1bmxlc3MgYVxuXHRcdCAqIHtAbGluayBTdGVyZW9DYW1lcmF9IGlzIGJlaW5nIHVzZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDEwXG5cdFx0ICovXG5cdFx0dGhpcy5mb2N1cyA9IDEwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFzcGVjdCByYXRpbywgdXN1YWxseSB0aGUgY2FudmFzIHdpZHRoIC8gY2FudmFzIGhlaWdodC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVwcmVzZW50cyB0aGUgZnJ1c3R1bSB3aW5kb3cgc3BlY2lmaWNhdGlvbi4gVGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIGVkaXRlZFxuXHRcdCAqIGRpcmVjdGx5IGJ1dCB2aWEge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI3NldFZpZXdPZmZzZXR9IGFuZCB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjY2xlYXJWaWV3T2Zmc2V0fS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRmlsbSBzaXplIHVzZWQgZm9yIHRoZSBsYXJnZXIgYXhpcy4gRGVmYXVsdCBpcyBgMzVgIChtaWxsaW1ldGVycykuIFRoaXNcblx0XHQgKiBwYXJhbWV0ZXIgZG9lcyBub3QgaW5mbHVlbmNlIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCB1bmxlc3Mge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2ZpbG1PZmZzZXR9XG5cdFx0ICogaXMgc2V0IHRvIGEgbm9uemVybyB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMzVcblx0XHQgKi9cblx0XHR0aGlzLmZpbG1HYXVnZSA9IDM1O1xuXG5cdFx0LyoqXG5cdFx0ICogSG9yaXpvbnRhbCBvZmYtY2VudGVyIG9mZnNldCBpbiB0aGUgc2FtZSB1bml0IGFzIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG5cdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XG5cblx0XHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcblx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcblxuXHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcblx0XHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcblxuXHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcblx0XHR0aGlzLmZpbG1PZmZzZXQgPSBzb3VyY2UuZmlsbU9mZnNldDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgRk9WIGJ5IGZvY2FsIGxlbmd0aCBpbiByZXNwZWN0IHRvIHRoZSBjdXJyZW50IHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuXHQgKlxuXHQgKiBUaGUgZGVmYXVsdCBmaWxtIGdhdWdlIGlzIDM1LCBzbyB0aGF0IHRoZSBmb2NhbCBsZW5ndGggY2FuIGJlIHNwZWNpZmllZCBmb3Jcblx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmb2NhbExlbmd0aCAtIFZhbHVlcyBmb3IgZm9jYWwgbGVuZ3RoIGFuZCBmaWxtIGdhdWdlIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0LlxuXHQgKi9cblx0c2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICkge1xuXG5cdFx0LyoqIHNlZSB7QGxpbmsgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWx9ICovXG5cdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblxuXHRcdHRoaXMuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIHZFeHRlbnRTbG9wZSApO1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZm9jYWwgbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2Zvdn0gYW5kXG5cdCAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb21wdXRlZCBmb2NhbCBsZW5ndGguXG5cdCAqL1xuXHRnZXRGb2NhbExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKCBERUcyUkFEICogMC41ICogdGhpcy5mb3YgKTtcblxuXHRcdHJldHVybiAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIHZFeHRlbnRTbG9wZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmVydGljYWwgZmllbGQgb2YgdmlldyBhbmdsZSBpbiBkZWdyZWVzIGNvbnNpZGVyaW5nIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSN6b29tfS5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZWZmZWN0aXZlIEZPVi5cblx0ICovXG5cdGdldEVmZmVjdGl2ZUZPVigpIHtcblxuXHRcdHJldHVybiBSQUQyREVHICogMiAqIE1hdGguYXRhbihcblx0XHRcdE1hdGgudGFuKCBERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGltYWdlIG9uIHRoZSBmaWxtLiBJZiB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjYXNwZWN0fSBpcyBncmVhdGVyIHRoYW4gb3Jcblx0ICogZXF1YWwgdG8gb25lIChsYW5kc2NhcGUgZm9ybWF0KSwgdGhlIHJlc3VsdCBlcXVhbHMge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2ZpbG1HYXVnZX0uXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpbG0gd2lkdGguXG5cdCAqL1xuXHRnZXRGaWxtV2lkdGgoKSB7XG5cblx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gcG9ydHJhaXQgZm9ybWF0IChhc3BlY3QgPCAxKVxuXHRcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAqIE1hdGgubWluKCB0aGlzLmFzcGVjdCwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvbiB0aGUgZmlsbS4gSWYge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2FzcGVjdH0gaXMgZ3JlYXRlciB0aGFuIG9yXG5cdCAqIGVxdWFsIHRvIG9uZSAobGFuZHNjYXBlIGZvcm1hdCksIHRoZSByZXN1bHQgZXF1YWxzIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaWxtIHdpZHRoLlxuXHQgKi9cblx0Z2V0RmlsbUhlaWdodCgpIHtcblxuXHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuXHRcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KCB0aGlzLmFzcGVjdCwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIDJEIGJvdW5kcyBvZiB0aGUgY2FtZXJhJ3Mgdmlld2FibGUgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgYWxvbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uLlxuXHQgKiBTZXRzIGBtaW5UYXJnZXRgIGFuZCBgbWF4VGFyZ2V0YCB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxvd2VyLWxlZnQgYW5kIHVwcGVyLXJpZ2h0IGNvcm5lcnMgb2YgdGhlIHZpZXcgcmVjdGFuZ2xlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgLSBUaGUgdmlld2luZyBkaXN0YW5jZS5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBtaW5UYXJnZXQgLSBUaGUgbG93ZXItbGVmdCBjb3JuZXIgb2YgdGhlIHZpZXcgcmVjdGFuZ2xlIGlzIHdyaXR0ZW4gaW50byB0aGlzIHZlY3Rvci5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBtYXhUYXJnZXQgLSBUaGUgdXBwZXItcmlnaHQgY29ybmVyIG9mIHRoZSB2aWV3IHJlY3RhbmdsZSBpcyB3cml0dGVuIGludG8gdGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRnZXRWaWV3Qm91bmRzKCBkaXN0YW5jZSwgbWluVGFyZ2V0LCBtYXhUYXJnZXQgKSB7XG5cblx0XHRfdjMuc2V0KCAtIDEsIC0gMSwgMC41ICkuYXBwbHlNYXRyaXg0KCB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XG5cblx0XHRtaW5UYXJnZXQuc2V0KCBfdjMueCwgX3YzLnkgKS5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSAvIF92My56ICk7XG5cblx0XHRfdjMuc2V0KCAxLCAxLCAwLjUgKS5hcHBseU1hdHJpeDQoIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblxuXHRcdG1heFRhcmdldC5zZXQoIF92My54LCBfdjMueSApLm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlIC8gX3YzLnogKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW1lcmEncyB2aWV3YWJsZSByZWN0YW5nbGUgYXQgYSBnaXZlbiBkaXN0YW5jZSBhbG9uZyB0aGUgdmlld2luZyBkaXJlY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSAtIFRoZSB2aWV3aW5nIGRpc3RhbmNlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSByZXN1bHQgd2hlcmUgeCBpcyB3aWR0aCBhbmQgeSBpcyBoZWlnaHQuXG5cdCAqIEByZXR1cm5zIHtWZWN0b3IyfSBUaGUgdmlldyBzaXplLlxuXHQgKi9cblx0Z2V0Vmlld1NpemUoIGRpc3RhbmNlLCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLmdldFZpZXdCb3VuZHMoIGRpc3RhbmNlLCBfbWluVGFyZ2V0LCBfbWF4VGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnMoIF9tYXhUYXJnZXQsIF9taW5UYXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3Jcblx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcblx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuXHQgKmBgYFxuXHQgKiAgICstLS0rLS0tKy0tLStcblx0ICogICB8IEEgfCBCIHwgQyB8XG5cdCAqICAgKy0tLSstLS0rLS0tK1xuXHQgKiAgIHwgRCB8IEUgfCBGIHxcblx0ICogICArLS0tKy0tLSstLS0rXG5cdCAqYGBgXG5cdCAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXM6XG5cdCAqYGBganNcblx0ICogY29uc3QgdyA9IDE5MjA7XG5cdCAqIGNvbnN0IGggPSAxMDgwO1xuXHQgKiBjb25zdCBmdWxsV2lkdGggPSB3ICogMztcblx0ICogY29uc3QgZnVsbEhlaWdodCA9IGggKiAyO1xuXHQgKlxuXHQgKiAvLyAtLUEtLVxuXHQgKiBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcblx0ICogLy8gLS1CLS1cblx0ICogY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG5cdCAqIC8vIC0tQy0tXG5cdCAqIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuXHQgKiAvLyAtLUQtLVxuXHQgKiBjYW1lcmEuc2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcblx0ICogLy8gLS1FLS1cblx0ICogY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG5cdCAqIC8vIC0tRi0tXG5cdCAqIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuXHQgKiBgYGBcblx0ICpcblx0ICogTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxXaWR0aCAtIFRoZSBmdWxsIHdpZHRoIG9mIG11bHRpdmlldyBzZXR1cC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxIZWlnaHQgLSBUaGUgZnVsbCBoZWlnaHQgb2YgbXVsdGl2aWV3IHNldHVwLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvZiB0aGUgc3ViY2FtZXJhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgb2YgdGhlIHN1YmNhbWVyYS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHN1YmNhbWVyYS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2Ygc3ViY2FtZXJhLlxuXHQgKi9cblx0c2V0Vmlld09mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRvZmZzZXRYOiAwLFxuXHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cdFx0dGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuXHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XG5cdFx0dGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgdmlldyBvZmZzZXQgZnJvbSB0aGUgcHJvamVjdGlvbiBtYXRyaXguXG5cdCAqL1xuXHRjbGVhclZpZXdPZmZzZXQoKSB7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY2FtZXJhJ3MgcHJvamVjdGlvbiBtYXRyaXguIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFueSBjaGFuZ2Ugb2Zcblx0ICogY2FtZXJhIHByb3BlcnRpZXMuXG5cdCAqL1xuXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuXG5cdFx0Y29uc3QgbmVhciA9IHRoaXMubmVhcjtcblx0XHRsZXQgdG9wID0gbmVhciAqIE1hdGgudGFuKCBERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbTtcblx0XHRsZXQgaGVpZ2h0ID0gMiAqIHRvcDtcblx0XHRsZXQgd2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodDtcblx0XHRsZXQgbGVmdCA9IC0gMC41ICogd2lkdGg7XG5cdFx0Y29uc3QgdmlldyA9IHRoaXMudmlldztcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRjb25zdCBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcblx0XHRcdFx0ZnVsbEhlaWdodCA9IHZpZXcuZnVsbEhlaWdodDtcblxuXHRcdFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdHRvcCAtPSB2aWV3Lm9mZnNldFkgKiBoZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXHRcdFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuXHRcdGlmICggc2tldyAhPT0gMCApIGxlZnQgKz0gbmVhciAqIHNrZXcgLyB0aGlzLmdldEZpbG1XaWR0aCgpO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIsIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblxuXHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xuXG5cdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cblx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XG5cblx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcblx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFBlcnNwZWN0aXZlQ2FtZXJhIH07XG4iLCJpbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0sIFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcbmltcG9ydCB7IFBlcnNwZWN0aXZlQ2FtZXJhIH0gZnJvbSAnLi9QZXJzcGVjdGl2ZUNhbWVyYS5qcyc7XG5cbmNvbnN0IGZvdiA9IC0gOTA7IC8vIG5lZ2F0aXZlIGZvdiBpcyBub3QgYW4gZXJyb3JcbmNvbnN0IGFzcGVjdCA9IDE7XG5cbi8qKlxuICogQSBzcGVjaWFsIHR5cGUgb2YgY2FtZXJhIHRoYXQgaXMgcG9zaXRpb25lZCBpbiAzRCBzcGFjZSB0byByZW5kZXIgaXRzIHN1cnJvdW5kaW5ncyBpbnRvIGFcbiAqIGN1YmUgcmVuZGVyIHRhcmdldC4gVGhlIHJlbmRlciB0YXJnZXQgY2FuIHRoZW4gYmUgdXNlZCBhcyBhbiBlbnZpcm9ubWVudCBtYXAgZm9yIHJlbmRlcmluZ1xuICogcmVhbHRpbWUgcmVmbGVjdGlvbnMgaW4geW91ciBzY2VuZS5cbiAqXG4gKiBgYGBqc1xuICogLy8gQ3JlYXRlIGN1YmUgcmVuZGVyIHRhcmdldFxuICogY29uc3QgY3ViZVJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTEN1YmVSZW5kZXJUYXJnZXQoIDI1NiwgeyBnZW5lcmF0ZU1pcG1hcHM6IHRydWUsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIH0gKTtcbiAqXG4gKiAvLyBDcmVhdGUgY3ViZSBjYW1lcmFcbiAqIGNvbnN0IGN1YmVDYW1lcmEgPSBuZXcgVEhSRUUuQ3ViZUNhbWVyYSggMSwgMTAwMDAwLCBjdWJlUmVuZGVyVGFyZ2V0ICk7XG4gKiBzY2VuZS5hZGQoIGN1YmVDYW1lcmEgKTtcbiAqXG4gKiAvLyBDcmVhdGUgY2FyXG4gKiBjb25zdCBjaHJvbWVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgZW52TWFwOiBjdWJlUmVuZGVyVGFyZ2V0LnRleHR1cmUgfSApO1xuICogY29uc3QgY2FyID0gbmV3IFRIUkVFLk1lc2goIGNhckdlb21ldHJ5LCBjaHJvbWVNYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBjYXIgKTtcbiAqXG4gKiAvLyBVcGRhdGUgdGhlIHJlbmRlciB0YXJnZXQgY3ViZVxuICogY2FyLnZpc2libGUgPSBmYWxzZTtcbiAqIGN1YmVDYW1lcmEucG9zaXRpb24uY29weSggY2FyLnBvc2l0aW9uICk7XG4gKiBjdWJlQ2FtZXJhLnVwZGF0ZSggcmVuZGVyZXIsIHNjZW5lICk7XG4gKlxuICogLy8gUmVuZGVyIHRoZSBzY2VuZVxuICogY2FyLnZpc2libGUgPSB0cnVlO1xuICogcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgQ3ViZUNhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjdWJlIGNhbWVyYS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgLSBUaGUgY2FtZXJhJ3MgbmVhciBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZhciAtIFRoZSBjYW1lcmEncyBmYXIgcGxhbmUuXG5cdCAqIEBwYXJhbSB7V2ViR0xDdWJlUmVuZGVyVGFyZ2V0fSByZW5kZXJUYXJnZXQgLSBUaGUgY3ViZSByZW5kZXIgdGFyZ2V0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG5lYXIsIGZhciwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdWJlIHJlbmRlciB0YXJnZXQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7V2ViR0xDdWJlUmVuZGVyVGFyZ2V0fVxuXHRcdCAqL1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgYWN0aXZlIGNvb3JkaW5hdGUgc3lzdGVtLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez8oV2ViR0xDb29yZGluYXRlU3lzdGVtfFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0pfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgYWN0aXZlIG1pcG1hcCBsZXZlbFxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5hY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cblx0XHRjb25zdCBjYW1lcmFQWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBYLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG5cdFx0Y29uc3QgY2FtZXJhTlggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFOWC5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuXHRcdGNvbnN0IGNhbWVyYVBZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhUFkubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cblx0XHRjb25zdCBjYW1lcmFOWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5ZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG5cdFx0Y29uc3QgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFQWi5sYXllcnMgPSB0aGlzLmxheWVycztcblx0XHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuXHRcdGNvbnN0IGNhbWVyYU5aID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhTloubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGUgY3ViZSBjYW1lcmEgaXMgY2hhbmdlZC5cblx0ICovXG5cdHVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKSB7XG5cblx0XHRjb25zdCBjb29yZGluYXRlU3lzdGVtID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuXG5cdFx0Y29uc3QgY2FtZXJhcyA9IHRoaXMuY2hpbGRyZW4uY29uY2F0KCk7XG5cblx0XHRjb25zdCBbIGNhbWVyYVBYLCBjYW1lcmFOWCwgY2FtZXJhUFksIGNhbWVyYU5ZLCBjYW1lcmFQWiwgY2FtZXJhTlogXSA9IGNhbWVyYXM7XG5cblx0XHRmb3IgKCBjb25zdCBjYW1lcmEgb2YgY2FtZXJhcyApIHRoaXMucmVtb3ZlKCBjYW1lcmEgKTtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBYLmxvb2tBdCggMSwgMCwgMCApO1xuXG5cdFx0XHRjYW1lcmFOWC51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5YLmxvb2tBdCggLSAxLCAwLCAwICk7XG5cblx0XHRcdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRjYW1lcmFQWS5sb29rQXQoIDAsIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAxICk7XG5cdFx0XHRjYW1lcmFOWS5sb29rQXQoIDAsIC0gMSwgMCApO1xuXG5cdFx0XHRjYW1lcmFQWi51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdCggMCwgMCwgMSApO1xuXG5cdFx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5aLmxvb2tBdCggMCwgMCwgLSAxICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdFx0Y2FtZXJhUFgubG9va0F0KCAtIDEsIDAsIDAgKTtcblxuXHRcdFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYU5YLmxvb2tBdCggMSwgMCwgMCApO1xuXG5cdFx0XHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcblx0XHRcdGNhbWVyYVBZLmxvb2tBdCggMCwgMSwgMCApO1xuXG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0Y2FtZXJhTlkubG9va0F0KCAwLCAtIDEsIDAgKTtcblxuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdCggMCwgMCwgMSApO1xuXG5cdFx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdFx0Y2FtZXJhTloubG9va0F0KCAwLCAwLCAtIDEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkN1YmVDYW1lcmEudXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgY2FtZXJhIG9mIGNhbWVyYXMgKSB7XG5cblx0XHRcdHRoaXMuYWRkKCBjYW1lcmEgKTtcblxuXHRcdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgcmVuZGVyIHRoZSBnaXZlbiBzY2VuZSB3aXRoIHRoZSBnaXZlbiByZW5kZXJlclxuXHQgKiBpbnRvIHRoZSBjdWJlIHJlbmRlciB0YXJnZXQgb2YgdGhlIGNhbWVyYS5cblx0ICpcblx0ICogQHBhcmFtIHsoUmVuZGVyZXJ8V2ViR0xSZW5kZXJlcil9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG5cdCAqL1xuXHR1cGRhdGUoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRjb25zdCB7IHJlbmRlclRhcmdldCwgYWN0aXZlTWlwbWFwTGV2ZWwgfSA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSAhPT0gcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0dGhpcy5jb29yZGluYXRlU3lzdGVtID0gcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbTtcblxuXHRcdFx0dGhpcy51cGRhdGVDb29yZGluYXRlU3lzdGVtKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBbIGNhbWVyYVBYLCBjYW1lcmFOWCwgY2FtZXJhUFksIGNhbWVyYU5ZLCBjYW1lcmFQWiwgY2FtZXJhTlogXSA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0Y29uc3QgY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblx0XHRjb25zdCBjdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSByZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0Y29uc3QgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cblx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCAwLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgMSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCApO1xuXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDIsIGFjdGl2ZU1pcG1hcExldmVsICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFkgKTtcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCAzLCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgNCwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiApO1xuXG5cdFx0Ly8gbWlwbWFwcyBhcmUgZ2VuZXJhdGVkIGR1cmluZyB0aGUgbGFzdCBjYWxsIG9mIHJlbmRlcigpXG5cdFx0Ly8gYXQgdGhpcyBwb2ludCwgYWxsIHNpZGVzIG9mIHRoZSBjdWJlIHJlbmRlciB0YXJnZXQgYXJlIGRlZmluZWRcblxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCA1LCBhY3RpdmVNaXBtYXBMZXZlbCApO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQsIGN1cnJlbnRBY3RpdmVDdWJlRmFjZSwgY3VycmVudEFjdGl2ZU1pcG1hcExldmVsICk7XG5cblx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gY3VycmVudFhyRW5hYmxlZDtcblxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLm5lZWRzUE1SRU1VcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDdWJlQ2FtZXJhIH07XG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9UZXh0dXJlLmpzJztcbmltcG9ydCB7IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1YmUgdGV4dHVyZSBtYWRlIHVwIG9mIHNpeCBpbWFnZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xuICogbG9hZGVyLnNldFBhdGgoICd0ZXh0dXJlcy9jdWJlL3Bpc2EvJyApO1xuICpcbiAqIGNvbnN0IHRleHR1cmVDdWJlID0gbG9hZGVyLmxvYWQoIFtcbiAqIFx0J3B4LnBuZycsICdueC5wbmcnLCAncHkucG5nJywgJ255LnBuZycsICdwei5wbmcnLCAnbnoucG5nJ1xuICogXSApO1xuICpcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgZW52TWFwOiB0ZXh0dXJlQ3ViZSB9ICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBDdWJlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGN1YmUgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxJbWFnZT59IFtpbWFnZXM9W11dIC0gQW4gYXJyYXkgaG9sZGluZyBhIGltYWdlIGZvciBlYWNoIHNpZGUgb2YgYSBjdWJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hcHBpbmc9Q3ViZVJlZmxlY3Rpb25NYXBwaW5nXSAtIFRoZSB0ZXh0dXJlIG1hcHBpbmcuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcFM9Q2xhbXBUb0VkZ2VXcmFwcGluZ10gLSBUaGUgd3JhcFMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcFQ9Q2xhbXBUb0VkZ2VXcmFwcGluZ10gLSBUaGUgd3JhcFQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWFnRmlsdGVyPUxpbmVhckZpbHRlcl0gLSBUaGUgbWFnIGZpbHRlciB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttaW5GaWx0ZXI9TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXSAtIFRoZSBtaW4gZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zvcm1hdD1SR0JBRm9ybWF0XSAtIFRoZSB0ZXh0dXJlIGZvcm1hdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlPVVuc2lnbmVkQnl0ZVR5cGVdIC0gVGhlIHRleHR1cmUgdHlwZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbmlzb3Ryb3B5PVRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZXSAtIFRoZSBhbmlzb3Ryb3B5IHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yU3BhY2U9Tm9Db2xvclNwYWNlXSAtIFRoZSBjb2xvciBzcGFjZSB2YWx1ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBpbWFnZXMgPSBbXSwgbWFwcGluZyA9IEN1YmVSZWZsZWN0aW9uTWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzQ3ViZVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHRleHR1cmUgaXMgZmxpcHBlZCBhbG9uZyB0aGUgdmVydGljYWwgYXhpcyB3aGVuXG5cdFx0ICogdXBsb2FkZWQgdG8gdGhlIEdQVS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbGlhcyBmb3Ige0BsaW5rIEN1YmVUZXh0dXJlI2ltYWdlfS5cblx0ICpcblx0ICogQHR5cGUge0FycmF5PEltYWdlPn1cblx0ICovXG5cdGdldCBpbWFnZXMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbWFnZTtcblxuXHR9XG5cblx0c2V0IGltYWdlcyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmltYWdlID0gdmFsdWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEN1YmVUZXh0dXJlIH07XG4iLCJpbXBvcnQgeyBCYWNrU2lkZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIE5vQmxlbmRpbmcgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgY2xvbmVVbmlmb3JtcyB9IGZyb20gJy4vc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzJztcbmltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9XZWJHTFJlbmRlclRhcmdldC5qcyc7XG5pbXBvcnQgeyBDdWJlQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9DdWJlQ2FtZXJhLmpzJztcbmltcG9ydCB7IEN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xuXG4vKipcbiAqIEEgY3ViZSByZW5kZXIgdGFyZ2V0IHVzZWQgaW4gY29udGV4dCBvZiB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG4gKlxuICogQGF1Z21lbnRzIFdlYkdMUmVuZGVyVGFyZ2V0XG4gKi9cbmNsYXNzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjdWJlIHJlbmRlciB0YXJnZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSAtIFRoZSBzaXplIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH5PcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHN1cGVyKCBzaXplLCBzaXplLCBvcHRpb25zICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGltYWdlID0geyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCBkZXB0aDogMSB9O1xuXHRcdGNvbnN0IGltYWdlcyA9IFsgaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZSBdO1xuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcndyaXR0ZW4gd2l0aCBhIGRpZmZlcmVudCB0ZXh0dXJlIHR5cGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RGF0YUFycmF5VGV4dHVyZX1cblx0XHQgKi9cblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoIGltYWdlcywgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5jb2xvclNwYWNlICk7XG5cblx0XHQvLyBCeSBjb252ZW50aW9uIC0tIGxpa2VseSBiYXNlZCBvbiB0aGUgUmVuZGVyTWFuIHNwZWMgZnJvbSB0aGUgMTk5MCdzIC0tIGN1YmUgbWFwcyBhcmUgc3BlY2lmaWVkIGJ5IFdlYkdMIChhbmQgdGhyZWUuanMpXG5cdFx0Ly8gaW4gYSBjb29yZGluYXRlIHN5c3RlbSBpbiB3aGljaCBwb3NpdGl2ZS14IGlzIHRvIHRoZSByaWdodCB3aGVuIGxvb2tpbmcgdXAgdGhlIHBvc2l0aXZlLXogYXhpcyAtLSBpbiBvdGhlciB3b3Jkcyxcblx0XHQvLyBpbiBhIGxlZnQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLiBCeSBjb250aW51aW5nIHRoaXMgY29udmVudGlvbiwgcHJlZXhpc3RpbmcgY3ViZSBtYXBzIGNvbnRpbnVlZCB0byByZW5kZXIgY29ycmVjdGx5LlxuXG5cdFx0Ly8gdGhyZWUuanMgdXNlcyBhIHJpZ2h0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gU28gZW52aXJvbm1lbnQgbWFwcyB1c2VkIGluIHRocmVlLmpzIGFwcGVhciB0byBoYXZlIHB4IGFuZCBueCBzd2FwcGVkXG5cdFx0Ly8gYW5kIHRoZSBmbGFnIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBjb250cm9scyB0aGlzIGNvbnZlcnNpb24uIFRoZSBmbGlwIGlzIG5vdCByZXF1aXJlZCB3aGVuIHVzaW5nIFdlYkdMQ3ViZVJlbmRlclRhcmdldC50ZXh0dXJlXG5cdFx0Ly8gYXMgYSBjdWJlIHRleHR1cmUgKHRoaXMgaXMgZGV0ZWN0ZWQgd2hlbiBpc1JlbmRlclRhcmdldFRleHR1cmUgaXMgc2V0IHRvIHRydWUgZm9yIGN1YmUgdGV4dHVyZXMpLlxuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBlcXVpcmVjdGFuZ3VsYXIgdGV4dHVyZSB0byBhIGN1YmUgbWFwLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmUuXG5cdCAqIEByZXR1cm4ge1dlYkdMQ3ViZVJlbmRlclRhcmdldH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjdWJlIHJlbmRlciB0YXJnZXQuXG5cdCAqL1xuXHRmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSggcmVuZGVyZXIsIHRleHR1cmUgKSB7XG5cblx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHRleHR1cmUudHlwZTtcblx0XHR0aGlzLnRleHR1cmUuY29sb3JTcGFjZSA9IHRleHR1cmUuY29sb3JTcGFjZTtcblxuXHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XG5cdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWFnRmlsdGVyO1xuXG5cdFx0Y29uc3Qgc2hhZGVyID0ge1xuXG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHR0RXF1aXJlY3Q6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdH0sXG5cblx0XHRcdHZlcnRleFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xuXG5cdFx0XHRcdHZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIGRpciwgMC4wICkgKS54eXogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcblxuXHRcdFx0XHRcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG5cdFx0XHRcdFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxuXG5cdFx0XHRcdH1cblx0XHRcdGAsXG5cblx0XHRcdGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovYFxuXG5cdFx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcblxuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xuXG5cdFx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XG5cblx0XHRcdFx0fVxuXHRcdFx0YFxuXHRcdH07XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSggNSwgNSwgNSApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdFx0bmFtZTogJ0N1YmVtYXBGcm9tRXF1aXJlY3QnLFxuXG5cdFx0XHR1bmlmb3JtczogY2xvbmVVbmlmb3Jtcyggc2hhZGVyLnVuaWZvcm1zICksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0XHRibGVuZGluZzogTm9CbGVuZGluZ1xuXG5cdFx0fSApO1xuXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlID0gdGV4dHVyZTtcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRjb25zdCBjdXJyZW50TWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHQvLyBBdm9pZCBibHVycmVkIHBvbGVzXG5cdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cblx0XHRjb25zdCBjYW1lcmEgPSBuZXcgQ3ViZUNhbWVyYSggMSwgMTAsIHRoaXMgKTtcblx0XHRjYW1lcmEudXBkYXRlKCByZW5kZXJlciwgbWVzaCApO1xuXG5cdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBjdXJyZW50TWluRmlsdGVyO1xuXG5cdFx0bWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0bWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGlzIGN1YmUgcmVuZGVyIHRhcmdldC5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cblx0ICogQHBhcmFtIHtib29sZWFufSBbY29sb3I9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBjb2xvciBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQgb3Igbm90LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXB0aD10cnVlXSAtIFdoZXRoZXIgdGhlIGRlcHRoIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBvciBub3QuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0ZW5jaWw9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzdGVuY2lsIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBvciBub3QuXG5cdCAqL1xuXHRjbGVhciggcmVuZGVyZXIsIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcblxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcywgaSApO1xuXG5cdFx0XHRyZW5kZXJlci5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IH07XG4iLCJpbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuXG4vKipcbiAqIFRoaXMgaXMgYWxtb3N0IGlkZW50aWNhbCB0byBhbiB7QGxpbmsgT2JqZWN0M0R9LiBJdHMgcHVycG9zZSBpcyB0b1xuICogbWFrZSB3b3JraW5nIHdpdGggZ3JvdXBzIG9mIG9iamVjdHMgc3ludGFjdGljYWxseSBjbGVhcmVyLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBDcmVhdGUgYSBncm91cCBhbmQgYWRkIHRoZSB0d28gY3ViZXMuXG4gKiAvLyBUaGVzZSBjdWJlcyBjYW4gbm93IGJlIHJvdGF0ZWQgLyBzY2FsZWQgZXRjIGFzIGEgZ3JvdXAuXG4gKiBjb25zdCBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICpcbiAqIGdyb3VwLmFkZCggbWVzaEEgKTtcbiAqIGdyb3VwLmFkZCggbWVzaEIgKTtcbiAqXG4gKiBzY2VuZS5hZGQoIGdyb3VwICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgR3JvdXAgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0dyb3VwID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdHcm91cCc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEdyb3VwIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnLi4vLi4vb2JqZWN0cy9Hcm91cC5qcyc7XG5cbmNvbnN0IF9tb3ZlRXZlbnQgPSB7IHR5cGU6ICdtb3ZlJyB9O1xuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBYUiBjb250cm9sbGVyIHdpdGggaXRzXG4gKiBkaWZmZXJlbnQgY29vcmRpbmF0ZSBzeXN0ZW1zLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgWFIgY29udHJvbGxlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogQSBncm91cCByZXByZXNlbnRpbmcgdGhlIHRhcmdldCByYXkgc3BhY2Vcblx0XHQgKiBvZiB0aGUgWFIgY29udHJvbGxlci5cblx0XHQgKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUgez9Hcm91cH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFyZ2V0UmF5ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZ3JvdXAgcmVwcmVzZW50aW5nIHRoZSBncmlwIHNwYWNlXG5cdFx0ICogb2YgdGhlIFhSIGNvbnRyb2xsZXIuXG5cdFx0ICpcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHs/R3JvdXB9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX2dyaXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBncm91cCByZXByZXNlbnRpbmcgdGhlIGhhbmQgc3BhY2Vcblx0XHQgKiBvZiB0aGUgWFIgY29udHJvbGxlci5cblx0XHQgKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUgez9Hcm91cH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5faGFuZCA9IG51bGw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ3JvdXAgcmVwcmVzZW50aW5nIHRoZSBoYW5kIHNwYWNlIG9mIHRoZSBYUiBjb250cm9sbGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtHcm91cH0gQSBncm91cCByZXByZXNlbnRpbmcgdGhlIGhhbmQgc3BhY2Ugb2YgdGhlIFhSIGNvbnRyb2xsZXIuXG5cdCAqL1xuXHRnZXRIYW5kU3BhY2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2hhbmQgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2hhbmQgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuX2hhbmQuam9pbnRzID0ge307XG5cdFx0XHR0aGlzLl9oYW5kLmlucHV0U3RhdGUgPSB7IHBpbmNoaW5nOiBmYWxzZSB9O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2hhbmQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ3JvdXAgcmVwcmVzZW50aW5nIHRoZSB0YXJnZXQgcmF5IHNwYWNlIG9mIHRoZSBYUiBjb250cm9sbGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtHcm91cH0gQSBncm91cCByZXByZXNlbnRpbmcgdGhlIHRhcmdldCByYXkgc3BhY2Ugb2YgdGhlIFhSIGNvbnRyb2xsZXIuXG5cdCAqL1xuXHRnZXRUYXJnZXRSYXlTcGFjZSgpIHtcblxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkgPSBuZXcgR3JvdXAoKTtcblx0XHRcdHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGdyb3VwIHJlcHJlc2VudGluZyB0aGUgZ3JpcCBzcGFjZSBvZiB0aGUgWFIgY29udHJvbGxlci5cblx0ICpcblx0ICogQHJldHVybiB7R3JvdXB9IEEgZ3JvdXAgcmVwcmVzZW50aW5nIHRoZSBncmlwIHNwYWNlIG9mIHRoZSBYUiBjb250cm9sbGVyLlxuXHQgKi9cblx0Z2V0R3JpcFNwYWNlKCkge1xuXG5cdFx0aWYgKCB0aGlzLl9ncmlwID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9ncmlwID0gbmV3IEdyb3VwKCk7XG5cdFx0XHR0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2dyaXAudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZ3JpcC5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2dyaXA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBnaXZlbiBldmVudCB0byB0aGUgZ3JvdXBzIHJlcHJlc2VudGluZ1xuXHQgKiB0aGUgZGlmZmVyZW50IGNvb3JkaW5hdGUgc3BhY2VzIG9mIHRoZSBYUiBjb250cm9sbGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG5cdCAqIEByZXR1cm4ge1dlYlhSQ29udHJvbGxlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGRpc3BhdGNoRXZlbnQoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLl90YXJnZXRSYXkgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3RhcmdldFJheS5kaXNwYXRjaEV2ZW50KCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9ncmlwICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9ncmlwLmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2hhbmQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2hhbmQuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29ubmVjdHMgdGhlIGNvbnRyb2xsZXIgd2l0aCB0aGUgZ2l2ZW4gWFIgaW5wdXQgc291cmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1hSSW5wdXRTb3VyY2V9IGlucHV0U291cmNlIC0gVGhlIGlucHV0IHNvdXJjZS5cblx0ICogQHJldHVybiB7V2ViWFJDb250cm9sbGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29ubmVjdCggaW5wdXRTb3VyY2UgKSB7XG5cblx0XHRpZiAoIGlucHV0U291cmNlICYmIGlucHV0U291cmNlLmhhbmQgKSB7XG5cblx0XHRcdGNvbnN0IGhhbmQgPSB0aGlzLl9oYW5kO1xuXG5cdFx0XHRpZiAoIGhhbmQgKSB7XG5cblx0XHRcdFx0Zm9yICggY29uc3QgaW5wdXRqb2ludCBvZiBpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpICkge1xuXG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBoYW5kIHdpdGggam9pbnRzIHdoZW4gY29ubmVjdGVkXG5cdFx0XHRcdFx0dGhpcy5fZ2V0SGFuZEpvaW50KCBoYW5kLCBpbnB1dGpvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Nvbm5lY3RlZCcsIGRhdGE6IGlucHV0U291cmNlIH0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIGNvbnRyb2xsZXIgZnJvbSB0aGUgZ2l2ZW4gWFIgaW5wdXQgc291cmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1hSSW5wdXRTb3VyY2V9IGlucHV0U291cmNlIC0gVGhlIGlucHV0IHNvdXJjZS5cblx0ICogQHJldHVybiB7V2ViWFJDb250cm9sbGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0ZGlzY29ubmVjdCggaW5wdXRTb3VyY2UgKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc2Nvbm5lY3RlZCcsIGRhdGE6IGlucHV0U291cmNlIH0gKTtcblxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9ncmlwICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5faGFuZCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbnRyb2xsZXIgd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgc291cmNlLCBYUiBmcmFtZSBhbmQgcmVmZXJlbmNlIHNwYWNlLlxuXHQgKiBUaGlzIHVwZGF0ZXMgdGhlIHRyYW5zZm9ybWF0aW9ucyBvZiB0aGUgZ3JvdXBzIHRoYXQgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnRcblx0ICogY29vcmRpbmF0ZSBzeXN0ZW1zIG9mIHRoZSBjb250cm9sbGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1hSSW5wdXRTb3VyY2V9IGlucHV0U291cmNlIC0gVGhlIGlucHV0IHNvdXJjZS5cblx0ICogQHBhcmFtIHtYUkZyYW1lfSBmcmFtZSAtIFRoZSBYUiBmcmFtZS5cblx0ICogQHBhcmFtIHtYUlJlZmVyZW5jZVNwYWNlfSByZWZlcmVuY2VTcGFjZSAtIFRoZSByZWZlcmVuY2Ugc3BhY2UuXG5cdCAqIEByZXR1cm4ge1dlYlhSQ29udHJvbGxlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHVwZGF0ZSggaW5wdXRTb3VyY2UsIGZyYW1lLCByZWZlcmVuY2VTcGFjZSApIHtcblxuXHRcdGxldCBpbnB1dFBvc2UgPSBudWxsO1xuXHRcdGxldCBncmlwUG9zZSA9IG51bGw7XG5cdFx0bGV0IGhhbmRQb3NlID0gbnVsbDtcblxuXHRcdGNvbnN0IHRhcmdldFJheSA9IHRoaXMuX3RhcmdldFJheTtcblx0XHRjb25zdCBncmlwID0gdGhpcy5fZ3JpcDtcblx0XHRjb25zdCBoYW5kID0gdGhpcy5faGFuZDtcblxuXHRcdGlmICggaW5wdXRTb3VyY2UgJiYgZnJhbWUuc2Vzc2lvbi52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlLWJsdXJyZWQnICkge1xuXG5cdFx0XHRpZiAoIGhhbmQgJiYgaW5wdXRTb3VyY2UuaGFuZCApIHtcblxuXHRcdFx0XHRoYW5kUG9zZSA9IHRydWU7XG5cblx0XHRcdFx0Zm9yICggY29uc3QgaW5wdXRqb2ludCBvZiBpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpICkge1xuXG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBqb2ludHMgZ3JvdXBzIHdpdGggdGhlIFhSSm9pbnQgcG9zZXNcblx0XHRcdFx0XHRjb25zdCBqb2ludFBvc2UgPSBmcmFtZS5nZXRKb2ludFBvc2UoIGlucHV0am9pbnQsIHJlZmVyZW5jZVNwYWNlICk7XG5cblx0XHRcdFx0XHQvLyBUaGUgdHJhbnNmb3JtIG9mIHRoaXMgam9pbnQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGpvaW50IHBvc2Ugb24gZWFjaCBmcmFtZVxuXHRcdFx0XHRcdGNvbnN0IGpvaW50ID0gdGhpcy5fZ2V0SGFuZEpvaW50KCBoYW5kLCBpbnB1dGpvaW50ICk7XG5cblx0XHRcdFx0XHRpZiAoIGpvaW50UG9zZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0am9pbnQubWF0cml4LmZyb21BcnJheSggam9pbnRQb3NlLnRyYW5zZm9ybS5tYXRyaXggKTtcblx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeC5kZWNvbXBvc2UoIGpvaW50LnBvc2l0aW9uLCBqb2ludC5yb3RhdGlvbiwgam9pbnQuc2NhbGUgKTtcblx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0am9pbnQuam9pbnRSYWRpdXMgPSBqb2ludFBvc2UucmFkaXVzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0am9pbnQudmlzaWJsZSA9IGpvaW50UG9zZSAhPT0gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3VzdG9tIGV2ZW50c1xuXG5cdFx0XHRcdC8vIENoZWNrIHBpbmNoelxuXHRcdFx0XHRjb25zdCBpbmRleFRpcCA9IGhhbmQuam9pbnRzWyAnaW5kZXgtZmluZ2VyLXRpcCcgXTtcblx0XHRcdFx0Y29uc3QgdGh1bWJUaXAgPSBoYW5kLmpvaW50c1sgJ3RodW1iLXRpcCcgXTtcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBpbmRleFRpcC5wb3NpdGlvbi5kaXN0YW5jZVRvKCB0aHVtYlRpcC5wb3NpdGlvbiApO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlVG9QaW5jaCA9IDAuMDI7XG5cdFx0XHRcdGNvbnN0IHRocmVzaG9sZCA9IDAuMDA1O1xuXG5cdFx0XHRcdGlmICggaGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nICYmIGRpc3RhbmNlID4gZGlzdGFuY2VUb1BpbmNoICsgdGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0aGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAncGluY2hlbmQnLFxuXHRcdFx0XHRcdFx0aGFuZGVkbmVzczogaW5wdXRTb3VyY2UuaGFuZGVkbmVzcyxcblx0XHRcdFx0XHRcdHRhcmdldDogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA8PSBkaXN0YW5jZVRvUGluY2ggLSB0aHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCgge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoc3RhcnQnLFxuXHRcdFx0XHRcdFx0aGFuZGVkbmVzczogaW5wdXRTb3VyY2UuaGFuZGVkbmVzcyxcblx0XHRcdFx0XHRcdHRhcmdldDogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBncmlwICE9PSBudWxsICYmIGlucHV0U291cmNlLmdyaXBTcGFjZSApIHtcblxuXHRcdFx0XHRcdGdyaXBQb3NlID0gZnJhbWUuZ2V0UG9zZSggaW5wdXRTb3VyY2UuZ3JpcFNwYWNlLCByZWZlcmVuY2VTcGFjZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBncmlwUG9zZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZnJvbUFycmF5KCBncmlwUG9zZS50cmFuc2Zvcm0ubWF0cml4ICk7XG5cdFx0XHRcdFx0XHRncmlwLm1hdHJpeC5kZWNvbXBvc2UoIGdyaXAucG9zaXRpb24sIGdyaXAucm90YXRpb24sIGdyaXAuc2NhbGUgKTtcblx0XHRcdFx0XHRcdGdyaXAubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggZ3JpcFBvc2UubGluZWFyVmVsb2NpdHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGdyaXAubGluZWFyVmVsb2NpdHkuY29weSggZ3JpcFBvc2UubGluZWFyVmVsb2NpdHkgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBncmlwUG9zZS5hbmd1bGFyVmVsb2NpdHkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRncmlwLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KCBncmlwUG9zZS5hbmd1bGFyVmVsb2NpdHkgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGFyZ2V0UmF5ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlucHV0UG9zZSA9IGZyYW1lLmdldFBvc2UoIGlucHV0U291cmNlLnRhcmdldFJheVNwYWNlLCByZWZlcmVuY2VTcGFjZSApO1xuXG5cdFx0XHRcdC8vIFNvbWUgcnVudGltZXMgKG5hbWVseSBWaXZlIENvc21vcyB3aXRoIFZpdmUgT3BlblhSIFJ1bnRpbWUpIGhhdmUgb25seSBncmlwIHNwYWNlIGFuZCByYXkgc3BhY2UgaXMgZXF1YWwgdG8gaXRcblx0XHRcdFx0aWYgKCBpbnB1dFBvc2UgPT09IG51bGwgJiYgZ3JpcFBvc2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpbnB1dFBvc2UgPSBncmlwUG9zZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbnB1dFBvc2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4LmZyb21BcnJheSggaW5wdXRQb3NlLnRyYW5zZm9ybS5tYXRyaXggKTtcblx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4LmRlY29tcG9zZSggdGFyZ2V0UmF5LnBvc2l0aW9uLCB0YXJnZXRSYXkucm90YXRpb24sIHRhcmdldFJheS5zY2FsZSApO1xuXHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmICggaW5wdXRQb3NlLmxpbmVhclZlbG9jaXR5ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5LmxpbmVhclZlbG9jaXR5LmNvcHkoIGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGlucHV0UG9zZS5hbmd1bGFyVmVsb2NpdHkgKSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eS5jb3B5KCBpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9tb3ZlRXZlbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0YXJnZXRSYXkgIT09IG51bGwgKSB7XG5cblx0XHRcdHRhcmdldFJheS52aXNpYmxlID0gKCBpbnB1dFBvc2UgIT09IG51bGwgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ3JpcCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Z3JpcC52aXNpYmxlID0gKCBncmlwUG9zZSAhPT0gbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYW5kICE9PSBudWxsICkge1xuXG5cdFx0XHRoYW5kLnZpc2libGUgPSAoIGhhbmRQb3NlICE9PSBudWxsICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBncm91cCByZXByZXNlbnRpbmcgdGhlIGhhbmQgam9pbnQgZm9yIHRoZSBnaXZlbiBpbnB1dCBqb2ludC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtHcm91cH0gaGFuZCAtIFRoZSBncm91cCByZXByZXNlbnRpbmcgdGhlIGhhbmQgc3BhY2UuXG5cdCAqIEBwYXJhbSB7WFJKb2ludFNwYWNlfSBpbnB1dGpvaW50IC0gVGhlIGhhbmQgam9pbnQgZGF0YS5cblx0ICogQHJldHVybiB7R3JvdXB9IEEgZ3JvdXAgcmVwcmVzZW50aW5nIHRoZSBoYW5kIGpvaW50IGZvciB0aGUgZ2l2ZW4gaW5wdXQgam9pbnQuXG5cdCAqL1xuXHRfZ2V0SGFuZEpvaW50KCBoYW5kLCBpbnB1dGpvaW50ICkge1xuXG5cdFx0aWYgKCBoYW5kLmpvaW50c1sgaW5wdXRqb2ludC5qb2ludE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBqb2ludCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0am9pbnQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0am9pbnQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0aGFuZC5qb2ludHNbIGlucHV0am9pbnQuam9pbnROYW1lIF0gPSBqb2ludDtcblxuXHRcdFx0aGFuZC5hZGQoIGpvaW50ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZC5qb2ludHNbIGlucHV0am9pbnQuam9pbnROYW1lIF07XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgV2ViWFJDb250cm9sbGVyIH07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGFuIGV4cG9uZW50aWFsIHNxdWFyZWQgZm9nLFxuICogd2hpY2ggZ2l2ZXMgYSBjbGVhciB2aWV3IG5lYXIgdGhlIGNhbWVyYSBhbmQgYSBmYXN0ZXIgdGhhbiBleHBvbmVudGlhbGx5XG4gKiBkZW5zZW5pbmcgZm9nIGZhcnRoZXIgZnJvbSB0aGUgY2FtZXJhLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICogc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZ0V4cDIoIDB4Y2NjY2NjLCAwLjAwMiApO1xuICogYGBgXG4gKi9cbmNsYXNzIEZvZ0V4cDIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZvZy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J9IGNvbG9yIC0gVGhlIGZvZydzIGNvbG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlbnNpdHk9MC4wMDAyNV0gLSBEZWZpbmVzIGhvdyBmYXN0IHRoZSBmb2cgd2lsbCBncm93IGRlbnNlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBkZW5zaXR5ID0gMC4wMDAyNSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNGb2dFeHAyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSBmb2cuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZvZydzIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG5cblx0XHQvKipcblx0XHQgKiAgRGVmaW5lcyBob3cgZmFzdCB0aGUgZm9nIHdpbGwgZ3JvdyBkZW5zZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMC4wMDAyNVxuXHRcdCAqL1xuXHRcdHRoaXMuZGVuc2l0eSA9IGRlbnNpdHk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGZvZyB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtGb2dFeHAyfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvciwgdGhpcy5kZW5zaXR5ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBmb2cgaW50byBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0gez8oT2JqZWN0fHN0cmluZyl9IG1ldGEgLSBBbiBvcHRpb25hbCB2YWx1ZSBob2xkaW5nIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlcmlhbGl6YXRpb24uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZm9nXG5cdCAqL1xuXHR0b0pTT04oIC8qIG1ldGEgKi8gKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ0ZvZ0V4cDInLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXG5cdFx0XHRkZW5zaXR5OiB0aGlzLmRlbnNpdHlcblx0XHR9O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBGb2dFeHAyIH07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGEgbGluZWFyIGZvZyB0aGF0IGdyb3dzIGxpbmVhcmx5IGRlbnNlclxuICogd2l0aCB0aGUgZGlzdGFuY2UuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gKiBzY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKCAweGNjY2NjYywgMTAsIDE1ICk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgRm9nIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmb2cuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfENvbG9yfSBjb2xvciAtIFRoZSBmb2cncyBjb2xvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuZWFyPTFdIC0gVGhlIG1pbmltdW0gZGlzdGFuY2UgdG8gc3RhcnQgYXBwbHlpbmcgZm9nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zhcj0xMDAwXSAtIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGF0IHdoaWNoIGZvZyBzdG9wcyBiZWluZyBjYWxjdWxhdGVkIGFuZCBhcHBsaWVkLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNGb2cgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIGZvZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZm9nJ3MgY29sb3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIHRvIHN0YXJ0IGFwcGx5aW5nIGZvZy4gT2JqZWN0cyB0aGF0IGFyZSBsZXNzIHRoYW5cblx0XHQgKiBgbmVhcmAgdW5pdHMgZnJvbSB0aGUgYWN0aXZlIGNhbWVyYSB3b24ndCBiZSBhZmZlY3RlZCBieSBmb2cuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gZGlzdGFuY2UgYXQgd2hpY2ggZm9nIHN0b3BzIGJlaW5nIGNhbGN1bGF0ZWQgYW5kIGFwcGxpZWQuXG5cdFx0ICogT2JqZWN0cyB0aGF0IGFyZSBtb3JlIHRoYW4gYGZhcmAgdW5pdHMgYXdheSBmcm9tIHRoZSBhY3RpdmUgY2FtZXJhIHdvbid0XG5cdFx0ICogYmUgYWZmZWN0ZWQgYnkgZm9nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxMDAwXG5cdFx0ICovXG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGZvZyB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtGb2d9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBGb2coIHRoaXMuY29sb3IsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIGZvZyBpbnRvIEpTT04uXG5cdCAqXG5cdCAqIEBwYXJhbSB7PyhPYmplY3R8c3RyaW5nKX0gbWV0YSAtIEFuIG9wdGlvbmFsIHZhbHVlIGhvbGRpbmcgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VyaWFsaXphdGlvbi5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXplZCBmb2dcblx0ICovXG5cdHRvSlNPTiggLyogbWV0YSAqLyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nJyxcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdFx0bmVhcjogdGhpcy5uZWFyLFxuXHRcdFx0ZmFyOiB0aGlzLmZhclxuXHRcdH07XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEZvZyB9O1xuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcbmltcG9ydCB7IEV1bGVyIH0gZnJvbSAnLi4vbWF0aC9FdWxlci5qcyc7XG5cbi8qKlxuICogU2NlbmVzIGFsbG93IHlvdSB0byBzZXQgdXAgd2hhdCBpcyB0byBiZSByZW5kZXJlZCBhbmQgd2hlcmUgYnkgdGhyZWUuanMuXG4gKiBUaGlzIGlzIHdoZXJlIHlvdSBwbGFjZSAzRCBvYmplY3RzIGxpa2UgbWVzaGVzLCBsaW5lcyBvciBsaWdodHMuXG4gKlxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIFNjZW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNjZW5lLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NjZW5lID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTY2VuZSc7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBzY2VuZS4gVmFsaWQgaW5wdXRzIGFyZTpcblx0XHQgKlxuXHRcdCAqIC0gQSBjb2xvciBmb3IgZGVmaW5pbmcgYSB1bmlmb3JtIGNvbG9yZWQgYmFja2dyb3VuZC5cblx0XHQgKiAtIEEgdGV4dHVyZSBmb3IgZGVmaW5pbmcgYSAoZmxhdCkgdGV4dHVyZWQgYmFja2dyb3VuZC5cblx0XHQgKiAtIEN1YmUgdGV4dHVyZXMgb3IgZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmVzIGZvciBkZWZpbmluZyBhIHNreWJveC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/KENvbG9yfFRleHR1cmUpfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJhY2tncm91bmQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyB0aGUgZW52aXJvbm1lbnQgbWFwIGZvciBhbGwgcGh5c2ljYWwgbWF0ZXJpYWxzIGluIHRoZSBzY2VuZS4gSG93ZXZlcixcblx0XHQgKiBpdCdzIG5vdCBwb3NzaWJsZSB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdGV4dHVyZSBhc3NpZ25lZCB0byB0aGUgYGVudk1hcGBcblx0XHQgKiBtYXRlcmlhbCBwcm9wZXJ0eS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5lbnZpcm9ubWVudCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIGZvZyBpbnN0YW5jZSBkZWZpbmluZyB0aGUgdHlwZSBvZiBmb2cgdGhhdCBhZmZlY3RzIGV2ZXJ5dGhpbmdcblx0XHQgKiByZW5kZXJlZCBpbiB0aGUgc2NlbmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7PyhGb2d8Rm9nRXhwMil9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZm9nID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIGJsdXJyaW5lc3Mgb2YgdGhlIGJhY2tncm91bmQuIE9ubHkgaW5mbHVlbmNlcyBlbnZpcm9ubWVudCBtYXBzXG5cdFx0ICogYXNzaWduZWQgdG8ge0BsaW5rIFNjZW5lI2JhY2tncm91bmR9LiBWYWxpZCBpbnB1dCBpcyBhIGZsb2F0IGJldHdlZW4gYDBgXG5cdFx0ICogYW5kIGAxYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQXR0ZW51YXRlcyB0aGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQuIE9ubHkgYXBwbGllcyB0byBiYWNrZ3JvdW5kIHRleHR1cmVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYmFja2dyb3VuZCBpbiByYWRpYW5zLiBPbmx5IGluZmx1ZW5jZXMgZW52aXJvbm1lbnQgbWFwc1xuXHRcdCAqIGFzc2lnbmVkIHRvIHtAbGluayBTY2VuZSNiYWNrZ3JvdW5kfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtFdWxlcn1cblx0XHQgKiBAZGVmYXVsdCAoMCwwLDApXG5cdFx0ICovXG5cdFx0dGhpcy5iYWNrZ3JvdW5kUm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEF0dGVudWF0ZXMgdGhlIGNvbG9yIG9mIHRoZSBlbnZpcm9ubWVudC4gT25seSBpbmZsdWVuY2VzIGVudmlyb25tZW50IG1hcHNcblx0XHQgKiBhc3NpZ25lZCB0byB7QGxpbmsgU2NlbmUjZW52aXJvbm1lbnR9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcm90YXRpb24gb2YgdGhlIGVudmlyb25tZW50IG1hcCBpbiByYWRpYW5zLiBPbmx5IGluZmx1ZW5jZXMgcGh5c2ljYWwgbWF0ZXJpYWxzXG5cdFx0ICogaW4gdGhlIHNjZW5lIHdoZW4ge0BsaW5rIFNjZW5lI2Vudmlyb25tZW50fSBpcyB1c2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0V1bGVyfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHQgKi9cblx0XHR0aGlzLmVudmlyb25tZW50Um90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEZvcmNlcyBldmVyeXRoaW5nIGluIHRoZSBzY2VuZSB0byBiZSByZW5kZXJlZCB3aXRoIHRoZSBkZWZpbmVkIG1hdGVyaWFsLiBJdCBpcyBwb3NzaWJsZVxuXHRcdCAqIHRvIGV4Y2x1ZGUgbWF0ZXJpYWxzIGZyb20gb3ZlcnJpZGUgYnkgc2V0dGluZyB7QGxpbmsgTWF0ZXJpYWwjYWxsb3dPdmVycmlkZX0gdG8gYGZhbHNlYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/TWF0ZXJpYWx9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0XHRpZiAoIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCAnb2JzZXJ2ZScsIHsgZGV0YWlsOiB0aGlzIH0gKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5lbnZpcm9ubWVudCAhPT0gbnVsbCApIHRoaXMuZW52aXJvbm1lbnQgPSBzb3VyY2UuZW52aXJvbm1lbnQuY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcblxuXHRcdHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBzb3VyY2UuYmFja2dyb3VuZEJsdXJyaW5lc3M7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gc291cmNlLmJhY2tncm91bmRJbnRlbnNpdHk7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kUm90YXRpb24uY29weSggc291cmNlLmJhY2tncm91bmRSb3RhdGlvbiApO1xuXG5cdFx0dGhpcy5lbnZpcm9ubWVudEludGVuc2l0eSA9IHNvdXJjZS5lbnZpcm9ubWVudEludGVuc2l0eTtcblx0XHR0aGlzLmVudmlyb25tZW50Um90YXRpb24uY29weSggc291cmNlLmVudmlyb25tZW50Um90YXRpb24gKTtcblxuXHRcdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpO1xuXG5cdFx0aWYgKCB0aGlzLmJhY2tncm91bmRCbHVycmluZXNzID4gMCApIGRhdGEub2JqZWN0LmJhY2tncm91bmRCbHVycmluZXNzID0gdGhpcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcztcblx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZEludGVuc2l0eSAhPT0gMSApIGRhdGEub2JqZWN0LmJhY2tncm91bmRJbnRlbnNpdHkgPSB0aGlzLmJhY2tncm91bmRJbnRlbnNpdHk7XG5cdFx0ZGF0YS5vYmplY3QuYmFja2dyb3VuZFJvdGF0aW9uID0gdGhpcy5iYWNrZ3JvdW5kUm90YXRpb24udG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5ICE9PSAxICkgZGF0YS5vYmplY3QuZW52aXJvbm1lbnRJbnRlbnNpdHkgPSB0aGlzLmVudmlyb25tZW50SW50ZW5zaXR5O1xuXHRcdGRhdGEub2JqZWN0LmVudmlyb25tZW50Um90YXRpb24gPSB0aGlzLmVudmlyb25tZW50Um90YXRpb24udG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNjZW5lIH07XG4iLCJpbXBvcnQgeyBnZW5lcmF0ZVVVSUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIFwiSW50ZXJsZWF2ZWRcIiBtZWFucyB0aGF0IG11bHRpcGxlIGF0dHJpYnV0ZXMsIHBvc3NpYmx5IG9mIGRpZmZlcmVudCB0eXBlcyxcbiAqIChlLmcuLCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgY29sb3IpIGFyZSBwYWNrZWQgaW50byBhIHNpbmdsZSBhcnJheSBidWZmZXIuXG4gKlxuICogQW4gaW50cm9kdWN0aW9uIGludG8gaW50ZXJsZWF2ZWQgYXJyYXlzIGNhbiBiZSBmb3VuZCBoZXJlOiBbSW50ZXJsZWF2ZWQgYXJyYXkgYmFzaWNzXXtAbGluayBodHRwczovL2Jsb2cudG9qaWNvZGUuY29tLzIwMTEvMDUvaW50ZXJsZWF2ZWQtYXJyYXktYmFzaWNzLmh0bWx9XG4gKi9cbmNsYXNzIEludGVybGVhdmVkQnVmZmVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnRlcmxlYXZlZCBidWZmZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gYXJyYXkgLSBBIHR5cGVkIGFycmF5IHdpdGggYSBzaGFyZWQgYnVmZmVyIHN0b3JpbmcgYXR0cmlidXRlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBUaGUgbnVtYmVyIG9mIHR5cGVkLWFycmF5IGVsZW1lbnRzIHBlciB2ZXJ0ZXguXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIHN0cmlkZSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBBIHR5cGVkIGFycmF5IHdpdGggYSBzaGFyZWQgYnVmZmVyIHN0b3JpbmcgYXR0cmlidXRlIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHR5cGVkLWFycmF5IGVsZW1lbnRzIHBlciB2ZXJ0ZXguXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvdGFsIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgaW50ZW5kZWQgdXNhZ2UgcGF0dGVybiBvZiB0aGUgZGF0YSBzdG9yZSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLlxuXHRcdCAqXG5cdFx0ICogTm90ZTogQWZ0ZXIgdGhlIGluaXRpYWwgdXNlIG9mIGEgYnVmZmVyLCBpdHMgdXNhZ2UgY2Fubm90IGJlIGNoYW5nZWQuIEluc3RlYWQsXG5cdFx0ICogaW5zdGFudGlhdGUgYSBuZXcgb25lIGFuZCBzZXQgdGhlIGRlc2lyZWQgdXNhZ2UgYmVmb3JlIHRoZSBuZXh0IHJlbmRlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoU3RhdGljRHJhd1VzYWdlfER5bmFtaWNEcmF3VXNhZ2V8U3RyZWFtRHJhd1VzYWdlfFN0YXRpY1JlYWRVc2FnZXxEeW5hbWljUmVhZFVzYWdlfFN0cmVhbVJlYWRVc2FnZXxTdGF0aWNDb3B5VXNhZ2V8RHluYW1pY0NvcHlVc2FnZXxTdHJlYW1Db3B5VXNhZ2UpfVxuXHRcdCAqIEBkZWZhdWx0IFN0YXRpY0RyYXdVc2FnZVxuXHRcdCAqL1xuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIG9ubHkgdXBkYXRlIHNvbWUgY29tcG9uZW50cyBvZiBzdG9yZWQgdmVjdG9ycyAoZm9yIGV4YW1wbGUsIGp1c3QgdGhlXG5cdFx0ICogY29tcG9uZW50IHJlbGF0ZWQgdG8gY29sb3IpLiBVc2UgdGhlIGBhZGRVcGRhdGVSYW5nZSgpYCBmdW5jdGlvbiB0byBhZGQgcmFuZ2VzIHRvIHRoaXMgYXJyYXkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cblx0XHQgKi9cblx0XHR0aGlzLnVwZGF0ZVJhbmdlcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB2ZXJzaW9uIG51bWJlciwgaW5jcmVtZW50ZWQgZXZlcnkgdGltZSB0aGUgYG5lZWRzVXBkYXRlYCBpcyBzZXQgdG8gYHRydWVgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIFVVSUQgb2YgdGhlIGludGVybGVhdmVkIGJ1ZmZlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlbmRlcmVyIGhhcyB0cmFuc2ZlcnJlZCB0aGUgYXR0cmlidXRlIGFycmF5XG5cdCAqIGRhdGEgdG8gdGhlIEdQVS5cblx0ICovXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIHRoYXQgdGhpcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgYW5kIHNob3VsZCBiZSByZS1zZW50IHRvXG5cdCAqIHRoZSBHUFUuIFNldCB0aGlzIHRvIGB0cnVlYCB3aGVuIHlvdSBtb2RpZnkgdGhlIHZhbHVlIG9mIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1c2FnZSBvZiB0aGlzIGludGVybGVhdmVkIGJ1ZmZlci5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RhdGljRHJhd1VzYWdlfER5bmFtaWNEcmF3VXNhZ2V8U3RyZWFtRHJhd1VzYWdlfFN0YXRpY1JlYWRVc2FnZXxEeW5hbWljUmVhZFVzYWdlfFN0cmVhbVJlYWRVc2FnZXxTdGF0aWNDb3B5VXNhZ2V8RHluYW1pY0NvcHlVc2FnZXxTdHJlYW1Db3B5VXNhZ2UpfSB2YWx1ZSAtIFRoZSB1c2FnZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0ludGVybGVhdmVkQnVmZmVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGludGVybGVhdmVkIGJ1ZmZlci5cblx0ICovXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJhbmdlIG9mIGRhdGEgaW4gdGhlIGRhdGEgYXJyYXkgdG8gYmUgdXBkYXRlZCBvbiB0aGUgR1BVLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBQb3NpdGlvbiBhdCB3aGljaCB0byBzdGFydCB1cGRhdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyB0byB1cGRhdGUuXG5cdCAqL1xuXHRhZGRVcGRhdGVSYW5nZSggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0dGhpcy51cGRhdGVSYW5nZXMucHVzaCggeyBzdGFydCwgY291bnQgfSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSB1cGRhdGUgcmFuZ2VzLlxuXHQgKi9cblx0Y2xlYXJVcGRhdGVSYW5nZXMoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGggPSAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGludGVybGVhdmVkIGJ1ZmZlciB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0ludGVybGVhdmVkQnVmZmVyfSBzb3VyY2UgLSBUaGUgaW50ZXJsZWF2ZWQgYnVmZmVyIHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge0ludGVybGVhdmVkQnVmZmVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuXHRcdHRoaXMudXNhZ2UgPSBzb3VyY2UudXNhZ2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyBhIHZlY3RvciBmcm9tIHRoZSBnaXZlbiBpbnRlcmxlYXZlZCBidWZmZXIgdG8gdGhpcyBvbmUuIFRoZSBzdGFydFxuXHQgKiBhbmQgZGVzdGluYXRpb24gcG9zaXRpb24gaW4gdGhlIGF0dHJpYnV0ZSBidWZmZXJzIGFyZSByZXByZXNlbnRlZCBieSB0aGVcblx0ICogZ2l2ZW4gaW5kaWNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MSAtIFRoZSBkZXN0aW5hdGlvbiBpbmRleCBpbnRvIHRoaXMgaW50ZXJsZWF2ZWQgYnVmZmVyLlxuXHQgKiBAcGFyYW0ge0ludGVybGVhdmVkQnVmZmVyfSBpbnRlcmxlYXZlZEJ1ZmZlciAtIFRoZSBpbnRlcmxlYXZlZCBidWZmZXIgdG8gY29weSBmcm9tLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgyIC0gVGhlIHNvdXJjZSBpbmRleCBpbnRvIHRoZSBnaXZlbiBpbnRlcmxlYXZlZCBidWZmZXIuXG5cdCAqIEByZXR1cm4ge0ludGVybGVhdmVkQnVmZmVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29weUF0KCBpbmRleDEsIGludGVybGVhdmVkQnVmZmVyLCBpbmRleDIgKSB7XG5cblx0XHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG5cdFx0aW5kZXgyICo9IGludGVybGVhdmVkQnVmZmVyLnN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gaW50ZXJsZWF2ZWRCdWZmZXIuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gYXJyYXkgZGF0YSBpbiB0aGUgaW50ZXJsZWF2ZWQgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhUeXBlZEFycmF5fEFycmF5KX0gdmFsdWUgLSBUaGUgYXJyYXkgZGF0YSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gVGhlIG9mZnNldCBpbiB0aGlzIGludGVybGVhdmVkIGJ1ZmZlcidzIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldCggdmFsdWUsIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGludGVybGVhdmVkIGJ1ZmZlciB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gQW4gb2JqZWN0IHdpdGggc2hhcmVkIGFycmF5IGJ1ZmZlcnMgdGhhdCBhbGxvd3MgdG8gcmV0YWluIHNoYXJlZCBzdHJ1Y3R1cmVzLlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlcn0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID0gdGhpcy5hcnJheS5zbGljZSggMCApLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFycmF5ID0gbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdICk7XG5cblx0XHRjb25zdCBpYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBhcnJheSwgdGhpcy5zdHJpZGUgKTtcblx0XHRpYi5zZXRVc2FnZSggdGhpcy51c2FnZSApO1xuXG5cdFx0cmV0dXJuIGliO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBhZnRlciB0aGUgUmVuZGVyZXIgaGFzIHRyYW5zZmVycmVkXG5cdCAqIHRoZSBhcnJheSBkYXRhIHRvIHRoZSBHUFUuIENhbiBiZSB1c2VkIHRvIHBlcmZvcm0gY2xlYW4tdXAgb3BlcmF0aW9ucyBhZnRlclxuXHQgKiB0aGUgdXBsb2FkIHdoZW4gZGF0YSBhcmUgbm90IG5lZWRlZCBhbnltb3JlIG9uIHRoZSBDUFUgc2lkZS5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgYG9uVXBsb2FkKClgIGNhbGxiYWNrLlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdG9uVXBsb2FkKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBpbnRlcmxlYXZlZCBidWZmZXIgaW50byBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gQW4gb3B0aW9uYWwgdmFsdWUgaG9sZGluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJpYWxpemF0aW9uLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGludGVybGVhdmVkIGJ1ZmZlci5cblx0ICovXG5cdHRvSlNPTiggZGF0YSApIHtcblxuXHRcdGlmICggZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnMgPSB7fTtcblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIFVVSUQgZm9yIGFycmF5IGJ1ZmZlciBpZiBuZWNlc3NhcnlcblxuXHRcdGlmICggdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdH1cblxuXHRcdGlmICggZGF0YS5hcnJheUJ1ZmZlcnNbIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnNbIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkIF0gPSBBcnJheS5mcm9tKCBuZXcgVWludDMyQXJyYXkoIHRoaXMuYXJyYXkuYnVmZmVyICkgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0YnVmZmVyOiB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCxcblx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdHN0cmlkZTogdGhpcy5zdHJpZGVcblx0XHR9O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlciB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBkZW5vcm1hbGl6ZSwgbm9ybWFsaXplIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHZlcnNpb24gb2YgYSBidWZmZXIgYXR0cmlidXRlIHdpdGggaW50ZXJsZWF2ZWQgZGF0YS4gSW50ZXJsZWF2ZWRcbiAqIGF0dHJpYnV0ZXMgc2hhcmUgYSBjb21tb24gaW50ZXJsZWF2ZWQgZGF0YSBzdG9yYWdlICh7QGxpbmsgSW50ZXJsZWF2ZWRCdWZmZXJ9KSBhbmQgcmVmZXIgd2l0aFxuICogZGlmZmVyZW50IG9mZnNldHMgaW50byB0aGUgYnVmZmVyLlxuICovXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtJbnRlcmxlYXZlZEJ1ZmZlcn0gaW50ZXJsZWF2ZWRCdWZmZXIgLSBUaGUgYnVmZmVyIGhvbGRpbmcgdGhlIGludGVybGVhdmVkIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgYXR0cmlidXRlIG9mZnNldCBpbnRvIHRoZSBidWZmZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGF0YSBhcmUgbm9ybWFsaXplZCBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIG5vcm1hbGl6ZWQgPSBmYWxzZSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnVmZmVyIGhvbGRpbmcgdGhlIGludGVybGVhdmVkIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7SW50ZXJsZWF2ZWRCdWZmZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaXRlbSBzaXplLCBzZWUge0BsaW5rIEJ1ZmZlckF0dHJpYnV0ZSNpdGVtU2l6ZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhdHRyaWJ1dGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBkYXRhIGFyZSBub3JtYWxpemVkIG9yIG5vdCwgc2VlIHtAbGluayBCdWZmZXJBdHRyaWJ1dGUjbm9ybWFsaXplZH1cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtJbnRlcmxlYXZlZEJ1ZmZlcn1cblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGl0ZW0gY291bnQgb2YgdGhpcyBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCBjb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYXJyYXkgaG9sZGluZyB0aGUgaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSBkYXRhLlxuXHQgKlxuXHQgKiBAdHlwZSB7VHlwZWRBcnJheX1cblx0ICovXG5cdGdldCBhcnJheSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIHRoYXQgdGhpcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgYW5kIHNob3VsZCBiZSByZS1zZW50IHRvXG5cdCAqIHRoZSBHUFUuIFNldCB0aGlzIHRvIGB0cnVlYCB3aGVuIHlvdSBtb2RpZnkgdGhlIHZhbHVlIG9mIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZGF0YS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gNHg0IG1hdHJpeCB0byB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBPbmx5IHdvcmtzIHdpdGhcblx0ICogaXRlbSBzaXplIGAzYC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIG1hdHJpeCB0byBhcHBseS5cblx0ICogQHJldHVybiB7SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmRhdGEuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZ2l2ZW4gM3gzIG5vcm1hbCBtYXRyaXggdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZS4gT25seSB3b3JrcyB3aXRoXG5cdCAqIGl0ZW0gc2l6ZSBgM2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4M30gbSAtIFRoZSBub3JtYWwgbWF0cml4IHRvIGFwcGx5LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGFwcGx5Tm9ybWFsTWF0cml4KCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yLmFwcGx5Tm9ybWFsTWF0cml4KCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXggdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZS4gT25seSB3b3JrcyB3aXRoXG5cdCAqIGl0ZW0gc2l6ZSBgM2AgYW5kIHdpdGggZGlyZWN0aW9uIHZlY3RvcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbSAtIFRoZSBtYXRyaXggdG8gYXBwbHkuXG5cdCAqIEByZXR1cm4ge0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0dHJhbnNmb3JtRGlyZWN0aW9uKCBtICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXG5cdFx0XHRfdmVjdG9yLnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBnaXZlbiBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCBpbmRleC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmV0dXJuZWQgdmFsdWUuXG5cdCAqL1xuXHRnZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQgKSB7XG5cblx0XHRsZXQgdmFsdWUgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIGNvbXBvbmVudCBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB2YWx1ZSA9IGRlbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGdpdmVuIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb21wb25lbnQgLSBUaGUgY29tcG9uZW50IGluZGV4LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHZhbHVlID0gbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIGNvbXBvbmVudCBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdyBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gdGhlIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHggY29tcG9uZW50LlxuXHQgKi9cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgeSBjb21wb25lbnQuXG5cdCAqL1xuXHRnZXRZKCBpbmRleCApIHtcblxuXHRcdGxldCB5ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgeiBjb21wb25lbnQuXG5cdCAqL1xuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IGRlbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gejtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHcgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgdyBjb21wb25lbnQuXG5cdCAqL1xuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHggYW5kIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgZm9yIHRoZSB4IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIGZvciB0aGUgeSBjb21wb25lbnQgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHgsIHkgYW5kIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW50byB0aGUgYnVmZmVyIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdmFsdWUgZm9yIHRoZSB4IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZhbHVlIGZvciB0aGUgeSBjb21wb25lbnQgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB2YWx1ZSBmb3IgdGhlIHogY29tcG9uZW50IHRvIHNldC5cblx0ICogQHJldHVybiB7SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCwgeSwgeiBhbmQgdyBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBmb3IgdGhlIHggY29tcG9uZW50IHRvIHNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmFsdWUgZm9yIHRoZSB5IGNvbXBvbmVudCB0byBzZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHZhbHVlIGZvciB0aGUgeiBjb21wb25lbnQgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB2YWx1ZSBmb3IgdGhlIHcgY29tcG9uZW50IHRvIHNldC5cblx0ICogQHJldHVybiB7SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgYnVmZmVyIGF0dHJpYnV0ZSB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBJZiBubyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIGNsb25pbmcgYW4gaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlLWludGVybGVhdmUgYnVmZmVyIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBBbiBvYmplY3Qgd2l0aCBpbnRlcmxlYXZlZCBidWZmZXJzIHRoYXQgYWxsb3dzIHRvIHJldGFpbiB0aGUgaW50ZXJsZWF2ZWQgcHJvcGVydHkuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZX0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicgKTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdGhpcy5pdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCBhcnJheSApLCB0aGlzLml0ZW1TaXplLCB0aGlzLm5vcm1hbGl6ZWQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSA9IHRoaXMuZGF0YS5jbG9uZSggZGF0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdLCB0aGlzLml0ZW1TaXplLCB0aGlzLm9mZnNldCwgdGhpcy5ub3JtYWxpemVkICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBidWZmZXIgYXR0cmlidXRlIGludG8gSlNPTi5cblx0ICpcblx0ICogSWYgbm8gcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBjbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gQW4gb3B0aW9uYWwgdmFsdWUgaG9sZGluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJpYWxpemF0aW9uLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqL1xuXHR0b0pTT04oIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS50b0pTT04oKTogU2VyaWFsaXppbmcgYW4gaW50ZXJsZWF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlLWludGVybGVhdmUgYnVmZmVyIGRhdGEuJyApO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaSAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCB0aGlzLml0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIGogXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZS1pbnRlcmxlYXZlIGRhdGEgYW5kIHNhdmUgaXQgYXMgYW4gb3JkaW5hcnkgYnVmZmVyIGF0dHJpYnV0ZSBmb3Igbm93XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBhcnJheSxcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gc2F2ZSBhcyB0cnVlIGludGVybGVhdmVkIGF0dHJpYnV0ZVxuXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPSB7fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbIHRoaXMuZGF0YS51dWlkIF0gPSB0aGlzLmRhdGEudG9KU09OKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZTogdHJ1ZSxcblx0XHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHRcdGRhdGE6IHRoaXMuZGF0YS51dWlkLFxuXHRcdFx0XHRvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuXHRcdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHRcdH07XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfTtcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuXG4vKipcbiAqIEEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyBpbnN0YW5jZXMgb2Yge0BsaW5rIFNwcml0ZX0uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCggJ3RleHR1cmVzL3Nwcml0ZS5wbmcnICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCggeyBtYXA6IG1hcCwgY29sb3I6IDB4ZmZmZmZmIH0gKTtcbiAqXG4gKiBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKCBtYXRlcmlhbCApO1xuICogc3ByaXRlLnNjYWxlLnNldCgyMDAsIDIwMCwgMSlcbiAqIHNjZW5lLmFkZCggc3ByaXRlICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTWF0ZXJpYWxcbiAqL1xuY2xhc3MgU3ByaXRlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3ByaXRlIG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29sb3Igb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIG1hcC4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhbiBhbHBoYSBjaGFubmVsLCB0eXBpY2FsbHkgY29tYmluZWRcblx0XHQgKiB3aXRoIHtAbGluayBNYXRlcmlhbCN0cmFuc3BhcmVudH0gb3Ige0BsaW5rIE1hdGVyaWFsI2FscGhhVGVzdH0uIFRoZSB0ZXh0dXJlIG1hcFxuXHRcdCAqIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGUgZGlmZnVzZSBgY29sb3JgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYWxwaGEgbWFwIGlzIGEgZ3JheXNjYWxlIHRleHR1cmUgdGhhdCBjb250cm9scyB0aGUgb3BhY2l0eSBhY3Jvc3MgdGhlXG5cdFx0ICogc3VyZmFjZSAoYmxhY2s6IGZ1bGx5IHRyYW5zcGFyZW50OyB3aGl0ZTogZnVsbHkgb3BhcXVlKS5cblx0XHQgKlxuXHRcdCAqIE9ubHkgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQsIGlnbm9yaW5nIHRoZSBhbHBoYSBjaGFubmVsIGlmIG9uZVxuXHRcdCAqIGV4aXN0cy4gRm9yIFJHQiBhbmQgUkdCQSB0ZXh0dXJlcywgdGhlIHJlbmRlcmVyIHdpbGwgdXNlIHRoZSBncmVlbiBjaGFubmVsXG5cdFx0ICogd2hlbiBzYW1wbGluZyB0aGlzIHRleHR1cmUgZHVlIHRvIHRoZSBleHRyYSBiaXQgb2YgcHJlY2lzaW9uIHByb3ZpZGVkIGZvclxuXHRcdCAqIGdyZWVuIGluIERYVC1jb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgUkdCIDU2NSBmb3JtYXRzLiBMdW1pbmFuY2Utb25seSBhbmRcblx0XHQgKiBsdW1pbmFuY2UvYWxwaGEgdGV4dHVyZXMgd2lsbCBhbHNvIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvdGF0aW9uIG9mIHRoZSBzcHJpdGUgaW4gcmFkaWFucy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoZXRoZXIgc2l6ZSBvZiB0aGUgc3ByaXRlIGlzIGF0dGVudWF0ZWQgYnkgdGhlIGNhbWVyYSBkZXB0aCAocGVyc3BlY3RpdmUgY2FtZXJhIG9ubHkpLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJ3cml0dGVuIHNpbmNlIHNwcml0ZSBtYXRlcmlhbHMgYXJlIHRyYW5zcGFyZW50XG5cdFx0ICogYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGFmZmVjdGVkIGJ5IGZvZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3ByaXRlTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi4vbWF0aC9UcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEludGVybGVhdmVkQnVmZmVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgU3ByaXRlTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanMnO1xuXG5sZXQgX2dlb21ldHJ5O1xuXG5jb25zdCBfaW50ZXJzZWN0UG9pbnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfd29ybGRTY2FsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tdlBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfYWxpZ25lZFBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX3JvdGF0ZWRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF92aWV3V29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5cbmNvbnN0IF92QSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3V2QSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5jb25zdCBfdXZDID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xuXG4vKipcbiAqIEEgc3ByaXRlIGlzIGEgcGxhbmUgdGhhdCBhbHdheXMgZmFjZXMgdG93YXJkcyB0aGUgY2FtZXJhLCBnZW5lcmFsbHkgd2l0aCBhXG4gKiBwYXJ0aWFsbHkgdHJhbnNwYXJlbnQgdGV4dHVyZSBhcHBsaWVkLlxuICpcbiAqIFNwcml0ZXMgZG8gbm90IGNhc3Qgc2hhZG93cywgc2V0dGluZyB7QGxpbmsgT2JqZWN0M0QjY2FzdFNoYWRvd30gdG8gYHRydWVgIHdpbGxcbiAqIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoICdzcHJpdGUucG5nJyApO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoIHsgbWFwOiBtYXAgfSApO1xuICpcbiAqIGNvbnN0IHNwcml0ZSA9IG5ldyBUSFJFRS5TcHJpdGUoIG1hdGVyaWFsICk7XG4gKiBzY2VuZS5hZGQoIHNwcml0ZSApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIFNwcml0ZSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzcHJpdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3ByaXRlTWF0ZXJpYWx9IFttYXRlcmlhbF0gLSBUaGUgc3ByaXRlIG1hdGVyaWFsLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1hdGVyaWFsID0gbmV3IFNwcml0ZU1hdGVyaWFsKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1Nwcml0ZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3ByaXRlJztcblxuXHRcdGlmICggX2dlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdF9nZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0XHRcdC0gMC41LCAtIDAuNSwgMCwgMCwgMCxcblx0XHRcdFx0MC41LCAtIDAuNSwgMCwgMSwgMCxcblx0XHRcdFx0MC41LCAwLjUsIDAsIDEsIDEsXG5cdFx0XHRcdC0gMC41LCAwLjUsIDAsIDAsIDFcblx0XHRcdF0gKTtcblxuXHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoIGZsb2F0MzJBcnJheSwgNSApO1xuXG5cdFx0XHRfZ2VvbWV0cnkuc2V0SW5kZXgoIFsgMCwgMSwgMixcdDAsIDIsIDMgXSApO1xuXHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgMywgMCwgZmFsc2UgKSApO1xuXHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgMiwgMywgZmFsc2UgKSApO1xuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNwcml0ZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtCdWZmZXJHZW9tZXRyeX1cblx0XHQgKi9cblx0XHR0aGlzLmdlb21ldHJ5ID0gX2dlb21ldHJ5O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNwcml0ZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtTcHJpdGVNYXRlcmlhbH1cblx0XHQgKi9cblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3ByaXRlJ3MgYW5jaG9yIHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCB0aGUgc3ByaXRlIHJvdGF0ZXMuXG5cdFx0ICogQSB2YWx1ZSBvZiBgKDAuNSwgMC41KWAgY29ycmVzcG9uZHMgdG8gdGhlIG1pZHBvaW50IG9mIHRoZSBzcHJpdGUuIEEgdmFsdWVcblx0XHQgKiBvZiBgKDAsIDApYCBjb3JyZXNwb25kcyB0byB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHNwcml0ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgwLjUsMC41KVxuXHRcdCAqL1xuXHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoIDAuNSwgMC41ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBpbnRlcnNlY3Rpb24gcG9pbnRzIGJldHdlZW4gYSBjYXN0ZWQgcmF5IGFuZCB0aGlzIHNwcml0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtSYXljYXN0ZXJ9IHJheWNhc3RlciAtIFRoZSByYXljYXN0ZXIuXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gaW50ZXJzZWN0cyAtIFRoZSB0YXJnZXQgYXJyYXkgdGhhdCBob2xkcyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cblx0ICovXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGlmICggcmF5Y2FzdGVyLmNhbWVyYSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwcml0ZTogXCJSYXljYXN0ZXIuY2FtZXJhXCIgbmVlZHMgdG8gYmUgc2V0IGluIG9yZGVyIHRvIHJheWNhc3QgYWdhaW5zdCBzcHJpdGVzLicgKTtcblxuXHRcdH1cblxuXHRcdF93b3JsZFNjYWxlLnNldEZyb21NYXRyaXhTY2FsZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0X3ZpZXdXb3JsZE1hdHJpeC5jb3B5KCByYXljYXN0ZXIuY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0dGhpcy5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggcmF5Y2FzdGVyLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdF9tdlBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tb2RlbFZpZXdNYXRyaXggKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLmNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICYmIHRoaXMubWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID09PSBmYWxzZSApIHtcblxuXHRcdFx0X3dvcmxkU2NhbGUubXVsdGlwbHlTY2FsYXIoIC0gX212UG9zaXRpb24ueiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm90YXRpb24gPSB0aGlzLm1hdGVyaWFsLnJvdGF0aW9uO1xuXHRcdGxldCBzaW4sIGNvcztcblxuXHRcdGlmICggcm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdGNvcyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdFx0c2luID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdHRyYW5zZm9ybVZlcnRleCggX3ZBLnNldCggLSAwLjUsIC0gMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xuXHRcdHRyYW5zZm9ybVZlcnRleCggX3ZCLnNldCggMC41LCAtIDAuNSwgMCApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MgKTtcblx0XHR0cmFuc2Zvcm1WZXJ0ZXgoIF92Qy5zZXQoIDAuNSwgMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xuXG5cdFx0X3V2QS5zZXQoIDAsIDAgKTtcblx0XHRfdXZCLnNldCggMSwgMCApO1xuXHRcdF91dkMuc2V0KCAxLCAxICk7XG5cblx0XHQvLyBjaGVjayBmaXJzdCB0cmlhbmdsZVxuXHRcdGxldCBpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKCBfdkEsIF92QiwgX3ZDLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50ICk7XG5cblx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgc2Vjb25kIHRyaWFuZ2xlXG5cdFx0XHR0cmFuc2Zvcm1WZXJ0ZXgoIF92Qi5zZXQoIC0gMC41LCAwLjUsIDAgKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zICk7XG5cdFx0XHRfdXZCLnNldCggMCwgMSApO1xuXG5cdFx0XHRpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKCBfdkEsIF92QywgX3ZCLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50ICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggX2ludGVyc2VjdFBvaW50ICk7XG5cblx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiBfaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcblx0XHRcdHV2OiBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0aW9uKCBfaW50ZXJzZWN0UG9pbnQsIF92QSwgX3ZCLCBfdkMsIF91dkEsIF91dkIsIF91dkMsIG5ldyBWZWN0b3IyKCkgKSxcblx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aWYgKCBzb3VyY2UuY2VudGVyICE9PSB1bmRlZmluZWQgKSB0aGlzLmNlbnRlci5jb3B5KCBzb3VyY2UuY2VudGVyICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVZlcnRleCggdmVydGV4UG9zaXRpb24sIG12UG9zaXRpb24sIGNlbnRlciwgc2NhbGUsIHNpbiwgY29zICkge1xuXG5cdC8vIGNvbXB1dGUgcG9zaXRpb24gaW4gY2FtZXJhIHNwYWNlXG5cdF9hbGlnbmVkUG9zaXRpb24uc3ViVmVjdG9ycyggdmVydGV4UG9zaXRpb24sIGNlbnRlciApLmFkZFNjYWxhciggMC41ICkubXVsdGlwbHkoIHNjYWxlICk7XG5cblx0Ly8gdG8gY2hlY2sgaWYgcm90YXRpb24gaXMgbm90IHplcm9cblx0aWYgKCBzaW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdF9yb3RhdGVkUG9zaXRpb24ueCA9ICggY29zICogX2FsaWduZWRQb3NpdGlvbi54ICkgLSAoIHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueSApO1xuXHRcdF9yb3RhdGVkUG9zaXRpb24ueSA9ICggc2luICogX2FsaWduZWRQb3NpdGlvbi54ICkgKyAoIGNvcyAqIF9hbGlnbmVkUG9zaXRpb24ueSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRfcm90YXRlZFBvc2l0aW9uLmNvcHkoIF9hbGlnbmVkUG9zaXRpb24gKTtcblxuXHR9XG5cblxuXHR2ZXJ0ZXhQb3NpdGlvbi5jb3B5KCBtdlBvc2l0aW9uICk7XG5cdHZlcnRleFBvc2l0aW9uLnggKz0gX3JvdGF0ZWRQb3NpdGlvbi54O1xuXHR2ZXJ0ZXhQb3NpdGlvbi55ICs9IF9yb3RhdGVkUG9zaXRpb24ueTtcblxuXHQvLyB0cmFuc2Zvcm0gdG8gd29ybGQgc3BhY2Vcblx0dmVydGV4UG9zaXRpb24uYXBwbHlNYXRyaXg0KCBfdmlld1dvcmxkTWF0cml4ICk7XG5cbn1cblxuZXhwb3J0IHsgU3ByaXRlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5cbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgcHJvdmlkaW5nIGEgYmFzaWMgTGV2ZWwgb2YgRGV0YWlsIChMT0QpIG1lY2hhbmlzbS5cbiAqXG4gKiBFdmVyeSBMT0QgbGV2ZWwgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIG9iamVjdCwgYW5kIHJlbmRlcmluZyBjYW4gYmUgc3dpdGNoZWRcbiAqIGJldHdlZW4gdGhlbSBhdCB0aGUgZGlzdGFuY2VzIHNwZWNpZmllZC4gVHlwaWNhbGx5IHlvdSB3b3VsZCBjcmVhdGUsIHNheSxcbiAqIHRocmVlIG1lc2hlcywgb25lIGZvciBmYXIgYXdheSAobG93IGRldGFpbCksIG9uZSBmb3IgbWlkIHJhbmdlIChtZWRpdW1cbiAqIGRldGFpbCkgYW5kIG9uZSBmb3IgY2xvc2UgdXAgKGhpZ2ggZGV0YWlsKS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbG9kID0gbmV3IFRIUkVFLkxPRCgpO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKTtcbiAqXG4gKiAvL0NyZWF0ZSBzcGhlcmVzIHdpdGggMyBsZXZlbHMgb2YgZGV0YWlsIGFuZCBjcmVhdGUgbmV3IExPRCBsZXZlbHMgZm9yIHRoZW1cbiAqIGZvciggbGV0IGkgPSAwOyBpIDwgMzsgaSsrICkge1xuICpcbiAqIFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMTAsIDMgLSBpICk7XG4gKiBcdGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBcdGxvZC5hZGRMZXZlbCggbWVzaCwgaSAqIDc1ICk7XG4gKlxuICogfVxuICpcbiAqIHNjZW5lLmFkZCggbG9kICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgTE9EIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IExPRC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNMT0QgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgTE9EIGluZGV4LlxuXHRcdCAqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSAwO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xPRCc7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGFycmF5IGhvbGRzIHRoZSBMT0QgbGV2ZWxzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBuYW1lIExPRCNsZXZlbHNcblx0XHRcdCAqIEB0eXBlIHtBcnJheTx7b2JqZWN0Ok9iamVjdDNELGRpc3RhbmNlOm51bWJlcixoeXN0ZXJlc2lzOm51bWJlcn0+fVxuXHRcdFx0ICovXG5cdFx0XHRsZXZlbHM6IHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgTE9EIG9iamVjdCBpcyB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHJlbmRlcmVyIHBlciBmcmFtZVxuXHRcdCAqIG9yIG5vdC4gSWYgc2V0IHRvIGBmYWxzZWAsIHlvdSBoYXZlIHRvIGNhbGwge0BsaW5rIExPRCN1cGRhdGV9IGluIHRoZVxuXHRcdCAqIHJlbmRlciBsb29wIGJ5IHlvdXJzZWxmLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgZmFsc2UgKTtcblxuXHRcdGNvbnN0IGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0dGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlLCBsZXZlbC5oeXN0ZXJlc2lzICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG1lc2ggdGhhdCB3aWxsIGRpc3BsYXkgYXQgYSBjZXJ0YWluIGRpc3RhbmNlIGFuZCBncmVhdGVyLiBUeXBpY2FsbHlcblx0ICogdGhlIGZ1cnRoZXIgYXdheSB0aGUgZGlzdGFuY2UsIHRoZSBsb3dlciB0aGUgZGV0YWlsIG9uIHRoZSBtZXNoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0IHRvIGRpc3BsYXkgYXQgdGhpcyBsZXZlbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaXN0YW5jZT0wXSAtIFRoZSBkaXN0YW5jZSBhdCB3aGljaCB0byBkaXNwbGF5IHRoaXMgbGV2ZWwgb2YgZGV0YWlsLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2h5c3RlcmVzaXM9MF0gLSBUaHJlc2hvbGQgdXNlZCB0byBhdm9pZCBmbGlja2VyaW5nIGF0IExPRCBib3VuZGFyaWVzLCBhcyBhIGZyYWN0aW9uIG9mIGRpc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtMT0R9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhZGRMZXZlbCggb2JqZWN0LCBkaXN0YW5jZSA9IDAsIGh5c3RlcmVzaXMgPSAwICkge1xuXG5cdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuXHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0bGV0IGw7XG5cblx0XHRmb3IgKCBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XG5cblx0XHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIGh5c3RlcmVzaXM6IGh5c3RlcmVzaXMsIG9iamVjdDogb2JqZWN0IH0gKTtcblxuXHRcdHRoaXMuYWRkKCBvYmplY3QgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBleGlzdGluZyBsZXZlbCwgYmFzZWQgb24gdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYS5cblx0ICogUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgbGV2ZWwgaGFzIGJlZW4gcmVtb3ZlZC4gT3RoZXJ3aXNlIGBmYWxzZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSAtIERpc3RhbmNlIG9mIHRoZSBsZXZlbCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGxldmVsIGhhcyBiZWVuIHJlbW92ZWQgb3Igbm90LlxuXHQgKi9cblx0cmVtb3ZlTGV2ZWwoIGRpc3RhbmNlICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGxldmVsc1sgaSBdLmRpc3RhbmNlID09PSBkaXN0YW5jZSApIHtcblxuXHRcdFx0XHRjb25zdCByZW1vdmVkRWxlbWVudHMgPSBsZXZlbHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCByZW1vdmVkRWxlbWVudHNbIDAgXS5vYmplY3QgKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBMT0QgbGV2ZWwgaW5kZXguXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgYWN0aXZlIExPRCBsZXZlbCBpbmRleC5cblx0ICovXG5cdGdldEN1cnJlbnRMZXZlbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50TGV2ZWw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAzRCBvYmplY3QgdGhhdCBpcyBncmVhdGVyIHRoYW5cblx0ICogdGhlIGdpdmVuIGRpc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgLSBUaGUgTE9EIGRpc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3QzRHxudWxsfSBUaGUgZm91bmQgM0Qgb2JqZWN0LiBgbnVsbGAgaWYgbm8gM0Qgb2JqZWN0IGhhcyBiZWVuIGZvdW5kLlxuXHQgKi9cblx0Z2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0Zm9yICggaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgbGV2ZWxEaXN0YW5jZSA9IGxldmVsc1sgaSBdLmRpc3RhbmNlO1xuXG5cdFx0XHRcdGlmICggbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRsZXZlbERpc3RhbmNlIC09IGxldmVsRGlzdGFuY2UgKiBsZXZlbHNbIGkgXS5oeXN0ZXJlc2lzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxEaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIGEgY2FzdGVkIHJheSBhbmQgdGhpcyBMT0QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmF5Y2FzdGVyfSByYXljYXN0ZXIgLSBUaGUgcmF5Y2FzdGVyLlxuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGludGVyc2VjdHMgLSBUaGUgdGFyZ2V0IGFycmF5IHRoYXQgaG9sZHMgdGhlIGludGVyc2VjdGlvbiBwb2ludHMuXG5cdCAqL1xuXHRyYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGlmICggbGV2ZWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBfdjEgKTtcblxuXHRcdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIExPRCBieSBjb21wdXRpbmcgd2hpY2ggTE9EIGxldmVsIHNob3VsZCBiZSB2aXNpYmxlIGFjY29yZGluZ1xuXHQgKiB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgd2l0aC5cblx0ICovXG5cdHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRfdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdF92Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBfdjEuZGlzdGFuY2VUbyggX3YyICkgLyBjYW1lcmEuem9vbTtcblxuXHRcdFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0Zm9yICggaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgbGV2ZWxEaXN0YW5jZSA9IGxldmVsc1sgaSBdLmRpc3RhbmNlO1xuXG5cdFx0XHRcdGlmICggbGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRsZXZlbERpc3RhbmNlIC09IGxldmVsRGlzdGFuY2UgKiBsZXZlbHNbIGkgXS5oeXN0ZXJlc2lzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlID49IGxldmVsRGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSBpIC0gMTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvVXBkYXRlID09PSBmYWxzZSApIGRhdGEub2JqZWN0LmF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xuXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlLFxuXHRcdFx0XHRoeXN0ZXJlc2lzOiBsZXZlbC5oeXN0ZXJlc2lzXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBMT0QgfTtcbiIsImltcG9ydCB7IE1lc2ggfSBmcm9tICcuL01lc2guanMnO1xuaW1wb3J0IHsgQm94MyB9IGZyb20gJy4uL21hdGgvQm94My5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uL21hdGgvVmVjdG9yNC5qcyc7XG5pbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XG5pbXBvcnQgeyBBdHRhY2hlZEJpbmRNb2RlLCBEZXRhY2hlZEJpbmRNb2RlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgX2Jhc2VQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcbmNvbnN0IF9za2luV2VpZ2h0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yNCgpO1xuXG5jb25zdCBfdmVjdG9yMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tYXRyaXg0ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3ZlcnRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3NwaGVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuY29uc3QgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcmF5ID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XG5cbi8qKlxuICogQSBtZXNoIHRoYXQgaGFzIGEge0BsaW5rIFNrZWxldG9ufSB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gYW5pbWF0ZSB0aGVcbiAqIHZlcnRpY2VzIG9mIHRoZSBnZW9tZXRyeSB3aXRoIHNraW5uaW5nL3NrZWxldG9uIGFuaW1hdGlvbi5cbiAqXG4gKiBOZXh0IHRvIGEgdmFsaWQgc2tlbGV0b24sIHRoZSBza2lubmVkIG1lc2ggcmVxdWlyZXMgc2tpbiBpbmRpY2VzIGFuZCB3ZWlnaHRzXG4gKiBhcyBidWZmZXIgYXR0cmlidXRlcyBpbiBpdHMgZ2VvbWV0cnkuIFRoZXNlIGF0dHJpYnV0ZSBkZWZpbmUgd2hpY2ggYm9uZXMgYWZmZWN0IGEgc2luZ2xlXG4gKiB2ZXJ0ZXggdG8gYSBjZXJ0YWluIGV4dGVuZC5cbiAqXG4gKiBUeXBpY2FsbHkgc2tpbm5lZCBtZXNoZXMgYXJlIG5vdCBjcmVhdGVkIG1hbnVhbGx5IGJ1dCBsb2FkZXJzIGxpa2Uge0BsaW5rIEdMVEZMb2FkZXJ9XG4gKiBvciB7QGxpbmsgRkJYTG9hZGVyIH0gaW1wb3J0IHJlc3BlY3RpdmUgbW9kZWxzLlxuICpcbiAqIEBhdWdtZW50cyBNZXNoXG4gKi9cbmNsYXNzIFNraW5uZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2tpbm5lZCBtZXNoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBbZ2VvbWV0cnldIC0gVGhlIG1lc2ggZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx8QXJyYXk8TWF0ZXJpYWw+fSBbbWF0ZXJpYWxdIC0gVGhlIG1lc2ggbWF0ZXJpYWwuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cblx0XHQvKipcblx0XHQgKiBgQXR0YWNoZWRCaW5kTW9kZWAgbWVhbnMgdGhlIHNraW5uZWQgbWVzaCBzaGFyZXMgdGhlIHNhbWUgd29ybGQgc3BhY2UgYXMgdGhlIHNrZWxldG9uLlxuXHRcdCAqIFRoaXMgaXMgbm90IHRydWUgd2hlbiB1c2luZyBgRGV0YWNoZWRCaW5kTW9kZWAgd2hpY2ggaXMgdXNlZnVsIHdoZW4gc2hhcmluZyBhIHNrZWxldG9uXG5cdFx0ICogYWNyb3NzIG11bHRpcGxlIHNraW5uZWQgbWVzaGVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhBdHRhY2hlZEJpbmRNb2RlfERldGFjaGVkQmluZE1vZGUpfVxuXHRcdCAqIEBkZWZhdWx0IEF0dGFjaGVkQmluZE1vZGVcblx0XHQgKi9cblx0XHR0aGlzLmJpbmRNb2RlID0gQXR0YWNoZWRCaW5kTW9kZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBiYXNlIG1hdHJpeCB0aGF0IGlzIHVzZWQgZm9yIHRoZSBib3VuZCBib25lIHRyYW5zZm9ybXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TWF0cml4NH1cblx0XHQgKi9cblx0XHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJhc2UgbWF0cml4IHRoYXQgaXMgdXNlZCBmb3IgcmVzZXR0aW5nIHRoZSBib3VuZCBib25lIHRyYW5zZm9ybXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TWF0cml4NH1cblx0XHQgKi9cblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNraW5uZWQgbWVzaC4gQ2FuIGJlIGNvbXB1dGVkIHZpYSB7QGxpbmsgU2tpbm5lZE1lc2gjY29tcHV0ZUJvdW5kaW5nQm94fS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/Qm94M31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYm91bmRpbmcgc3BoZXJlIG9mIHRoZSBza2lubmVkIG1lc2guIENhbiBiZSBjb21wdXRlZCB2aWEge0BsaW5rIFNraW5uZWRNZXNoI2NvbXB1dGVCb3VuZGluZ1NwaGVyZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1NwaGVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBza2lubmVkIG1lc2gsIGFuZCB1cGRhdGVzIHtAbGluayBTa2lubmVkTWVzaCNib3VuZGluZ0JveH0uXG5cdCAqIFRoZSBib3VuZGluZyBib3ggaXMgbm90IGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgYnkgdGhlIGVuZ2luZTsgdGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYnkgeW91ciBhcHAuXG5cdCAqIElmIHRoZSBza2lubmVkIG1lc2ggaXMgYW5pbWF0ZWQsIHRoZSBib3VuZGluZyBib3ggc2hvdWxkIGJlIHJlY29tcHV0ZWQgcGVyIGZyYW1lIGluIG9yZGVyIHRvIHJlZmxlY3Rcblx0ICogdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlLlxuXHQgKi9cblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZ2V0VmVydGV4UG9zaXRpb24oIGksIF92ZXJ0ZXggKTtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlcnRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSBvZiB0aGUgc2tpbm5lZCBtZXNoLCBhbmQgdXBkYXRlcyB7QGxpbmsgU2tpbm5lZE1lc2gjYm91bmRpbmdTcGhlcmV9LlxuXHQgKiBUaGUgYm91bmRpbmcgc3BoZXJlIGlzIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgYnkgdGhlIGVuZ2luZSBvbmNlIHdoZW4gaXQgaXMgbmVlZGVkLCBlLmcuLCBmb3IgcmF5IGNhc3Rpbmdcblx0ICogYW5kIHZpZXcgZnJ1c3R1bSBjdWxsaW5nLiBJZiB0aGUgc2tpbm5lZCBtZXNoIGlzIGFuaW1hdGVkLCB0aGUgYm91bmRpbmcgc3BoZXJlIHNob3VsZCBiZSByZWNvbXB1dGVkXG5cdCAqIHBlciBmcmFtZSBpbiBvcmRlciB0byByZWZsZWN0IHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZS5cblx0ICovXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUubWFrZUVtcHR5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZ2V0VmVydGV4UG9zaXRpb24oIGksIF92ZXJ0ZXggKTtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuZXhwYW5kQnlQb2ludCggX3ZlcnRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmJpbmRNb2RlID0gc291cmNlLmJpbmRNb2RlO1xuXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBzb3VyY2UuYmluZE1hdHJpeCApO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggc291cmNlLmJpbmRNYXRyaXhJbnZlcnNlICk7XG5cblx0XHR0aGlzLnNrZWxldG9uID0gc291cmNlLnNrZWxldG9uO1xuXG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdCb3ggIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94LmNsb25lKCk7XG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBzcGhlcmUgaW4gd29ybGQgc3BhY2VcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlLmNvcHkoIHRoaXMuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gY29udmVydCByYXkgdG8gbG9jYWwgc3BhY2Ugb2Ygc2tpbm5lZCBtZXNoXG5cblx0XHRfaW52ZXJzZU1hdHJpeC5jb3B5KCBtYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdF9yYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXggKTtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBib3ggaW4gbG9jYWwgc3BhY2VcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBfcmF5LmludGVyc2VjdHNCb3goIHRoaXMuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25zIHdpdGggZ2VvbWV0cnlcblxuXHRcdHRoaXMuX2NvbXB1dGVJbnRlcnNlY3Rpb25zKCByYXljYXN0ZXIsIGludGVyc2VjdHMsIF9yYXkgKTtcblxuXHR9XG5cblx0Z2V0VmVydGV4UG9zaXRpb24oIGluZGV4LCB0YXJnZXQgKSB7XG5cblx0XHRzdXBlci5nZXRWZXJ0ZXhQb3NpdGlvbiggaW5kZXgsIHRhcmdldCApO1xuXG5cdFx0dGhpcy5hcHBseUJvbmVUcmFuc2Zvcm0oIGluZGV4LCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kcyB0aGUgZ2l2ZW4gc2tlbGV0b24gdG8gdGhlIHNraW5uZWQgbWVzaC5cblx0ICpcblx0ICogQHBhcmFtIHtTa2VsZXRvbn0gc2tlbGV0b24gLSBUaGUgc2tlbGV0b24gdG8gYmluZC5cblx0ICogQHBhcmFtIHtNYXRyaXg0fSBbYmluZE1hdHJpeF0gLSBUaGUgYmluZCBtYXRyaXguIElmIG5vIGJpbmQgbWF0cml4IGlzIHByb3ZpZGVkLFxuXHQgKiB0aGUgc2tpbm5lZCBtZXNoJ3Mgd29ybGQgbWF0cml4IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuXHQgKi9cblx0YmluZCggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cblx0XHR0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG5cblx0XHRpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cblx0XHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5iaW5kTWF0cml4LmNvcHkoIGJpbmRNYXRyaXggKTtcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkoIGJpbmRNYXRyaXggKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIHNraW5uZWQgbWVzaCBpbiB0aGUgcmVzdCBwb3NlKS5cblx0ICovXG5cdHBvc2UoKSB7XG5cblx0XHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIHNraW4gd2VpZ2h0cyB3aGljaCBhcmUgZGVmaW5lZCBhcyBhIGJ1ZmZlciBhdHRyaWJ1dGVcblx0ICogaW4gdGhlIHNraW5uZWQgbWVzaCdzIGdlb21ldHJ5LlxuXHQgKi9cblx0bm9ybWFsaXplU2tpbldlaWdodHMoKSB7XG5cblx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0Y29uc3Qgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2tpbldlaWdodC5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBza2luV2VpZ2h0LCBpICk7XG5cblx0XHRcdGNvbnN0IHNjYWxlID0gMS4wIC8gdmVjdG9yLm1hbmhhdHRhbkxlbmd0aCgpO1xuXG5cdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuXHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmVjdG9yLnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxuXG5cdFx0XHR9XG5cblx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgdmVjdG9yLncgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IEF0dGFjaGVkQmluZE1vZGUgKSB7XG5cblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gRGV0YWNoZWRCaW5kTW9kZSApIHtcblxuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLmJpbmRNYXRyaXggKS5pbnZlcnQoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBib25lIHRyYW5zZm9ybSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGluZGV4IHRvIHRoZSBnaXZlblxuXHQgKiB2ZXJ0ZXggcG9zaXRpb24uIFJldHVybnMgdGhlIHVwZGF0ZWQgdmVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgdmVydGV4IGluZGV4LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiB0aGUgc2tpbm5lZCBtZXNoJ3Mgd29ybGQgbWF0cml4IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgdXBkYXRlZCB2ZXJ0ZXggcG9zaXRpb24uXG5cdCAqL1xuXHRhcHBseUJvbmVUcmFuc2Zvcm0oIGluZGV4LCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0X3NraW5JbmRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5JbmRleCwgaW5kZXggKTtcblx0XHRfc2tpbldlaWdodC5mcm9tQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQsIGluZGV4ICk7XG5cblx0XHRfYmFzZVBvc2l0aW9uLmNvcHkoIHRhcmdldCApLmFwcGx5TWF0cml4NCggdGhpcy5iaW5kTWF0cml4ICk7XG5cblx0XHR0YXJnZXQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBfc2tpbldlaWdodC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0aWYgKCB3ZWlnaHQgIT09IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0XHRfbWF0cml4NC5tdWx0aXBseU1hdHJpY2VzKCBza2VsZXRvbi5ib25lc1sgYm9uZUluZGV4IF0ubWF0cml4V29ybGQsIHNrZWxldG9uLmJvbmVJbnZlcnNlc1sgYm9uZUluZGV4IF0gKTtcblxuXHRcdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBfdmVjdG9yMy5jb3B5KCBfYmFzZVBvc2l0aW9uICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4NCApLCB3ZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldC5hcHBseU1hdHJpeDQoIHRoaXMuYmluZE1hdHJpeEludmVyc2UgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU2tpbm5lZE1lc2ggfTtcbiIsImltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5cbi8qKlxuICogQSBib25lIHdoaWNoIGlzIHBhcnQgb2YgYSB7QGxpbmsgU2tlbGV0b259LiBUaGUgc2tlbGV0b24gaW4gdHVybiBpcyB1c2VkIGJ5XG4gKiB0aGUge0BsaW5rIFNraW5uZWRNZXNofS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgcm9vdCA9IG5ldyBUSFJFRS5Cb25lKCk7XG4gKiBjb25zdCBjaGlsZCA9IG5ldyBUSFJFRS5Cb25lKCk7XG4gKlxuICogcm9vdC5hZGQoIGNoaWxkICk7XG4gKiBjaGlsZC5wb3NpdGlvbi55ID0gNTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBPYmplY3QzRFxuICovXG5jbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJvbmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzQm9uZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJvbmUgfTtcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRleHR1cmUgZGlyZWN0bHkgZnJvbSByYXcgYnVmZmVyIGRhdGEuXG4gKlxuICogVGhlIGludGVycHJldGF0aW9uIG9mIHRoZSBkYXRhIGRlcGVuZHMgb24gdHlwZSBhbmQgZm9ybWF0OiBJZiB0aGUgdHlwZSBpc1xuICogYFVuc2lnbmVkQnl0ZVR5cGVgLCBhIGBVaW50OEFycmF5YCB3aWxsIGJlIHVzZWZ1bCBmb3IgYWRkcmVzc2luZyB0aGVcbiAqIHRleGVsIGRhdGEuIElmIHRoZSBmb3JtYXQgaXMgYFJHQkFGb3JtYXRgLCBkYXRhIG5lZWRzIGZvdXIgdmFsdWVzIGZvclxuICogb25lIHRleGVsOyBSZWQsIEdyZWVuLCBCbHVlIGFuZCBBbHBoYSAodHlwaWNhbGx5IHRoZSBvcGFjaXR5KS5cbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBEYXRhVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGRhdGEgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHs/VHlwZWRBcnJheX0gW2RhdGE9bnVsbF0gLSBUaGUgYnVmZmVyIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmb3JtYXQ9UkdCQUZvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSB0ZXh0dXJlIHR5cGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWFwcGluZz1UZXh0dXJlLkRFRkFVTFRfTUFQUElOR10gLSBUaGUgdGV4dHVyZSBtYXBwaW5nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dyYXBTPUNsYW1wVG9FZGdlV3JhcHBpbmddIC0gVGhlIHdyYXBTIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dyYXBUPUNsYW1wVG9FZGdlV3JhcHBpbmddIC0gVGhlIHdyYXBUIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hZ0ZpbHRlcj1OZWFyZXN0RmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21pbkZpbHRlcj1OZWFyZXN0RmlsdGVyXSAtIFRoZSBtaW4gZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FuaXNvdHJvcHk9VGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUFldIC0gVGhlIGFuaXNvdHJvcHkgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29sb3JTcGFjZT1Ob0NvbG9yU3BhY2VdIC0gVGhlIGNvbG9yIHNwYWNlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyLCBtaW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSBkZWZpbml0aW9uIG9mIGEgZGF0YSB0ZXh0dXJlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3tkYXRhOlR5cGVkQXJyYXksd2lkdGg6bnVtYmVyLGhlaWdodDpudW1iZXJ9fVxuXHRcdCAqL1xuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gZ2VuZXJhdGUgbWlwbWFwcyAoaWYgcG9zc2libGUpIGZvciBhIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0ZXh0dXJlIGlzIGZsaXBwZWQgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgd2hlblxuXHRcdCAqIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBhbGlnbm1lbnQgcmVxdWlyZW1lbnRzIGZvciB0aGUgc3RhcnQgb2YgZWFjaCBwaXhlbCByb3cgaW4gbWVtb3J5LlxuXHRcdCAqXG5cdFx0ICogT3ZlcndyaXR0ZW4gYW5kIHNldCB0byBgMWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IERhdGFUZXh0dXJlIH07XG4iLCJpbXBvcnQge1xuXHRSR0JBRm9ybWF0LFxuXHRGbG9hdFR5cGVcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEJvbmUgfSBmcm9tICcuL0JvbmUuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBEYXRhVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuY29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIHRoZSBhcm1hdHVyZXMgaW4gYHRocmVlLmpzYC4gVGhlIHNrZWxldG9uXG4gKiBpcyBkZWZpbmVkIGJ5IGEgaGllcmFyY2h5IG9mIGJvbmVzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBib25lcyA9IFtdO1xuICpcbiAqIGNvbnN0IHNob3VsZGVyID0gbmV3IFRIUkVFLkJvbmUoKTtcbiAqIGNvbnN0IGVsYm93ID0gbmV3IFRIUkVFLkJvbmUoKTtcbiAqIGNvbnN0IGhhbmQgPSBuZXcgVEhSRUUuQm9uZSgpO1xuICpcbiAqIHNob3VsZGVyLmFkZCggZWxib3cgKTtcbiAqIGVsYm93LmFkZCggaGFuZCApO1xuICpcbiAqIGJvbmVzLnB1c2goIHNob3VsZGVyICwgZWxib3csIGhhbmQpO1xuICpcbiAqIHNob3VsZGVyLnBvc2l0aW9uLnkgPSAtNTtcbiAqIGVsYm93LnBvc2l0aW9uLnkgPSAwO1xuICogaGFuZC5wb3NpdGlvbi55ID0gNTtcbiAqXG4gKiBjb25zdCBhcm1Ta2VsZXRvbiA9IG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMgKTtcbiAqIGBgYFxuICovXG5jbGFzcyBTa2VsZXRvbiB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2tlbGV0b24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8Qm9uZT59IFtib25lc10gLSBBbiBhcnJheSBvZiBib25lcy5cblx0ICogQHBhcmFtIHtBcnJheTxNYXRyaXg0Pn0gW2JvbmVJbnZlcnNlc10gLSBBbiBhcnJheSBvZiBib25lIGludmVyc2UgbWF0cmljZXMuXG5cdCAqIElmIG5vdCBwcm92aWRlZCwgdGhlc2UgbWF0cmljZXMgd2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IHZpYSB7QGxpbmsgU2tlbGV0b24jY2FsY3VsYXRlSW52ZXJzZXN9LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGJvbmVzID0gW10sIGJvbmVJbnZlcnNlcyA9IFtdICkge1xuXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBib25lcyBkZWZpbmluZyB0aGUgc2tlbGV0b24uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8Qm9uZT59XG5cdFx0ICovXG5cdFx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBib25lIGludmVyc2UgbWF0cmljZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8TWF0cml4ND59XG5cdFx0ICovXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXM7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBidWZmZXIgaG9sZGluZyB0aGUgYm9uZSBkYXRhLlxuXHRcdCAqIElucHV0IGRhdGEgZm9yIHtAbGluayBTa2VsZXRvbiNib25lVGV4dHVyZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0Zsb2F0MzJBcnJheX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB0ZXh0dXJlIGhvbGRpbmcgdGhlIGJvbmUgZGF0YSBmb3IgdXNlXG5cdFx0ICogaW4gdGhlIHZlcnRleCBzaGFkZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0RhdGFUZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuaW5pdCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHNrZWxldG9uLiBUaGlzIG1ldGhvZCBnZXRzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBidXQgZGVwZW5kaW5nIG9uIGhvdyB0aGUgc2tlbGV0b24gaXMgY3JlYXRlZCBpdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gY2FsbCB0aGlzIG1ldGhvZFxuXHQgKiBtYW51YWxseS5cblx0ICovXG5cdGluaXQoKSB7XG5cblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0Y29uc3QgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJvbmVzLmxlbmd0aCAqIDE2ICk7XG5cblx0XHQvLyBjYWxjdWxhdGUgaW52ZXJzZSBib25lIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeVxuXG5cdFx0aWYgKCBib25lSW52ZXJzZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlXG5cblx0XHRcdGlmICggYm9uZXMubGVuZ3RoICE9PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiBOdW1iZXIgb2YgaW52ZXJzZSBib25lIG1hdHJpY2VzIGRvZXMgbm90IG1hdGNoIGFtb3VudCBvZiBib25lcy4nICk7XG5cblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBNYXRyaXg0KCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBib25lIGludmVyc2UgbWF0cmljZXMuIFRoaXMgbWV0aG9kIHJlc2V0cyB7QGxpbmsgU2tlbGV0b24jYm9uZUludmVyc2VzfVxuXHQgKiBhbmQgZmlsbHMgaXQgd2l0aCBuZXcgbWF0cmljZXMuXG5cdCAqL1xuXHRjYWxjdWxhdGVJbnZlcnNlcygpIHtcblxuXHRcdHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aCA9IDA7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdGlmICggdGhpcy5ib25lc1sgaSBdICkge1xuXG5cdFx0XHRcdGludmVyc2UuY29weSggdGhpcy5ib25lc1sgaSBdLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBza2VsZXRvbiB0byB0aGUgYmFzZSBwb3NlLlxuXHQgKi9cblx0cG9zZSgpIHtcblxuXHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdGlmICggYm9uZSApIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMuYm9uZUludmVyc2VzWyBpIF0gKS5pbnZlcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdFx0XHRcdGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBza2VsZXRvbiB0byB0aGUgYmFzZSBwb3NlLlxuXHQgKi9cblx0dXBkYXRlKCkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG5cdFx0XHRjb25zdCBtYXRyaXggPSBib25lc1sgaSBdID8gYm9uZXNbIGkgXS5tYXRyaXhXb3JsZCA6IF9pZGVudGl0eU1hdHJpeDtcblxuXHRcdFx0X29mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIGJvbmVJbnZlcnNlc1sgaSBdICk7XG5cdFx0XHRfb2Zmc2V0TWF0cml4LnRvQXJyYXkoIGJvbmVNYXRyaWNlcywgaSAqIDE2ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJvbmVUZXh0dXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHNrZWxldG9uIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NrZWxldG9ufSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBhIGRhdGEgdGV4dHVyZSBmb3IgcGFzc2luZyBib25lIGRhdGEgdG8gdGhlIHZlcnRleCBzaGFkZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NrZWxldG9ufSBBIHJlZmVyZW5jZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29tcHV0ZUJvbmVUZXh0dXJlKCkge1xuXG5cdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuXHRcdC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuXHRcdC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cdFx0bGV0IHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG5cdFx0c2l6ZSA9IE1hdGguY2VpbCggc2l6ZSAvIDQgKSAqIDQ7XG5cdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cblx0XHRjb25zdCBib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICogc2l6ZSAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblx0XHRib25lTWF0cmljZXMuc2V0KCB0aGlzLmJvbmVNYXRyaWNlcyApOyAvLyBjb3B5IGN1cnJlbnQgdmFsdWVzXG5cblx0XHRjb25zdCBib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcztcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIHRocm91Z2ggdGhlIHNrZWxldG9uJ3MgYm9uZSBhcnJheSBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgd2l0aCBhXG5cdCAqIG1hdGNoaW5nIG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJvbmUuXG5cdCAqIEByZXR1cm4ge0JvbmV8dW5kZWZpbmVkfSBUaGUgZm91bmQgYm9uZS4gYHVuZGVmaW5lZGAgaWYgbm8gYm9uZSBoYXMgYmVlbiBmb3VuZC5cblx0ICovXG5cdGdldEJvbmVCeU5hbWUoIG5hbWUgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lLm5hbWUgPT09IG5hbWUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCApIHtcblxuXHRcdGlmICggdGhpcy5ib25lVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU2V0dXBzIHRoZSBza2VsZXRvbiBieSB0aGUgZ2l2ZW4gSlNPTiBhbmQgYm9uZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIHNrZWxldG9uIGFzIHNlcmlhbGl6ZWQgSlNPTi5cblx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBCb25lPn0gYm9uZXMgLSBBbiBhcnJheSBvZiBib25lcy5cblx0ICogQHJldHVybiB7U2tlbGV0b259IEEgcmVmZXJlbmNlIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRmcm9tSlNPTigganNvbiwgYm9uZXMgKSB7XG5cblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmJvbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHV1aWQgPSBqc29uLmJvbmVzWyBpIF07XG5cdFx0XHRsZXQgYm9uZSA9IGJvbmVzWyB1dWlkIF07XG5cblx0XHRcdGlmICggYm9uZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiBObyBib25lIGZvdW5kIHdpdGggVVVJRDonLCB1dWlkICk7XG5cdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYm9uZXMucHVzaCggYm9uZSApO1xuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGpzb24uYm9uZUludmVyc2VzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIHNrZWxldG9uIGludG8gSlNPTi5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXplZCBza2VsZXRvbi5cblx0ICogQHNlZSB7QGxpbmsgT2JqZWN0TG9hZGVyI3BhcnNlfVxuXHQgKi9cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ1NrZWxldG9uJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnU2tlbGV0b24udG9KU09OJ1xuXHRcdFx0fSxcblx0XHRcdGJvbmVzOiBbXSxcblx0XHRcdGJvbmVJbnZlcnNlczogW11cblx0XHR9O1xuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYm9uZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzWyBpIF07XG5cdFx0XHRkYXRhLmJvbmVzLnB1c2goIGJvbmUudXVpZCApO1xuXG5cdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1sgaSBdO1xuXHRcdFx0ZGF0YS5ib25lSW52ZXJzZXMucHVzaCggYm9uZUludmVyc2UudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU2tlbGV0b24gfTtcbiIsImltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlLmpzJztcblxuLyoqXG4gKiBBbiBpbnN0YW5jZWQgdmVyc2lvbiBvZiBhIGJ1ZmZlciBhdHRyaWJ1dGUuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckF0dHJpYnV0ZVxuICovXG5jbGFzcyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlZCBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IGhvbGRpbmcgdGhlIGF0dHJpYnV0ZSBkYXRhLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaXRlbVNpemUgLSBUaGUgaXRlbSBzaXplLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3JtYWxpemVkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGRhdGEgYXJlIG5vcm1hbGl6ZWQgb3Igbm90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21lc2hQZXJBdHRyaWJ1dGU9MV0gLSBIb3cgb2Z0ZW4gYSB2YWx1ZSBvZiB0aGlzIGJ1ZmZlciBhdHRyaWJ1dGUgc2hvdWxkIGJlIHJlcGVhdGVkLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCwgbWVzaFBlckF0dHJpYnV0ZSA9IDEgKSB7XG5cblx0XHRzdXBlciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgaG93IG9mdGVuIGEgdmFsdWUgb2YgdGhpcyBidWZmZXIgYXR0cmlidXRlIHNob3VsZCBiZSByZXBlYXRlZC4gQVxuXHRcdCAqIHZhbHVlIG9mIG9uZSBtZWFucyB0aGF0IGVhY2ggdmFsdWUgb2YgdGhlIGluc3RhbmNlZCBhdHRyaWJ1dGUgaXMgdXNlZCBmb3Jcblx0XHQgKiBhIHNpbmdsZSBpbnN0YW5jZS4gQSB2YWx1ZSBvZiB0d28gbWVhbnMgdGhhdCBlYWNoIHZhbHVlIGlzIHVzZWQgZm9yIHR3b1xuXHRcdCAqIGNvbnNlY3V0aXZlIGluc3RhbmNlcyAoYW5kIHNvIG9uKS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH07XG4iLCJpbXBvcnQgeyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi9NZXNoLmpzJztcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBEYXRhVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzJztcbmltcG9ydCB7IEZsb2F0VHlwZSwgUmVkRm9ybWF0IH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgX2luc3RhbmNlTG9jYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfaW5zdGFuY2VXb3JsZE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcblxuY29uc3QgX2luc3RhbmNlSW50ZXJzZWN0cyA9IFtdO1xuXG5jb25zdCBfYm94MyA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9pZGVudGl0eSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9tZXNoID0gLypAX19QVVJFX18qLyBuZXcgTWVzaCgpO1xuY29uc3QgX3NwaGVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xuXG4vKipcbiAqIEEgc3BlY2lhbCB2ZXJzaW9uIG9mIGEgbWVzaCB3aXRoIGluc3RhbmNlZCByZW5kZXJpbmcgc3VwcG9ydC4gVXNlXG4gKiB0aGlzIGNsYXNzIGlmIHlvdSBoYXZlIHRvIHJlbmRlciBhIGxhcmdlIG51bWJlciBvZiBvYmplY3RzIHdpdGggdGhlIHNhbWVcbiAqIGdlb21ldHJ5IGFuZCBtYXRlcmlhbChzKSBidXQgd2l0aCBkaWZmZXJlbnQgd29ybGQgdHJhbnNmb3JtYXRpb25zLiBUaGUgdXNhZ2VcbiAqIG9mICdJbnN0YW5jZWRNZXNoJyB3aWxsIGhlbHAgeW91IHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGRyYXcgY2FsbHMgYW5kIHRodXNcbiAqIGltcHJvdmUgdGhlIG92ZXJhbGwgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGluIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogQGF1Z21lbnRzIE1lc2hcbiAqL1xuY2xhc3MgSW5zdGFuY2VkTWVzaCBleHRlbmRzIE1lc2gge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlZCBtZXNoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBbZ2VvbWV0cnldIC0gVGhlIG1lc2ggZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx8QXJyYXk8TWF0ZXJpYWw+fSBbbWF0ZXJpYWxdIC0gVGhlIG1lc2ggbWF0ZXJpYWwuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgaW5zdGFuY2VzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5LCBtYXRlcmlhbCwgY291bnQgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzSW5zdGFuY2VkTWVzaCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBvZiBhbGwgaW5zdGFuY2VzLiBZb3UgaGF2ZSB0byBzZXQgaXRzXG5cdFx0ICoge0BsaW5rIEJ1ZmZlckF0dHJpYnV0ZSNuZWVkc1VwZGF0ZX0gZmxhZyB0byB0cnVlIGlmIHlvdSBtb2RpZnkgaW5zdGFuY2VkIGRhdGFcblx0XHQgKiB2aWEge0BsaW5rIEluc3RhbmNlZE1lc2gjc2V0TWF0cml4QXR9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZX1cblx0XHQgKi9cblx0XHR0aGlzLmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY291bnQgKiAxNiApLCAxNiApO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVwcmVzZW50cyB0aGUgY29sb3Igb2YgYWxsIGluc3RhbmNlcy4gWW91IGhhdmUgdG8gc2V0IGl0c1xuXHRcdCAqIHtAbGluayBCdWZmZXJBdHRyaWJ1dGUjbmVlZHNVcGRhdGV9IGZsYWcgdG8gdHJ1ZSBpZiB5b3UgbW9kaWZ5IGluc3RhbmNlZCBkYXRhXG5cdFx0ICogdmlhIHtAbGluayBJbnN0YW5jZWRNZXNoI3NldENvbG9yQXR9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaW5zdGFuY2VDb2xvciA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBtb3JwaCB0YXJnZXQgd2VpZ2h0cyBvZiBhbGwgaW5zdGFuY2VzLiBZb3UgaGF2ZSB0byBzZXQgaXRzXG5cdFx0ICoge0BsaW5rIFRleHR1cmUjbmVlZHNVcGRhdGV9IGZsYWcgdG8gdHJ1ZSBpZiB5b3UgbW9kaWZ5IGluc3RhbmNlZCBkYXRhXG5cdFx0ICogdmlhIHtAbGluayBJbnN0YW5jZWRNZXNoI3NldE1vcnBoQXR9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9EYXRhVGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tb3JwaFRleHR1cmUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpbnN0YW5jZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBib3VuZGluZyBib3ggb2YgdGhlIGluc3RhbmNlZCBtZXNoLiBDYW4gYmUgY29tcHV0ZWQgdmlhIHtAbGluayBJbnN0YW5jZWRNZXNoI2NvbXB1dGVCb3VuZGluZ0JveH0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0JveDN9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJvdW5kaW5nIHNwaGVyZSBvZiB0aGUgaW5zdGFuY2VkIG1lc2guIENhbiBiZSBjb21wdXRlZCB2aWEge0BsaW5rIEluc3RhbmNlZE1lc2gjY29tcHV0ZUJvdW5kaW5nU3BoZXJlfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/U3BoZXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnNldE1hdHJpeEF0KCBpLCBfaWRlbnRpdHkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGluc3RhbmNlZCBtZXNoLCBhbmQgdXBkYXRlcyB7QGxpbmsgSW5zdGFuY2VkTWVzaCNib3VuZGluZ0JveH0uXG5cdCAqIFRoZSBib3VuZGluZyBib3ggaXMgbm90IGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgYnkgdGhlIGVuZ2luZTsgdGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYnkgeW91ciBhcHAuXG5cdCAqIFlvdSBtYXkgbmVlZCB0byByZWNvbXB1dGUgdGhlIGJvdW5kaW5nIGJveCBpZiBhbiBpbnN0YW5jZSBpcyB0cmFuc2Zvcm1lZCB2aWEge0BsaW5rIEluc3RhbmNlZE1lc2gjc2V0TWF0cml4QXR9LlxuXHQgKi9cblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudDtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5nZXRNYXRyaXhBdCggaSwgX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcblxuXHRcdFx0X2JveDMuY29weSggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKS5hcHBseU1hdHJpeDQoIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3gudW5pb24oIF9ib3gzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgc3BoZXJlIG9mIHRoZSBpbnN0YW5jZWQgbWVzaCwgYW5kIHVwZGF0ZXMge0BsaW5rIEluc3RhbmNlZE1lc2gjYm91bmRpbmdTcGhlcmV9XG5cdCAqIFRoZSBlbmdpbmUgYXV0b21hdGljYWxseSBjb21wdXRlcyB0aGUgYm91bmRpbmcgc3BoZXJlIHdoZW4gaXQgaXMgbmVlZGVkLCBlLmcuLCBmb3IgcmF5IGNhc3Rpbmcgb3IgdmlldyBmcnVzdHVtIGN1bGxpbmcuXG5cdCAqIFlvdSBtYXkgbmVlZCB0byByZWNvbXB1dGUgdGhlIGJvdW5kaW5nIHNwaGVyZSBpZiBhbiBpbnN0YW5jZSBpcyB0cmFuc2Zvcm1lZCB2aWEge0BsaW5rIEluc3RhbmNlZE1lc2gjc2V0TWF0cml4QXR9LlxuXHQgKi9cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudDtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkuYXBwbHlNYXRyaXg0KCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnVuaW9uKCBfc3BoZXJlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuaW5zdGFuY2VNYXRyaXguY29weSggc291cmNlLmluc3RhbmNlTWF0cml4ICk7XG5cblx0XHRpZiAoIHNvdXJjZS5tb3JwaFRleHR1cmUgIT09IG51bGwgKSB0aGlzLm1vcnBoVGV4dHVyZSA9IHNvdXJjZS5tb3JwaFRleHR1cmUuY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5pbnN0YW5jZUNvbG9yICE9PSBudWxsICkgdGhpcy5pbnN0YW5jZUNvbG9yID0gc291cmNlLmluc3RhbmNlQ29sb3IuY2xvbmUoKTtcblxuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3guY2xvbmUoKTtcblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY29sb3Igb2YgdGhlIGRlZmluZWQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbnN0YW5jZSBpbmRleC5cblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICovXG5cdGdldENvbG9yQXQoIGluZGV4LCBjb2xvciApIHtcblxuXHRcdGNvbG9yLmZyb21BcnJheSggdGhpcy5pbnN0YW5jZUNvbG9yLmFycmF5LCBpbmRleCAqIDMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGxvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgZGVmaW5lZCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluc3RhbmNlIGluZGV4LlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKi9cblx0Z2V0TWF0cml4QXQoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHRtYXRyaXguZnJvbUFycmF5KCB0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LCBpbmRleCAqIDE2ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBtb3JwaCB0YXJnZXQgd2VpZ2h0cyBvZiB0aGUgZGVmaW5lZCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluc3RhbmNlIGluZGV4LlxuXHQgKiBAcGFyYW0ge01lc2h9IG9iamVjdCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKi9cblx0Z2V0TW9ycGhBdCggaW5kZXgsIG9iamVjdCApIHtcblxuXHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0Y29uc3QgYXJyYXkgPSB0aGlzLm1vcnBoVGV4dHVyZS5zb3VyY2UuZGF0YS5kYXRhO1xuXG5cdFx0Y29uc3QgbGVuID0gb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGggKyAxOyAvLyBBbGwgaW5mbHVlbmNlcyArIHRoZSBiYXNlSW5mbHVlbmNlU3VtXG5cblx0XHRjb25zdCBkYXRhSW5kZXggPSBpbmRleCAqIGxlbiArIDE7IC8vIFNraXAgdGhlIGJhc2VJbmZsdWVuY2VTdW0gYXQgdGhlIGJlZ2lubmluZ1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG9iamVjdEluZmx1ZW5jZXNbIGkgXSA9IGFycmF5WyBkYXRhSW5kZXggKyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCByYXljYXN0VGltZXMgPSB0aGlzLmNvdW50O1xuXG5cdFx0X21lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdGlmICggX21lc2gubWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBzcGhlcmUgZmlyc3RcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRfc3BoZXJlLmNvcHkoIHRoaXMuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gbm93IHRlc3QgZWFjaCBpbnN0YW5jZVxuXG5cdFx0Zm9yICggbGV0IGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkICsrICkge1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHdvcmxkIG1hdHJpeCBmb3IgZWFjaCBpbnN0YW5jZVxuXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xuXG5cdFx0XHRfaW5zdGFuY2VXb3JsZE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcblxuXHRcdFx0Ly8gdGhlIG1lc2ggcmVwcmVzZW50cyB0aGlzIHNpbmdsZSBpbnN0YW5jZVxuXG5cdFx0XHRfbWVzaC5tYXRyaXhXb3JsZCA9IF9pbnN0YW5jZVdvcmxkTWF0cml4O1xuXG5cdFx0XHRfbWVzaC5yYXljYXN0KCByYXljYXN0ZXIsIF9pbnN0YW5jZUludGVyc2VjdHMgKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IF9pbnN0YW5jZUludGVyc2VjdHNbIGkgXTtcblx0XHRcdFx0aW50ZXJzZWN0Lmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuXHRcdFx0XHRpbnRlcnNlY3Qub2JqZWN0ID0gdGhpcztcblx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfaW5zdGFuY2VJbnRlcnNlY3RzLmxlbmd0aCA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBjb2xvciB0byB0aGUgZGVmaW5lZCBpbnN0YW5jZS4gTWFrZSBzdXJlIHlvdSBzZXQgdGhlIGBuZWVkc1VwZGF0ZWAgZmxhZyBvZlxuXHQgKiB7QGxpbmsgSW5zdGFuY2VkTWVzaCNpbnN0YW5jZUNvbG9yfSB0byBgdHJ1ZWAgYWZ0ZXIgdXBkYXRpbmcgYWxsIHRoZSBjb2xvcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbnN0YW5jZSBpbmRleC5cblx0ICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBUaGUgaW5zdGFuY2UgY29sb3IuXG5cdCAqL1xuXHRzZXRDb2xvckF0KCBpbmRleCwgY29sb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvciA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMgKS5maWxsKCAxICksIDMgKTtcblxuXHRcdH1cblxuXHRcdGNvbG9yLnRvQXJyYXkoIHRoaXMuaW5zdGFuY2VDb2xvci5hcnJheSwgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGRlZmluZWQgaW5zdGFuY2UuIE1ha2Ugc3VyZSB5b3Ugc2V0IHRoZSBgbmVlZHNVcGRhdGVgIGZsYWcgb2Zcblx0ICoge0BsaW5rIEluc3RhbmNlZE1lc2gjaW5zdGFuY2VNYXRyaXh9IHRvIGB0cnVlYCBhZnRlciB1cGRhdGluZyBhbGwgdGhlIGNvbG9ycy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluc3RhbmNlIGluZGV4LlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeCAtIFRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbi5cblx0ICovXG5cdHNldE1hdHJpeEF0KCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0bWF0cml4LnRvQXJyYXkoIHRoaXMuaW5zdGFuY2VNYXRyaXguYXJyYXksIGluZGV4ICogMTYgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1vcnBoIHRhcmdldCB3ZWlnaHRzIHRvIHRoZSBkZWZpbmVkIGluc3RhbmNlLiBNYWtlIHN1cmUgeW91IHNldCB0aGUgYG5lZWRzVXBkYXRlYCBmbGFnIG9mXG5cdCAqIHtAbGluayBJbnN0YW5jZWRNZXNoI21vcnBoVGV4dHVyZX0gdG8gYHRydWVgIGFmdGVyIHVwZGF0aW5nIGFsbCB0aGUgaW5mbHVlbmNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluc3RhbmNlIGluZGV4LlxuXHQgKiBAcGFyYW0ge01lc2h9IG9iamVjdCAtICBBIG1lc2ggd2hpY2ggYG1vcnBoVGFyZ2V0SW5mbHVlbmNlc2AgcHJvcGVydHkgY29udGFpbmluZyB0aGUgbW9ycGggdGFyZ2V0IHdlaWdodHNcblx0ICogb2YgYSBzaW5nbGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRNb3JwaEF0KCBpbmRleCwgb2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgb2JqZWN0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRjb25zdCBsZW4gPSBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aCArIDE7IC8vIG1vcnBoQmFzZUluZmx1ZW5jZSArIGFsbCBpbmZsdWVuY2VzXG5cblx0XHRpZiAoIHRoaXMubW9ycGhUZXh0dXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggbmV3IEZsb2F0MzJBcnJheSggbGVuICogdGhpcy5jb3VudCApLCBsZW4sIHRoaXMuY291bnQsIFJlZEZvcm1hdCwgRmxvYXRUeXBlICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhcnJheSA9IHRoaXMubW9ycGhUZXh0dXJlLnNvdXJjZS5kYXRhLmRhdGE7XG5cblx0XHRsZXQgbW9ycGhJbmZsdWVuY2VzU3VtID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRtb3JwaEluZmx1ZW5jZXNTdW0gKz0gb2JqZWN0SW5mbHVlbmNlc1sgaSBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA/IDEgOiAxIC0gbW9ycGhJbmZsdWVuY2VzU3VtO1xuXG5cdFx0Y29uc3QgZGF0YUluZGV4ID0gbGVuICogaW5kZXg7XG5cblx0XHRhcnJheVsgZGF0YUluZGV4IF0gPSBtb3JwaEJhc2VJbmZsdWVuY2U7XG5cblx0XHRhcnJheS5zZXQoIG9iamVjdEluZmx1ZW5jZXMsIGRhdGFJbmRleCArIDEgKTtcblxuXHR9XG5cblx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdFx0aWYgKCB0aGlzLm1vcnBoVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tb3JwaFRleHR1cmUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBJbnN0YW5jZWRNZXNoIH07XG4iLCJpbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi9NYXRyaXgzLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG5jb25zdCBfdmVjdG9yMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92ZWN0b3IyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKTtcblxuLyoqXG4gKiBBIHR3byBkaW1lbnNpb25hbCBzdXJmYWNlIHRoYXQgZXh0ZW5kcyBpbmZpbml0ZWx5IGluIDNEIHNwYWNlLCByZXByZXNlbnRlZFxuICogaW4gW0hlc3NpYW4gbm9ybWFsIGZvcm1de0BsaW5rIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vSGVzc2lhbk5vcm1hbEZvcm0uaHRtbH1cbiAqIGJ5IGEgdW5pdCBsZW5ndGggbm9ybWFsIHZlY3RvciBhbmQgYSBjb25zdGFudC5cbiAqL1xuY2xhc3MgUGxhbmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBsYW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtub3JtYWw9KDEsMCwwKV0gLSBBIHVuaXQgbGVuZ3RoIHZlY3RvciBkZWZpbmluZyB0aGUgbm9ybWFsIG9mIHRoZSBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb25zdGFudD0wXSAtIFRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSBwbGFuZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBub3JtYWwgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBjb25zdGFudCA9IDAgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUGxhbmUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB1bml0IGxlbmd0aCB2ZWN0b3IgZGVmaW5pbmcgdGhlIG5vcm1hbCBvZiB0aGUgcGxhbmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbCA9IG5vcm1hbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSBwbGFuZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBsYW5lIGNvbXBvbmVudHMgYnkgY29weWluZyB0aGUgZ2l2ZW4gdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG5vcm1hbCAtIFRoZSBub3JtYWwuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb25zdGFudCAtIFRoZSBjb25zdGFudC5cblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRzZXQoIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBsYW5lIGNvbXBvbmVudHMgYnkgZGVmaW5pbmcgYHhgLCBgeWAsIGB6YCBhcyB0aGVcblx0ICogcGxhbmUgbm9ybWFsIGFuZCBgd2AgYXMgdGhlIGNvbnN0YW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB2YWx1ZSBmb3IgdGhlIG5vcm1hbCdzIHggY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2YWx1ZSBmb3IgdGhlIG5vcm1hbCdzIHkgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB2YWx1ZSBmb3IgdGhlIG5vcm1hbCdzIHogY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSBjb25zdGFudCB2YWx1ZS5cblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRzZXRDb21wb25lbnRzKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBsYW5lIGZyb20gdGhlIGdpdmVuIG5vcm1hbCBhbmQgY29wbGFuYXIgcG9pbnQgKHRoYXQgaXMgYSBwb2ludFxuXHQgKiB0aGF0IGxpZXMgb250byB0aGUgcGxhbmUpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IG5vcm1hbCAtIFRoZSBub3JtYWwuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBBIGNvcGxhbmFyIHBvaW50LlxuXHQgKiBAcmV0dXJuIHtQbGFuZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBwbGFuZS5cblx0ICovXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIHBvaW50ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwbGFuZSBmcm9tIHRocmVlIGNvcGxhbmFyIHBvaW50cy4gVGhlIHdpbmRpbmcgb3JkZXIgaXNcblx0ICogYXNzdW1lZCB0byBiZSBjb3VudGVyLWNsb2Nrd2lzZSwgYW5kIGRldGVybWluZXMgdGhlIGRpcmVjdGlvbiBvZlxuXHQgKiB0aGUgcGxhbmUgbm9ybWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IGEgLSBUaGUgZmlyc3QgY29wbGFuYXIgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYiAtIFRoZSBzZWNvbmQgY29wbGFuYXIgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gYyAtIFRoZSB0aGlyZCBjb3BsYW5hciBwb2ludC5cblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRzZXRGcm9tQ29wbGFuYXJQb2ludHMoIGEsIGIsIGMgKSB7XG5cblx0XHRjb25zdCBub3JtYWwgPSBfdmVjdG9yMS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIF92ZWN0b3IyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cblxuXHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gcGxhbmUgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtQbGFuZX0gcGxhbmUgLSBUaGUgcGxhbmUgdG8gY29weS5cblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRjb3B5KCBwbGFuZSApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgcGxhbmUgbm9ybWFsIGFuZCBhZGp1c3RzIHRoZSBjb25zdGFudCBhY2NvcmRpbmdseS5cblx0ICpcblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRub3JtYWxpemUoKSB7XG5cblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuXHRcdGNvbnN0IGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTmVnYXRlcyBib3RoIHRoZSBwbGFuZSBub3JtYWwgYW5kIHRoZSBjb25zdGFudC5cblx0ICpcblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2lnbmVkIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHBvaW50IHRvIHRoaXMgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgZm9yLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaWduZWQgZGlzdGFuY2UuXG5cdCAqL1xuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3BoZXJlIHRvIHRoaXMgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgc3BoZXJlIHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIGZvci5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2lnbmVkIGRpc3RhbmNlLlxuXHQgKi9cblx0ZGlzdGFuY2VUb1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJvamVjdHMgYSB0aGUgZ2l2ZW4gcG9pbnQgb250byB0aGUgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gcG9pbnQgLSBUaGUgcG9pbnQgdG8gcHJvamVjdC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIHByb2plY3RlZCBwb2ludCBvbiB0aGUgcGxhbmUuXG5cdCAqL1xuXHRwcm9qZWN0UG9pbnQoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHBvaW50ICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLm5vcm1hbCwgLSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IG9mIHRoZSBwYXNzZWQgbGluZSBhbmQgdGhlIHBsYW5lLiBSZXR1cm5zXG5cdCAqIGBudWxsYCBpZiB0aGUgbGluZSBkb2VzIG5vdCBpbnRlcnNlY3QuIFJldHVybnMgdGhlIGxpbmUncyBzdGFydGluZyBwb2ludCBpZlxuXHQgKiB0aGUgbGluZSBpcyBjb3BsYW5hciB3aXRoIHRoZSBwbGFuZS5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5lM30gbGluZSAtIFRoZSBsaW5lIHRvIGNvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBmb3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4gez9WZWN0b3IzfSBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuXHQgKi9cblx0aW50ZXJzZWN0TGluZSggbGluZSwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggX3ZlY3RvcjEgKTtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0aWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGxpbmUuc3RhcnQgKS5hZGRTY2FsZWRWZWN0b3IoIGRpcmVjdGlvbiwgdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHdpdGggKHBhc3NlcyB0aHJvdWdoKSB0aGUgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGluZTN9IGxpbmUgLSBUaGUgbGluZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBwbGFuZSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzTGluZSggbGluZSApIHtcblxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG5cdFx0Y29uc3Qgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcblx0XHRjb25zdCBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XG5cblx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94IGludGVyc2VjdHMgd2l0aCB0aGUgcGxhbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJvdW5kaW5nIGJveCB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB3aXRoIHRoZSBwbGFuZSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGJvdW5kaW5nIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhlIHBsYW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlIC0gVGhlIGJvdW5kaW5nIHNwaGVyZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBib3VuZGluZyBzcGhlcmUgaW50ZXJzZWN0cyB3aXRoIHRoZSBwbGFuZSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNvcGxhbmFyIHZlY3RvciB0byB0aGUgcGxhbmUsIGJ5IGNhbGN1bGF0aW5nIHRoZVxuXHQgKiBwcm9qZWN0aW9uIG9mIHRoZSBub3JtYWwgYXQgdGhlIG9yaWdpbiBvbnRvIHRoZSBwbGFuZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIGNvcGxhbmFyIHBvaW50LlxuXHQgKi9cblx0Y29wbGFuYXJQb2ludCggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IGEgNHg0IG1hdHJpeCB0byB0aGUgcGxhbmUuIFRoZSBtYXRyaXggbXVzdCBiZSBhbiBhZmZpbmUsIGhvbW9nZW5lb3VzIHRyYW5zZm9ybS5cblx0ICpcblx0ICogVGhlIG9wdGlvbmFsIG5vcm1hbCBtYXRyaXggY2FuIGJlIHByZS1jb21wdXRlZCBsaWtlIHNvOlxuXHQgKiBgYGBqc1xuXHQgKiBjb25zdCBvcHRpb25hbE5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICogQHBhcmFtIHtNYXRyaXg0fSBbb3B0aW9uYWxOb3JtYWxNYXRyaXhdIC0gQSBwcmUtY29tcHV0ZWQgbm9ybWFsIG1hdHJpeC5cblx0ICogQHJldHVybiB7UGxhbmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGxhbmUuXG5cdCAqL1xuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cblx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBfbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRjb25zdCByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggX3ZlY3RvcjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZXMgdGhlIHBsYW5lIGJ5IHRoZSBkaXN0YW5jZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBvZmZzZXQgdmVjdG9yLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvbmx5IGFmZmVjdHMgdGhlIHBsYW5lIGNvbnN0YW50IGFuZCB3aWxsIG5vdCBhZmZlY3QgdGhlIG5vcm1hbCB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gb2Zmc2V0IC0gVGhlIG9mZnNldCB2ZWN0b3IuXG5cdCAqIEByZXR1cm4ge1BsYW5lfSBBIHJlZmVyZW5jZSB0byB0aGlzIHBsYW5lLlxuXHQgKi9cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgcGxhbmUgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSAtIFRoZSBwbGFuZSB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHBsYW5lIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHBsYW5lIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1BsYW5lfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUGxhbmUgfTtcbiIsImltcG9ydCB7IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4vU3BoZXJlLmpzJztcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9QbGFuZS5qcyc7XG5cbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8qKlxuICogRnJ1c3R1bXMgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXQgaXMgaW5zaWRlIHRoZSBjYW1lcmEncyBmaWVsZCBvZiB2aWV3LlxuICogVGhleSBoZWxwIHNwZWVkIHVwIHRoZSByZW5kZXJpbmcgcHJvY2VzcyAtIG9iamVjdHMgd2hpY2ggbGllIG91dHNpZGUgYSBjYW1lcmEnc1xuICogZnJ1c3R1bSBjYW4gc2FmZWx5IGJlIGV4Y2x1ZGVkIGZyb20gcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbWFpbmx5IGludGVuZGVkIGZvciB1c2UgaW50ZXJuYWxseSBieSBhIHJlbmRlcmVyLlxuICovXG5jbGFzcyBGcnVzdHVtIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmcnVzdHVtLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBbcDBdIC0gVGhlIGZpcnN0IHBsYW5lIHRoYXQgZW5jbG9zZXMgdGhlIGZydXN0dW0uXG5cdCAqIEBwYXJhbSB7UGxhbmV9IFtwMV0gLSBUaGUgc2Vjb25kIHBsYW5lIHRoYXQgZW5jbG9zZXMgdGhlIGZydXN0dW0uXG5cdCAqIEBwYXJhbSB7UGxhbmV9IFtwMl0gLSBUaGUgdGhpcmQgcGxhbmUgdGhhdCBlbmNsb3NlcyB0aGUgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtQbGFuZX0gW3AzXSAtIFRoZSBmb3VydGggcGxhbmUgdGhhdCBlbmNsb3NlcyB0aGUgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtQbGFuZX0gW3A0XSAtIFRoZSBmaWZ0aCBwbGFuZSB0aGF0IGVuY2xvc2VzIHRoZSBmcnVzdHVtLlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBbcDVdIC0gVGhlIHNpeHRoIHBsYW5lIHRoYXQgZW5jbG9zZXMgdGhlIGZydXN0dW0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcDAgPSBuZXcgUGxhbmUoKSwgcDEgPSBuZXcgUGxhbmUoKSwgcDIgPSBuZXcgUGxhbmUoKSwgcDMgPSBuZXcgUGxhbmUoKSwgcDQgPSBuZXcgUGxhbmUoKSwgcDUgPSBuZXcgUGxhbmUoKSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgYXJyYXkgaG9sZHMgdGhlIHBsYW5lcyB0aGF0IGVuY2xvc2UgdGhlIGZydXN0dW0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8UGxhbmU+fVxuXHRcdCAqL1xuXHRcdHRoaXMucGxhbmVzID0gWyBwMCwgcDEsIHAyLCBwMywgcDQsIHA1IF07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBmcnVzdHVtIHBsYW5lcyBieSBjb3B5aW5nIHRoZSBnaXZlbiBwbGFuZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxhbmV9IFtwMF0gLSBUaGUgZmlyc3QgcGxhbmUgdGhhdCBlbmNsb3NlcyB0aGUgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtQbGFuZX0gW3AxXSAtIFRoZSBzZWNvbmQgcGxhbmUgdGhhdCBlbmNsb3NlcyB0aGUgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtQbGFuZX0gW3AyXSAtIFRoZSB0aGlyZCBwbGFuZSB0aGF0IGVuY2xvc2VzIHRoZSBmcnVzdHVtLlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBbcDNdIC0gVGhlIGZvdXJ0aCBwbGFuZSB0aGF0IGVuY2xvc2VzIHRoZSBmcnVzdHVtLlxuXHQgKiBAcGFyYW0ge1BsYW5lfSBbcDRdIC0gVGhlIGZpZnRoIHBsYW5lIHRoYXQgZW5jbG9zZXMgdGhlIGZydXN0dW0uXG5cdCAqIEBwYXJhbSB7UGxhbmV9IFtwNV0gLSBUaGUgc2l4dGggcGxhbmUgdGhhdCBlbmNsb3NlcyB0aGUgZnJ1c3R1bS5cblx0ICogQHJldHVybiB7RnJ1c3R1bX0gQSByZWZlcmVuY2UgdG8gdGhpcyBmcnVzdHVtLlxuXHQgKi9cblx0c2V0KCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG5cdFx0cGxhbmVzWyAyIF0uY29weSggcDIgKTtcblx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG5cdFx0cGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGZydXN0dW0gdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtGcnVzdHVtfSBmcnVzdHVtIC0gVGhlIGZydXN0dW0gdG8gY29weS5cblx0ICogQHJldHVybiB7RnJ1c3R1bX0gQSByZWZlcmVuY2UgdG8gdGhpcyBmcnVzdHVtLlxuXHQgKi9cblx0Y29weSggZnJ1c3R1bSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBmcnVzdHVtIHBsYW5lcyBmcm9tIHRoZSBnaXZlbiBwcm9qZWN0aW9uIG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtIC0gVGhlIHByb2plY3Rpb24gbWF0cml4LlxuXHQgKiBAcGFyYW0geyhXZWJHTENvb3JkaW5hdGVTeXN0ZW18V2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSl9IGNvb3JkaW5hdGVTeXN0ZW0gLSBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0uXG5cdCAqIEByZXR1cm4ge0ZydXN0dW19IEEgcmVmZXJlbmNlIHRvIHRoaXMgZnJ1c3R1bS5cblx0ICovXG5cdHNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBtLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XG5cdFx0Y29uc3QgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcblx0XHRjb25zdCBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcblx0XHRjb25zdCBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XG5cblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUyLCBtZTYsIG1lMTAsIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIDNEIG9iamVjdCdzIGJvdW5kaW5nIHNwaGVyZSBpcyBpbnRlcnNlY3RpbmcgdGhpcyBmcnVzdHVtLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIDNEIG9iamVjdCBtdXN0IGhhdmUgYSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBib3VuZGluZyBzcGhlcmUgY2FuIGJlIGNhbGN1bGF0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgM0Qgb2JqZWN0J3MgYm91bmRpbmcgc3BoZXJlIGlzIGludGVyc2VjdGluZyB0aGlzIGZydXN0dW0gb3Igbm90LlxuXHQgKi9cblx0aW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBvYmplY3QuYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBvYmplY3QuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUuY29weSggb2JqZWN0LmJvdW5kaW5nU3BoZXJlICkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHNwcml0ZSBpcyBpbnRlcnNlY3RpbmcgdGhpcyBmcnVzdHVtLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzcHJpdGUgaXMgaW50ZXJzZWN0aW5nIHRoaXMgZnJ1c3R1bSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzU3ByaXRlKCBzcHJpdGUgKSB7XG5cblx0XHRfc3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHRfc3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3Njtcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggc3ByaXRlLm1hdHJpeFdvcmxkICk7XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYm91bmRpbmcgc3BoZXJlIGlzIGludGVyc2VjdGluZyB0aGlzIGZydXN0dW0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgYm91bmRpbmcgc3BoZXJlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGJvdW5kaW5nIHNwaGVyZSBpcyBpbnRlcnNlY3RpbmcgdGhpcyBmcnVzdHVtIG9yIG5vdC5cblx0ICovXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdGNvbnN0IGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0Y29uc3QgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94IGlzIGludGVyc2VjdGluZyB0aGlzIGZydXN0dW0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJvdW5kaW5nIGJveCB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBib3VuZGluZyBib3ggaXMgaW50ZXJzZWN0aW5nIHRoaXMgZnJ1c3R1bSBvciBub3QuXG5cdCAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBsYW5lID0gcGxhbmVzWyBpIF07XG5cblx0XHRcdC8vIGNvcm5lciBhdCBtYXggZGlzdGFuY2VcblxuXHRcdFx0X3ZlY3Rvci54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuXHRcdFx0X3ZlY3Rvci55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuXHRcdFx0X3ZlY3Rvci56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggX3ZlY3RvciApIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGxpZXMgd2l0aGluIHRoZSBmcnVzdHVtLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBvaW50IGxpZXMgd2l0aGluIHRoaXMgZnJ1c3R1bSBvciBub3QuXG5cdCAqL1xuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGZydXN0dW0gd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7RnJ1c3R1bX0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRnJ1c3R1bSB9O1xuIiwiaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEZydXN0dW0gfSBmcm9tICcuL0ZydXN0dW0uanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vTWF0cml4NC5qcyc7XG5cbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2ZydXN0dW0gPSAvKkBfX1BVUkVfXyovIG5ldyBGcnVzdHVtKCk7XG5cbi8qKlxuICogRnJ1c3R1bUFycmF5IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyB2aXNpYmxlIGluIGF0IGxlYXN0IG9uZSBjYW1lcmFcbiAqIGZyb20gYW4gYXJyYXkgb2YgY2FtZXJhcy4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBtdWx0aS12aWV3IHJlbmRlcmVycy5cbiovXG5jbGFzcyBGcnVzdHVtQXJyYXkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZydXN0dW0gYXJyYXkuXG5cdCAqXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb29yZGluYXRlIHN5c3RlbSB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7V2ViR0xDb29yZGluYXRlU3lzdGVtfFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW19XG5cdFx0ICogQGRlZmF1bHQgV2ViR0xDb29yZGluYXRlU3lzdGVtXG5cdFx0ICovXG5cdFx0dGhpcy5jb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIDNEIG9iamVjdCdzIGJvdW5kaW5nIHNwaGVyZSBpcyBpbnRlcnNlY3RpbmcgYW55IGZydXN0dW1cblx0ICogZnJvbSB0aGUgY2FtZXJhIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0IHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjYW1lcmFBcnJheSAtIEFuIG9iamVjdCB3aXRoIGEgY2FtZXJhcyBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIGNhbWVyYXMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIDNEIG9iamVjdCBpcyB2aXNpYmxlIGluIGFueSBjYW1lcmEuXG5cdCAqL1xuXHRpbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QsIGNhbWVyYUFycmF5ICkge1xuXG5cdFx0aWYgKCAhIGNhbWVyYUFycmF5LmlzQXJyYXlDYW1lcmEgfHwgY2FtZXJhQXJyYXkuY2FtZXJhcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNhbWVyYUFycmF5LmNhbWVyYXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjYW1lcmEgPSBjYW1lcmFBcnJheS5jYW1lcmFzWyBpIF07XG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoXG5cdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LFxuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlXG5cdFx0XHQpO1xuXG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChcblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgsXG5cdFx0XHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gT2JqZWN0IGlzIHZpc2libGUgaW4gYXQgbGVhc3Qgb25lIGNhbWVyYVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7IC8vIE5vdCB2aXNpYmxlIGluIGFueSBjYW1lcmFcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBzcHJpdGUgaXMgaW50ZXJzZWN0aW5nIGFueSBmcnVzdHVtXG5cdCAqIGZyb20gdGhlIGNhbWVyYSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtIHtTcHJpdGV9IHNwcml0ZSAtIFRoZSBzcHJpdGUgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNhbWVyYUFycmF5IC0gQW4gb2JqZWN0IHdpdGggYSBjYW1lcmFzIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgY2FtZXJhcy5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3ByaXRlIGlzIHZpc2libGUgaW4gYW55IGNhbWVyYS5cblx0ICovXG5cdGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSwgY2FtZXJhQXJyYXkgKSB7XG5cblx0XHRpZiAoICEgY2FtZXJhQXJyYXkgfHwgISBjYW1lcmFBcnJheS5jYW1lcmFzIHx8IGNhbWVyYUFycmF5LmNhbWVyYXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjYW1lcmFBcnJheS5jYW1lcmFzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2FtZXJhID0gY2FtZXJhQXJyYXkuY2FtZXJhc1sgaSBdO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKFxuXHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeCxcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZVxuXHRcdFx0KTtcblxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoXG5cdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4LFxuXHRcdFx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW1cblx0XHRcdCk7XG5cblx0XHRcdGlmICggX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZSggc3ByaXRlICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIFNwcml0ZSBpcyB2aXNpYmxlIGluIGF0IGxlYXN0IG9uZSBjYW1lcmFcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBOb3QgdmlzaWJsZSBpbiBhbnkgY2FtZXJhXG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYm91bmRpbmcgc3BoZXJlIGlzIGludGVyc2VjdGluZyBhbnkgZnJ1c3R1bVxuXHQgKiBmcm9tIHRoZSBjYW1lcmEgYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUgLSBUaGUgYm91bmRpbmcgc3BoZXJlIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjYW1lcmFBcnJheSAtIEFuIG9iamVjdCB3aXRoIGEgY2FtZXJhcyBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIGNhbWVyYXMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHNwaGVyZSBpcyB2aXNpYmxlIGluIGFueSBjYW1lcmEuXG5cdCAqL1xuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUsIGNhbWVyYUFycmF5ICkge1xuXG5cdFx0aWYgKCAhIGNhbWVyYUFycmF5IHx8ICEgY2FtZXJhQXJyYXkuY2FtZXJhcyB8fCBjYW1lcmFBcnJheS5jYW1lcmFzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2FtZXJhQXJyYXkuY2FtZXJhcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNhbWVyYSA9IGNhbWVyYUFycmF5LmNhbWVyYXNbIGkgXTtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhcblx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXgsXG5cdFx0XHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2Vcblx0XHRcdCk7XG5cblx0XHRcdF9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KFxuXHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeCxcblx0XHRcdFx0dGhpcy5jb29yZGluYXRlU3lzdGVtXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoIF9mcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBTcGhlcmUgaXMgdmlzaWJsZSBpbiBhdCBsZWFzdCBvbmUgY2FtZXJhXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTsgLy8gTm90IHZpc2libGUgaW4gYW55IGNhbWVyYVxuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGJvdW5kaW5nIGJveCBpcyBpbnRlcnNlY3RpbmcgYW55IGZydXN0dW1cblx0ICogZnJvbSB0aGUgY2FtZXJhIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDN9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdG8gdGVzdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNhbWVyYUFycmF5IC0gQW4gb2JqZWN0IHdpdGggYSBjYW1lcmFzIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgY2FtZXJhcy5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYm94IGlzIHZpc2libGUgaW4gYW55IGNhbWVyYS5cblx0ICovXG5cdGludGVyc2VjdHNCb3goIGJveCwgY2FtZXJhQXJyYXkgKSB7XG5cblx0XHRpZiAoICEgY2FtZXJhQXJyYXkgfHwgISBjYW1lcmFBcnJheS5jYW1lcmFzIHx8IGNhbWVyYUFycmF5LmNhbWVyYXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjYW1lcmFBcnJheS5jYW1lcmFzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2FtZXJhID0gY2FtZXJhQXJyYXkuY2FtZXJhc1sgaSBdO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKFxuXHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeCxcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZVxuXHRcdFx0KTtcblxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoXG5cdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4LFxuXHRcdFx0XHR0aGlzLmNvb3JkaW5hdGVTeXN0ZW1cblx0XHRcdCk7XG5cblx0XHRcdGlmICggX2ZydXN0dW0uaW50ZXJzZWN0c0JveCggYm94ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIEJveCBpcyB2aXNpYmxlIGluIGF0IGxlYXN0IG9uZSBjYW1lcmFcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBOb3QgdmlzaWJsZSBpbiBhbnkgY2FtZXJhXG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgbGllcyB3aXRoaW4gYW55IGZydXN0dW1cblx0ICogZnJvbSB0aGUgY2FtZXJhIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjYW1lcmFBcnJheSAtIEFuIG9iamVjdCB3aXRoIGEgY2FtZXJhcyBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIGNhbWVyYXMuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBvaW50IGlzIHZpc2libGUgaW4gYW55IGNhbWVyYS5cblx0ICovXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50LCBjYW1lcmFBcnJheSApIHtcblxuXHRcdGlmICggISBjYW1lcmFBcnJheSB8fCAhIGNhbWVyYUFycmF5LmNhbWVyYXMgfHwgY2FtZXJhQXJyYXkuY2FtZXJhcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNhbWVyYUFycmF5LmNhbWVyYXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjYW1lcmEgPSBjYW1lcmFBcnJheS5jYW1lcmFzWyBpIF07XG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoXG5cdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LFxuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlXG5cdFx0XHQpO1xuXG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChcblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgsXG5cdFx0XHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBfZnJ1c3R1bS5jb250YWluc1BvaW50KCBwb2ludCApICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBQb2ludCBpcyB2aXNpYmxlIGluIGF0IGxlYXN0IG9uZSBjYW1lcmFcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBOb3QgdmlzaWJsZSBpbiBhbnkgY2FtZXJhXG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGZydXN0dW0gYXJyYXkgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7RnJ1c3R1bUFycmF5fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgRnJ1c3R1bUFycmF5KCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEZydXN0dW1BcnJheSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xuaW1wb3J0IHsgRmxvYXRUeXBlLCBSZWRJbnRlZ2VyRm9ybWF0LCBVbnNpZ25lZEludFR5cGUsIFJHQkFGb3JtYXQgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi9NZXNoLmpzJztcbmltcG9ydCB7IENvbG9yTWFuYWdlbWVudCB9IGZyb20gJy4uL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xuaW1wb3J0IHsgRnJ1c3R1bSB9IGZyb20gJy4uL21hdGgvRnJ1c3R1bS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgeyBGcnVzdHVtQXJyYXkgfSBmcm9tICcuLi9tYXRoL0ZydXN0dW1BcnJheS5qcyc7XG5cbmZ1bmN0aW9uIGFzY0lkU29ydCggYSwgYiApIHtcblxuXHRyZXR1cm4gYSAtIGI7XG5cbn1cblxuZnVuY3Rpb24gc29ydE9wYXF1ZSggYSwgYiApIHtcblxuXHRyZXR1cm4gYS56IC0gYi56O1xuXG59XG5cbmZ1bmN0aW9uIHNvcnRUcmFuc3BhcmVudCggYSwgYiApIHtcblxuXHRyZXR1cm4gYi56IC0gYS56O1xuXG59XG5cbmNsYXNzIE11bHRpRHJhd1JlbmRlckxpc3Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdFx0dGhpcy5wb29sID0gW107XG5cdFx0dGhpcy5saXN0ID0gW107XG5cblx0fVxuXG5cdHB1c2goIHN0YXJ0LCBjb3VudCwgeiwgaW5kZXggKSB7XG5cblx0XHRjb25zdCBwb29sID0gdGhpcy5wb29sO1xuXHRcdGNvbnN0IGxpc3QgPSB0aGlzLmxpc3Q7XG5cdFx0aWYgKCB0aGlzLmluZGV4ID49IHBvb2wubGVuZ3RoICkge1xuXG5cdFx0XHRwb29sLnB1c2goIHtcblxuXHRcdFx0XHRzdGFydDogLSAxLFxuXHRcdFx0XHRjb3VudDogLSAxLFxuXHRcdFx0XHR6OiAtIDEsXG5cdFx0XHRcdGluZGV4OiAtIDEsXG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGl0ZW0gPSBwb29sWyB0aGlzLmluZGV4IF07XG5cdFx0bGlzdC5wdXNoKCBpdGVtICk7XG5cdFx0dGhpcy5pbmRleCArKztcblxuXHRcdGl0ZW0uc3RhcnQgPSBzdGFydDtcblx0XHRpdGVtLmNvdW50ID0gY291bnQ7XG5cdFx0aXRlbS56ID0gejtcblx0XHRpdGVtLmluZGV4ID0gaW5kZXg7XG5cblx0fVxuXG5cdHJlc2V0KCkge1xuXG5cdFx0dGhpcy5saXN0Lmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfd2hpdGVDb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAxLCAxLCAxICk7XG5jb25zdCBfZnJ1c3R1bSA9IC8qQF9fUFVSRV9fKi8gbmV3IEZydXN0dW0oKTtcbmNvbnN0IF9mcnVzdHVtQXJyYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBGcnVzdHVtQXJyYXkoKTtcbmNvbnN0IF9ib3ggPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2ZvcndhcmQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVtcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9yZW5kZXJMaXN0ID0gLypAX19QVVJFX18qLyBuZXcgTXVsdGlEcmF3UmVuZGVyTGlzdCgpO1xuY29uc3QgX21lc2ggPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoKCk7XG5jb25zdCBfYmF0Y2hJbnRlcnNlY3RzID0gW107XG5cbi8vIGNvcGllcyBkYXRhIGZyb20gYXR0cmlidXRlIFwic3JjXCIgaW50byBcInRhcmdldFwiIHN0YXJ0aW5nIGF0IFwidGFyZ2V0T2Zmc2V0XCJcbmZ1bmN0aW9uIGNvcHlBdHRyaWJ1dGVEYXRhKCBzcmMsIHRhcmdldCwgdGFyZ2V0T2Zmc2V0ID0gMCApIHtcblxuXHRjb25zdCBpdGVtU2l6ZSA9IHRhcmdldC5pdGVtU2l6ZTtcblx0aWYgKCBzcmMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB8fCBzcmMuYXJyYXkuY29uc3RydWN0b3IgIT09IHRhcmdldC5hcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdC8vIHVzZSB0aGUgY29tcG9uZW50IGdldHRlcnMgYW5kIHNldHRlcnMgaWYgdGhlIGFycmF5IGRhdGEgY2Fubm90XG5cdFx0Ly8gYmUgY29waWVkIGRpcmVjdGx5XG5cdFx0Y29uc3QgdmVydGV4Q291bnQgPSBzcmMuY291bnQ7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBjID0gMDsgYyA8IGl0ZW1TaXplOyBjICsrICkge1xuXG5cdFx0XHRcdHRhcmdldC5zZXRDb21wb25lbnQoIGkgKyB0YXJnZXRPZmZzZXQsIGMsIHNyYy5nZXRDb21wb25lbnQoIGksIGMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIGZhc3RlciBjb3B5IGFwcHJvYWNoIHVzaW5nIHR5cGVkIGFycmF5IHNldCBmdW5jdGlvblxuXHRcdHRhcmdldC5hcnJheS5zZXQoIHNyYy5hcnJheSwgdGFyZ2V0T2Zmc2V0ICogaXRlbVNpemUgKTtcblxuXHR9XG5cblx0dGFyZ2V0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxufVxuXG4vLyBzYWZlbHkgY29waWVzIGFycmF5IGNvbnRlbnRzIHRvIGEgcG90ZW50aWFsbHkgc21hbGxlciBhcnJheVxuZnVuY3Rpb24gY29weUFycmF5Q29udGVudHMoIHNyYywgdGFyZ2V0ICkge1xuXG5cdGlmICggc3JjLmNvbnN0cnVjdG9yICE9PSB0YXJnZXQuY29uc3RydWN0b3IgKSB7XG5cblx0XHQvLyBpZiBhcnJheXMgYXJlIG9mIGEgZGlmZmVyZW50IHR5cGUgKGVnIGR1ZSB0byBpbmRleCBzaXplIGluY3JlYXNpbmcpIHRoZW4gZGF0YSBtdXN0IGJlIHBlci1lbGVtZW50IGNvcGllZFxuXHRcdGNvbnN0IGxlbiA9IE1hdGgubWluKCBzcmMubGVuZ3RoLCB0YXJnZXQubGVuZ3RoICk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0XHR0YXJnZXRbIGkgXSA9IHNyY1sgaSBdO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBpZiB0aGUgYXJyYXlzIHVzZSB0aGUgc2FtZSBkYXRhIGxheW91dCB3ZSBjYW4gdXNlIGEgZmFzdCBibG9jayBjb3B5XG5cdFx0Y29uc3QgbGVuID0gTWF0aC5taW4oIHNyYy5sZW5ndGgsIHRhcmdldC5sZW5ndGggKTtcblx0XHR0YXJnZXQuc2V0KCBuZXcgc3JjLmNvbnN0cnVjdG9yKCBzcmMuYnVmZmVyLCAwLCBsZW4gKSApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEEgc3BlY2lhbCB2ZXJzaW9uIG9mIGEgbWVzaCB3aXRoIG11bHRpIGRyYXcgYmF0Y2ggcmVuZGVyaW5nIHN1cHBvcnQuIFVzZVxuICogdGhpcyBjbGFzcyBpZiB5b3UgaGF2ZSB0byByZW5kZXIgYSBsYXJnZSBudW1iZXIgb2Ygb2JqZWN0cyB3aXRoIHRoZSBzYW1lXG4gKiBtYXRlcmlhbCBidXQgd2l0aCBkaWZmZXJlbnQgZ2VvbWV0cmllcyBvciB3b3JsZCB0cmFuc2Zvcm1hdGlvbnMuIFRoZSB1c2FnZSBvZlxuICogYEJhdGNoZWRNZXNoYCB3aWxsIGhlbHAgeW91IHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGRyYXcgY2FsbHMgYW5kIHRodXMgaW1wcm92ZSB0aGUgb3ZlcmFsbFxuICogcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGluIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGJveCA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApO1xuICogY29uc3Qgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCAxLCAxMiwgMTIgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDAwZmYwMCB9ICk7XG4gKlxuICogLy8gaW5pdGlhbGl6ZSBhbmQgYWRkIGdlb21ldHJpZXMgaW50byB0aGUgYmF0Y2hlZCBtZXNoXG4gKiBjb25zdCBiYXRjaGVkTWVzaCA9IG5ldyBCYXRjaGVkTWVzaCggMTAsIDUwMDAsIDEwMDAwLCBtYXRlcmlhbCApO1xuICogY29uc3QgYm94R2VvbWV0cnlJZCA9IGJhdGNoZWRNZXNoLmFkZEdlb21ldHJ5KCBib3ggKTtcbiAqIGNvbnN0IHNwaGVyZUdlb21ldHJ5SWQgPSBiYXRjaGVkTWVzaC5hZGRHZW9tZXRyeSggc3BoZXJlICk7XG4gKlxuICogLy8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aG9zZSBnZW9tZXRyaWVzXG4gKiBjb25zdCBib3hJbnN0YW5jZWRJZDEgPSBiYXRjaGVkTWVzaC5hZGRJbnN0YW5jZSggYm94R2VvbWV0cnlJZCApO1xuICogY29uc3QgYm94SW5zdGFuY2VkSWQyID0gYmF0Y2hlZE1lc2guYWRkSW5zdGFuY2UoIGJveEdlb21ldHJ5SWQgKTtcbiAqXG4gKiBjb25zdCBzcGhlcmVJbnN0YW5jZWRJZDEgPSBiYXRjaGVkTWVzaC5hZGRJbnN0YW5jZSggc3BoZXJlR2VvbWV0cnlJZCApO1xuICogY29uc3Qgc3BoZXJlSW5zdGFuY2VkSWQyID0gYmF0Y2hlZE1lc2guYWRkSW5zdGFuY2UoIHNwaGVyZUdlb21ldHJ5SWQgKTtcbiAqXG4gKiAvLyBwb3NpdGlvbiB0aGUgZ2VvbWV0cmllc1xuICogYmF0Y2hlZE1lc2guc2V0TWF0cml4QXQoIGJveEluc3RhbmNlZElkMSwgYm94TWF0cml4MSApO1xuICogYmF0Y2hlZE1lc2guc2V0TWF0cml4QXQoIGJveEluc3RhbmNlZElkMiwgYm94TWF0cml4MiApO1xuICpcbiAqIGJhdGNoZWRNZXNoLnNldE1hdHJpeEF0KCBzcGhlcmVJbnN0YW5jZWRJZDEsIHNwaGVyZU1hdHJpeDEgKTtcbiAqIGJhdGNoZWRNZXNoLnNldE1hdHJpeEF0KCBzcGhlcmVJbnN0YW5jZWRJZDIsIHNwaGVyZU1hdHJpeDIgKTtcbiAqXG4gKiBzY2VuZS5hZGQoIGJhdGNoZWRNZXNoICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTWVzaFxuICovXG5jbGFzcyBCYXRjaGVkTWVzaCBleHRlbmRzIE1lc2gge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJhdGNoZWQgbWVzaC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEluc3RhbmNlQ291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMgcGxhbm5lZCB0byBiZSBhZGRlZCBhbmQgcmVuZGVyZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWZXJ0ZXhDb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBiZSB1c2VkIGJ5IGFsbCB1bmlxdWUgZ2VvbWV0cmllcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXhJbmRleENvdW50PW1heFZlcnRleENvdW50KjJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGluZGljZXMgdG8gYmUgdXNlZCBieSBhbGwgdW5pcXVlIGdlb21ldHJpZXNcblx0ICogQHBhcmFtIHtNYXRlcmlhbHxBcnJheTxNYXRlcmlhbD59IFttYXRlcmlhbF0gLSBUaGUgbWVzaCBtYXRlcmlhbC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBtYXhJbnN0YW5jZUNvdW50LCBtYXhWZXJ0ZXhDb3VudCwgbWF4SW5kZXhDb3VudCA9IG1heFZlcnRleENvdW50ICogMiwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdXBlciggbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzQmF0Y2hlZE1lc2ggPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBzZXQgb3QgYHRydWVgLCB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG9mIGEgYmF0Y2ggYXJlIGZydXN0dW0gY3VsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgb2YgYSBiYXRjaCBhcmUgc29ydGVkIHRvIGltcHJvdmUgb3ZlcmRyYXctcmVsYXRlZCBhcnRpZmFjdHMuXG5cdFx0ICogSWYgdGhlIG1hdGVyaWFsIGlzIG1hcmtlZCBhcyBcInRyYW5zcGFyZW50XCIgb2JqZWN0cyBhcmUgcmVuZGVyZWQgYmFjayB0byBmcm9udCBhbmQgaWYgbm90IHRoZW4gdGhleSBhcmVcblx0XHQgKiByZW5kZXJlZCBmcm9udCB0byBiYWNrLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgYmF0Y2hlZCBtZXNoLiBDYW4gYmUgY29tcHV0ZWQgdmlhIHtAbGluayBCYXRjaGVkTWVzaCNjb21wdXRlQm91bmRpbmdCb3h9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9Cb3gzfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBib3VuZGluZyBzcGhlcmUgb2YgdGhlIGJhdGNoZWQgbWVzaC4gQ2FuIGJlIGNvbXB1dGVkIHZpYSB7QGxpbmsgQmF0Y2hlZE1lc2gjY29tcHV0ZUJvdW5kaW5nU3BoZXJlfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/U3BoZXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRha2VzIGEgc29ydCBhIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIGJlZm9yZSByZW5kZXIuIFRoZSBmdW5jdGlvbiB0YWtlcyBhIGxpc3Qgb2YgaW5zdGFuY2VzIHRvXG5cdFx0ICogc29ydCBhbmQgYSBjYW1lcmEuIFRoZSBvYmplY3RzIGluIHRoZSBsaXN0IGluY2x1ZGUgYSBcInpcIiBmaWVsZCB0byBwZXJmb3JtIGEgZGVwdGgtb3JkZXJlZFxuXHRcdCAqIHNvcnQgd2l0aC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/RnVuY3Rpb259XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY3VzdG9tU29ydCA9IG51bGw7XG5cblx0XHQvLyBzdG9yZXMgdmlzaWJsZSwgYWN0aXZlLCBhbmQgZ2VvbWV0cnkgaWQgcGVyIGluc3RhbmNlIGFuZCByZXNlcnZlZCBidWZmZXIgcmFuZ2VzIGZvciBnZW9tZXRyaWVzXG5cdFx0dGhpcy5faW5zdGFuY2VJbmZvID0gW107XG5cdFx0dGhpcy5fZ2VvbWV0cnlJbmZvID0gW107XG5cblx0XHQvLyBpbnN0YW5jZSwgZ2VvbWV0cnkgaWRzIHRoYXQgaGF2ZSBiZWVuIHNldCBhcyBpbmFjdGl2ZSwgYW5kIGFyZSBhdmFpbGFibGUgdG8gYmUgb3ZlcndyaXR0ZW5cblx0XHR0aGlzLl9hdmFpbGFibGVJbnN0YW5jZUlkcyA9IFtdO1xuXHRcdHRoaXMuX2F2YWlsYWJsZUdlb21ldHJ5SWRzID0gW107XG5cblx0XHQvLyB1c2VkIHRvIHRyYWNrIHdoZXJlIHRoZSBuZXh0IHBvaW50IGlzIHRoYXQgZ2VvbWV0cnkgc2hvdWxkIGJlIGluc2VydGVkXG5cdFx0dGhpcy5fbmV4dEluZGV4U3RhcnQgPSAwO1xuXHRcdHRoaXMuX25leHRWZXJ0ZXhTdGFydCA9IDA7XG5cdFx0dGhpcy5fZ2VvbWV0cnlDb3VudCA9IDA7XG5cblx0XHQvLyBmbGFnc1xuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkID0gZmFsc2U7XG5cblx0XHQvLyBjYWNoZWQgdXNlciBvcHRpb25zXG5cdFx0dGhpcy5fbWF4SW5zdGFuY2VDb3VudCA9IG1heEluc3RhbmNlQ291bnQ7XG5cdFx0dGhpcy5fbWF4VmVydGV4Q291bnQgPSBtYXhWZXJ0ZXhDb3VudDtcblx0XHR0aGlzLl9tYXhJbmRleENvdW50ID0gbWF4SW5kZXhDb3VudDtcblxuXHRcdC8vIGJ1ZmZlcnMgZm9yIG11bHRpIGRyYXdcblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudHMgPSBuZXcgSW50MzJBcnJheSggbWF4SW5zdGFuY2VDb3VudCApO1xuXHRcdHRoaXMuX211bHRpRHJhd1N0YXJ0cyA9IG5ldyBJbnQzMkFycmF5KCBtYXhJbnN0YW5jZUNvdW50ICk7XG5cdFx0dGhpcy5fbXVsdGlEcmF3Q291bnQgPSAwO1xuXHRcdHRoaXMuX211bHRpRHJhd0luc3RhbmNlcyA9IG51bGw7XG5cblx0XHQvLyBMb2NhbCBtYXRyaXggcGVyIGdlb21ldHJ5IGJ5IHVzaW5nIGRhdGEgdGV4dHVyZVxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5faW5kaXJlY3RUZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuX2luaXRNYXRyaWNlc1RleHR1cmUoKTtcblx0XHR0aGlzLl9pbml0SW5kaXJlY3RUZXh0dXJlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBiYXRjaC5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgbWF4SW5zdGFuY2VDb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9tYXhJbnN0YW5jZUNvdW50O1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGluc3RhbmNlIGNvdW50LlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCBpbnN0YW5jZUNvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2luc3RhbmNlSW5mby5sZW5ndGggLSB0aGlzLl9hdmFpbGFibGVJbnN0YW5jZUlkcy5sZW5ndGg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHVudXNlZCB2ZXJ0aWNlcy5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgdW51c2VkVmVydGV4Q291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWF4VmVydGV4Q291bnQgLSB0aGlzLl9uZXh0VmVydGV4U3RhcnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHVudXNlZCBpbmRpY2VzLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCB1bnVzZWRJbmRleENvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX21heEluZGV4Q291bnQgLSB0aGlzLl9uZXh0SW5kZXhTdGFydDtcblxuXHR9XG5cblx0X2luaXRNYXRyaWNlc1RleHR1cmUoKSB7XG5cblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG5cdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgbWF0cmljZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBtYXRyaWNlcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG5cdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBtYXRyaWNlcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG5cdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBtYXRyaWNlcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5fbWF4SW5zdGFuY2VDb3VudCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuXHRcdHNpemUgPSBNYXRoLmNlaWwoIHNpemUgLyA0ICkgKiA0O1xuXHRcdHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xuXG5cdFx0Y29uc3QgbWF0cmljZXNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxuXHRcdGNvbnN0IG1hdHJpY2VzVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggbWF0cmljZXNBcnJheSwgc2l6ZSwgc2l6ZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XG5cblx0XHR0aGlzLl9tYXRyaWNlc1RleHR1cmUgPSBtYXRyaWNlc1RleHR1cmU7XG5cblx0fVxuXG5cdF9pbml0SW5kaXJlY3RUZXh0dXJlKCkge1xuXG5cdFx0bGV0IHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuX21heEluc3RhbmNlQ291bnQgKTtcblx0XHRzaXplID0gTWF0aC5jZWlsKCBzaXplICk7XG5cblx0XHRjb25zdCBpbmRpcmVjdEFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBzaXplICogc2l6ZSApO1xuXHRcdGNvbnN0IGluZGlyZWN0VGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggaW5kaXJlY3RBcnJheSwgc2l6ZSwgc2l6ZSwgUmVkSW50ZWdlckZvcm1hdCwgVW5zaWduZWRJbnRUeXBlICk7XG5cblx0XHR0aGlzLl9pbmRpcmVjdFRleHR1cmUgPSBpbmRpcmVjdFRleHR1cmU7XG5cblx0fVxuXG5cdF9pbml0Q29sb3JzVGV4dHVyZSgpIHtcblxuXHRcdGxldCBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLl9tYXhJbnN0YW5jZUNvdW50ICk7XG5cdFx0c2l6ZSA9IE1hdGguY2VpbCggc2l6ZSApO1xuXG5cdFx0Ly8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWwgaW5pdGlhbGl6ZWQgdG8gd2hpdGVcblx0XHRjb25zdCBjb2xvcnNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApLmZpbGwoIDEgKTtcblx0XHRjb25zdCBjb2xvcnNUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBjb2xvcnNBcnJheSwgc2l6ZSwgc2l6ZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XG5cdFx0Y29sb3JzVGV4dHVyZS5jb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlO1xuXG5cdFx0dGhpcy5fY29sb3JzVGV4dHVyZSA9IGNvbG9yc1RleHR1cmU7XG5cblx0fVxuXG5cdF9pbml0aWFsaXplR2VvbWV0cnkoIHJlZmVyZW5jZSApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXhWZXJ0ZXhDb3VudCA9IHRoaXMuX21heFZlcnRleENvdW50O1xuXHRcdGNvbnN0IG1heEluZGV4Q291bnQgPSB0aGlzLl9tYXhJbmRleENvdW50O1xuXHRcdGlmICggdGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcmVmZXJlbmNlLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3JjQXR0cmlidXRlID0gcmVmZXJlbmNlLmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXHRcdFx0XHRjb25zdCB7IGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCB9ID0gc3JjQXR0cmlidXRlO1xuXG5cdFx0XHRcdGNvbnN0IGRzdEFycmF5ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBtYXhWZXJ0ZXhDb3VudCAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdGNvbnN0IGRzdEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGRzdEFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSwgZHN0QXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZWZlcmVuY2UuZ2V0SW5kZXgoKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBSZXNlcnZlIGxhc3QgdTE2IGluZGV4IGZvciBwcmltaXRpdmUgcmVzdGFydC5cblx0XHRcdFx0Y29uc3QgaW5kZXhBcnJheSA9IG1heFZlcnRleENvdW50ID4gNjU1MzVcblx0XHRcdFx0XHQ/IG5ldyBVaW50MzJBcnJheSggbWF4SW5kZXhDb3VudCApXG5cdFx0XHRcdFx0OiBuZXcgVWludDE2QXJyYXkoIG1heEluZGV4Q291bnQgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kZXhBcnJheSwgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGUgZ2VvbWV0cnkgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBjb21iaW5lZCBnZW9tZXRyeSBhdHRyaWJ1dGVzXG5cdF92YWxpZGF0ZUdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuXHRcdC8vIGNoZWNrIHRvIGVuc3VyZSB0aGUgZ2VvbWV0cmllcyBhcmUgdXNpbmcgY29uc2lzdGVudCBhdHRyaWJ1dGVzIGFuZCBpbmRpY2VzXG5cdFx0Y29uc3QgYmF0Y2hHZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0aWYgKCBCb29sZWFuKCBnZW9tZXRyeS5nZXRJbmRleCgpICkgIT09IEJvb2xlYW4oIGJhdGNoR2VvbWV0cnkuZ2V0SW5kZXgoKSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogQWxsIGdlb21ldHJpZXMgbXVzdCBjb25zaXN0ZW50bHkgaGF2ZSBcImluZGV4XCIuJyApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBiYXRjaEdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggISBnZW9tZXRyeS5oYXNBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBUSFJFRS5CYXRjaGVkTWVzaDogQWRkZWQgZ2VvbWV0cnkgbWlzc2luZyBcIiR7IGF0dHJpYnV0ZU5hbWUgfVwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29uc2lzdGVudCBhdHRyaWJ1dGVzLmAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzcmNBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcblx0XHRcdGNvbnN0IGRzdEF0dHJpYnV0ZSA9IGJhdGNoR2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRpZiAoIHNyY0F0dHJpYnV0ZS5pdGVtU2l6ZSAhPT0gZHN0QXR0cmlidXRlLml0ZW1TaXplIHx8IHNyY0F0dHJpYnV0ZS5ub3JtYWxpemVkICE9PSBkc3RBdHRyaWJ1dGUubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogQWxsIGF0dHJpYnV0ZXMgbXVzdCBoYXZlIGEgY29uc2lzdGVudCBpdGVtU2l6ZSBhbmQgbm9ybWFsaXplZCB2YWx1ZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlcyB0aGUgaW5zdGFuY2UgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gSUQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIGluc3RhbmNlIHRvIHZhbGlkYXRlLlxuXHQgKi9cblx0dmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICkge1xuXG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXHRcdGlmICggaW5zdGFuY2VJZCA8IDAgfHwgaW5zdGFuY2VJZCA+PSBpbnN0YW5jZUluZm8ubGVuZ3RoIHx8IGluc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggYFRIUkVFLkJhdGNoZWRNZXNoOiBJbnZhbGlkIGluc3RhbmNlSWQgJHtpbnN0YW5jZUlkfS4gSW5zdGFuY2UgaXMgZWl0aGVyIG91dCBvZiByYW5nZSBvciBoYXMgYmVlbiBkZWxldGVkLmAgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlcyB0aGUgZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gSUQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUlkIC0gVGhlIGdlb21ldHJ5IHRvIHZhbGlkYXRlLlxuXHQgKi9cblx0dmFsaWRhdGVHZW9tZXRyeUlkKCBnZW9tZXRyeUlkICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvTGlzdCA9IHRoaXMuX2dlb21ldHJ5SW5mbztcblx0XHRpZiAoIGdlb21ldHJ5SWQgPCAwIHx8IGdlb21ldHJ5SWQgPj0gZ2VvbWV0cnlJbmZvTGlzdC5sZW5ndGggfHwgZ2VvbWV0cnlJbmZvTGlzdFsgZ2VvbWV0cnlJZCBdLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggYFRIUkVFLkJhdGNoZWRNZXNoOiBJbnZhbGlkIGdlb21ldHJ5SWQgJHtnZW9tZXRyeUlkfS4gR2VvbWV0cnkgaXMgZWl0aGVyIG91dCBvZiByYW5nZSBvciBoYXMgYmVlbiBkZWxldGVkLmAgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgc29ydCBhIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIGJlZm9yZSByZW5kZXIuIFRoZSBmdW5jdGlvbiB0YWtlcyBhIGxpc3Qgb2YgaW5zdGFuY2VzIHRvXG5cdCAqIHNvcnQgYW5kIGEgY2FtZXJhLiBUaGUgb2JqZWN0cyBpbiB0aGUgbGlzdCBpbmNsdWRlIGEgXCJ6XCIgZmllbGQgdG8gcGVyZm9ybSBhIGRlcHRoLW9yZGVyZWQgc29ydCB3aXRoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuXHQgKiBAcmV0dXJuIHtCYXRjaGVkTWVzaH0gQSByZWZlcmVuY2UgdG8gdGhpcyBiYXRjaGVkIG1lc2guXG5cdCAqL1xuXHRzZXRDdXN0b21Tb3J0KCBmdW5jICkge1xuXG5cdFx0dGhpcy5jdXN0b21Tb3J0ID0gZnVuYztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBib3VuZGluZyBib3gsIHVwZGF0aW5nIHtAbGluayBCYXRjaGVkTWVzaCNib3VuZGluZ0JveH0uXG5cdCAqIEJvdW5kaW5nIGJveGVzIGFyZW4ndCBjb21wdXRlZCBieSBkZWZhdWx0LiBUaGV5IG5lZWQgdG8gYmUgZXhwbGljaXRseSBjb21wdXRlZCxcblx0ICogb3RoZXJ3aXNlIHRoZXkgYXJlIGBudWxsYC5cblx0ICovXG5cdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHRoaXMuYm91bmRpbmdCb3g7XG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXG5cdFx0Ym91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VJbmZvLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaW5zdGFuY2VJbmZvWyBpIF0uYWN0aXZlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeUlkID0gaW5zdGFuY2VJbmZvWyBpIF0uZ2VvbWV0cnlJbmRleDtcblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tYXRyaXggKTtcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3hBdCggZ2VvbWV0cnlJZCwgX2JveCApLmFwcGx5TWF0cml4NCggX21hdHJpeCApO1xuXHRcdFx0Ym91bmRpbmdCb3gudW5pb24oIF9ib3ggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBib3VuZGluZyBzcGhlcmUsIHVwZGF0aW5nIHtAbGluayBCYXRjaGVkTWVzaCNib3VuZGluZ1NwaGVyZX0uXG5cdCAqIEJvdW5kaW5nIHNwaGVyZXMgYXJlbid0IGNvbXB1dGVkIGJ5IGRlZmF1bHQuIFRoZXkgbmVlZCB0byBiZSBleHBsaWNpdGx5IGNvbXB1dGVkLFxuXHQgKiBvdGhlcndpc2UgdGhleSBhcmUgYG51bGxgLlxuXHQgKi9cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXHRcdGNvbnN0IGluc3RhbmNlSW5mbyA9IHRoaXMuX2luc3RhbmNlSW5mbztcblxuXHRcdGJvdW5kaW5nU3BoZXJlLm1ha2VFbXB0eSgpO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJZCA9IGluc3RhbmNlSW5mb1sgaSBdLmdlb21ldHJ5SW5kZXg7XG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4ICk7XG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nU3BoZXJlQXQoIGdlb21ldHJ5SWQsIF9zcGhlcmUgKS5hcHBseU1hdHJpeDQoIF9tYXRyaXggKTtcblx0XHRcdGJvdW5kaW5nU3BoZXJlLnVuaW9uKCBfc3BoZXJlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IGluc3RhbmNlIHRvIHRoZSBiYXRjaCB1c2luZyB0aGUgZ2VvbWV0cnkgb2YgdGhlIGdpdmVuIElEIGFuZCByZXR1cm5zXG5cdCAqIGEgbmV3IGlkIHJlZmVycmluZyB0byB0aGUgbmV3IGluc3RhbmNlIHRvIGJlIHVzZWQgYnkgb3RoZXIgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJZCAtIFRoZSBJRCBvZiBhIHByZXZpb3VzbHkgYWRkZWQgZ2VvbWV0cnkgdmlhIHtAbGluayBCYXRjaGVkTWVzaCNhZGRHZW9tZXRyeX0uXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluc3RhbmNlIElELlxuXHQgKi9cblx0YWRkSW5zdGFuY2UoIGdlb21ldHJ5SWQgKSB7XG5cblx0XHRjb25zdCBhdENhcGFjaXR5ID0gdGhpcy5faW5zdGFuY2VJbmZvLmxlbmd0aCA+PSB0aGlzLm1heEluc3RhbmNlQ291bnQ7XG5cblx0XHQvLyBlbnN1cmUgd2UncmUgbm90IG92ZXIgZ2VvbWV0cnlcblx0XHRpZiAoIGF0Q2FwYWNpdHkgJiYgdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogTWF4aW11bSBpdGVtIGNvdW50IHJlYWNoZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0ge1xuXHRcdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHRcdGdlb21ldHJ5SW5kZXg6IGdlb21ldHJ5SWQsXG5cdFx0fTtcblxuXHRcdGxldCBkcmF3SWQgPSBudWxsO1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSB1c2luZyBwcmV2aW91c2x5IGZyZWVkIGluc3RhbmNlIGlkc1xuXHRcdGlmICggdGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMuc29ydCggYXNjSWRTb3J0ICk7XG5cblx0XHRcdGRyYXdJZCA9IHRoaXMuX2F2YWlsYWJsZUluc3RhbmNlSWRzLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl9pbnN0YW5jZUluZm9bIGRyYXdJZCBdID0gaW5zdGFuY2VJbmZvO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZHJhd0lkID0gdGhpcy5faW5zdGFuY2VJbmZvLmxlbmd0aDtcblx0XHRcdHRoaXMuX2luc3RhbmNlSW5mby5wdXNoKCBpbnN0YW5jZUluZm8gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hdHJpY2VzVGV4dHVyZSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZTtcblx0XHRfbWF0cml4LmlkZW50aXR5KCkudG9BcnJheSggbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGEsIGRyYXdJZCAqIDE2ICk7XG5cdFx0bWF0cmljZXNUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGNvbG9yc1RleHR1cmUgPSB0aGlzLl9jb2xvcnNUZXh0dXJlO1xuXHRcdGlmICggY29sb3JzVGV4dHVyZSApIHtcblxuXHRcdFx0X3doaXRlQ29sb3IudG9BcnJheSggY29sb3JzVGV4dHVyZS5pbWFnZS5kYXRhLCBkcmF3SWQgKiA0ICk7XG5cdFx0XHRjb2xvcnNUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID0gdHJ1ZTtcblx0XHRyZXR1cm4gZHJhd0lkO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gZ2VvbWV0cnkgdG8gdGhlIGJhdGNoIGFuZCByZXR1cm5zIHRoZSBhc3NvY2lhdGVkXG5cdCAqIGdlb21ldHJ5IGlkIHJlZmVycmluZyB0byBpdCB0byBiZSB1c2VkIGluIG90aGVyIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgdG8gYWRkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3Jlc2VydmVkVmVydGV4Q291bnQ9LTFdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZnlpbmcgdGhlIGFtb3VudCBvZlxuXHQgKiB2ZXJ0ZXggYnVmZmVyIHNwYWNlIHRvIHJlc2VydmUgZm9yIHRoZSBhZGRlZCBnZW9tZXRyeS4gVGhpcyBpcyBuZWNlc3NhcnkgaWYgaXQgaXMgcGxhbm5lZFxuXHQgKiB0byBzZXQgYSBuZXcgZ2VvbWV0cnkgYXQgdGhpcyBpbmRleCBhdCBhIGxhdGVyIHRpbWUgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGdlb21ldHJ5IHZlcnRleCBidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzZXJ2ZWRJbmRleENvdW50PS0xXSAtIE9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZ5aW5nIHRoZSBhbW91bnQgb2YgaW5kZXhcblx0ICogYnVmZmVyIHNwYWNlIHRvIHJlc2VydmUgZm9yIHRoZSBhZGRlZCBnZW9tZXRyeS4gVGhpcyBpcyBuZWNlc3NhcnkgaWYgaXQgaXMgcGxhbm5lZCB0byBzZXQgYVxuXHQgKiBuZXcgZ2VvbWV0cnkgYXQgdGhpcyBpbmRleCBhdCBhIGxhdGVyIHRpbWUgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkuIERlZmF1bHRzIHRvXG5cdCAqIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGdlb21ldHJ5IGluZGV4IGJ1ZmZlci5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2VvbWV0cnkgSUQuXG5cdCAqL1xuXHRhZGRHZW9tZXRyeSggZ2VvbWV0cnksIHJlc2VydmVkVmVydGV4Q291bnQgPSAtIDEsIHJlc2VydmVkSW5kZXhDb3VudCA9IC0gMSApIHtcblxuXHRcdHRoaXMuX2luaXRpYWxpemVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdHRoaXMuX3ZhbGlkYXRlR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSB7XG5cdFx0XHQvLyBnZW9tZXRyeSBpbmZvcm1hdGlvblxuXHRcdFx0dmVydGV4U3RhcnQ6IC0gMSxcblx0XHRcdHZlcnRleENvdW50OiAtIDEsXG5cdFx0XHRyZXNlcnZlZFZlcnRleENvdW50OiAtIDEsXG5cblx0XHRcdGluZGV4U3RhcnQ6IC0gMSxcblx0XHRcdGluZGV4Q291bnQ6IC0gMSxcblx0XHRcdHJlc2VydmVkSW5kZXhDb3VudDogLSAxLFxuXG5cdFx0XHQvLyBkcmF3IHJhbmdlIGluZm9ybWF0aW9uXG5cdFx0XHRzdGFydDogLSAxLFxuXHRcdFx0Y291bnQ6IC0gMSxcblxuXHRcdFx0Ly8gc3RhdGVcblx0XHRcdGJvdW5kaW5nQm94OiBudWxsLFxuXHRcdFx0Ym91bmRpbmdTcGhlcmU6IG51bGwsXG5cdFx0XHRhY3RpdmU6IHRydWUsXG5cdFx0fTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5SW5mb0xpc3QgPSB0aGlzLl9nZW9tZXRyeUluZm87XG5cdFx0Z2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ID0gdGhpcy5fbmV4dFZlcnRleFN0YXJ0O1xuXHRcdGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50ID0gcmVzZXJ2ZWRWZXJ0ZXhDb3VudCA9PT0gLSAxID8gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkuY291bnQgOiByZXNlcnZlZFZlcnRleENvdW50O1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdGNvbnN0IGhhc0luZGV4ID0gaW5kZXggIT09IG51bGw7XG5cdFx0aWYgKCBoYXNJbmRleCApIHtcblxuXHRcdFx0Z2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgPSB0aGlzLl9uZXh0SW5kZXhTdGFydDtcblx0XHRcdGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQgPSByZXNlcnZlZEluZGV4Q291bnQgPT09IC0gMSA/IGluZGV4LmNvdW50IDogcmVzZXJ2ZWRJbmRleENvdW50O1xuXG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0Z2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgIT09IC0gMSAmJlxuXHRcdFx0Z2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgKyBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50ID4gdGhpcy5fbWF4SW5kZXhDb3VudCB8fFxuXHRcdFx0Z2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ICsgZ2VvbWV0cnlJbmZvLnJlc2VydmVkVmVydGV4Q291bnQgPiB0aGlzLl9tYXhWZXJ0ZXhDb3VudFxuXHRcdCkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogUmVzZXJ2ZWQgc3BhY2UgcmVxdWVzdCBleGNlZWRzIHRoZSBtYXhpbXVtIGJ1ZmZlciBzaXplLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBpZFxuXHRcdGxldCBnZW9tZXRyeUlkO1xuXHRcdGlmICggdGhpcy5fYXZhaWxhYmxlR2VvbWV0cnlJZHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5fYXZhaWxhYmxlR2VvbWV0cnlJZHMuc29ydCggYXNjSWRTb3J0ICk7XG5cblx0XHRcdGdlb21ldHJ5SWQgPSB0aGlzLl9hdmFpbGFibGVHZW9tZXRyeUlkcy5zaGlmdCgpO1xuXHRcdFx0Z2VvbWV0cnlJbmZvTGlzdFsgZ2VvbWV0cnlJZCBdID0gZ2VvbWV0cnlJbmZvO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeUlkID0gdGhpcy5fZ2VvbWV0cnlDb3VudDtcblx0XHRcdHRoaXMuX2dlb21ldHJ5Q291bnQgKys7XG5cdFx0XHRnZW9tZXRyeUluZm9MaXN0LnB1c2goIGdlb21ldHJ5SW5mbyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHRoZSBnZW9tZXRyeVxuXHRcdHRoaXMuc2V0R2VvbWV0cnlBdCggZ2VvbWV0cnlJZCwgZ2VvbWV0cnkgKTtcblxuXHRcdC8vIGluY3JlbWVudCB0aGUgbmV4dCBnZW9tZXRyeSBwb3NpdGlvblxuXHRcdHRoaXMuX25leHRJbmRleFN0YXJ0ID0gZ2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgKyBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50O1xuXHRcdHRoaXMuX25leHRWZXJ0ZXhTdGFydCA9IGdlb21ldHJ5SW5mby52ZXJ0ZXhTdGFydCArIGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50O1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5SWQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlcyB0aGUgZ2VvbWV0cnkgYXQgdGhlIGdpdmVuIElEIHdpdGggdGhlIHByb3ZpZGVkIGdlb21ldHJ5LiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmVcblx0ICogaXMgbm90IGVub3VnaCBzcGFjZSByZXNlcnZlZCBmb3IgZ2VvbWV0cnkuIENhbGxpbmcgdGhpcyB3aWxsIGNoYW5nZSBhbGwgaW5zdGFuY2VzIHRoYXQgYXJlXG5cdCAqIHJlbmRlcmluZyB0aGF0IGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJZCAtIFRoZSBJRCBvZiB0aGUgZ2VvbWV0cnkgdGhhdCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5IC0gVGhlIG5ldyBnZW9tZXRyeS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2VvbWV0cnkgSUQuXG5cdCAqL1xuXHRzZXRHZW9tZXRyeUF0KCBnZW9tZXRyeUlkLCBnZW9tZXRyeSApIHtcblxuXHRcdGlmICggZ2VvbWV0cnlJZCA+PSB0aGlzLl9nZW9tZXRyeUNvdW50ICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5CYXRjaGVkTWVzaDogTWF4aW11bSBnZW9tZXRyeSBjb3VudCByZWFjaGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3ZhbGlkYXRlR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRjb25zdCBiYXRjaEdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBoYXNJbmRleCA9IGJhdGNoR2VvbWV0cnkuZ2V0SW5kZXgoKSAhPT0gbnVsbDtcblx0XHRjb25zdCBkc3RJbmRleCA9IGJhdGNoR2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRjb25zdCBzcmNJbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gdGhpcy5fZ2VvbWV0cnlJbmZvWyBnZW9tZXRyeUlkIF07XG5cdFx0aWYgKFxuXHRcdFx0aGFzSW5kZXggJiZcblx0XHRcdHNyY0luZGV4LmNvdW50ID4gZ2VvbWV0cnlJbmZvLnJlc2VydmVkSW5kZXhDb3VudCB8fFxuXHRcdFx0Z2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCA+IGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50XG5cdFx0KSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkJhdGNoZWRNZXNoOiBSZXNlcnZlZCBzcGFjZSBub3QgbGFyZ2UgZW5vdWdoIGZvciBwcm92aWRlZCBnZW9tZXRyeS4nICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb3B5IGdlb21ldHJ5IGJ1ZmZlciBkYXRhIG92ZXJcblx0XHRjb25zdCB2ZXJ0ZXhTdGFydCA9IGdlb21ldHJ5SW5mby52ZXJ0ZXhTdGFydDtcblx0XHRjb25zdCByZXNlcnZlZFZlcnRleENvdW50ID0gZ2VvbWV0cnlJbmZvLnJlc2VydmVkVmVydGV4Q291bnQ7XG5cdFx0Z2VvbWV0cnlJbmZvLnZlcnRleENvdW50ID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkuY291bnQ7XG5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJhdGNoR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Ly8gY29weSBhdHRyaWJ1dGUgZGF0YVxuXHRcdFx0Y29uc3Qgc3JjQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XG5cdFx0XHRjb25zdCBkc3RBdHRyaWJ1dGUgPSBiYXRjaEdlb21ldHJ5LmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSApO1xuXHRcdFx0Y29weUF0dHJpYnV0ZURhdGEoIHNyY0F0dHJpYnV0ZSwgZHN0QXR0cmlidXRlLCB2ZXJ0ZXhTdGFydCApO1xuXG5cdFx0XHQvLyBmaWxsIHRoZSByZXN0IGluIHdpdGggemVyb2VzXG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IHNyY0F0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGZvciAoIGxldCBpID0gc3JjQXR0cmlidXRlLmNvdW50LCBsID0gcmVzZXJ2ZWRWZXJ0ZXhDb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSB2ZXJ0ZXhTdGFydCArIGk7XG5cdFx0XHRcdGZvciAoIGxldCBjID0gMDsgYyA8IGl0ZW1TaXplOyBjICsrICkge1xuXG5cdFx0XHRcdFx0ZHN0QXR0cmlidXRlLnNldENvbXBvbmVudCggaW5kZXgsIGMsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZHN0QXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdGRzdEF0dHJpYnV0ZS5hZGRVcGRhdGVSYW5nZSggdmVydGV4U3RhcnQgKiBpdGVtU2l6ZSwgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb3B5IGluZGV4XG5cdFx0aWYgKCBoYXNJbmRleCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXhTdGFydCA9IGdlb21ldHJ5SW5mby5pbmRleFN0YXJ0O1xuXHRcdFx0Y29uc3QgcmVzZXJ2ZWRJbmRleENvdW50ID0gZ2VvbWV0cnlJbmZvLnJlc2VydmVkSW5kZXhDb3VudDtcblx0XHRcdGdlb21ldHJ5SW5mby5pbmRleENvdW50ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKS5jb3VudDtcblxuXHRcdFx0Ly8gY29weSBpbmRleCBkYXRhIG92ZXJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNyY0luZGV4LmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGRzdEluZGV4LnNldFgoIGluZGV4U3RhcnQgKyBpLCB2ZXJ0ZXhTdGFydCArIHNyY0luZGV4LmdldFgoIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpbGwgdGhlIHJlc3QgaW4gd2l0aCB6ZXJvZXNcblx0XHRcdGZvciAoIGxldCBpID0gc3JjSW5kZXguY291bnQsIGwgPSByZXNlcnZlZEluZGV4Q291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGRzdEluZGV4LnNldFgoIGluZGV4U3RhcnQgKyBpLCB2ZXJ0ZXhTdGFydCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRzdEluZGV4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdGRzdEluZGV4LmFkZFVwZGF0ZVJhbmdlKCBpbmRleFN0YXJ0LCBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50ICk7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgdGhlIGRyYXcgcmFuZ2Vcblx0XHRnZW9tZXRyeUluZm8uc3RhcnQgPSBoYXNJbmRleCA/IGdlb21ldHJ5SW5mby5pbmRleFN0YXJ0IDogZ2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0O1xuXHRcdGdlb21ldHJ5SW5mby5jb3VudCA9IGhhc0luZGV4ID8gZ2VvbWV0cnlJbmZvLmluZGV4Q291bnQgOiBnZW9tZXRyeUluZm8udmVydGV4Q291bnQ7XG5cblx0XHQvLyBzdG9yZSB0aGUgYm91bmRpbmcgYm94ZXNcblx0XHRnZW9tZXRyeUluZm8uYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdGdlb21ldHJ5SW5mby5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeUluZm8uYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdGdlb21ldHJ5SW5mby5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGdlb21ldHJ5SWQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoZSBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBJRCBmcm9tIHRoaXMgYmF0Y2guIEFueSBpbnN0YW5jZXMgcmVmZXJlbmNpbmdcblx0ICogdGhpcyBnZW9tZXRyeSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBhcyBhIHNpZGUgZWZmZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJZCAtIFRoZSBJRCBvZiB0aGUgZ2VvbWV0cnkgdG8gcmVtb3ZlIGZyb20gdGhlIGJhdGNoLlxuXHQgKiBAcmV0dXJuIHtCYXRjaGVkTWVzaH0gQSByZWZlcmVuY2UgdG8gdGhpcyBiYXRjaGVkIG1lc2guXG5cdCAqL1xuXHRkZWxldGVHZW9tZXRyeSggZ2VvbWV0cnlJZCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5SW5mb0xpc3QgPSB0aGlzLl9nZW9tZXRyeUluZm87XG5cdFx0aWYgKCBnZW9tZXRyeUlkID49IGdlb21ldHJ5SW5mb0xpc3QubGVuZ3RoIHx8IGdlb21ldHJ5SW5mb0xpc3RbIGdlb21ldHJ5SWQgXS5hY3RpdmUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdC8vIGRlbGV0ZSBhbnkgaW5zdGFuY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG5cdFx0Y29uc3QgaW5zdGFuY2VJbmZvID0gdGhpcy5faW5zdGFuY2VJbmZvO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlSW5mby5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSAmJiBpbnN0YW5jZUluZm9bIGkgXS5nZW9tZXRyeUluZGV4ID09PSBnZW9tZXRyeUlkICkge1xuXG5cdFx0XHRcdHRoaXMuZGVsZXRlSW5zdGFuY2UoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlJbmZvTGlzdFsgZ2VvbWV0cnlJZCBdLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2F2YWlsYWJsZUdlb21ldHJ5SWRzLnB1c2goIGdlb21ldHJ5SWQgKTtcblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgaW5zdGFuY2UgZnJvbSB0aGUgYmF0Y2ggdXNpbmcgdGhlIGdpdmVuIElELlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5zdGFuY2VJZCAtIFRoZSBJRCBvZiB0aGUgaW5zdGFuY2UgdG8gcmVtb3ZlIGZyb20gdGhlIGJhdGNoLlxuXHQgKiBAcmV0dXJuIHtCYXRjaGVkTWVzaH0gQSByZWZlcmVuY2UgdG8gdGhpcyBiYXRjaGVkIG1lc2guXG5cdCAqL1xuXHRkZWxldGVJbnN0YW5jZSggaW5zdGFuY2VJZCApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHR0aGlzLl9pbnN0YW5jZUluZm9bIGluc3RhbmNlSWQgXS5hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLl9hdmFpbGFibGVJbnN0YW5jZUlkcy5wdXNoKCBpbnN0YW5jZUlkICk7XG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXBhY2tzIHRoZSBzdWIgZ2VvbWV0cmllcyBpbiBbbmFtZV0gdG8gcmVtb3ZlIGFueSB1bnVzZWQgc3BhY2UgcmVtYWluaW5nIGZyb21cblx0ICogcHJldmlvdXNseSBkZWxldGVkIGdlb21ldHJ5LCBmcmVlaW5nIHVwIHNwYWNlIHRvIGFkZCBuZXcgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIElEIG9mIHRoZSBpbnN0YW5jZSB0byByZW1vdmUgZnJvbSB0aGUgYmF0Y2guXG5cdCAqIEByZXR1cm4ge0JhdGNoZWRNZXNofSBBIHJlZmVyZW5jZSB0byB0aGlzIGJhdGNoZWQgbWVzaC5cblx0ICovXG5cdG9wdGltaXplKCkge1xuXG5cdFx0Ly8gdHJhY2sgdGhlIG5leHQgaW5kaWNlcyB0byBjb3B5IGRhdGEgdG9cblx0XHRsZXQgbmV4dFZlcnRleFN0YXJ0ID0gMDtcblx0XHRsZXQgbmV4dEluZGV4U3RhcnQgPSAwO1xuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBnZW9tZXRyeSByYW5nZXMgaW4gb3JkZXIgc29ydGVkIGZyb20gZWFybGllc3QgaW4gdGhlIGdlb21ldHJ5IGJ1ZmZlciB0byBsYXRlc3Rcblx0XHQvLyBpbiB0aGUgZ2VvbWV0cnkgYnVmZmVyLiBCZWNhdXNlIGRyYXcgcmFuZ2Ugb2JqZWN0cyBjYW4gYmUgcmV1c2VkIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGVpciBvcmRlci5cblx0XHRjb25zdCBnZW9tZXRyeUluZm9MaXN0ID0gdGhpcy5fZ2VvbWV0cnlJbmZvO1xuXHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeUluZm9MaXN0XG5cdFx0XHQubWFwKCAoIGUsIGkgKSA9PiBpIClcblx0XHRcdC5zb3J0KCAoIGEsIGIgKSA9PiB7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5SW5mb0xpc3RbIGEgXS52ZXJ0ZXhTdGFydCAtIGdlb21ldHJ5SW5mb0xpc3RbIGIgXS52ZXJ0ZXhTdGFydDtcblxuXHRcdFx0fSApO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdlb21ldHJ5SW5mb0xpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Ly8gaWYgYSBnZW9tZXRyeSByYW5nZSBpcyBpbmFjdGl2ZSB0aGVuIGRvbid0IGNvcHkgYW55dGhpbmdcblx0XHRcdGNvbnN0IGluZGV4ID0gaW5kaWNlc1sgaSBdO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gZ2VvbWV0cnlJbmZvTGlzdFsgaW5kZXggXTtcblx0XHRcdGlmICggZ2VvbWV0cnlJbmZvLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgYSBnZW9tZXRyeSBjb250YWlucyBhbiBpbmRleCBidWZmZXIgdGhlbiBzaGlmdCBpdCwgYXMgd2VsbFxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5SW5mby5pbmRleFN0YXJ0ICE9PSBuZXh0SW5kZXhTdGFydCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHsgaW5kZXhTdGFydCwgdmVydGV4U3RhcnQsIHJlc2VydmVkSW5kZXhDb3VudCB9ID0gZ2VvbWV0cnlJbmZvO1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRcdC8vIHNoaWZ0IHRoZSBpbmRleCBwb2ludGVycyBiYXNlZCBvbiBob3cgdGhlIHZlcnRleCBkYXRhIHdpbGwgc2hpZnRcblx0XHRcdFx0XHQvLyBhZGp1c3RpbmcgdGhlIGluZGV4IG11c3QgaGFwcGVuIGZpcnN0IHNvIHRoZSBvcmlnaW5hbCB2ZXJ0ZXggc3RhcnQgdmFsdWUgaXMgYXZhaWxhYmxlXG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudERlbHRhID0gbmV4dFZlcnRleFN0YXJ0IC0gdmVydGV4U3RhcnQ7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSBpbmRleFN0YXJ0OyBqIDwgaW5kZXhTdGFydCArIHJlc2VydmVkSW5kZXhDb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0YXJyYXlbIGogXSA9IGFycmF5WyBqIF0gKyBlbGVtZW50RGVsdGE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleC5hcnJheS5jb3B5V2l0aGluKCBuZXh0SW5kZXhTdGFydCwgaW5kZXhTdGFydCwgaW5kZXhTdGFydCArIHJlc2VydmVkSW5kZXhDb3VudCApO1xuXHRcdFx0XHRcdGluZGV4LmFkZFVwZGF0ZVJhbmdlKCBuZXh0SW5kZXhTdGFydCwgcmVzZXJ2ZWRJbmRleENvdW50ICk7XG5cblx0XHRcdFx0XHRnZW9tZXRyeUluZm8uaW5kZXhTdGFydCA9IG5leHRJbmRleFN0YXJ0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXh0SW5kZXhTdGFydCArPSBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGEgZ2VvbWV0cnkgbmVlZHMgdG8gYmUgbW92ZWQgdGhlbiBjb3B5IGF0dHJpYnV0ZSBkYXRhIHRvIG92ZXJ3cml0ZSB1bnVzZWQgc3BhY2Vcblx0XHRcdGlmICggZ2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ICE9PSBuZXh0VmVydGV4U3RhcnQgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB2ZXJ0ZXhTdGFydCwgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCB9ID0gZ2VvbWV0cnlJbmZvO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdFx0XHRjb25zdCB7IGFycmF5LCBpdGVtU2l6ZSB9ID0gYXR0cmlidXRlO1xuXHRcdFx0XHRcdGFycmF5LmNvcHlXaXRoaW4oIG5leHRWZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCB2ZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCAoIHZlcnRleFN0YXJ0ICsgcmVzZXJ2ZWRWZXJ0ZXhDb3VudCApICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYWRkVXBkYXRlUmFuZ2UoIG5leHRWZXJ0ZXhTdGFydCAqIGl0ZW1TaXplLCByZXNlcnZlZFZlcnRleENvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlJbmZvLnZlcnRleFN0YXJ0ID0gbmV4dFZlcnRleFN0YXJ0O1xuXG5cdFx0XHR9XG5cblx0XHRcdG5leHRWZXJ0ZXhTdGFydCArPSBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRWZXJ0ZXhDb3VudDtcblx0XHRcdGdlb21ldHJ5SW5mby5zdGFydCA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgOiBnZW9tZXRyeUluZm8udmVydGV4U3RhcnQ7XG5cblx0XHRcdC8vIHN0ZXAgdGhlIG5leHQgZ2VvbWV0cnkgcG9pbnRzIHRvIHRoZSBzaGlmdGVkIHBvc2l0aW9uXG5cdFx0XHR0aGlzLl9uZXh0SW5kZXhTdGFydCA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnlJbmZvLmluZGV4U3RhcnQgKyBnZW9tZXRyeUluZm8ucmVzZXJ2ZWRJbmRleENvdW50IDogMDtcblx0XHRcdHRoaXMuX25leHRWZXJ0ZXhTdGFydCA9IGdlb21ldHJ5SW5mby52ZXJ0ZXhTdGFydCArIGdlb21ldHJ5SW5mby5yZXNlcnZlZFZlcnRleENvdW50O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIHRoZSBnaXZlbiBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SWQgLSBUaGUgSUQgb2YgdGhlIGdlb21ldHJ5IHRvIHJldHVybiB0aGUgYm91bmRpbmcgYm94IGZvci5cblx0ICogQHBhcmFtIHtCb3gzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7Qm94M3xudWxsfSBUaGUgZ2VvbWV0cnkncyBib3VuZGluZyBib3guIFJldHVybnMgYG51bGxgIGlmIG5vIGdlb21ldHJ5IGhhcyBiZWVuIGZvdW5kIGZvciB0aGUgZ2l2ZW4gSUQuXG5cdCAqL1xuXHRnZXRCb3VuZGluZ0JveEF0KCBnZW9tZXRyeUlkLCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gdGhpcy5fZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJvdW5kaW5nIGJveFxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSB0aGlzLl9nZW9tZXRyeUluZm9bIGdlb21ldHJ5SWQgXTtcblx0XHRpZiAoIGdlb21ldHJ5SW5mby5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgYm94ID0gbmV3IEJveDMoKTtcblx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRmb3IgKCBsZXQgaSA9IGdlb21ldHJ5SW5mby5zdGFydCwgbCA9IGdlb21ldHJ5SW5mby5zdGFydCArIGdlb21ldHJ5SW5mby5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGl2ID0gaTtcblx0XHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRcdGl2ID0gaW5kZXguZ2V0WCggaXYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGl2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeUluZm8uYm91bmRpbmdCb3ggPSBib3g7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQuY29weSggZ2VvbWV0cnlJbmZvLmJvdW5kaW5nQm94ICk7XG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGJvdW5kaW5nIHNwaGVyZSBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJZCAtIFRoZSBJRCBvZiB0aGUgZ2VvbWV0cnkgdG8gcmV0dXJuIHRoZSBib3VuZGluZyBzcGhlcmUgZm9yLlxuXHQgKiBAcGFyYW0ge1NwaGVyZX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1NwaGVyZXxudWxsfSBUaGUgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUuIFJldHVybnMgYG51bGxgIGlmIG5vIGdlb21ldHJ5IGhhcyBiZWVuIGZvdW5kIGZvciB0aGUgZ2l2ZW4gSUQuXG5cdCAqL1xuXHRnZXRCb3VuZGluZ1NwaGVyZUF0KCBnZW9tZXRyeUlkLCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIGdlb21ldHJ5SWQgPj0gdGhpcy5fZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJvdW5kaW5nIHNwaGVyZVxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSB0aGlzLl9nZW9tZXRyeUluZm9bIGdlb21ldHJ5SWQgXTtcblx0XHRpZiAoIGdlb21ldHJ5SW5mby5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveEF0KCBnZW9tZXRyeUlkLCBfYm94ICk7XG5cdFx0XHRfYm94LmdldENlbnRlciggc3BoZXJlLmNlbnRlciApO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSBnZW9tZXRyeUluZm8uc3RhcnQsIGwgPSBnZW9tZXRyeUluZm8uc3RhcnQgKyBnZW9tZXRyeUluZm8uY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBpdiA9IGk7XG5cdFx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0XHRpdiA9IGluZGV4LmdldFgoIGl2ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGl2ICk7XG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBfdmVjdG9yICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXHRcdFx0Z2VvbWV0cnlJbmZvLmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmNvcHkoIGdlb21ldHJ5SW5mby5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGRlZmluZWQgaW5zdGFuY2UuXG5cdCAqIE5lZ2F0aXZlbHkgc2NhbGVkIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5zdGFuY2VJZCAtIFRoZSBJRCBvZiBhbiBpbnN0YW5jZSB0byBzZXQgdGhlIG1hdHJpeCBvZi5cblx0ICogQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXggLSBBIDR4NCBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBvZiBhIHNpbmdsZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7QmF0Y2hlZE1lc2h9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYmF0Y2hlZCBtZXNoLlxuXHQgKi9cblx0c2V0TWF0cml4QXQoIGluc3RhbmNlSWQsIG1hdHJpeCApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHRjb25zdCBtYXRyaWNlc1RleHR1cmUgPSB0aGlzLl9tYXRyaWNlc1RleHR1cmU7XG5cdFx0Y29uc3QgbWF0cmljZXNBcnJheSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhO1xuXHRcdG1hdHJpeC50b0FycmF5KCBtYXRyaWNlc0FycmF5LCBpbnN0YW5jZUlkICogMTYgKTtcblx0XHRtYXRyaWNlc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGRlZmluZWQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIElEIG9mIGFuIGluc3RhbmNlIHRvIGdldCB0aGUgbWF0cml4IG9mLlxuXHQgKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXg0fSBUaGUgaW5zdGFuY2UncyBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdCAqL1xuXHRnZXRNYXRyaXhBdCggaW5zdGFuY2VJZCwgbWF0cml4ICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblx0XHRyZXR1cm4gbWF0cml4LmZyb21BcnJheSggdGhpcy5fbWF0cmljZXNUZXh0dXJlLmltYWdlLmRhdGEsIGluc3RhbmNlSWQgKiAxNiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gY29sb3IgdG8gdGhlIGRlZmluZWQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIElEIG9mIGFuIGluc3RhbmNlIHRvIHNldCB0aGUgY29sb3Igb2YuXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIC0gVGhlIGNvbG9yIHRvIHNldCB0aGUgaW5zdGFuY2UgdG8uXG5cdCAqIEByZXR1cm4ge0JhdGNoZWRNZXNofSBBIHJlZmVyZW5jZSB0byB0aGlzIGJhdGNoZWQgbWVzaC5cblx0ICovXG5cdHNldENvbG9yQXQoIGluc3RhbmNlSWQsIGNvbG9yICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblxuXHRcdGlmICggdGhpcy5fY29sb3JzVGV4dHVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5faW5pdENvbG9yc1RleHR1cmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbG9yLnRvQXJyYXkoIHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSwgaW5zdGFuY2VJZCAqIDQgKTtcblx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIGRlZmluZWQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIElEIG9mIGFuIGluc3RhbmNlIHRvIGdldCB0aGUgY29sb3Igb2YuXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIC0gVGhlIHRhcmdldCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge0NvbG9yfSBUaGUgaW5zdGFuY2UncyBjb2xvci5cblx0ICovXG5cdGdldENvbG9yQXQoIGluc3RhbmNlSWQsIGNvbG9yICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblx0XHRyZXR1cm4gY29sb3IuZnJvbUFycmF5KCB0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEsIGluc3RhbmNlSWQgKiA0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluc3RhbmNlSWQgLSBUaGUgaWQgb2YgdGhlIGluc3RhbmNlIHRvIHNldCB0aGUgdmlzaWJpbGl0eSBvZi5cblx0ICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIC0gV2hldGhlciB0aGUgaW5zdGFuY2UgaXMgdmlzaWJsZSBvciBub3QuXG5cdCAqIEByZXR1cm4ge0JhdGNoZWRNZXNofSBBIHJlZmVyZW5jZSB0byB0aGlzIGJhdGNoZWQgbWVzaC5cblx0ICovXG5cdHNldFZpc2libGVBdCggaW5zdGFuY2VJZCwgdmlzaWJsZSApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHRpZiAoIHRoaXMuX2luc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLnZpc2libGUgPT09IHZpc2libGUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5zdGFuY2VJbmZvWyBpbnN0YW5jZUlkIF0udmlzaWJsZSA9IHZpc2libGU7XG5cdFx0dGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBkZWZpbmVkIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5zdGFuY2VJZCAtIFRoZSBJRCBvZiBhbiBpbnN0YW5jZSB0byBnZXQgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGluc3RhbmNlIGlzIHZpc2libGUgb3Igbm90LlxuXHQgKi9cblx0Z2V0VmlzaWJsZUF0KCBpbnN0YW5jZUlkICkge1xuXG5cdFx0dGhpcy52YWxpZGF0ZUluc3RhbmNlSWQoIGluc3RhbmNlSWQgKTtcblxuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZUluZm9bIGluc3RhbmNlSWQgXS52aXNpYmxlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2VvbWV0cnkgSUQgb2YgdGhlIGluc3RhbmNlIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluc3RhbmNlSWQgLSBUaGUgSUQgb2YgdGhlIGluc3RhbmNlIHRvIHNldCB0aGUgZ2VvbWV0cnkgSUQgb2YuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUlkIC0gVGhlIGdlb21ldHJ5IElEIHRvIGJlIHVzZSBieSB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0JhdGNoZWRNZXNofSBBIHJlZmVyZW5jZSB0byB0aGlzIGJhdGNoZWQgbWVzaC5cblx0ICovXG5cdHNldEdlb21ldHJ5SWRBdCggaW5zdGFuY2VJZCwgZ2VvbWV0cnlJZCApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cdFx0dGhpcy52YWxpZGF0ZUdlb21ldHJ5SWQoIGdlb21ldHJ5SWQgKTtcblxuXHRcdHRoaXMuX2luc3RhbmNlSW5mb1sgaW5zdGFuY2VJZCBdLmdlb21ldHJ5SW5kZXggPSBnZW9tZXRyeUlkO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBnZW9tZXRyeSBJRCBvZiB0aGUgZGVmaW5lZCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluc3RhbmNlSWQgLSBUaGUgSUQgb2YgYW4gaW5zdGFuY2UgdG8gZ2V0IHRoZSBnZW9tZXRyeSBJRCBvZi5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5zdGFuY2UncyBnZW9tZXRyeSBJRC5cblx0ICovXG5cdGdldEdlb21ldHJ5SWRBdCggaW5zdGFuY2VJZCApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVJbnN0YW5jZUlkKCBpbnN0YW5jZUlkICk7XG5cblx0XHRyZXR1cm4gdGhpcy5faW5zdGFuY2VJbmZvWyBpbnN0YW5jZUlkIF0uZ2VvbWV0cnlJbmRleDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcmFuZ2UgcmVwcmVzZW50aW5nIHRoZSBzdWJzZXQgb2YgdHJpYW5nbGVzIHJlbGF0ZWQgdG8gdGhlIGF0dGFjaGVkIGdlb21ldHJ5LFxuXHQgKiBpbmRpY2F0aW5nIHRoZSBzdGFydGluZyBvZmZzZXQgYW5kIGNvdW50LCBvciBgbnVsbGAgaWYgaW52YWxpZC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SWQgLSBUaGUgaWQgb2YgdGhlIGdlb21ldHJ5IHRvIGdldCB0aGUgcmFuZ2Ugb2YuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSAtIFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHt7XG5cdCAqIFx0dmVydGV4U3RhcnQ6bnVtYmVyLHZlcnRleENvdW50Om51bWJlcixyZXNlcnZlZFZlcnRleENvdW50Om51bWJlcixcblx0ICogXHRpbmRleFN0YXJ0Om51bWJlcixpbmRleENvdW50Om51bWJlcixyZXNlcnZlZEluZGV4Q291bnQ6bnVtYmVyLFxuXHQgKiBcdHN0YXJ0Om51bWJlcixjb3VudDpudW1iZXJcblx0ICogfX0gVGhlIHJlc3VsdCBvYmplY3Qgd2l0aCByYW5nZSBkYXRhLlxuXHQgKi9cblx0Z2V0R2VvbWV0cnlSYW5nZUF0KCBnZW9tZXRyeUlkLCB0YXJnZXQgPSB7fSApIHtcblxuXHRcdHRoaXMudmFsaWRhdGVHZW9tZXRyeUlkKCBnZW9tZXRyeUlkICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSB0aGlzLl9nZW9tZXRyeUluZm9bIGdlb21ldHJ5SWQgXTtcblx0XHR0YXJnZXQudmVydGV4U3RhcnQgPSBnZW9tZXRyeUluZm8udmVydGV4U3RhcnQ7XG5cdFx0dGFyZ2V0LnZlcnRleENvdW50ID0gZ2VvbWV0cnlJbmZvLnZlcnRleENvdW50O1xuXHRcdHRhcmdldC5yZXNlcnZlZFZlcnRleENvdW50ID0gZ2VvbWV0cnlJbmZvLnJlc2VydmVkVmVydGV4Q291bnQ7XG5cblx0XHR0YXJnZXQuaW5kZXhTdGFydCA9IGdlb21ldHJ5SW5mby5pbmRleFN0YXJ0O1xuXHRcdHRhcmdldC5pbmRleENvdW50ID0gZ2VvbWV0cnlJbmZvLmluZGV4Q291bnQ7XG5cdFx0dGFyZ2V0LnJlc2VydmVkSW5kZXhDb3VudCA9IGdlb21ldHJ5SW5mby5yZXNlcnZlZEluZGV4Q291bnQ7XG5cblx0XHR0YXJnZXQuc3RhcnQgPSBnZW9tZXRyeUluZm8uc3RhcnQ7XG5cdFx0dGFyZ2V0LmNvdW50ID0gZ2VvbWV0cnlJbmZvLmNvdW50O1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2l6ZXMgdGhlIG5lY2Vzc2FyeSBidWZmZXJzIHRvIHN1cHBvcnQgdGhlIHByb3ZpZGVkIG51bWJlciBvZiBpbnN0YW5jZXMuXG5cdCAqIElmIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgc2hyaW5rIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIGJ1dCB0aGVyZSBhcmUgbm90IGVub3VnaFxuXHQgKiB1bnVzZWQgSWRzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgdGhlbiBhbiBlcnJvciBpcyB0aHJvd24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJbnN0YW5jZUNvdW50IC0gVGhlIG1heCBudW1iZXIgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgYWRkZWQgYW5kIHJlbmRlcmVkIGJ5IHRoZSBiYXRjaC5cblx0Ki9cblx0c2V0SW5zdGFuY2VDb3VudCggbWF4SW5zdGFuY2VDb3VudCApIHtcblxuXHRcdC8vIHNocmluayB0aGUgYXZhaWxhYmxlIGluc3RhbmNlcyBhcyBtdWNoIGFzIHBvc3NpYmxlXG5cdFx0Y29uc3QgYXZhaWxhYmxlSW5zdGFuY2VJZHMgPSB0aGlzLl9hdmFpbGFibGVJbnN0YW5jZUlkcztcblx0XHRjb25zdCBpbnN0YW5jZUluZm8gPSB0aGlzLl9pbnN0YW5jZUluZm87XG5cdFx0YXZhaWxhYmxlSW5zdGFuY2VJZHMuc29ydCggYXNjSWRTb3J0ICk7XG5cdFx0d2hpbGUgKCBhdmFpbGFibGVJbnN0YW5jZUlkc1sgYXZhaWxhYmxlSW5zdGFuY2VJZHMubGVuZ3RoIC0gMSBdID09PSBpbnN0YW5jZUluZm8ubGVuZ3RoICkge1xuXG5cdFx0XHRpbnN0YW5jZUluZm8ucG9wKCk7XG5cdFx0XHRhdmFpbGFibGVJbnN0YW5jZUlkcy5wb3AoKTtcblxuXHRcdH1cblxuXHRcdC8vIHRocm93IGFuIGVycm9yIGlmIGl0IGNhbid0IGJlIHNocnVuayB0byB0aGUgZGVzaXJlZCBzaXplXG5cdFx0aWYgKCBtYXhJbnN0YW5jZUNvdW50IDwgaW5zdGFuY2VJbmZvLmxlbmd0aCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgQmF0Y2hlZE1lc2g6IEluc3RhbmNlIGlkcyBvdXRzaWRlIHRoZSByYW5nZSAkeyBtYXhJbnN0YW5jZUNvdW50IH0gYXJlIGJlaW5nIHVzZWQuIENhbm5vdCBzaHJpbmsgaW5zdGFuY2UgY291bnQuYCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29weSB0aGUgbXVsdGkgZHJhdyBjb3VudHNcblx0XHRjb25zdCBtdWx0aURyYXdDb3VudHMgPSBuZXcgSW50MzJBcnJheSggbWF4SW5zdGFuY2VDb3VudCApO1xuXHRcdGNvbnN0IG11bHRpRHJhd1N0YXJ0cyA9IG5ldyBJbnQzMkFycmF5KCBtYXhJbnN0YW5jZUNvdW50ICk7XG5cdFx0Y29weUFycmF5Q29udGVudHMoIHRoaXMuX211bHRpRHJhd0NvdW50cywgbXVsdGlEcmF3Q291bnRzICk7XG5cdFx0Y29weUFycmF5Q29udGVudHMoIHRoaXMuX211bHRpRHJhd1N0YXJ0cywgbXVsdGlEcmF3U3RhcnRzICk7XG5cblx0XHR0aGlzLl9tdWx0aURyYXdDb3VudHMgPSBtdWx0aURyYXdDb3VudHM7XG5cdFx0dGhpcy5fbXVsdGlEcmF3U3RhcnRzID0gbXVsdGlEcmF3U3RhcnRzO1xuXHRcdHRoaXMuX21heEluc3RhbmNlQ291bnQgPSBtYXhJbnN0YW5jZUNvdW50O1xuXG5cdFx0Ly8gdXBkYXRlIHRleHR1cmUgZGF0YSBmb3IgaW5zdGFuY2Ugc2FtcGxpbmdcblx0XHRjb25zdCBpbmRpcmVjdFRleHR1cmUgPSB0aGlzLl9pbmRpcmVjdFRleHR1cmU7XG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlO1xuXHRcdGNvbnN0IGNvbG9yc1RleHR1cmUgPSB0aGlzLl9jb2xvcnNUZXh0dXJlO1xuXG5cdFx0aW5kaXJlY3RUZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9pbml0SW5kaXJlY3RUZXh0dXJlKCk7XG5cdFx0Y29weUFycmF5Q29udGVudHMoIGluZGlyZWN0VGV4dHVyZS5pbWFnZS5kYXRhLCB0aGlzLl9pbmRpcmVjdFRleHR1cmUuaW1hZ2UuZGF0YSApO1xuXG5cdFx0bWF0cmljZXNUZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9pbml0TWF0cmljZXNUZXh0dXJlKCk7XG5cdFx0Y29weUFycmF5Q29udGVudHMoIG1hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhLCB0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YSApO1xuXG5cdFx0aWYgKCBjb2xvcnNUZXh0dXJlICkge1xuXG5cdFx0XHRjb2xvcnNUZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX2luaXRDb2xvcnNUZXh0dXJlKCk7XG5cdFx0XHRjb3B5QXJyYXlDb250ZW50cyggY29sb3JzVGV4dHVyZS5pbWFnZS5kYXRhLCB0aGlzLl9jb2xvcnNUZXh0dXJlLmltYWdlLmRhdGEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2l6ZXMgdGhlIGF2YWlsYWJsZSBzcGFjZSBpbiB0aGUgYmF0Y2gncyB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlciBhdHRyaWJ1dGVzIHRvIHRoZSBwcm92aWRlZCBzaXplcy5cblx0ICogSWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBzaHJpbmsgdGhlIGdlb21ldHJ5IGJ1ZmZlcnMgYnV0IHRoZXJlIGlzIG5vdCBlbm91Z2ggdW51c2VkIHNwYWNlIGF0IHRoZVxuXHQgKiBlbmQgb2YgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZXMgdGhlbiBhbiBlcnJvciBpcyB0aHJvd24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWZXJ0ZXhDb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBiZSB1c2VkIGJ5IGFsbCB1bmlxdWUgZ2VvbWV0cmllcyB0byByZXNpemUgdG8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJbmRleENvdW50IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGluZGljZXMgdG8gYmUgdXNlZCBieSBhbGwgdW5pcXVlIGdlb21ldHJpZXMgdG8gcmVzaXplIHRvLlxuXHQqL1xuXHRzZXRHZW9tZXRyeVNpemUoIG1heFZlcnRleENvdW50LCBtYXhJbmRleENvdW50ICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgY2FuIHNocmluayB0byB0aGUgcmVxdWVzdGVkIHZlcnRleCBhdHRyaWJ1dGUgc2l6ZVxuXHRcdGNvbnN0IHZhbGlkUmFuZ2VzID0gWyAuLi50aGlzLl9nZW9tZXRyeUluZm8gXS5maWx0ZXIoIGluZm8gPT4gaW5mby5hY3RpdmUgKTtcblx0XHRjb25zdCByZXF1aXJlZFZlcnRleExlbmd0aCA9IE1hdGgubWF4KCAuLi52YWxpZFJhbmdlcy5tYXAoIHJhbmdlID0+IHJhbmdlLnZlcnRleFN0YXJ0ICsgcmFuZ2UucmVzZXJ2ZWRWZXJ0ZXhDb3VudCApICk7XG5cdFx0aWYgKCByZXF1aXJlZFZlcnRleExlbmd0aCA+IG1heFZlcnRleENvdW50ICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBCYXRjaGVkTWVzaDogR2VvbWV0cnkgdmVydGV4IHZhbHVlcyBhcmUgYmVpbmcgdXNlZCBvdXRzaWRlIHRoZSByYW5nZSAkeyBtYXhJbmRleENvdW50IH0uIENhbm5vdCBzaHJpbmsgZnVydGhlci5gICk7XG5cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBjYW4gc2hyaW5rIHRvIHRoZSByZXF1ZXN0ZWQgaW5kZXggYXR0cmlidXRlIHNpemVcblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IHJlcXVpcmVkSW5kZXhMZW5ndGggPSBNYXRoLm1heCggLi4udmFsaWRSYW5nZXMubWFwKCByYW5nZSA9PiByYW5nZS5pbmRleFN0YXJ0ICsgcmFuZ2UucmVzZXJ2ZWRJbmRleENvdW50ICkgKTtcblx0XHRcdGlmICggcmVxdWlyZWRJbmRleExlbmd0aCA+IG1heEluZGV4Q291bnQgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgQmF0Y2hlZE1lc2g6IEdlb21ldHJ5IGluZGV4IHZhbHVlcyBhcmUgYmVpbmcgdXNlZCBvdXRzaWRlIHRoZSByYW5nZSAkeyBtYXhJbmRleENvdW50IH0uIENhbm5vdCBzaHJpbmsgZnVydGhlci5gICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHQvLyBkaXNwb3NlIG9mIHRoZSBwcmV2aW91cyBnZW9tZXRyeVxuXHRcdGNvbnN0IG9sZEdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRvbGRHZW9tZXRyeS5kaXNwb3NlKCk7XG5cblx0XHQvLyByZWNyZWF0ZSB0aGUgZ2VvbWV0cnkgbmVlZGVkIGJhc2VkIG9uIHRoZSBwcmV2aW91cyB2YXJpYW50XG5cdFx0dGhpcy5fbWF4VmVydGV4Q291bnQgPSBtYXhWZXJ0ZXhDb3VudDtcblx0XHR0aGlzLl9tYXhJbmRleENvdW50ID0gbWF4SW5kZXhDb3VudDtcblxuXHRcdGlmICggdGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCApIHtcblxuXHRcdFx0dGhpcy5fZ2VvbWV0cnlJbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dGhpcy5faW5pdGlhbGl6ZUdlb21ldHJ5KCBvbGRHZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29weSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIGdlb21ldHJ5XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGlmICggb2xkR2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdGNvcHlBcnJheUNvbnRlbnRzKCBvbGRHZW9tZXRyeS5pbmRleC5hcnJheSwgZ2VvbWV0cnkuaW5kZXguYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBvbGRHZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb3B5QXJyYXlDb250ZW50cyggb2xkR2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0uYXJyYXksIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdLmFycmF5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IGluc3RhbmNlSW5mbyA9IHRoaXMuX2luc3RhbmNlSW5mbztcblx0XHRjb25zdCBnZW9tZXRyeUluZm9MaXN0ID0gdGhpcy5fZ2VvbWV0cnlJbmZvO1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCBiYXRjaEdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5XG5cdFx0X21lc2gubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdF9tZXNoLmdlb21ldHJ5LmluZGV4ID0gYmF0Y2hHZW9tZXRyeS5pbmRleDtcblx0XHRfbWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzID0gYmF0Y2hHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGlmICggX21lc2guZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdGlmICggX21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VJbmZvLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggISBpbnN0YW5jZUluZm9bIGkgXS52aXNpYmxlIHx8ICEgaW5zdGFuY2VJbmZvWyBpIF0uYWN0aXZlICkge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5SWQgPSBpbnN0YW5jZUluZm9bIGkgXS5nZW9tZXRyeUluZGV4O1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gZ2VvbWV0cnlJbmZvTGlzdFsgZ2VvbWV0cnlJZCBdO1xuXHRcdFx0X21lc2guZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKCBnZW9tZXRyeUluZm8uc3RhcnQsIGdlb21ldHJ5SW5mby5jb3VudCApO1xuXG5cdFx0XHQvLyBnZXQgdGhlIGludGVyc2VjdHNcblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tZXNoLm1hdHJpeFdvcmxkICkucHJlbXVsdGlwbHkoIG1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94QXQoIGdlb21ldHJ5SWQsIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nU3BoZXJlQXQoIGdlb21ldHJ5SWQsIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRfbWVzaC5yYXljYXN0KCByYXljYXN0ZXIsIF9iYXRjaEludGVyc2VjdHMgKTtcblxuXHRcdFx0Ly8gYWRkIGJhdGNoIGlkIHRvIHRoZSBpbnRlcnNlY3RzXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGwgPSBfYmF0Y2hJbnRlcnNlY3RzLmxlbmd0aDsgaiA8IGw7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0ID0gX2JhdGNoSW50ZXJzZWN0c1sgaiBdO1xuXHRcdFx0XHRpbnRlcnNlY3Qub2JqZWN0ID0gdGhpcztcblx0XHRcdFx0aW50ZXJzZWN0LmJhdGNoSWQgPSBpO1xuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9iYXRjaEludGVyc2VjdHMubGVuZ3RoID0gMDtcblxuXHRcdH1cblxuXHRcdF9tZXNoLm1hdGVyaWFsID0gbnVsbDtcblx0XHRfbWVzaC5nZW9tZXRyeS5pbmRleCA9IG51bGw7XG5cdFx0X21lc2guZ2VvbWV0cnkuYXR0cmlidXRlcyA9IHt9O1xuXHRcdF9tZXNoLmdlb21ldHJ5LnNldERyYXdSYW5nZSggMCwgSW5maW5pdHkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5LmNsb25lKCk7XG5cdFx0dGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkID0gc291cmNlLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHNvdXJjZS5zb3J0T2JqZWN0cztcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94ICE9PSBudWxsID8gc291cmNlLmJvdW5kaW5nQm94LmNsb25lKCkgOiBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgPyBzb3VyY2UuYm91bmRpbmdTcGhlcmUuY2xvbmUoKSA6IG51bGw7XG5cblx0XHR0aGlzLl9nZW9tZXRyeUluZm8gPSBzb3VyY2UuX2dlb21ldHJ5SW5mby5tYXAoIGluZm8gPT4gKCB7XG5cdFx0XHQuLi5pbmZvLFxuXG5cdFx0XHRib3VuZGluZ0JveDogaW5mby5ib3VuZGluZ0JveCAhPT0gbnVsbCA/IGluZm8uYm91bmRpbmdCb3guY2xvbmUoKSA6IG51bGwsXG5cdFx0XHRib3VuZGluZ1NwaGVyZTogaW5mby5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCA/IGluZm8uYm91bmRpbmdTcGhlcmUuY2xvbmUoKSA6IG51bGwsXG5cdFx0fSApICk7XG5cdFx0dGhpcy5faW5zdGFuY2VJbmZvID0gc291cmNlLl9pbnN0YW5jZUluZm8ubWFwKCBpbmZvID0+ICggeyAuLi5pbmZvIH0gKSApO1xuXG5cdFx0dGhpcy5fYXZhaWxhYmxlSW5zdGFuY2VJZHMgPSBzb3VyY2UuX2F2YWlsYWJsZUluc3RhbmNlSWRzLnNsaWNlKCk7XG5cdFx0dGhpcy5fYXZhaWxhYmxlR2VvbWV0cnlJZHMgPSBzb3VyY2UuX2F2YWlsYWJsZUdlb21ldHJ5SWRzLnNsaWNlKCk7XG5cblx0XHR0aGlzLl9uZXh0SW5kZXhTdGFydCA9IHNvdXJjZS5fbmV4dEluZGV4U3RhcnQ7XG5cdFx0dGhpcy5fbmV4dFZlcnRleFN0YXJ0ID0gc291cmNlLl9uZXh0VmVydGV4U3RhcnQ7XG5cdFx0dGhpcy5fZ2VvbWV0cnlDb3VudCA9IHNvdXJjZS5fZ2VvbWV0cnlDb3VudDtcblxuXHRcdHRoaXMuX21heEluc3RhbmNlQ291bnQgPSBzb3VyY2UuX21heEluc3RhbmNlQ291bnQ7XG5cdFx0dGhpcy5fbWF4VmVydGV4Q291bnQgPSBzb3VyY2UuX21heFZlcnRleENvdW50O1xuXHRcdHRoaXMuX21heEluZGV4Q291bnQgPSBzb3VyY2UuX21heEluZGV4Q291bnQ7XG5cblx0XHR0aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkID0gc291cmNlLl9nZW9tZXRyeUluaXRpYWxpemVkO1xuXHRcdHRoaXMuX211bHRpRHJhd0NvdW50cyA9IHNvdXJjZS5fbXVsdGlEcmF3Q291bnRzLnNsaWNlKCk7XG5cdFx0dGhpcy5fbXVsdGlEcmF3U3RhcnRzID0gc291cmNlLl9tdWx0aURyYXdTdGFydHMuc2xpY2UoKTtcblxuXHRcdHRoaXMuX2luZGlyZWN0VGV4dHVyZSA9IHNvdXJjZS5faW5kaXJlY3RUZXh0dXJlLmNsb25lKCk7XG5cdFx0dGhpcy5faW5kaXJlY3RUZXh0dXJlLmltYWdlLmRhdGEgPSB0aGlzLl9pbmRpcmVjdFRleHR1cmUuaW1hZ2UuZGF0YS5zbGljZSgpO1xuXG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlID0gc291cmNlLl9tYXRyaWNlc1RleHR1cmUuY2xvbmUoKTtcblx0XHR0aGlzLl9tYXRyaWNlc1RleHR1cmUuaW1hZ2UuZGF0YSA9IHRoaXMuX21hdHJpY2VzVGV4dHVyZS5pbWFnZS5kYXRhLnNsaWNlKCk7XG5cblx0XHRpZiAoIHRoaXMuX2NvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2NvbG9yc1RleHR1cmUgPSBzb3VyY2UuX2NvbG9yc1RleHR1cmUuY2xvbmUoKTtcblx0XHRcdHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YSA9IHRoaXMuX2NvbG9yc1RleHR1cmUuaW1hZ2UuZGF0YS5zbGljZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0Ly8gQXNzdW1pbmcgdGhlIGdlb21ldHJ5IGlzIG5vdCBzaGFyZWQgd2l0aCBvdGhlciBtZXNoZXNcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdHRoaXMuX21hdHJpY2VzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fbWF0cmljZXNUZXh0dXJlID0gbnVsbDtcblxuXHRcdHRoaXMuX2luZGlyZWN0VGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5faW5kaXJlY3RUZXh0dXJlID0gbnVsbDtcblxuXHRcdGlmICggdGhpcy5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fY29sb3JzVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl9jb2xvcnNUZXh0dXJlID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0b25CZWZvcmVSZW5kZXIoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwvKiwgX2dyb3VwKi8gKSB7XG5cblx0XHQvLyBpZiB2aXNpYmlsaXR5IGhhcyBub3QgY2hhbmdlZCBhbmQgZnJ1c3R1bSBjdWxsaW5nIGFuZCBvYmplY3Qgc29ydGluZyBpcyBub3QgcmVxdWlyZWRcblx0XHQvLyB0aGVuIHNraXAgaXRlcmF0aW5nIG92ZXIgYWxsIGl0ZW1zXG5cdFx0aWYgKCAhIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkICYmICEgdGhpcy5wZXJPYmplY3RGcnVzdHVtQ3VsbGVkICYmICEgdGhpcy5zb3J0T2JqZWN0cyApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIGluZGV4ZWQgdmVyc2lvbiBvZiB0aGUgbXVsdGkgZHJhdyBmdW5jdGlvbiByZXF1aXJlcyBzcGVjaWZ5aW5nIHRoZSBzdGFydFxuXHRcdC8vIG9mZnNldCBpbiBieXRlcy5cblx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0Y29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gaW5kZXggPT09IG51bGwgPyAxIDogaW5kZXguYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHRjb25zdCBpbnN0YW5jZUluZm8gPSB0aGlzLl9pbnN0YW5jZUluZm87XG5cdFx0Y29uc3QgbXVsdGlEcmF3U3RhcnRzID0gdGhpcy5fbXVsdGlEcmF3U3RhcnRzO1xuXHRcdGNvbnN0IG11bHRpRHJhd0NvdW50cyA9IHRoaXMuX211bHRpRHJhd0NvdW50cztcblx0XHRjb25zdCBnZW9tZXRyeUluZm9MaXN0ID0gdGhpcy5fZ2VvbWV0cnlJbmZvO1xuXHRcdGNvbnN0IHBlck9iamVjdEZydXN0dW1DdWxsZWQgPSB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0Y29uc3QgaW5kaXJlY3RUZXh0dXJlID0gdGhpcy5faW5kaXJlY3RUZXh0dXJlO1xuXHRcdGNvbnN0IGluZGlyZWN0QXJyYXkgPSBpbmRpcmVjdFRleHR1cmUuaW1hZ2UuZGF0YTtcblxuXHRcdGNvbnN0IGZydXN0dW0gPSBjYW1lcmEuaXNBcnJheUNhbWVyYSA/IF9mcnVzdHVtQXJyYXkgOiBfZnJ1c3R1bTtcblx0XHQvLyBwcmVwYXJlIHRoZSBmcnVzdHVtIGluIHRoZSBsb2NhbCBmcmFtZVxuXHRcdGlmICggcGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCAmJiAhIGNhbWVyYS5pc0FycmF5Q2FtZXJhICkge1xuXG5cdFx0XHRfbWF0cml4XG5cdFx0XHRcdC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApXG5cdFx0XHRcdC5tdWx0aXBseSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoXG5cdFx0XHRcdF9tYXRyaXgsXG5cdFx0XHRcdHJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRsZXQgbXVsdGlEcmF3Q291bnQgPSAwO1xuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyApIHtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGxvY2FsIGZyYW1lXG5cdFx0XHRfbWF0cml4LmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRcdF92ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKS5hcHBseU1hdHJpeDQoIF9tYXRyaXggKTtcblx0XHRcdF9mb3J3YXJkLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIF9tYXRyaXggKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VJbmZvLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZUluZm9bIGkgXS52aXNpYmxlICYmIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5SWQgPSBpbnN0YW5jZUluZm9bIGkgXS5nZW9tZXRyeUluZGV4O1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBib3VuZHMgaW4gd29ybGQgc3BhY2Vcblx0XHRcdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfbWF0cml4ICk7XG5cdFx0XHRcdFx0dGhpcy5nZXRCb3VuZGluZ1NwaGVyZUF0KCBnZW9tZXRyeUlkLCBfc3BoZXJlICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4ICk7XG5cblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgYmF0Y2hlZCBnZW9tZXRyeSBpcyB3aXRoaW4gdGhlIGZydXN0dW1cblx0XHRcdFx0XHRsZXQgY3VsbGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCBwZXJPYmplY3RGcnVzdHVtQ3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHRjdWxsZWQgPSAhIGZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSwgY2FtZXJhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgY3VsbGVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gY2FtZXJhIHVzZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5SW5mbyA9IGdlb21ldHJ5SW5mb0xpc3RbIGdlb21ldHJ5SWQgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHogPSBfdGVtcC5zdWJWZWN0b3JzKCBfc3BoZXJlLmNlbnRlciwgX3ZlY3RvciApLmRvdCggX2ZvcndhcmQgKTtcblx0XHRcdFx0XHRcdF9yZW5kZXJMaXN0LnB1c2goIGdlb21ldHJ5SW5mby5zdGFydCwgZ2VvbWV0cnlJbmZvLmNvdW50LCB6LCBpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgdGhlIGRyYXcgcmFuZ2VzIGFuZCBwcmVwIGZvciByZW5kZXJpbmdcblx0XHRcdGNvbnN0IGxpc3QgPSBfcmVuZGVyTGlzdC5saXN0O1xuXHRcdFx0Y29uc3QgY3VzdG9tU29ydCA9IHRoaXMuY3VzdG9tU29ydDtcblx0XHRcdGlmICggY3VzdG9tU29ydCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRsaXN0LnNvcnQoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID8gc29ydFRyYW5zcGFyZW50IDogc29ydE9wYXF1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGN1c3RvbVNvcnQuY2FsbCggdGhpcywgbGlzdCwgY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGl0ZW0gPSBsaXN0WyBpIF07XG5cdFx0XHRcdG11bHRpRHJhd1N0YXJ0c1sgbXVsdGlEcmF3Q291bnQgXSA9IGl0ZW0uc3RhcnQgKiBieXRlc1BlckVsZW1lbnQ7XG5cdFx0XHRcdG11bHRpRHJhd0NvdW50c1sgbXVsdGlEcmF3Q291bnQgXSA9IGl0ZW0uY291bnQ7XG5cdFx0XHRcdGluZGlyZWN0QXJyYXlbIG11bHRpRHJhd0NvdW50IF0gPSBpdGVtLmluZGV4O1xuXHRcdFx0XHRtdWx0aURyYXdDb3VudCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRfcmVuZGVyTGlzdC5yZXNldCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VJbmZvLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZUluZm9bIGkgXS52aXNpYmxlICYmIGluc3RhbmNlSW5mb1sgaSBdLmFjdGl2ZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5SWQgPSBpbnN0YW5jZUluZm9bIGkgXS5nZW9tZXRyeUluZGV4O1xuXG5cdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJhdGNoZWQgZ2VvbWV0cnkgaXMgd2l0aGluIHRoZSBmcnVzdHVtXG5cdFx0XHRcdFx0bGV0IGN1bGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggcGVyT2JqZWN0RnJ1c3R1bUN1bGxlZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IHRoZSBib3VuZHMgaW4gd29ybGQgc3BhY2Vcblx0XHRcdFx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tYXRyaXggKTtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdTcGhlcmVBdCggZ2VvbWV0cnlJZCwgX3NwaGVyZSApLmFwcGx5TWF0cml4NCggX21hdHJpeCApO1xuXHRcdFx0XHRcdFx0Y3VsbGVkID0gISBmcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUsIGNhbWVyYSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIGN1bGxlZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0gZ2VvbWV0cnlJbmZvTGlzdFsgZ2VvbWV0cnlJZCBdO1xuXHRcdFx0XHRcdFx0bXVsdGlEcmF3U3RhcnRzWyBtdWx0aURyYXdDb3VudCBdID0gZ2VvbWV0cnlJbmZvLnN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50O1xuXHRcdFx0XHRcdFx0bXVsdGlEcmF3Q291bnRzWyBtdWx0aURyYXdDb3VudCBdID0gZ2VvbWV0cnlJbmZvLmNvdW50O1xuXHRcdFx0XHRcdFx0aW5kaXJlY3RBcnJheVsgbXVsdGlEcmF3Q291bnQgXSA9IGk7XG5cdFx0XHRcdFx0XHRtdWx0aURyYXdDb3VudCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGluZGlyZWN0VGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fbXVsdGlEcmF3Q291bnQgPSBtdWx0aURyYXdDb3VudDtcblx0XHR0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IGZhbHNlO1xuXG5cdH1cblxuXHRvbkJlZm9yZVNoYWRvdyggcmVuZGVyZXIsIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLyogLCBncm91cCAqLyApIHtcblxuXHRcdHRoaXMub25CZWZvcmVSZW5kZXIoIHJlbmRlcmVyLCBudWxsLCBzaGFkb3dDYW1lcmEsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJhdGNoZWRNZXNoIH07XG4iLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcblxuLyoqXG4gKiBBIG1hdGVyaWFsIGZvciByZW5kZXJpbmcgbGluZSBwcmltaXRpdmVzLlxuICpcbiAqIE1hdGVyaWFscyBkZWZpbmUgdGhlIGFwcGVhcmFuY2Ugb2YgcmVuZGVyYWJsZSAzRCBvYmplY3RzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYgfSApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE1hdGVyaWFsXG4gKi9cbmNsYXNzIExpbmVCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpbmUgYmFzaWMgbWF0ZXJpYWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBBbiBvYmplY3Qgd2l0aCBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzXG5cdCAqIGRlZmluaW5nIHRoZSBtYXRlcmlhbCdzIGFwcGVhcmFuY2UuIEFueSBwcm9wZXJ0eSBvZiB0aGUgbWF0ZXJpYWxcblx0ICogKGluY2x1ZGluZyBhbnkgcHJvcGVydHkgZnJvbSBpbmhlcml0ZWQgbWF0ZXJpYWxzKSBjYW4gYmUgcGFzc2VkXG5cdCAqIGluIGhlcmUuIENvbG9yIHZhbHVlcyBjYW4gYmUgcGFzc2VkIGFueSB0eXBlIG9mIHZhbHVlIGFjY2VwdGVkXG5cdCAqIGJ5IHtAbGluayBDb2xvciNzZXR9LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0xpbmVCYXNpY01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0XHQvKipcblx0XHQgKiBDb2xvciBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICogQGRlZmF1bHQgKDEsMSwxKVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgbGluZXMgdXNpbmcgZGF0YSBmcm9tIGEgdGV4dHVyZS4gVGhlIHRleHR1cmUgbWFwXG5cdFx0ICogY29sb3IgaXMgbW9kdWxhdGVkIGJ5IHRoZSBkaWZmdXNlIGBjb2xvcmAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIENvbnRyb2xzIGxpbmUgdGhpY2tuZXNzIG9yIGxpbmVzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uIFdlYkdMIGFuZCBXZWJHUFVcblx0XHQgKiBpZ25vcmUgdGhpcyBzZXR0aW5nIGFuZCBhbHdheXMgcmVuZGVyIGxpbmUgcHJpbWl0aXZlcyB3aXRoIGFcblx0XHQgKiB3aWR0aCBvZiBvbmUgcGl4ZWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGFwcGVhcmFuY2Ugb2YgbGluZSBlbmRzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdidXR0J3wncm91bmQnfCdzcXVhcmUnKX1cblx0XHQgKiBAZGVmYXVsdCAncm91bmQnXG5cdFx0ICovXG5cdFx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgYXBwZWFyYW5jZSBvZiBsaW5lIGpvaW50cy5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgU1ZHUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeygncm91bmQnfCdiZXZlbCd8J21pdGVyJyl9XG5cdFx0ICogQGRlZmF1bHQgJ3JvdW5kJ1xuXHRcdCAqL1xuXHRcdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgYWZmZWN0ZWQgYnkgZm9nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cdFx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG5cdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xuaW1wb3J0IHsgUmF5IH0gZnJvbSAnLi4vbWF0aC9SYXkuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcblxuY29uc3QgX3ZTdGFydCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92RW5kID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcblxuY29uc3QgX2ludGVyc2VjdFBvaW50T25SYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfaW50ZXJzZWN0UG9pbnRPblNlZ21lbnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8qKlxuICogQSBjb250aW51b3VzIGxpbmUuIFRoZSBsaW5lIGFyZSByZW5kZXJlZCBieSBjb25uZWN0aW5nIGNvbnNlY3V0aXZlXG4gKiB2ZXJ0aWNlcyB3aXRoIHN0cmFpZ2h0IGxpbmVzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMDAwZmYgfSApO1xuICpcbiAqIGNvbnN0IHBvaW50cyA9IFtdO1xuICogcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEwLCAwLCAwICkgKTtcbiAqIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMTAsIDAgKSApO1xuICogcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAxMCwgMCwgMCApICk7XG4gKlxuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcbiAqXG4gKiBjb25zdCBsaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBsaW5lICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBbZ2VvbWV0cnldIC0gVGhlIGxpbmUgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx8QXJyYXk8TWF0ZXJpYWw+fSBbbWF0ZXJpYWxdIC0gVGhlIGxpbmUgbWF0ZXJpYWwuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTGluZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGluZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtCdWZmZXJHZW9tZXRyeX1cblx0XHQgKi9cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGluZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtNYXRlcmlhbHxBcnJheTxNYXRlcmlhbD59XG5cdFx0ICogQGRlZmF1bHQgTGluZUJhc2ljTWF0ZXJpYWxcblx0XHQgKi9cblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHQvKipcblx0XHQgKiBBIGRpY3Rpb25hcnkgcmVwcmVzZW50aW5nIHRoZSBtb3JwaCB0YXJnZXRzIGluIHRoZSBnZW9tZXRyeS4gVGhlIGtleSBpcyB0aGVcblx0XHQgKiBtb3JwaCB0YXJnZXRzIG5hbWUsIHRoZSB2YWx1ZSBpdHMgYXR0cmlidXRlIGluZGV4LiBUaGlzIG1lbWJlciBpcyBgdW5kZWZpbmVkYFxuXHRcdCAqIGJ5IGRlZmF1bHQgYW5kIG9ubHkgc2V0IHdoZW4gbW9ycGggdGFyZ2V0cyBhcmUgZGV0ZWN0ZWQgaW4gdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsbnVtYmVyPnx1bmRlZmluZWR9XG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB1bmRlZmluZWQ7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB3ZWlnaHRzIHR5cGljYWxseSBpbiB0aGUgcmFuZ2UgYFswLDFdYCB0aGF0IHNwZWNpZnkgaG93IG11Y2ggb2YgdGhlIG1vcnBoXG5cdFx0ICogaXMgYXBwbGllZC4gVGhpcyBtZW1iZXIgaXMgYHVuZGVmaW5lZGAgYnkgZGVmYXVsdCBhbmQgb25seSBzZXQgd2hlbiBtb3JwaCB0YXJnZXRzIGFyZVxuXHRcdCAqIGRldGVjdGVkIGluIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBzb3VyY2UubWF0ZXJpYWwgKSA/IHNvdXJjZS5tYXRlcmlhbC5zbGljZSgpIDogc291cmNlLm1hdGVyaWFsO1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIGFuIGFycmF5IG9mIGRpc3RhbmNlIHZhbHVlcyB3aGljaCBhcmUgbmVjZXNzYXJ5IGZvciByZW5kZXJpbmcgZGFzaGVkIGxpbmVzLlxuXHQgKiBGb3IgZWFjaCB2ZXJ0ZXggaW4gdGhlIGdlb21ldHJ5LCB0aGUgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGN1bXVsYXRpdmUgbGVuZ3RoIGZyb20gdGhlXG5cdCAqIGN1cnJlbnQgcG9pbnQgdG8gdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtMaW5lfSBBIHJlZmVyZW5jZSB0byB0aGlzIGxpbmUuXG5cdCAqL1xuXHRjb21wdXRlTGluZURpc3RhbmNlcygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIHdlIGFzc3VtZSBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbGluZURpc3RhbmNlcyA9IFsgMCBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSAtIDEgKTtcblx0XHRcdFx0X3ZFbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcblxuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gPSBsaW5lRGlzdGFuY2VzWyBpIC0gMSBdO1xuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gKz0gX3ZTdGFydC5kaXN0YW5jZVRvKCBfdkVuZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBsaW5lRGlzdGFuY2VzLCAxICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmUuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIGEgY2FzdGVkIHJheSBhbmQgdGhpcyBsaW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1JheWNhc3Rlcn0gcmF5Y2FzdGVyIC0gVGhlIHJheWNhc3Rlci5cblx0ICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBpbnRlcnNlY3RzIC0gVGhlIHRhcmdldCBhcnJheSB0aGF0IGhvbGRzIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuXHQgKi9cblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLkxpbmUudGhyZXNob2xkO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXHRcdF9zcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4LmNvcHkoIG1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cblx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCBfcmF5LCBsb2NhbFRocmVzaG9sZFNxLCBhLCBiLCBpICk7XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3QgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuaXNMaW5lTG9vcCApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggZW5kIC0gMSApO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggc3RhcnQgKTtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCBfcmF5LCBsb2NhbFRocmVzaG9sZFNxLCBhLCBiLCBlbmQgLSAxICk7XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3QgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbiggcG9zaXRpb25BdHRyaWJ1dGUuY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgbCA9IGVuZCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0ID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgX3JheSwgbG9jYWxUaHJlc2hvbGRTcSwgaSwgaSArIDEsIGkgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIF9yYXksIGxvY2FsVGhyZXNob2xkU3EsIGVuZCAtIDEsIHN0YXJ0LCBlbmQgLSAxICk7XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3QgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWVzIG9mIHtAbGluayBMaW5lI21vcnBoVGFyZ2V0RGljdGlvbmFyeX0gYW5kIHtAbGluayBMaW5lI21vcnBoVGFyZ2V0SW5mbHVlbmNlc31cblx0ICogdG8gbWFrZSBzdXJlIGV4aXN0aW5nIG1vcnBoIHRhcmdldHMgY2FuIGluZmx1ZW5jZSB0aGlzIDNEIG9iamVjdC5cblx0ICovXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHRocmVzaG9sZFNxLCBhLCBiLCBpICkge1xuXG5cdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0X3ZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYSApO1xuXHRfdkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYiApO1xuXG5cdGNvbnN0IGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCBfdlN0YXJ0LCBfdkVuZCwgX2ludGVyc2VjdFBvaW50T25SYXksIF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudCApO1xuXG5cdGlmICggZGlzdFNxID4gdGhyZXNob2xkU3EgKSByZXR1cm47XG5cblx0X2ludGVyc2VjdFBvaW50T25SYXkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTsgLy8gTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggX2ludGVyc2VjdFBvaW50T25SYXkgKTtcblxuXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdHJldHVybiB7XG5cblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludE9uU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICksXG5cdFx0aW5kZXg6IGksXG5cdFx0ZmFjZTogbnVsbCxcblx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0YmFyeWNvb3JkOiBudWxsLFxuXHRcdG9iamVjdDogb2JqZWN0XG5cblx0fTtcblxufVxuXG5leHBvcnQgeyBMaW5lIH07XG4iLCJpbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi9MaW5lLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcblxuY29uc3QgX3N0YXJ0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2VuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBBIHNlcmllcyBvZiBsaW5lcyBkcmF3biBiZXR3ZWVuIHBhaXJzIG9mIHZlcnRpY2VzLlxuICpcbiAqIEBhdWdtZW50cyBMaW5lXG4gKi9cbmNsYXNzIExpbmVTZWdtZW50cyBleHRlbmRzIExpbmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpbmUgc2VnbWVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IFtnZW9tZXRyeV0gLSBUaGUgbGluZSBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtNYXRlcmlhbHxBcnJheTxNYXRlcmlhbD59IFttYXRlcmlhbF0gLSBUaGUgbGluZSBtYXRlcmlhbC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTGluZVNlZ21lbnRzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG5cdH1cblxuXHRjb21wdXRlTGluZURpc3RhbmNlcygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIHdlIGFzc3VtZSBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbGluZURpc3RhbmNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHRfc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcblx0XHRcdFx0X2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcblxuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gPSAoIGkgPT09IDAgKSA/IDAgOiBsaW5lRGlzdGFuY2VzWyBpIC0gMSBdO1xuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpICsgMSBdID0gbGluZURpc3RhbmNlc1sgaSBdICsgX3N0YXJ0LmRpc3RhbmNlVG8oIF9lbmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbGluZURpc3RhbmNlcywgMSApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaW5lU2VnbWVudHMgfTtcbiIsImltcG9ydCB7IExpbmUgfSBmcm9tICcuL0xpbmUuanMnO1xuXG4vKipcbiAqIEEgY29udGludW91cyBsaW5lLiBUaGlzIGlzIG5lYXJseSB0aGUgc2FtZSBhcyB7QGxpbmsgTGluZX0gdGhlIG9ubHkgZGlmZmVyZW5jZVxuICogaXMgdGhhdCB0aGUgbGFzdCB2ZXJ0ZXggaXMgY29ubmVjdGVkIHdpdGggdGhlIGZpcnN0IHZlcnRleCBpbiBvcmRlciB0byBjbG9zZVxuICogdGhlIGxpbmUgdG8gZm9ybSBhIGxvb3AuXG4gKlxuICogQGF1Z21lbnRzIExpbmVcbiAqL1xuY2xhc3MgTGluZUxvb3AgZXh0ZW5kcyBMaW5lIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaW5lIGxvb3AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IFtnZW9tZXRyeV0gLSBUaGUgbGluZSBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtNYXRlcmlhbHxBcnJheTxNYXRlcmlhbD59IFttYXRlcmlhbF0gLSBUaGUgbGluZSBtYXRlcmlhbC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTGluZUxvb3AgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVMb29wJztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTGluZUxvb3AgfTtcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuXG4vKipcbiAqIEEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyBwb2ludCBwcmltaXRpdmVzLlxuICpcbiAqIE1hdGVyaWFscyBkZWZpbmUgdGhlIGFwcGVhcmFuY2Ugb2YgcmVuZGVyYWJsZSAzRCBvYmplY3RzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICpcbiAqIGZvciAoIGxldCBpID0gMDsgaSA8IDEwMDAwOyBpICsrICkge1xuICogXHRjb25zdCB4ID0gVEhSRUUuTWF0aFV0aWxzLnJhbmRGbG9hdFNwcmVhZCggMjAwMCApO1xuICogXHRjb25zdCB5ID0gVEhSRUUuTWF0aFV0aWxzLnJhbmRGbG9hdFNwcmVhZCggMjAwMCApO1xuICogXHRjb25zdCB6ID0gVEhSRUUuTWF0aFV0aWxzLnJhbmRGbG9hdFNwcmVhZCggMjAwMCApO1xuICpcbiAqIFx0dmVydGljZXMucHVzaCggeCwgeSwgeiApO1xuICogfVxuICpcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gKiBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBjb2xvcjogMHg4ODg4ODggfSApO1xuICogY29uc3QgcG9pbnRzID0gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBzY2VuZS5hZGQoIHBvaW50cyApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE1hdGVyaWFsXG4gKi9cbmNsYXNzIFBvaW50c01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvaW50cyBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUG9pbnRzTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIENvbG9yIG9mIHRoZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBtYXAuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYW4gYWxwaGEgY2hhbm5lbCwgdHlwaWNhbGx5IGNvbWJpbmVkXG5cdFx0ICogd2l0aCB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yIHtAbGluayBNYXRlcmlhbCNhbHBoYVRlc3R9LiBUaGUgdGV4dHVyZSBtYXBcblx0XHQgKiBjb2xvciBpcyBtb2R1bGF0ZWQgYnkgdGhlIGRpZmZ1c2UgYGNvbG9yYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIG1hcCBpcyBhIGdyYXlzY2FsZSB0ZXh0dXJlIHRoYXQgY29udHJvbHMgdGhlIG9wYWNpdHkgYWNyb3NzIHRoZVxuXHRcdCAqIHN1cmZhY2UgKGJsYWNrOiBmdWxseSB0cmFuc3BhcmVudDsgd2hpdGU6IGZ1bGx5IG9wYXF1ZSkuXG5cdFx0ICpcblx0XHQgKiBPbmx5IHRoZSBjb2xvciBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkLCBpZ25vcmluZyB0aGUgYWxwaGEgY2hhbm5lbCBpZiBvbmVcblx0XHQgKiBleGlzdHMuIEZvciBSR0IgYW5kIFJHQkEgdGV4dHVyZXMsIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgZ3JlZW4gY2hhbm5lbFxuXHRcdCAqIHdoZW4gc2FtcGxpbmcgdGhpcyB0ZXh0dXJlIGR1ZSB0byB0aGUgZXh0cmEgYml0IG9mIHByZWNpc2lvbiBwcm92aWRlZCBmb3Jcblx0XHQgKiBncmVlbiBpbiBEWFQtY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIFJHQiA1NjUgZm9ybWF0cy4gTHVtaW5hbmNlLW9ubHkgYW5kXG5cdFx0ICogbHVtaW5hbmNlL2FscGhhIHRleHR1cmVzIHdpbGwgYWxzbyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIHNpemUgb2YgdGhlIHBvaW50cyBpbiBwaXhlbHMuXG5cdFx0ICpcblx0XHQgKiBNaWdodCBiZSBjYXBwZWQgaWYgdGhlIHZhbHVlIGV4Y2VlZHMgaGFyZHdhcmUgZGVwZW5kZW50IHBhcmFtZXRlcnMgbGlrZSBbZ2wuQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xSZW5kZXJpbmdDb250ZXh0L2dldFBhcmFtZXRlfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuc2l6ZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgd2hldGhlciBzaXplIG9mIGluZGl2aWR1YWwgcG9pbnRzIGlzIGF0dGVudWF0ZWQgYnkgdGhlIGNhbWVyYSBkZXB0aCAocGVyc3BlY3RpdmUgY2FtZXJhIG9ubHkpLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGFmZmVjdGVkIGJ5IGZvZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBQb2ludHNNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xuaW1wb3J0IHsgUmF5IH0gZnJvbSAnLi4vbWF0aC9SYXkuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBQb2ludHNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9Qb2ludHNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9yYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcbmNvbnN0IF9wb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBkaXNwbGF5aW5nIHBvaW50cyBvciBwb2ludCBjbG91ZHMuXG4gKlxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIFBvaW50cyBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwb2ludCBjbG91ZC5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gW2dlb21ldHJ5XSAtIFRoZSBwb2ludHMgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx8QXJyYXk8TWF0ZXJpYWw+fSBbbWF0ZXJpYWxdIC0gVGhlIHBvaW50cyBtYXRlcmlhbC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNQb2ludHMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50cyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcG9pbnRzIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0J1ZmZlckdlb21ldHJ5fVxuXHRcdCAqL1xuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaW5lIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge01hdGVyaWFsfEFycmF5PE1hdGVyaWFsPn1cblx0XHQgKiBAZGVmYXVsdCBQb2ludHNNYXRlcmlhbFxuXHRcdCAqL1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZGljdGlvbmFyeSByZXByZXNlbnRpbmcgdGhlIG1vcnBoIHRhcmdldHMgaW4gdGhlIGdlb21ldHJ5LiBUaGUga2V5IGlzIHRoZVxuXHRcdCAqIG1vcnBoIHRhcmdldHMgbmFtZSwgdGhlIHZhbHVlIGl0cyBhdHRyaWJ1dGUgaW5kZXguIFRoaXMgbWVtYmVyIGlzIGB1bmRlZmluZWRgXG5cdFx0ICogYnkgZGVmYXVsdCBhbmQgb25seSBzZXQgd2hlbiBtb3JwaCB0YXJnZXRzIGFyZSBkZXRlY3RlZCBpbiB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0PFN0cmluZyxudW1iZXI+fHVuZGVmaW5lZH1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHdlaWdodHMgdHlwaWNhbGx5IGluIHRoZSByYW5nZSBgWzAsMV1gIHRoYXQgc3BlY2lmeSBob3cgbXVjaCBvZiB0aGUgbW9ycGhcblx0XHQgKiBpcyBhcHBsaWVkLiBUaGlzIG1lbWJlciBpcyBgdW5kZWZpbmVkYCBieSBkZWZhdWx0IGFuZCBvbmx5IHNldCB3aGVuIG1vcnBoIHRhcmdldHMgYXJlXG5cdFx0ICogZGV0ZWN0ZWQgaW4gdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuXHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gdW5kZWZpbmVkO1xuXG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIHNvdXJjZS5tYXRlcmlhbCApID8gc291cmNlLm1hdGVyaWFsLnNsaWNlKCkgOiBzb3VyY2UubWF0ZXJpYWw7XG5cdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIGEgY2FzdGVkIHJheSBhbmQgdGhpcyBwb2ludCBjbG91ZC5cblx0ICpcblx0ICogQHBhcmFtIHtSYXljYXN0ZXJ9IHJheWNhc3RlciAtIFRoZSByYXljYXN0ZXIuXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gaW50ZXJzZWN0cyAtIFRoZSB0YXJnZXQgYXJyYXkgdGhhdCBob2xkcyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cblx0ICovXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0Y29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMudGhyZXNob2xkO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXHRcdF9zcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly9cblxuXHRcdF9pbnZlcnNlTWF0cml4LmNvcHkoIG1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoIGkgKTtcblxuXHRcdFx0XHRfcG9zaXRpb24uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGEgKTtcblxuXHRcdFx0XHR0ZXN0UG9pbnQoIF9wb3NpdGlvbiwgYSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRfcG9zaXRpb24uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcblxuXHRcdFx0XHR0ZXN0UG9pbnQoIF9wb3NpdGlvbiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZXMgb2Yge0BsaW5rIFBvaW50cyNtb3JwaFRhcmdldERpY3Rpb25hcnl9IGFuZCB7QGxpbmsgUG9pbnRzI21vcnBoVGFyZ2V0SW5mbHVlbmNlc31cblx0ICogdG8gbWFrZSBzdXJlIGV4aXN0aW5nIG1vcnBoIHRhcmdldHMgY2FuIGluZmx1ZW5jZSB0aGlzIDNEIG9iamVjdC5cblx0ICovXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xuXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXgsIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIG9iamVjdCApIHtcblxuXHRjb25zdCByYXlQb2ludERpc3RhbmNlU3EgPSBfcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xuXG5cdGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcblxuXHRcdGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdF9yYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGludGVyc2VjdFBvaW50ICk7XG5cdFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuXHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuXHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LFxuXHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdGJhcnljb29yZDogbnVsbCxcblx0XHRcdG9iamVjdDogb2JqZWN0XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFBvaW50cyB9O1xuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xuXG4vKipcbiAqIEEgdGV4dHVyZSBmb3IgdXNlIHdpdGggYSB2aWRlby5cbiAqXG4gKiBgYGBqc1xuICogLy8gYXNzdW1pbmcgeW91IGhhdmUgY3JlYXRlZCBhIEhUTUwgdmlkZW8gZWxlbWVudCB3aXRoIGlkPVwidmlkZW9cIlxuICogY29uc3QgdmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggJ3ZpZGVvJyApO1xuICogY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5WaWRlb1RleHR1cmUoIHZpZGVvICk7XG4gKiBgYGBcbiAqXG4gKiBOb3RlOiBBZnRlciB0aGUgaW5pdGlhbCB1c2Ugb2YgYSB0ZXh0dXJlLCBpdHMgZGltZW5zaW9ucywgZm9ybWF0LCBhbmQgdHlwZVxuICogY2Fubm90IGJlIGNoYW5nZWQuIEluc3RlYWQsIGNhbGwge0BsaW5rIFRleHR1cmUjZGlzcG9zZX0gb24gdGhlIHRleHR1cmUgYW5kIGluc3RhbnRpYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBWaWRlb1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyB2aWRlbyB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvIC0gVGhlIHZpZGVvIGVsZW1lbnQgdG8gdXNlIGFzIGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hcHBpbmc9VGV4dHVyZS5ERUZBVUxUX01BUFBJTkddIC0gVGhlIHRleHR1cmUgbWFwcGluZy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwUyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwVD1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwVCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYWdGaWx0ZXI9TGluZWFyRmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21pbkZpbHRlcj1MaW5lYXJGaWx0ZXJdIC0gVGhlIG1pbiBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9ybWF0PVJHQkFGb3JtYXRdIC0gVGhlIHRleHR1cmUgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R5cGU9VW5zaWduZWRCeXRlVHlwZV0gLSBUaGUgdGV4dHVyZSB0eXBlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FuaXNvdHJvcHk9VGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUFldIC0gVGhlIGFuaXNvdHJvcHkgdmFsdWUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyID0gTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRcdHN1cGVyKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzVmlkZW9UZXh0dXJlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gZ2VuZXJhdGUgbWlwbWFwcyAoaWYgcG9zc2libGUpIGZvciBhIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvKCkge1xuXG5cdFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR2aWRlby5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKCB1cGRhdGVWaWRlbyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8gKSB7XG5cblx0XHRcdHZpZGVvLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soIHVwZGF0ZVZpZGVvICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmltYWdlICkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHJlbmRlcmVyIGFuZCBzZXRzIHtAbGluayBUZXh0dXJlI25lZWRzVXBkYXRlfVxuXHQgKiB0byBgdHJ1ZWAgZXZlcnkgdGltZSBhIG5ldyBmcmFtZSBpcyBhdmFpbGFibGUuXG5cdCAqXG5cdCAqIE9ubHkgcmVsZXZhbnQgaWYgYHJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIuXG5cdCAqL1xuXHR1cGRhdGUoKSB7XG5cblx0XHRjb25zdCB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cdFx0Y29uc3QgaGFzVmlkZW9GcmFtZUNhbGxiYWNrID0gJ3JlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2snIGluIHZpZGVvO1xuXG5cdFx0aWYgKCBoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPT09IGZhbHNlICYmIHZpZGVvLnJlYWR5U3RhdGUgPj0gdmlkZW8uSEFWRV9DVVJSRU5UX0RBVEEgKSB7XG5cblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBWaWRlb1RleHR1cmUgfTtcbiIsImltcG9ydCB7IFZpZGVvVGV4dHVyZSB9IGZyb20gJy4vVmlkZW9UZXh0dXJlLmpzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHdheSB0byBkZWZpbmUgdmlkZW8gZGF0YS4gSW5zdGVhZCBvZiB1c2luZ1xuICogYW4gaW5zdGFuY2Ugb2YgYEhUTUxWaWRlb0VsZW1lbnRgIGxpa2Ugd2l0aCBgVmlkZW9UZXh0dXJlYCwgYFZpZGVvRnJhbWVUZXh0dXJlYCBleHBlY3RzIGVhY2ggZnJhbWUgaXNcbiAqIGRlZmluZWQgbWFudWFsbHkgdmlhIHtAbGluayBWaWRlb0ZyYW1lVGV4dHVyZSNzZXRGcmFtZX0uIEEgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhpcyBtb2R1bGUgaXMgd2hlblxuICogdmlkZW8gZnJhbWVzIGFyZSBkZWNvZGVkIHdpdGggdGhlIFdlYkNvZGVjcyBBUEkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuVmlkZW9GcmFtZVRleHR1cmUoKTtcbiAqIHRleHR1cmUuc2V0RnJhbWUoIGZyYW1lICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgVmlkZW9UZXh0dXJlXG4gKi9cbmNsYXNzIFZpZGVvRnJhbWVUZXh0dXJlIGV4dGVuZHMgVmlkZW9UZXh0dXJlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyB2aWRlbyBmcmFtZSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hcHBpbmc9VGV4dHVyZS5ERUZBVUxUX01BUFBJTkddIC0gVGhlIHRleHR1cmUgbWFwcGluZy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwUyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwVD1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwVCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYWdGaWx0ZXI9TGluZWFyRmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21pbkZpbHRlcj1MaW5lYXJGaWx0ZXJdIC0gVGhlIG1pbiBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9ybWF0PVJHQkFGb3JtYXRdIC0gVGhlIHRleHR1cmUgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R5cGU9VW5zaWduZWRCeXRlVHlwZV0gLSBUaGUgdGV4dHVyZSB0eXBlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FuaXNvdHJvcHk9VGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUFldIC0gVGhlIGFuaXNvdHJvcHkgdmFsdWUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0c3VwZXIoIHt9LCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNWaWRlb0ZyYW1lVGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBvdmVyd3JpdHRlbiB3aXRoIGFuIGVtcHR5IGltcGxlbWVudGF0aW9uIHNpbmNlXG5cdCAqIHRoaXMgdHlwZSBvZiB0ZXh0dXJlIGlzIHVwZGF0ZWQgdmlhIGBzZXRGcmFtZSgpYC5cblx0ICovXG5cdHVwZGF0ZSgpIHt9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7IC8vIHJlc3RvcmluZyBUZXh0dXJlLmNsb25lKClcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIHZpZGVvLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIHRleHR1cmVcblx0ICogc28gdGhlIGRhdGEgY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cblx0ICpcblx0ICogQHBhcmFtIHtWaWRlb0ZyYW1lfSBmcmFtZSAtIFRoZSB2aWRlbyBmcmFtZS5cblx0ICovXG5cdHNldEZyYW1lKCBmcmFtZSApIHtcblxuXHRcdHRoaXMuaW1hZ2UgPSBmcmFtZTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgVmlkZW9GcmFtZVRleHR1cmUgfTtcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjYW4gb25seSBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSgpYCBtZXRob2RzXG4gKiBvZiByZW5kZXJlcnMuIEl0IGV4dHJhY3RzIHRoZSBjb250ZW50cyBvZiB0aGUgY3VycmVudCBib3VuZCBmcmFtZWJ1ZmZlciBhbmQgcHJvdmlkZXMgaXRcbiAqIGFzIGEgdGV4dHVyZSBmb3IgZnVydGhlciB1c2FnZS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICogY29uc3QgdGV4dHVyZVNpemUgPSAxMjggKiBwaXhlbFJhdGlvO1xuICpcbiAqIGNvbnN0IGZyYW1lVGV4dHVyZSA9IG5ldyBGcmFtZWJ1ZmZlclRleHR1cmUoIHRleHR1cmVTaXplLCB0ZXh0dXJlU2l6ZSApO1xuICpcbiAqIC8vIGNhbGN1bGF0ZSBzdGFydCBwb3NpdGlvbiBmb3IgY29weWluZyBwYXJ0IG9mIHRoZSBmcmFtZSBkYXRhXG4gKiBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xuICogdmVjdG9yLnggPSAoIHdpbmRvdy5pbm5lcldpZHRoICogcGl4ZWxSYXRpbyAvIDIgKSAtICggdGV4dHVyZVNpemUgLyAyICk7XG4gKiB2ZWN0b3IueSA9ICggd2luZG93LmlubmVySGVpZ2h0ICogcGl4ZWxSYXRpbyAvIDIgKSAtICggdGV4dHVyZVNpemUgLyAyICk7XG4gKlxuICogcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG4gKlxuICogLy8gY29weSBwYXJ0IG9mIHRoZSByZW5kZXJlZCBmcmFtZSBpbnRvIHRoZSBmcmFtZWJ1ZmZlciB0ZXh0dXJlXG4gKiByZW5kZXJlci5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIGZyYW1lVGV4dHVyZSwgdmVjdG9yICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBGcmFtZWJ1ZmZlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmcmFtZWJ1ZmZlciB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRzdXBlciggeyB3aWR0aCwgaGVpZ2h0IH0gKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNGcmFtZWJ1ZmZlclRleHR1cmUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IHRoZSB0ZXh0dXJlIGlzIHNhbXBsZWQgd2hlbiBhIHRleGVsIGNvdmVycyBtb3JlIHRoYW4gb25lIHBpeGVsLlxuXHRcdCAqXG5cdFx0ICogT3ZlcndyaXR0ZW4gYW5kIHNldCB0byBgTmVhcmVzdEZpbHRlcmAgYnkgZGVmYXVsdCB0byBkaXNhYmxlIGZpbHRlcmluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoTmVhcmVzdEZpbHRlcnxOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcnxOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyfExpbmVhckZpbHRlcnxMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyfExpbmVhck1pcG1hcExpbmVhckZpbHRlcil9XG5cdFx0ICogQGRlZmF1bHQgTmVhcmVzdEZpbHRlclxuXHRcdCAqL1xuXHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0aGUgdGV4dHVyZSBpcyBzYW1wbGVkIHdoZW4gYSB0ZXhlbCBjb3ZlcnMgbGVzcyB0aGFuIG9uZSBwaXhlbC5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYE5lYXJlc3RGaWx0ZXJgIGJ5IGRlZmF1bHQgdG8gZGlzYWJsZSBmaWx0ZXJpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXJ8TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcnxMaW5lYXJGaWx0ZXJ8TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcnxMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIpfVxuXHRcdCAqIEBkZWZhdWx0IE5lYXJlc3RGaWx0ZXJcblx0XHQgKi9cblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIGdlbmVyYXRlIG1pcG1hcHMgKGlmIHBvc3NpYmxlKSBmb3IgYSB0ZXh0dXJlLlxuXHRcdCAqXG5cdFx0ICogT3ZlcndyaXR0ZW4gYW5kIHNldCB0byBgZmFsc2VgIGJ5IGRlZmF1bHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRnJhbWVidWZmZXJUZXh0dXJlIH07XG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9UZXh0dXJlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGV4dHVyZSBiYXNlZCBvbiBkYXRhIGluIGNvbXByZXNzZWQgZm9ybS5cbiAqXG4gKiBUaGVzZSB0ZXh0dXJlIGFyZSB1c3VhbGx5IGxvYWRlZCB3aXRoIHtAbGluayBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcn0uXG4gKlxuICogQGF1Z21lbnRzIFRleHR1cmVcbiAqL1xuY2xhc3MgQ29tcHJlc3NlZFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb21wcmVzc2VkIHRleHR1cmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gbWlwbWFwcyAtIFRoaXMgYXJyYXkgaG9sZHMgZm9yIGFsbCBtaXBtYXBzIChpbmNsdWRpbmcgdGhlIGJhc2VzIG1pcClcblx0ICogdGhlIGRhdGEgYW5kIGRpbWVuc2lvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9ybWF0PVJHQkFGb3JtYXRdIC0gVGhlIHRleHR1cmUgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R5cGU9VW5zaWduZWRCeXRlVHlwZV0gLSBUaGUgdGV4dHVyZSB0eXBlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hcHBpbmc9VGV4dHVyZS5ERUZBVUxUX01BUFBJTkddIC0gVGhlIHRleHR1cmUgbWFwcGluZy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwUyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwVD1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwVCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYWdGaWx0ZXI9TGluZWFyRmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21pbkZpbHRlcj1MaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJdIC0gVGhlIG1pbiBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYW5pc290cm9weT1UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWV0gLSBUaGUgYW5pc290cm9weSB2YWx1ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvclNwYWNlPU5vQ29sb3JTcGFjZV0gLSBUaGUgY29sb3Igc3BhY2UuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICkge1xuXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSBwcm9wZXJ0eSBvZiBhIGNvbXByZXNzZWQgdGV4dHVyZSBqdXN0IGRlZmluZXMgaXRzIGRpbWVuc2lvbnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7e3dpZHRoOm51bWJlcixoZWlnaHQ6bnVtYmVyfX1cblx0XHQgKi9cblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGFycmF5IGhvbGRzIGZvciBhbGwgbWlwbWFwcyAoaW5jbHVkaW5nIHRoZSBiYXNlcyBtaXApIHRoZSBkYXRhIGFuZCBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PE9iamVjdD59XG5cdFx0ICovXG5cdFx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0ZXh0dXJlIGlzIGZsaXBwZWQgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgd2hlblxuXHRcdCAqIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdCBzaW5jZSBpdCBpcyBub3QgcG9zc2libGUgdG9cblx0XHQgKiBmbGlwIGNvbXByZXNzZWQgdGV4dHVyZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gZ2VuZXJhdGUgbWlwbWFwcyAoaWYgcG9zc2libGUpIGZvciBhIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdCBzaW5jZSBpdCBpcyBub3Rcblx0XHQgKiBwb3NzaWJsZSB0byBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIGRhdGEuIE1pcG1hcHNcblx0XHQgKiBtdXN0IGJlIGVtYmVkZGVkIGluIHRoZSBjb21wcmVzc2VkIHRleHR1cmUgZmlsZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfTtcbiIsImltcG9ydCB7IENsYW1wVG9FZGdlV3JhcHBpbmcgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfSBmcm9tICcuL0NvbXByZXNzZWRUZXh0dXJlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGV4dHVyZSAyRCBhcnJheSBiYXNlZCBvbiBkYXRhIGluIGNvbXByZXNzZWQgZm9ybS5cbiAqXG4gKiBUaGVzZSB0ZXh0dXJlIGFyZSB1c3VhbGx5IGxvYWRlZCB3aXRoIHtAbGluayBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcn0uXG4gKlxuICogQGF1Z21lbnRzIENvbXByZXNzZWRUZXh0dXJlXG4gKi9cbmNsYXNzIENvbXByZXNzZWRBcnJheVRleHR1cmUgZXh0ZW5kcyBDb21wcmVzc2VkVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29tcHJlc3NlZCBhcnJheSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IG1pcG1hcHMgLSBUaGlzIGFycmF5IGhvbGRzIGZvciBhbGwgbWlwbWFwcyAoaW5jbHVkaW5nIHRoZSBiYXNlcyBtaXApXG5cdCAqIHRoZSBkYXRhIGFuZCBkaW1lbnNpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9ybWF0PVJHQkFGb3JtYXRdIC0gVGhlIG1pbiBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSBtaW4gZmlsdGVyIHZhbHVlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBmb3JtYXQsIHR5cGUgKSB7XG5cblx0XHRzdXBlciggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgcHJvcGVydHkgb2YgYSBjb21wcmVzc2VkIHRleHR1cmUganVzdCBkZWZpbmVzIGl0cyBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQG5hbWUgQ29tcHJlc3NlZEFycmF5VGV4dHVyZSNpbWFnZVxuXHRcdCAqIEB0eXBlIHt7d2lkdGg6bnVtYmVyLGhlaWdodDpudW1iZXIsZGVwdGg6bnVtYmVyfX1cblx0XHQgKi9cblx0XHR0aGlzLmltYWdlLmRlcHRoID0gZGVwdGg7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGRlZmluZXMgaG93IHRoZSB0ZXh0dXJlIGlzIHdyYXBwZWQgaW4gdGhlIGRlcHRoIGFuZCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqICpXKiBpbiBVVlcgbWFwcGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoUmVwZWF0V3JhcHBpbmd8Q2xhbXBUb0VkZ2VXcmFwcGluZ3xNaXJyb3JlZFJlcGVhdFdyYXBwaW5nKX1cblx0XHQgKiBAZGVmYXVsdCBDbGFtcFRvRWRnZVdyYXBwaW5nXG5cdFx0ICovXG5cdFx0dGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHQvKipcblx0XHQgKiBBIHNldCBvZiBhbGwgbGF5ZXJzIHdoaWNoIG5lZWQgdG8gYmUgdXBkYXRlZCBpbiB0aGUgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtTZXQ8bnVtYmVyPn1cblx0XHQgKi9cblx0XHR0aGlzLmxheWVyVXBkYXRlcyA9IG5ldyBTZXQoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlc2NyaWJlcyB0aGF0IGEgc3BlY2lmaWMgbGF5ZXIgb2YgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZC5cblx0ICogTm9ybWFsbHkgd2hlbiB7QGxpbmsgVGV4dHVyZSNuZWVkc1VwZGF0ZX0gaXMgc2V0IHRvIGB0cnVlYCwgdGhlXG5cdCAqIGVudGlyZSBjb21wcmVzc2VkIHRleHR1cmUgYXJyYXkgaXMgc2VudCB0byB0aGUgR1BVLiBNYXJraW5nIHNwZWNpZmljXG5cdCAqIGxheWVycyB3aWxsIG9ubHkgdHJhbnNtaXQgc3Vic2V0cyBvZiBhbGwgbWlwbWFwcyBhc3NvY2lhdGVkIHdpdGggYVxuXHQgKiBzcGVjaWZpYyBkZXB0aCBpbiB0aGUgYXJyYXkgd2hpY2ggaXMgb2Z0ZW4gbXVjaCBtb3JlIHBlcmZvcm1hbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXllckluZGV4IC0gVGhlIGxheWVyIGluZGV4IHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXG5cdCAqL1xuXHRhZGRMYXllclVwZGF0ZSggbGF5ZXJJbmRleCApIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmFkZCggbGF5ZXJJbmRleCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBsYXllciB1cGRhdGVzIHJlZ2lzdHJ5LlxuXHQgKi9cblx0Y2xlYXJMYXllclVwZGF0ZXMoKSB7XG5cblx0XHR0aGlzLmxheWVyVXBkYXRlcy5jbGVhcigpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDb21wcmVzc2VkQXJyYXlUZXh0dXJlIH07XG4iLCJpbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfSBmcm9tICcuL0NvbXByZXNzZWRUZXh0dXJlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3ViZSB0ZXh0dXJlIGJhc2VkIG9uIGRhdGEgaW4gY29tcHJlc3NlZCBmb3JtLlxuICpcbiAqIFRoZXNlIHRleHR1cmUgYXJlIHVzdWFsbHkgbG9hZGVkIHdpdGgge0BsaW5rIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyfS5cbiAqXG4gKiBAYXVnbWVudHMgQ29tcHJlc3NlZFRleHR1cmVcbiAqL1xuY2xhc3MgQ29tcHJlc3NlZEN1YmVUZXh0dXJlIGV4dGVuZHMgQ29tcHJlc3NlZFRleHR1cmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbXByZXNzZWQgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxDb21wcmVzc2VkVGV4dHVyZT59IGltYWdlcyAtIEFuIGFycmF5IG9mIGNvbXByZXNzZWQgdGV4dHVyZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9ybWF0PVJHQkFGb3JtYXRdIC0gVGhlIHRleHR1cmUgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R5cGU9VW5zaWduZWRCeXRlVHlwZV0gLSBUaGUgdGV4dHVyZSB0eXBlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGltYWdlcywgZm9ybWF0LCB0eXBlICkge1xuXG5cdFx0c3VwZXIoIHVuZGVmaW5lZCwgaW1hZ2VzWyAwIF0ud2lkdGgsIGltYWdlc1sgMCBdLmhlaWdodCwgZm9ybWF0LCB0eXBlLCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNDb21wcmVzc2VkQ3ViZVRleHR1cmUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuXHRcdHRoaXMuaW1hZ2UgPSBpbWFnZXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IENvbXByZXNzZWRDdWJlVGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhIGNhbnZhcyBlbGVtZW50LlxuICpcbiAqIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIHRoZSBiYXNlIHRleHR1cmUgY2xhc3MsIGV4Y2VwdCB0aGF0IGl0IHNldHMge0BsaW5rIFRleHR1cmUjbmVlZHNVcGRhdGV9XG4gKiB0byBgdHJ1ZWAgaW1tZWRpYXRlbHkgc2luY2UgYSBjYW52YXMgY2FuIGRpcmVjdGx5IGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cbiAqXG4gKiBAYXVnbWVudHMgVGV4dHVyZVxuICovXG5jbGFzcyBDYW52YXNUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBUaGUgSFRNTCBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXBwaW5nPVRleHR1cmUuREVGQVVMVF9NQVBQSU5HXSAtIFRoZSB0ZXh0dXJlIG1hcHBpbmcuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcFM9Q2xhbXBUb0VkZ2VXcmFwcGluZ10gLSBUaGUgd3JhcFMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd3JhcFQ9Q2xhbXBUb0VkZ2VXcmFwcGluZ10gLSBUaGUgd3JhcFQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWFnRmlsdGVyPUxpbmVhckZpbHRlcl0gLSBUaGUgbWFnIGZpbHRlciB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttaW5GaWx0ZXI9TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXSAtIFRoZSBtaW4gZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zvcm1hdD1SR0JBRm9ybWF0XSAtIFRoZSB0ZXh0dXJlIGZvcm1hdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlPVVuc2lnbmVkQnl0ZVR5cGVdIC0gVGhlIHRleHR1cmUgdHlwZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbmlzb3Ryb3B5PVRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZXSAtIFRoZSBhbmlzb3Ryb3B5IHZhbHVlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0c3VwZXIoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzQ2FudmFzVGV4dHVyZSA9IHRydWU7XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ2FudmFzVGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBOZWFyZXN0RmlsdGVyLCBVbnNpZ25lZEludFR5cGUsIERlcHRoRm9ybWF0LCBEZXB0aFN0ZW5jaWxGb3JtYXQgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBzYXZlIHRoZSBkZXB0aCBpbmZvcm1hdGlvbiBvZiBhXG4gKiByZW5kZXJpbmcgaW50byBhIHRleHR1cmUuXG4gKlxuICogQGF1Z21lbnRzIFRleHR1cmVcbiAqL1xuY2xhc3MgRGVwdGhUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlPVVuc2lnbmVkSW50VHlwZV0gLSBUaGUgdGV4dHVyZSB0eXBlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21hcHBpbmc9VGV4dHVyZS5ERUZBVUxUX01BUFBJTkddIC0gVGhlIHRleHR1cmUgbWFwcGluZy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwUyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3cmFwVD1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwVCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYWdGaWx0ZXI9TGluZWFyRmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21pbkZpbHRlcj1MaW5lYXJGaWx0ZXJdIC0gVGhlIG1pbiBmaWx0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYW5pc290cm9weT1UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWV0gLSBUaGUgYW5pc290cm9weSB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmb3JtYXQ9RGVwdGhGb3JtYXRdIC0gVGhlIHRleHR1cmUgZm9ybWF0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHdpZHRoLCBoZWlnaHQsIHR5cGUgPSBVbnNpZ25lZEludFR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgbWluRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgYW5pc290cm9weSwgZm9ybWF0ID0gRGVwdGhGb3JtYXQgKSB7XG5cblx0XHRpZiAoIGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgcHJvcGVydHkgb2YgYSBkZXB0aCB0ZXh0dXJlIGp1c3QgZGVmaW5lcyBpdHMgZGltZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHt7d2lkdGg6bnVtYmVyLGhlaWdodDpudW1iZXJ9fVxuXHRcdCAqL1xuXHRcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0ZXh0dXJlIGlzIGZsaXBwZWQgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgd2hlblxuXHRcdCAqIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBnZW5lcmF0ZSBtaXBtYXBzIChpZiBwb3NzaWJsZSkgZm9yIGEgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIE92ZXJ3cml0dGVuIGFuZCBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29kZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBkZXB0aCBjb21wYXJlIGZ1bmN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez8oTmV2ZXJDb21wYXJlfExlc3NDb21wYXJlfEVxdWFsQ29tcGFyZXxMZXNzRXF1YWxDb21wYXJlfEdyZWF0ZXJDb21wYXJlfE5vdEVxdWFsQ29tcGFyZXxHcmVhdGVyRXF1YWxDb21wYXJlfEFsd2F5c0NvbXBhcmUpfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNvbXBhcmVGdW5jdGlvbiA9IG51bGw7XG5cblx0fVxuXG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnNvdXJjZSA9IG5ldyBTb3VyY2UoIE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UuaW1hZ2UgKSApOyAvLyBzZWUgIzMwNTQwXG5cdFx0dGhpcy5jb21wYXJlRnVuY3Rpb24gPSBzb3VyY2UuY29tcGFyZUZ1bmN0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcblxuXHRcdGlmICggdGhpcy5jb21wYXJlRnVuY3Rpb24gIT09IG51bGwgKSBkYXRhLmNvbXBhcmVGdW5jdGlvbiA9IHRoaXMuY29tcGFyZUZ1bmN0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IERlcHRoVGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi9EZXB0aFRleHR1cmUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZGVwdGggdGV4dHVyZXMuXG4gKlxuICogQGF1Z21lbnRzIERlcHRoVGV4dHVyZVxuICovXG5jbGFzcyBEZXB0aEFycmF5VGV4dHVyZSBleHRlbmRzIERlcHRoVGV4dHVyZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggYXJyYXkgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIC0gVGhlIGRlcHRoIG9mIHRoZSB0ZXh0dXJlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxICkge1xuXG5cdFx0c3VwZXIoIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNEZXB0aEFycmF5VGV4dHVyZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgZGVmaW5pdGlvbiBvZiBhIGRlcHRoIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7e3dpZHRoOm51bWJlcixoZWlnaHQ6bnVtYmVyLGRlcHRoOm51bWJlcn19XG5cdFx0ICovXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZGVwdGg6IGRlcHRoIH07XG5cblx0XHQvKipcblx0XHQgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgdGV4dHVyZSBpcyBmbGlwcGVkIGFsb25nIHRoZSB2ZXJ0aWNhbCBheGlzIHdoZW5cblx0XHQgKiB1cGxvYWRlZCB0byB0aGUgR1BVLlxuXHRcdCAqXG5cdFx0ICogT3ZlcndyaXR0ZW4gYW5kIHNldCB0byBgZmFsc2VgIGJ5IGRlZmF1bHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gZ2VuZXJhdGUgbWlwbWFwcyAoaWYgcG9zc2libGUpIGZvciBhIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBPdmVyd3JpdHRlbiBhbmQgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIENvZGUgY29ycmVzcG9uZGluZyB0byB0aGUgZGVwdGggY29tcGFyZSBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/KE5ldmVyQ29tcGFyZXxMZXNzQ29tcGFyZXxFcXVhbENvbXBhcmV8TGVzc0VxdWFsQ29tcGFyZXxHcmVhdGVyQ29tcGFyZXxOb3RFcXVhbENvbXBhcmV8R3JlYXRlckVxdWFsQ29tcGFyZXxBbHdheXNDb21wYXJlKX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jb21wYXJlRnVuY3Rpb24gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBzZXQgb2YgYWxsIGxheWVycyB3aGljaCBuZWVkIHRvIGJlIHVwZGF0ZWQgaW4gdGhlIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7U2V0PG51bWJlcj59XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllclVwZGF0ZXMgPSBuZXcgU2V0KCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXNjcmliZXMgdGhhdCBhIHNwZWNpZmljIGxheWVyIG9mIHRoZSB0ZXh0dXJlIG5lZWRzIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIE5vcm1hbGx5IHdoZW4ge0BsaW5rIFRleHR1cmUjbmVlZHNVcGRhdGV9IGlzIHNldCB0byBgdHJ1ZWAsIHRoZVxuXHQgKiBlbnRpcmUgc2xpY2UgaXMgc2VudCB0byB0aGUgR1BVLiBNYXJraW5nIHNwZWNpZmljXG5cdCAqIGxheWVycyB3aWxsIG9ubHkgdHJhbnNtaXQgc3Vic2V0cyBvZiBhbGwgbWlwbWFwcyBhc3NvY2lhdGVkIHdpdGggYVxuXHQgKiBzcGVjaWZpYyBkZXB0aCBpbiB0aGUgYXJyYXkgd2hpY2ggaXMgb2Z0ZW4gbXVjaCBtb3JlIHBlcmZvcm1hbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXllckluZGV4IC0gVGhlIGxheWVyIGluZGV4IHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXG5cdCAqL1xuXHRhZGRMYXllclVwZGF0ZSggbGF5ZXJJbmRleCApIHtcblxuXHRcdHRoaXMubGF5ZXJVcGRhdGVzLmFkZCggbGF5ZXJJbmRleCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBsYXllciB1cGRhdGVzIHJlZ2lzdHJ5LlxuXHQgKi9cblx0Y2xlYXJMYXllclVwZGF0ZXMoKSB7XG5cblx0XHR0aGlzLmxheWVyVXBkYXRlcy5jbGVhcigpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBEZXB0aEFycmF5VGV4dHVyZSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBBIGdlb21ldHJ5IGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSBjYXBzdWxlLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DYXBzdWxlR2VvbWV0cnkoIDEsIDEsIDQsIDgsIDEgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDAwZmYwMCB9ICk7XG4gKiBjb25zdCBjYXBzdWxlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBjYXBzdWxlICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgQ2Fwc3VsZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNhcHN1bGUgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gUmFkaXVzIG9mIHRoZSBjYXBzdWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0xXSAtIEhlaWdodCBvZiB0aGUgbWlkZGxlIHNlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY2FwU2VnbWVudHM9NF0gLSBOdW1iZXIgb2YgY3VydmUgc2VnbWVudHMgdXNlZCB0byBidWlsZCBlYWNoIGNhcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz04XSAtIE51bWJlciBvZiBzZWdtZW50ZWQgZmFjZXMgYXJvdW5kIHRoZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjYXBzdWxlLiBNdXN0IGJlIGFuIGludGVnZXIgPj0gMy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRTZWdtZW50cz0xXSAtIE51bWJlciBvZiByb3dzIG9mIGZhY2VzIGFsb25nIHRoZSBoZWlnaHQgb2YgdGhlIG1pZGRsZSBzZWN0aW9uLiBNdXN0IGJlIGFuIGludGVnZXIgPj0gMS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBoZWlnaHQgPSAxLCBjYXBTZWdtZW50cyA9IDQsIHJhZGlhbFNlZ21lbnRzID0gOCwgaGVpZ2h0U2VnbWVudHMgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYXBzdWxlR2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGNhcFNlZ21lbnRzOiBjYXBTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHR9O1xuXG5cdFx0aGVpZ2h0ID0gTWF0aC5tYXgoIDAsIGhlaWdodCApO1xuXHRcdGNhcFNlZ21lbnRzID0gTWF0aC5tYXgoIDEsIE1hdGguZmxvb3IoIGNhcFNlZ21lbnRzICkgKTtcblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApICk7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMSwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cdFx0Y29uc3QgY2FwQXJjTGVuZ3RoID0gKCBNYXRoLlBJIC8gMiApICogcmFkaXVzO1xuXHRcdGNvbnN0IGN5bGluZGVyUGFydExlbmd0aCA9IGhlaWdodDtcblx0XHRjb25zdCB0b3RhbEFyY0xlbmd0aCA9IDIgKiBjYXBBcmNMZW5ndGggKyBjeWxpbmRlclBhcnRMZW5ndGg7XG5cblx0XHRjb25zdCBudW1WZXJ0aWNhbFNlZ21lbnRzID0gY2FwU2VnbWVudHMgKiAyICsgaGVpZ2h0U2VnbWVudHM7XG5cdFx0Y29uc3QgdmVydGljZXNQZXJSb3cgPSByYWRpYWxTZWdtZW50cyArIDE7XG5cblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscywgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPD0gbnVtVmVydGljYWxTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGxldCBjdXJyZW50QXJjTGVuZ3RoID0gMDtcblx0XHRcdGxldCBwcm9maWxlWSA9IDA7XG5cdFx0XHRsZXQgcHJvZmlsZVJhZGl1cyA9IDA7XG5cdFx0XHRsZXQgbm9ybWFsWUNvbXBvbmVudCA9IDA7XG5cblx0XHRcdGlmICggaXkgPD0gY2FwU2VnbWVudHMgKSB7XG5cblx0XHRcdFx0Ly8gYm90dG9tIGNhcFxuXHRcdFx0XHRjb25zdCBzZWdtZW50UHJvZ3Jlc3MgPSBpeSAvIGNhcFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCBhbmdsZSA9ICggc2VnbWVudFByb2dyZXNzICogTWF0aC5QSSApIC8gMjtcblx0XHRcdFx0cHJvZmlsZVkgPSAtIGhhbGZIZWlnaHQgLSByYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRcdFx0cHJvZmlsZVJhZGl1cyA9IHJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXHRcdFx0XHRub3JtYWxZQ29tcG9uZW50ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRcdFx0Y3VycmVudEFyY0xlbmd0aCA9IHNlZ21lbnRQcm9ncmVzcyAqIGNhcEFyY0xlbmd0aDtcblxuXHRcdFx0fSBlbHNlIGlmICggaXkgPD0gY2FwU2VnbWVudHMgKyBoZWlnaHRTZWdtZW50cyApIHtcblxuXHRcdFx0XHQvLyBtaWRkbGUgc2VjdGlvblxuXHRcdFx0XHRjb25zdCBzZWdtZW50UHJvZ3Jlc3MgPSAoIGl5IC0gY2FwU2VnbWVudHMgKSAvIGhlaWdodFNlZ21lbnRzO1xuXHRcdFx0XHRwcm9maWxlWSA9IC0gaGFsZkhlaWdodCArIHNlZ21lbnRQcm9ncmVzcyAqIGhlaWdodDtcblx0XHRcdFx0cHJvZmlsZVJhZGl1cyA9IHJhZGl1cztcblx0XHRcdFx0bm9ybWFsWUNvbXBvbmVudCA9IDA7XG5cdFx0XHRcdGN1cnJlbnRBcmNMZW5ndGggPSBjYXBBcmNMZW5ndGggKyBzZWdtZW50UHJvZ3Jlc3MgKiBjeWxpbmRlclBhcnRMZW5ndGg7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdG9wIGNhcFxuXHRcdFx0XHRjb25zdCBzZWdtZW50UHJvZ3Jlc3MgPVxuXHRcdFx0XHRcdCggaXkgLSBjYXBTZWdtZW50cyAtIGhlaWdodFNlZ21lbnRzICkgLyBjYXBTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgYW5nbGUgPSAoIHNlZ21lbnRQcm9ncmVzcyAqIE1hdGguUEkgKSAvIDI7XG5cdFx0XHRcdHByb2ZpbGVZID0gaGFsZkhlaWdodCArIHJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXHRcdFx0XHRwcm9maWxlUmFkaXVzID0gcmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHRcdG5vcm1hbFlDb21wb25lbnQgPSByYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHRcdFx0Y3VycmVudEFyY0xlbmd0aCA9XG5cdFx0XHRcdFx0Y2FwQXJjTGVuZ3RoICsgY3lsaW5kZXJQYXJ0TGVuZ3RoICsgc2VnbWVudFByb2dyZXNzICogY2FwQXJjTGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHYgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIDEsIGN1cnJlbnRBcmNMZW5ndGggLyB0b3RhbEFyY0xlbmd0aCApICk7XG5cblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcG9sZXNcblxuXHRcdFx0bGV0IHVPZmZzZXQgPSAwO1xuXG5cdFx0XHRpZiAoIGl5ID09PSAwICkge1xuXG5cdFx0XHRcdHVPZmZzZXQgPSAwLjUgLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0fSBlbHNlIGlmICggaXkgPT09IG51bVZlcnRpY2FsU2VnbWVudHMgKSB7XG5cblx0XHRcdFx0dU9mZnNldCA9IC0gMC41IC8gcmFkaWFsU2VnbWVudHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPD0gcmFkaWFsU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gLSBwcm9maWxlUmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdHZlcnRleC55ID0gcHJvZmlsZVk7XG5cdFx0XHRcdHZlcnRleC56ID0gcHJvZmlsZVJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFsLnNldChcblx0XHRcdFx0XHQtIHByb2ZpbGVSYWRpdXMgKiBjb3NUaGV0YSxcblx0XHRcdFx0XHRub3JtYWxZQ29tcG9uZW50LFxuXHRcdFx0XHRcdHByb2ZpbGVSYWRpdXMgKiBzaW5UaGV0YVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUgKyB1T2Zmc2V0LCB2ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpeSA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgcHJldkluZGV4Um93ID0gKCBpeSAtIDEgKSAqIHZlcnRpY2VzUGVyUm93O1xuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IHJhZGlhbFNlZ21lbnRzOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGkxID0gcHJldkluZGV4Um93ICsgaXg7XG5cdFx0XHRcdFx0Y29uc3QgaTIgPSBwcmV2SW5kZXhSb3cgKyBpeCArIDE7XG5cdFx0XHRcdFx0Y29uc3QgaTMgPSBpeSAqIHZlcnRpY2VzUGVyUm93ICsgaXg7XG5cdFx0XHRcdFx0Y29uc3QgaTQgPSBpeSAqIHZlcnRpY2VzUGVyUm93ICsgaXggKyAxO1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpMSwgaTIsIGkzICk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpMiwgaTQsIGkzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge0NhcHN1bGVHZW9tZXRyeX0gQSBuZXcgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IENhcHN1bGVHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuaGVpZ2h0LCBkYXRhLmNhcFNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IENhcHN1bGVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG4vKipcbiAqIEEgc2ltcGxlIHNoYXBlIG9mIEV1Y2xpZGVhbiBnZW9tZXRyeS4gSXQgaXMgY29uc3RydWN0ZWQgZnJvbSBhXG4gKiBudW1iZXIgb2YgdHJpYW5ndWxhciBzZWdtZW50cyB0aGF0IGFyZSBvcmllbnRlZCBhcm91bmQgYSBjZW50cmFsIHBvaW50IGFuZFxuICogZXh0ZW5kIGFzIGZhciBvdXQgYXMgYSBnaXZlbiByYWRpdXMuIEl0IGlzIGJ1aWx0IGNvdW50ZXItY2xvY2t3aXNlIGZyb20gYVxuICogc3RhcnQgYW5nbGUgYW5kIGEgZ2l2ZW4gY2VudHJhbCBhbmdsZS4gSXQgY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGVcbiAqIHJlZ3VsYXIgcG9seWdvbnMsIHdoZXJlIHRoZSBudW1iZXIgb2Ygc2VnbWVudHMgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mXG4gKiBzaWRlcy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoIDUsIDMyICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICogY29uc3QgY2lyY2xlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBjaXJjbGUgKVxuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckdlb21ldHJ5XG4gKi9cbmNsYXNzIENpcmNsZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNpcmNsZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzZWdtZW50cz0zMl0gLSBOdW1iZXIgb2Ygc2VnbWVudHMgKHRyaWFuZ2xlcyksIG1pbmltdW0gPSBgM2AuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGFTdGFydD0wXSAtIFN0YXJ0IGFuZ2xlIGZvciBmaXJzdCBzZWdtZW50IGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGFMZW5ndGg9TWF0aC5QSSoyXSAtIFRoZSBjZW50cmFsIGFuZ2xlLCBvZnRlbiBjYWxsZWQgdGhldGEsXG5cdCAqIG9mIHRoZSBjaXJjdWxhciBzZWN0b3IgaW4gcmFkaWFucy4gVGhlIGRlZmF1bHQgdmFsdWUgcmVzdWx0cyBpbiBhIGNvbXBsZXRlIGNpcmNsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBzZWdtZW50cyA9IDMyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGNlbnRlciBwb2ludFxuXG5cdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXHRcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xuXG5cdFx0Zm9yICggbGV0IHMgPSAwLCBpID0gMzsgcyA8PSBzZWdtZW50czsgcyArKywgaSArPSAzICkge1xuXG5cdFx0XHRjb25zdCBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG5cdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0Ly8gdXZzXG5cblx0XHRcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXHRcdFx0dXYueSA9ICggdmVydGljZXNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge0NpcmNsZUdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2lyY2xlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBDaXJjbGVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG4vKipcbiAqIEEgZ2VvbWV0cnkgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIGN5bGluZGVyLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCA1LCA1LCAyMCwgMzIgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gKiBjb25zdCBjeWxpbmRlciA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggY3lsaW5kZXIgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJHZW9tZXRyeVxuICovXG5jbGFzcyBDeWxpbmRlckdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGN5bGluZGVyIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c1RvcD0xXSAtIFJhZGl1cyBvZiB0aGUgY3lsaW5kZXIgYXQgdGhlIHRvcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNCb3R0b209MV0gLSBSYWRpdXMgb2YgdGhlIGN5bGluZGVyIGF0IHRoZSBib3R0b20uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gSGVpZ2h0IG9mIHRoZSBjeWxpbmRlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz0zMl0gLSBOdW1iZXIgb2Ygc2VnbWVudGVkIGZhY2VzIGFyb3VuZCB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY3lsaW5kZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0U2VnbWVudHM9MV0gLSBOdW1iZXIgb2Ygcm93cyBvZiBmYWNlcyBhbG9uZyB0aGUgaGVpZ2h0IG9mIHRoZSBjeWxpbmRlci5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3BlbkVuZGVkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGJhc2Ugb2YgdGhlIGN5bGluZGVyIGlzIG9wZW4gb3IgY2FwcGVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3RoZXRhU3RhcnQ9MF0gLSBTdGFydCBhbmdsZSBmb3IgZmlyc3Qgc2VnbWVudCwgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YUxlbmd0aD1NYXRoLlBJKjJdIC0gVGhlIGNlbnRyYWwgYW5nbGUsIG9mdGVuIGNhbGxlZCB0aGV0YSwgb2YgdGhlIGNpcmN1bGFyIHNlY3RvciwgaW4gcmFkaWFucy5cblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgcmVzdWx0cyBpbiBhIGNvbXBsZXRlIGN5bGluZGVyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1c1RvcCA9IDEsIHJhZGl1c0JvdHRvbSA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuXHRcdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gW107XG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcblxuXHRcdGdlbmVyYXRlVG9yc28oKTtcblxuXHRcdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCByYWRpdXNUb3AgPiAwICkgZ2VuZXJhdGVDYXAoIHRydWUgKTtcblx0XHRcdGlmICggcmFkaXVzQm90dG9tID4gMCApIGdlbmVyYXRlQ2FwKCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuXG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXHRcdFx0Y29uc3Qgc2xvcGUgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleFJvdyA9IFtdO1xuXG5cdFx0XHRcdGNvbnN0IHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG5cblx0XHRcdFx0Y29uc3QgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cblx0XHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHRcdGNvbnN0IHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbC5zZXQoIHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEgKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0XHRcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XG5cblx0XHRcdFx0XHRpbmRleFJvdy5wdXNoKCBpbmRleCArKyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuXG5cdFx0XHRcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4QXJyYXlbIHkgXVsgeCBdO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4IF07XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHRcdFx0Y29uc3QgZCA9IGluZGV4QXJyYXlbIHkgXVsgeCArIDEgXTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgfHwgeSAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHJhZGl1c0JvdHRvbSA+IDAgfHwgeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxICkge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblx0XHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XG5cblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XG5cblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gKCB0b3AgPT09IHRydWUgKSA/IHJhZGl1c1RvcCA6IHJhZGl1c0JvdHRvbTtcblx0XHRcdGNvbnN0IHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcblxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xuXG5cdFx0XHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XG5cdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSAoIGNvc1RoZXRhICogMC41ICkgKyAwLjU7XG5cdFx0XHRcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XG5cdFx0XHRcdGNvbnN0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XG5cblx0XHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIHRvcFxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgYyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIGJvdHRvbVxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICsgMSwgaSwgYyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIHRvcCA9PT0gdHJ1ZSA/IDEgOiAyICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcmV0dXJuIHtDeWxpbmRlckdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggZGF0YS5yYWRpdXNUb3AsIGRhdGEucmFkaXVzQm90dG9tLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEN5bGluZGVyR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEN5bGluZGVyR2VvbWV0cnkgfSBmcm9tICcuL0N5bGluZGVyR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIEEgZ2VvbWV0cnkgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIGNvbmUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNvbmVHZW9tZXRyeSggNSwgMjAsIDMyICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICogY29uc3QgY29uZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBjb25lICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQ3lsaW5kZXJHZW9tZXRyeVxuICovXG5jbGFzcyBDb25lR2VvbWV0cnkgZXh0ZW5kcyBDeWxpbmRlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb25lIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xXSAtIFJhZGl1cyBvZiB0aGUgY29uZSBiYXNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0xXSAtIEhlaWdodCBvZiB0aGUgY29uZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz0zMl0gLSBOdW1iZXIgb2Ygc2VnbWVudGVkIGZhY2VzIGFyb3VuZCB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY29uZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRTZWdtZW50cz0xXSAtIE51bWJlciBvZiByb3dzIG9mIGZhY2VzIGFsb25nIHRoZSBoZWlnaHQgb2YgdGhlIGNvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wZW5FbmRlZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBiYXNlIG9mIHRoZSBjb25lIGlzIG9wZW4gb3IgY2FwcGVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3RoZXRhU3RhcnQ9MF0gLSBTdGFydCBhbmdsZSBmb3IgZmlyc3Qgc2VnbWVudCwgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YUxlbmd0aD1NYXRoLlBJKjJdIC0gVGhlIGNlbnRyYWwgYW5nbGUsIG9mdGVuIGNhbGxlZCB0aGV0YSwgb2YgdGhlIGNpcmN1bGFyIHNlY3RvciwgaW4gcmFkaWFucy5cblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgcmVzdWx0cyBpbiBhIGNvbXBsZXRlIGNvbmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlciggMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcmV0dXJuIHtDb25lR2VvbWV0cnl9IEEgbmV3IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDb25lR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDb25lR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuLyoqXG4gKiBBIHBvbHloZWRyb24gaXMgYSBzb2xpZCBpbiB0aHJlZSBkaW1lbnNpb25zIHdpdGggZmxhdCBmYWNlcy4gVGhpcyBjbGFzc1xuICogd2lsbCB0YWtlIGFuIGFycmF5IG9mIHZlcnRpY2VzLCBwcm9qZWN0IHRoZW0gb250byBhIHNwaGVyZSwgYW5kIHRoZW5cbiAqIGRpdmlkZSB0aGVtIHVwIHRvIHRoZSBkZXNpcmVkIGxldmVsIG9mIGRldGFpbC5cbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgUG9seWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvbHloZWRyb24gZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3ZlcnRpY2VzXSAtIEEgZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBkZXNjcmliaW5nIHRoZSBiYXNlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtpbmRpY2VzXSAtIEEgZmxhdCBhcnJheSBvZiBpbmRpY2VzIGRlc2NyaWJpbmcgdGhlIGJhc2Ugc2hhcGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gVGhlIHJhZGl1cyBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGV0YWlsPTBdIC0gSG93IG1hbnkgbGV2ZWxzIHRvIHN1YmRpdmlkZSB0aGUgZ2VvbWV0cnkuIFRoZSBtb3JlIGRldGFpbCwgdGhlIHNtb290aGVyIHRoZSBzaGFwZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB2ZXJ0aWNlcyA9IFtdLCBpbmRpY2VzID0gW10sIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBbXTtcblx0XHRjb25zdCB1dkJ1ZmZlciA9IFtdO1xuXG5cdFx0Ly8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG5cdFx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcblxuXHRcdC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xuXG5cdFx0YXBwbHlSYWRpdXMoIHJhZGl1cyApO1xuXG5cdFx0Ly8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXG5cblx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XG5cblx0XHRpZiAoIGRldGFpbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXG5cdFx0fVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc2lvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXG5cblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDAgXSwgYSApO1xuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAyIF0sIGMgKTtcblxuXHRcdFx0XHQvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0c3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApIHtcblxuXHRcdFx0Y29uc3QgY29scyA9IGRldGFpbCArIDE7XG5cblx0XHRcdC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXG5cblx0XHRcdGNvbnN0IHYgPSBbXTtcblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb25cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dlsgaSBdID0gW107XG5cblx0XHRcdFx0Y29uc3QgYWogPSBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblx0XHRcdFx0Y29uc3QgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblxuXHRcdFx0XHRjb25zdCByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuXHRcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29sczsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdFx0aWYgKCBqICUgMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlSYWRpdXMoIHJhZGl1cyApIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdHZlcnRleC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMCBdID0gdmVydGV4Lng7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBhemltdXRoKCB2ZXJ0ZXggKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHRjb25zdCB2ID0gaW5jbGluYXRpb24oIHZlcnRleCApIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb3JyZWN0VVZzKCk7XG5cblx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHV2QnVmZmVyLmxlbmd0aDsgaSArPSA2ICkge1xuXG5cdFx0XHRcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxuXG5cdFx0XHRcdGNvbnN0IHgwID0gdXZCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdGNvbnN0IHgxID0gdXZCdWZmZXJbIGkgKyAyIF07XG5cdFx0XHRcdGNvbnN0IHgyID0gdXZCdWZmZXJbIGkgKyA0IF07XG5cblx0XHRcdFx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcblx0XHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcblxuXHRcdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG5cdFx0XHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MSA8IDAuMiApIHV2QnVmZmVyWyBpICsgMiBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2QnVmZmVyWyBpICsgNCBdICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XG5cblx0XHRcdHZlcnRleEJ1ZmZlci5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xuXG5cdFx0XHRjb25zdCBzdHJpZGUgPSBpbmRleCAqIDM7XG5cblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIHN0cmlkZSArIDEgXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Y29uc3QgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNiApIHtcblxuXHRcdFx0XHRhLnNldCggdmVydGV4QnVmZmVyWyBpICsgMCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0sIHZlcnRleEJ1ZmZlclsgaSArIDIgXSApO1xuXHRcdFx0XHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xuXHRcdFx0XHRjLnNldCggdmVydGV4QnVmZmVyWyBpICsgNiBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA3IF0sIHZlcnRleEJ1ZmZlclsgaSArIDggXSApO1xuXG5cdFx0XHRcdHV2QS5zZXQoIHV2QnVmZmVyWyBqICsgMCBdLCB1dkJ1ZmZlclsgaiArIDEgXSApO1xuXHRcdFx0XHR1dkIuc2V0KCB1dkJ1ZmZlclsgaiArIDIgXSwgdXZCdWZmZXJbIGogKyAzIF0gKTtcblx0XHRcdFx0dXZDLnNldCggdXZCdWZmZXJbIGogKyA0IF0sIHV2QnVmZmVyWyBqICsgNSBdICk7XG5cblx0XHRcdFx0Y2VudHJvaWQuY29weSggYSApLmFkZCggYiApLmFkZCggYyApLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0XHRcdGNvbnN0IGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cblx0XHRcdFx0Y29ycmVjdFVWKCB1dkEsIGogKyAwLCBhLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkIsIGogKyAyLCBiLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkMsIGogKyA0LCBjLCBhemkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgc3RyaWRlLCB2ZWN0b3IsIGF6aW11dGggKSB7XG5cblx0XHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkge1xuXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHtcblxuXHRcdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuXHRcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmcm9tIHRoZSBnaXZlblxuXHQgKiBKU09OIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXplZCBnZW9tZXRyeS5cblx0ICogQHJldHVybiB7UG9seWhlZHJvbkdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUG9seWhlZHJvbkdlb21ldHJ5KCBkYXRhLnZlcnRpY2VzLCBkYXRhLmluZGljZXMsIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbHMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XG5cbi8qKlxuICogQSBnZW9tZXRyeSBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgZG9kZWNhaGVkcm9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeSgpO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKTtcbiAqIGNvbnN0IGRvZGVjYWhlZHJvbiA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggZG9kZWNhaGVkcm9uICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgUG9seWhlZHJvbkdlb21ldHJ5XG4gKi9cbmNsYXNzIERvZGVjYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkb2RlY2FoZWRyb24gZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gUmFkaXVzIG9mIHRoZSBkb2RlY2FoZWRyb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGV0YWlsPTBdIC0gU2V0dGluZyB0aGlzIHRvIGEgdmFsdWUgZ3JlYXRlciB0aGFuIGAwYCBhZGRzIHZlcnRpY2VzIG1ha2luZyBpdCBubyBsb25nZXIgYSBkb2RlY2FoZWRyb24uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdGNvbnN0IHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblx0XHRjb25zdCByID0gMSAvIHQ7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblxuXHRcdFx0Ly8gKMKxMSwgwrExLCDCsTEpXG5cdFx0XHQtIDEsIC0gMSwgLSAxLFx0LSAxLCAtIDEsIDEsXG5cdFx0XHQtIDEsIDEsIC0gMSwgLSAxLCAxLCAxLFxuXHRcdFx0MSwgLSAxLCAtIDEsIDEsIC0gMSwgMSxcblx0XHRcdDEsIDEsIC0gMSwgMSwgMSwgMSxcblxuXHRcdFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcblx0XHRcdDAsIC0gciwgLSB0LCAwLCAtIHIsIHQsXG5cdFx0XHQwLCByLCAtIHQsIDAsIHIsIHQsXG5cblx0XHRcdC8vICjCsTEvz4YsIMKxz4YsIDApXG5cdFx0XHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxuXHRcdFx0ciwgLSB0LCAwLCByLCB0LCAwLFxuXG5cdFx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdFx0LSB0LCAwLCAtIHIsIHQsIDAsIC0gcixcblx0XHRcdC0gdCwgMCwgciwgdCwgMCwgclxuXHRcdF07XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW1xuXHRcdFx0MywgMTEsIDcsIFx0MywgNywgMTUsIFx0MywgMTUsIDEzLFxuXHRcdFx0NywgMTksIDE3LCBcdDcsIDE3LCA2LCBcdDcsIDYsIDE1LFxuXHRcdFx0MTcsIDQsIDgsIFx0MTcsIDgsIDEwLCBcdDE3LCAxMCwgNixcblx0XHRcdDgsIDAsIDE2LCBcdDgsIDE2LCAyLCBcdDgsIDIsIDEwLFxuXHRcdFx0MCwgMTIsIDEsIFx0MCwgMSwgMTgsIFx0MCwgMTgsIDE2LFxuXHRcdFx0NiwgMTAsIDIsIFx0NiwgMiwgMTMsIFx0NiwgMTMsIDE1LFxuXHRcdFx0MiwgMTYsIDE4LCBcdDIsIDE4LCAzLCBcdDIsIDMsIDEzLFxuXHRcdFx0MTgsIDEsIDksIFx0MTgsIDksIDExLCBcdDE4LCAxMSwgMyxcblx0XHRcdDQsIDE0LCAxMiwgXHQ0LCAxMiwgMCwgXHQ0LCAwLCA4LFxuXHRcdFx0MTEsIDksIDUsIFx0MTEsIDUsIDE5LCBcdDExLCAxOSwgNyxcblx0XHRcdDE5LCA1LCAxNCwgXHQxOSwgMTQsIDQsIFx0MTksIDQsIDE3LFxuXHRcdFx0MSwgMTIsIDE0LCBcdDEsIDE0LCA1LCBcdDEsIDUsIDlcblx0XHRdO1xuXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge0RvZGVjYWhlZHJvbkdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgRG9kZWNhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IERvZGVjYWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IERFRzJSQUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBUcmlhbmdsZSgpO1xuXG4vKipcbiAqIENhbiBiZSB1c2VkIGFzIGEgaGVscGVyIG9iamVjdCB0byB2aWV3IHRoZSBlZGdlcyBvZiBhIGdlb21ldHJ5LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgpO1xuICogY29uc3QgZWRnZXMgPSBuZXcgVEhSRUUuRWRnZXNHZW9tZXRyeSggZ2VvbWV0cnkgKTtcbiAqIGNvbnN0IGxpbmUgPSBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKCBlZGdlcyApO1xuICogc2NlbmUuYWRkKCBsaW5lICk7XG4gKiBgYGBcbiAqXG4gKiBOb3RlOiBJdCBpcyBub3QgeWV0IHBvc3NpYmxlIHRvIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgRWRnZXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBlZGdlcyBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHs/QnVmZmVyR2VvbWV0cnl9IFtnZW9tZXRyeT1udWxsXSAtIFRoZSBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0xXSAtIEFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgKGluIGRlZ3JlZXMpXG5cdCAqIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiB0aGUgYWRqb2luaW5nIGZhY2VzIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG51bGwsIHRocmVzaG9sZEFuZ2xlID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHR0aHJlc2hvbGRBbmdsZTogdGhyZXNob2xkQW5nbGVcblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uUG9pbnRzID0gNDtcblx0XHRcdGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG5cdFx0XHRjb25zdCB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggREVHMlJBRCAqIHRocmVzaG9sZEFuZ2xlICk7XG5cblx0XHRcdGNvbnN0IGluZGV4QXR0ciA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRcdGNvbnN0IGluZGV4Q291bnQgPSBpbmRleEF0dHIgPyBpbmRleEF0dHIuY291bnQgOiBwb3NpdGlvbkF0dHIuY291bnQ7XG5cblx0XHRcdGNvbnN0IGluZGV4QXJyID0gWyAwLCAwLCAwIF07XG5cdFx0XHRjb25zdCB2ZXJ0S2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHRcdFx0Y29uc3QgaGFzaGVzID0gbmV3IEFycmF5KCAzICk7XG5cblx0XHRcdGNvbnN0IGVkZ2VEYXRhID0ge307XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGlmICggaW5kZXhBdHRyICkge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGluZGV4QXR0ci5nZXRYKCBpICk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGluZGV4QXR0ci5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpbmRleEF0dHIuZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGkgKyAxO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpICsgMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSBfdHJpYW5nbGU7XG5cdFx0XHRcdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMCBdICk7XG5cdFx0XHRcdGIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMSBdICk7XG5cdFx0XHRcdGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMiBdICk7XG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoIF9ub3JtYWwgKTtcblxuXHRcdFx0XHQvLyBjcmVhdGUgaGFzaGVzIGZvciB0aGUgZWRnZSBmcm9tIHRoZSB2ZXJ0aWNlc1xuXHRcdFx0XHRoYXNoZXNbIDAgXSA9IGAkeyBNYXRoLnJvdW5kKCBhLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYS56ICogcHJlY2lzaW9uICkgfWA7XG5cdFx0XHRcdGhhc2hlc1sgMSBdID0gYCR7IE1hdGgucm91bmQoIGIueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYi55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBiLnogKiBwcmVjaXNpb24gKSB9YDtcblx0XHRcdFx0aGFzaGVzWyAyIF0gPSBgJHsgTWF0aC5yb3VuZCggYy54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGMueiAqIHByZWNpc2lvbiApIH1gO1xuXG5cdFx0XHRcdC8vIHNraXAgZGVnZW5lcmF0ZSB0cmlhbmdsZXNcblx0XHRcdFx0aWYgKCBoYXNoZXNbIDAgXSA9PT0gaGFzaGVzWyAxIF0gfHwgaGFzaGVzWyAxIF0gPT09IGhhc2hlc1sgMiBdIHx8IGhhc2hlc1sgMiBdID09PSBoYXNoZXNbIDAgXSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgZXZlcnkgZWRnZVxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBmaXJzdCBhbmQgbmV4dCB2ZXJ0ZXggbWFraW5nIHVwIHRoZSBlZGdlXG5cdFx0XHRcdFx0Y29uc3Qgak5leHQgPSAoIGogKyAxICkgJSAzO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gwID0gaGFzaGVzWyBqIF07XG5cdFx0XHRcdFx0Y29uc3QgdmVjSGFzaDEgPSBoYXNoZXNbIGpOZXh0IF07XG5cdFx0XHRcdFx0Y29uc3QgdjAgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqIF0gXTtcblx0XHRcdFx0XHRjb25zdCB2MSA9IF90cmlhbmdsZVsgdmVydEtleXNbIGpOZXh0IF0gXTtcblxuXHRcdFx0XHRcdGNvbnN0IGhhc2ggPSBgJHsgdmVjSGFzaDAgfV8keyB2ZWNIYXNoMSB9YDtcblx0XHRcdFx0XHRjb25zdCByZXZlcnNlSGFzaCA9IGAkeyB2ZWNIYXNoMSB9XyR7IHZlY0hhc2gwIH1gO1xuXG5cdFx0XHRcdFx0aWYgKCByZXZlcnNlSGFzaCBpbiBlZGdlRGF0YSAmJiBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0XHRcdGlmICggX25vcm1hbC5kb3QoIGVkZ2VEYXRhWyByZXZlcnNlSGFzaCBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MC54LCB2MC55LCB2MC56ICk7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSA9IG51bGw7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhICggaGFzaCBpbiBlZGdlRGF0YSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBlZGdlIGhlcmUgdGhlbiBza2lwIGFkZGluZyBhIG5ldyBvbmVcblx0XHRcdFx0XHRcdGVkZ2VEYXRhWyBoYXNoIF0gPSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kZXgwOiBpbmRleEFyclsgaiBdLFxuXHRcdFx0XHRcdFx0XHRpbmRleDE6IGluZGV4QXJyWyBqTmV4dCBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWw6IF9ub3JtYWwuY2xvbmUoKSxcblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGVkZ2VEYXRhICkge1xuXG5cdFx0XHRcdGlmICggZWRnZURhdGFbIGtleSBdICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgeyBpbmRleDAsIGluZGV4MSB9ID0gZWRnZURhdGFbIGtleSBdO1xuXHRcdFx0XHRcdF92MC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MCApO1xuXHRcdFx0XHRcdF92MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MSApO1xuXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YwLngsIF92MC55LCBfdjAueiApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIF92MS54LCBfdjEueSwgX3YxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRWRnZXNHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgYW4gYW5hbHl0aWMgY3VydmUgb2JqZWN0IHRoYXQgY29udGFpbnMgbWV0aG9kc1xuICogZm9yIGludGVycG9sYXRpb24uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEN1cnZlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjdXJ2ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgcHJvcGVydHkgaXMgdXNlZCBmb3IgZGV0ZWN0aW5nIHRoZSBvYmplY3QgdHlwZVxuXHRcdCAqIGluIGNvbnRleHQgb2Ygc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHZhbHVlIGRldGVybWluZXMgdGhlIGFtb3VudCBvZiBkaXZpc2lvbnMgd2hlbiBjYWxjdWxhdGluZyB0aGVcblx0XHQgKiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3RocyBvZiBhIGN1cnZlIHZpYSB7QGxpbmsgQ3VydmUjZ2V0TGVuZ3Roc30uIFRvIGVuc3VyZVxuXHRcdCAqIHByZWNpc2lvbiB3aGVuIHVzaW5nIG1ldGhvZHMgbGlrZSB7QGxpbmsgQ3VydmUjZ2V0U3BhY2VkUG9pbnRzfSwgaXQgaXNcblx0XHQgKiByZWNvbW1lbmRlZCB0byBpbmNyZWFzZSB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpZiB0aGUgY3VydmUgaXMgdmVyeSBsYXJnZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMjAwXG5cdFx0ICovXG5cdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBNdXN0IGJlIHNldCB0byBgdHJ1ZWAgaWYgdGhlIGN1cnZlIHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBjYWNoZSB0aGF0IGhvbGRzIHByZWNvbXB1dGVkIGN1cnZlIGxlbmd0aCB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHs/QXJyYXk8bnVtYmVyPn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHZlY3RvciBpbiAyRCBvciAzRCBzcGFjZSAoZGVwZW5kaW5nIG9uIHRoZSBjdXJ2ZSBkZWZpbml0aW9uKVxuXHQgKiBmb3IgdGhlIGdpdmVuIGludGVycG9sYXRpb24gZmFjdG9yLlxuXHQgKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBBIGludGVycG9sYXRpb24gZmFjdG9yIHJlcHJlc2VudGluZyBhIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS4gTXVzdCBiZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICogQHBhcmFtIHsoVmVjdG9yMnxWZWN0b3IzKX0gW29wdGlvbmFsVGFyZ2V0XSAtIFRoZSBvcHRpb25hbCB0YXJnZXQgdmVjdG9yIHRoZSByZXN1bHQgaXMgd3JpdHRlbiB0by5cblx0ICogQHJldHVybiB7KFZlY3RvcjJ8VmVjdG9yMyl9IFRoZSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuIEl0IGNhbiBiZSBhIDJEIG9yIDNEIHZlY3RvciBkZXBlbmRpbmcgb24gdGhlIGN1cnZlIGRlZmluaXRpb24uXG5cdCAqL1xuXHRnZXRQb2ludCggLyogdCwgb3B0aW9uYWxUYXJnZXQgKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSB2ZWN0b3IgaW4gMkQgb3IgM0Qgc3BhY2UgKGRlcGVuZGluZyBvbiB0aGUgY3VydmUgZGVmaW5pdGlvbilcblx0ICogZm9yIHRoZSBnaXZlbiBpbnRlcnBvbGF0aW9uIGZhY3Rvci4gVW5saWtlIHtAbGluayBDdXJ2ZSNnZXRQb2ludH0sIHRoaXMgbWV0aG9kIGhvbm9ycyB0aGUgbGVuZ3RoXG5cdCAqIG9mIHRoZSBjdXJ2ZSB3aGljaCBlcXVpZGlzdGFudCBzYW1wbGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdSAtIEEgaW50ZXJwb2xhdGlvbiBmYWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gb24gdGhlIGN1cnZlLiBNdXN0IGJlIGluIHRoZSByYW5nZSBgWzAsMV1gLlxuXHQgKiBAcGFyYW0geyhWZWN0b3IyfFZlY3RvcjMpfSBbb3B0aW9uYWxUYXJnZXRdIC0gVGhlIG9wdGlvbmFsIHRhcmdldCB2ZWN0b3IgdGhlIHJlc3VsdCBpcyB3cml0dGVuIHRvLlxuXHQgKiBAcmV0dXJuIHsoVmVjdG9yMnxWZWN0b3IzKX0gVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS4gSXQgY2FuIGJlIGEgMkQgb3IgM0QgdmVjdG9yIGRlcGVuZGluZyBvbiB0aGUgY3VydmUgZGVmaW5pdGlvbi5cblx0ICovXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHNhbXBsZXMgdGhlIGN1cnZlIHZpYSB7QGxpbmsgQ3VydmUjZ2V0UG9pbnR9IGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHBvaW50cyByZXByZXNlbnRpbmdcblx0ICogdGhlIGN1cnZlIHNoYXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RpdmlzaW9ucz01XSAtIFRoZSBudW1iZXIgb2YgZGl2aXNpb25zLlxuXHQgKiBAcmV0dXJuIHtBcnJheTwoVmVjdG9yMnxWZWN0b3IzKT59IEFuIGFycmF5IGhvbGRpbmcgdGhlIHNhbXBsZWQgY3VydmUgdmFsdWVzLiBUaGUgbnVtYmVyIG9mIHBvaW50cyBpcyBgZGl2aXNpb25zICsgMWAuXG5cdCAqL1xuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDUgKSB7XG5cblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fVxuXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHNhbXBsZXMgdGhlIGN1cnZlIHZpYSB7QGxpbmsgQ3VydmUjZ2V0UG9pbnRBdH0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcG9pbnRzIHJlcHJlc2VudGluZ1xuXHQgKiB0aGUgY3VydmUgc2hhcGUuIFVubGlrZSB7QGxpbmsgQ3VydmUjZ2V0UG9pbnRzfSwgdGhpcyBtZXRob2QgcmV0dXJucyBlcXVpLXNwYWNlZCBwb2ludHMgYWNyb3NzIHRoZSBlbnRpcmVcblx0ICogY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGl2aXNpb25zPTVdIC0gVGhlIG51bWJlciBvZiBkaXZpc2lvbnMuXG5cdCAqIEByZXR1cm4ge0FycmF5PChWZWN0b3IyfFZlY3RvcjMpPn0gQW4gYXJyYXkgaG9sZGluZyB0aGUgc2FtcGxlZCBjdXJ2ZSB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIGBkaXZpc2lvbnMgKyAxYC5cblx0ICovXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdG90YWwgYXJjIGxlbmd0aCBvZiB0aGUgY3VydmUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgY3VydmUuXG5cdCAqL1xuXHRnZXRMZW5ndGgoKSB7XG5cblx0XHRjb25zdCBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cdFx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3RocyBvZiB0aGUgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGl2aXNpb25zPXRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zXSAtIFRoZSBudW1iZXIgb2YgZGl2aXNpb25zLlxuXHQgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBob2xkaW5nIHRoZSBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Rocy5cblx0ICovXG5cdGdldExlbmd0aHMoIGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zICkge1xuXG5cdFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJlxuXHRcdFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxuXHRcdFx0ISB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRjb25zdCBjYWNoZSA9IFtdO1xuXHRcdGxldCBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuXHRcdGxldCBzdW0gPSAwO1xuXG5cdFx0Y2FjaGUucHVzaCggMCApO1xuXG5cdFx0Zm9yICggbGV0IHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQoIHAgLyBkaXZpc2lvbnMgKTtcblx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xuXHRcdFx0bGFzdCA9IGN1cnJlbnQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG5cdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06IHN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgY3VtdWxhdGl2ZSBzZWdtZW50IGRpc3RhbmNlIGNhY2hlLiBUaGUgbWV0aG9kIG11c3QgYmUgY2FsbGVkXG5cdCAqIGV2ZXJ5IHRpbWUgY3VydmUgcGFyYW1ldGVycyBhcmUgY2hhbmdlZC4gSWYgYW4gdXBkYXRlZCBjdXJ2ZSBpcyBwYXJ0IG9mIGFcblx0ICogY29tcG9zZWQgY3VydmUgbGlrZSB7QGxpbmsgQ3VydmVQYXRofSwgdGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgb24gdGhlXG5cdCAqIGNvbXBvc2VkIGN1cnZlLCB0b28uXG5cdCAqL1xuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlbiBhbiBpbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgcmFuZ2UgYFswLDFdYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhbiB1cGRhdGVkXG5cdCAqIGludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBzYW1lIHJhbmdlIHRoYXQgY2FuIGJlIHVlZCB0byBzYW1wbGUgZXF1aWRpc3RhbnQgcG9pbnRzXG5cdCAqIGZyb20gYSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHUgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqIEBwYXJhbSB7P251bWJlcn0gZGlzdGFuY2UgLSBBbiBvcHRpb25hbCBkaXN0YW5jZSBvbiB0aGUgY3VydmUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHVwZGF0ZWQgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqL1xuXHRnZXRVdG9UbWFwcGluZyggdSwgZGlzdGFuY2UgPSBudWxsICkge1xuXG5cdFx0Y29uc3QgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0XHRsZXQgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuXHRcdGlmICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuXHRcdGxldCBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xuXG5cdFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cblx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cblx0XHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XG5cblx0XHRcdFx0bG93ID0gaSArIDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG5cdFx0XHRcdGhpZ2ggPSBpIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRoaWdoID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gRE9ORVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpID0gaGlnaDtcblxuXHRcdGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiBpIC8gKCBpbCAtIDEgKTtcblxuXHRcdH1cblxuXHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblx0XHRjb25zdCBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG5cdFx0Y29uc3QgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG5cdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuXHRcdGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0Y29uc3QgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuXHRcdHJldHVybiB0O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgZm9yIHRoZSBnaXZlbiBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cblx0ICogSWYgdGhlIGRlcml2ZWQgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG5cdCAqIHR3byBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcblx0ICogd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqIEBwYXJhbSB7KFZlY3RvcjJ8VmVjdG9yMyl9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4geyhWZWN0b3IyfFZlY3RvcjMpfSBUaGUgdGFuZ2VudCB2ZWN0b3IuXG5cdCAqL1xuXHRnZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuXHRcdGxldCB0MSA9IHQgLSBkZWx0YTtcblx0XHRsZXQgdDIgPSB0ICsgZGVsdGE7XG5cblx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cblx0XHRpZiAoIHQxIDwgMCApIHQxID0gMDtcblx0XHRpZiAoIHQyID4gMSApIHQyID0gMTtcblxuXHRcdGNvbnN0IHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XG5cdFx0Y29uc3QgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcblxuXHRcdGNvbnN0IHRhbmdlbnQgPSBvcHRpb25hbFRhcmdldCB8fCAoICggcHQxLmlzVmVjdG9yMiApID8gbmV3IFZlY3RvcjIoKSA6IG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdHRhbmdlbnQuY29weSggcHQyICkuc3ViKCBwdDEgKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0YW5nZW50O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2FtZSBhcyB7QGxpbmsgQ3VydmUjZ2V0VGFuZ2VudH0gYnV0IHdpdGggZXF1aWRpc3RhbnQgc2FtcGxlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHUgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqIEBwYXJhbSB7KFZlY3RvcjJ8VmVjdG9yMyl9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4geyhWZWN0b3IyfFZlY3RvcjMpfSBUaGUgdGFuZ2VudCB2ZWN0b3IuXG5cdCAqIEBzZWUge0BsaW5rIEN1cnZlI2dldFBvaW50QXR9XG5cdCAqL1xuXHRnZXRUYW5nZW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHRoZSBGcmVuZXQgRnJhbWVzLiBSZXF1aXJlcyBhIGN1cnZlIGRlZmluaXRpb24gaW4gM0Qgc3BhY2UuIFVzZWRcblx0ICogaW4gZ2VvbWV0cmllcyBsaWtlIHtAbGluayBUdWJlR2VvbWV0cnl9IG9yIHtAbGluayBFeHRydWRlR2VvbWV0cnl9LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudHMgLSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbG9zZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgY3VydmUgaXMgY2xvc2VkIG9yIG5vdC5cblx0ICogQHJldHVybiB7e3RhbmdlbnRzOiBBcnJheTxWZWN0b3IzPiwgbm9ybWFsczogQXJyYXk8VmVjdG9yMz4sIGJpbm9ybWFsczogQXJyYXk8VmVjdG9yMz59fSBUaGUgRnJlbmV0IEZyYW1lcy5cblx0ICovXG5cdGNvbXB1dGVGcmVuZXRGcmFtZXMoIHNlZ21lbnRzLCBjbG9zZWQgPSBmYWxzZSApIHtcblxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCB0YW5nZW50cyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCBiaW5vcm1hbHMgPSBbXTtcblxuXHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXG5cdFx0XHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRjb25zdCB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHRjb25zdCB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHRjb25zdCB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gbWluICkge1xuXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKCBjbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRcdGlmICggY2xvc2VkID09PSB0cnVlICkge1xuXG5cdFx0XHRsZXQgdGhldGEgPSBNYXRoLmFjb3MoIGNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcblxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XG5cblx0XHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGN1cnZlIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0N1cnZlfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBjdXJ2ZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0N1cnZlfSBzb3VyY2UgLSBUaGUgY3VydmUgdG8gY29weS5cblx0ICogQHJldHVybiB7Q3VydmV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY3VydmUuXG5cdCAqL1xuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIGN1cnZlIGludG8gSlNPTi5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXplZCBjdXJ2ZS5cblx0ICogQHNlZSB7QGxpbmsgT2JqZWN0TG9hZGVyI3BhcnNlfVxuXHQgKi9cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVzZXJpYWxpemVzIHRoZSBjdXJ2ZSBmcm9tIHRoZSBnaXZlbiBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIGhvbGRpbmcgdGhlIHNlcmlhbGl6ZWQgY3VydmUuXG5cdCAqIEByZXR1cm4ge0N1cnZlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGN1cnZlLlxuXHQgKi9cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IGpzb24uYXJjTGVuZ3RoRGl2aXNpb25zO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQ3VydmUgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuLyoqXG4gKiBBIGN1cnZlIHJlcHJlc2VudGluZyBhbiBlbGxpcHNlLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoXG4gKiBcdDAsIDAsXG4gKiBcdDEwLCAxMCxcbiAqIFx0MCwgMiAqIE1hdGguUEksXG4gKiBcdGZhbHNlLFxuICogXHQwXG4gKiApO1xuICpcbiAqIGNvbnN0IHBvaW50cyA9IGN1cnZlLmdldFBvaW50cyggNTAgKTtcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG4gKlxuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmYwMDAwIH0gKTtcbiAqXG4gKiAvLyBDcmVhdGUgdGhlIGZpbmFsIG9iamVjdCB0byBhZGQgdG8gdGhlIHNjZW5lXG4gKiBjb25zdCBlbGxpcHNlID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIEN1cnZlXG4gKi9cbmNsYXNzIEVsbGlwc2VDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBlbGxpcHNlIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FYPTBdIC0gVGhlIFggY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FZPTBdIC0gVGhlIFkgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3hSYWRpdXM9MV0gLSBUaGUgcmFkaXVzIG9mIHRoZSBlbGxpcHNlIGluIHRoZSB4IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5UmFkaXVzPTFdIC0gVGhlIHJhZGl1cyBvZiB0aGUgZWxsaXBzZSBpbiB0aGUgeSBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYVN0YXJ0QW5nbGU9MF0gLSBUaGUgc3RhcnQgYW5nbGUgb2YgdGhlIGN1cnZlIGluIHJhZGlhbnMgc3RhcnRpbmcgZnJvbSB0aGUgcG9zaXRpdmUgWCBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FFbmRBbmdsZT1NYXRoLlBJKjJdIC0gVGhlIGVuZCBhbmdsZSBvZiB0aGUgY3VydmUgaW4gcmFkaWFucyBzdGFydGluZyBmcm9tIHRoZSBwb3NpdGl2ZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FDbG9ja3dpc2U9ZmFsc2VdIC0gV2hldGhlciB0aGUgZWxsaXBzZSBpcyBkcmF3biBjbG9ja3dpc2Ugb3Igbm90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FSb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgZWxsaXBzZSBpbiByYWRpYW5zLCBjb3VudGVyY2xvY2t3aXNlIGZyb20gdGhlIHBvc2l0aXZlIFggYXhpcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhWCA9IDAsIGFZID0gMCwgeFJhZGl1cyA9IDEsIHlSYWRpdXMgPSAxLCBhU3RhcnRBbmdsZSA9IDAsIGFFbmRBbmdsZSA9IE1hdGguUEkgKiAyLCBhQ2xvY2t3aXNlID0gZmFsc2UsIGFSb3RhdGlvbiA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBYIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuYVggPSBhWDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBZIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuYVkgPSBhWTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYWRpdXMgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHggZGlyZWN0aW9uLlxuXHRcdCAqIFNldHRpbmcgdGhlIHRoaXMgdmFsdWUgZXF1YWwgdG8gdGhlIHtAbGluayBFbGxpcHNlQ3VydmUjeVJhZGl1c30gd2lsbCByZXN1bHQgaW4gYSBjaXJjbGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhZGl1cyBvZiB0aGUgZWxsaXBzZSBpbiB0aGUgeSBkaXJlY3Rpb24uXG5cdFx0ICogU2V0dGluZyB0aGUgdGhpcyB2YWx1ZSBlcXVhbCB0byB0aGUge0BsaW5rIEVsbGlwc2VDdXJ2ZSN4UmFkaXVzfSB3aWxsIHJlc3VsdCBpbiBhIGNpcmNsZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3RhcnQgYW5nbGUgb2YgdGhlIGN1cnZlIGluIHJhZGlhbnMgc3RhcnRpbmcgZnJvbSB0aGUgcG9zaXRpdmUgWCBheGlzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVuZCBhbmdsZSBvZiB0aGUgY3VydmUgaW4gcmFkaWFucyBzdGFydGluZyBmcm9tIHRoZSBwb3NpdGl2ZSBYIGF4aXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IE1hdGguUEkqMlxuXHRcdCAqL1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgZWxsaXBzZSBpcyBkcmF3biBjbG9ja3dpc2Ugb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGluIHJhZGlhbnMsIGNvdW50ZXJjbG9ja3dpc2UgZnJvbSB0aGUgcG9zaXRpdmUgWCBheGlzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb247XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIEEgaW50ZXJwb2xhdGlvbiBmYWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gb24gdGhlIGN1cnZlLiBNdXN0IGJlIGluIHRoZSByYW5nZSBgWzAsMV1gLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuXG5cdCAqL1xuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHR3b1BpID0gTWF0aC5QSSAqIDI7XG5cdFx0bGV0IGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cdFx0Y29uc3Qgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcblxuXHRcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA+IHR3b1BpICkgZGVsdGFBbmdsZSAtPSB0d29QaTtcblxuXHRcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdGlmICggZGVsdGFBbmdsZSA9PT0gdHdvUGkgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cdFx0bGV0IHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0bGV0IHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG5cdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xuXG5cdFx0XHRjb25zdCB0eCA9IHggLSB0aGlzLmFYO1xuXHRcdFx0Y29uc3QgdHkgPSB5IC0gdGhpcy5hWTtcblxuXHRcdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHRcdFx0eCA9IHR4ICogY29zIC0gdHkgKiBzaW4gKyB0aGlzLmFYO1xuXHRcdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50LnNldCggeCwgeSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuYVggPSBzb3VyY2UuYVg7XG5cdFx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcblxuXHRcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xuXG5cdFx0dGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IHNvdXJjZS5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBzb3VyY2UuYUNsb2Nrd2lzZTtcblxuXHRcdHRoaXMuYVJvdGF0aW9uID0gc291cmNlLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmFYID0gdGhpcy5hWDtcblx0XHRkYXRhLmFZID0gdGhpcy5hWTtcblxuXHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcblx0XHRkYXRhLnlSYWRpdXMgPSB0aGlzLnlSYWRpdXM7XG5cblx0XHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xuXG5cdFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xuXG5cdFx0ZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmFYID0ganNvbi5hWDtcblx0XHR0aGlzLmFZID0ganNvbi5hWTtcblxuXHRcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcblx0XHR0aGlzLnlSYWRpdXMgPSBqc29uLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xuXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBqc29uLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBFbGxpcHNlQ3VydmUgfTtcbiIsImltcG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4vRWxsaXBzZUN1cnZlLmpzJztcblxuLyoqXG4gKiBBIGN1cnZlIHJlcHJlc2VudGluZyBhbiBhcmMuXG4gKlxuICogQGF1Z21lbnRzIEVsbGlwc2VDdXJ2ZVxuICovXG5jbGFzcyBBcmNDdXJ2ZSBleHRlbmRzIEVsbGlwc2VDdXJ2ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYXJjIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FYPTBdIC0gVGhlIFggY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FZPTBdIC0gVGhlIFkgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FSYWRpdXM9MV0gLSBUaGUgcmFkaXVzIG9mIHRoZSBlbGxpcHNlIGluIHRoZSB4IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthU3RhcnRBbmdsZT0wXSAtIFRoZSBzdGFydCBhbmdsZSBvZiB0aGUgY3VydmUgaW4gcmFkaWFucyBzdGFydGluZyBmcm9tIHRoZSBwb3NpdGl2ZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYUVuZEFuZ2xlPU1hdGguUEkqMl0gLSBUaGUgZW5kIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBpbiByYWRpYW5zIHN0YXJ0aW5nIGZyb20gdGhlIHBvc2l0aXZlIFggYXhpcy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbYUNsb2Nrd2lzZT1mYWxzZV0gLSBXaGV0aGVyIHRoZSBlbGxpcHNlIGlzIGRyYXduIGNsb2Nrd2lzZSBvciBub3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0c3VwZXIoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0FyY0N1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFyY0N1cnZlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5cbmZ1bmN0aW9uIEN1YmljUG9seSgpIHtcblxuXHQvKipcblx0ICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcblx0KiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cblx0KiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuXHQqXG5cdCogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG5cdCogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuXHQqL1xuXG5cdC8qXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cblx0LSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuXHQtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG5cdFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG5cdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cblx0Ki9cblxuXHRsZXQgYzAgPSAwLCBjMSA9IDAsIGMyID0gMCwgYzMgPSAwO1xuXG5cdC8qXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcblx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdCAqIHN1Y2ggdGhhdFxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG5cdCAqICBhbmRcblx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdCggeDAsIHgxLCB0MCwgdDEgKSB7XG5cblx0XHRjMCA9IHgwO1xuXHRcdGMxID0gdDA7XG5cdFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuXHRcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGluaXRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xuXG5cdFx0XHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XG5cblx0XHR9LFxuXG5cdFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXG5cdFx0XHRsZXQgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuXHRcdFx0bGV0IHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuXHRcdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cdFx0XHR0MSAqPSBkdDE7XG5cdFx0XHR0MiAqPSBkdDE7XG5cblx0XHRcdGluaXQoIHgxLCB4MiwgdDEsIHQyICk7XG5cblx0XHR9LFxuXG5cdFx0Y2FsYzogZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHRjb25zdCB0MiA9IHQgKiB0O1xuXHRcdFx0Y29uc3QgdDMgPSB0MiAqIHQ7XG5cdFx0XHRyZXR1cm4gYzAgKyBjMSAqIHQgKyBjMiAqIHQyICsgYzMgKiB0MztcblxuXHRcdH1cblxuXHR9O1xuXG59XG5cbi8vXG5cbmNvbnN0IHRtcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHB4ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XG5jb25zdCBweSA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmljUG9seSgpO1xuY29uc3QgcHogPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJpY1BvbHkoKTtcblxuLyoqXG4gKiBBIGN1cnZlIHJlcHJlc2VudGluZyBhIENhdG11bGwtUm9tIHNwbGluZS5cbiAqXG4gKiBgYGBqc1xuICogLy9DcmVhdGUgYSBjbG9zZWQgd2F2ZXkgbG9vcFxuICogY29uc3QgY3VydmUgPSBuZXcgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyggW1xuICogXHRuZXcgVEhSRUUuVmVjdG9yMyggLTEwLCAwLCAxMCApLFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMyggLTUsIDUsIDUgKSxcbiAqIFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSxcbiAqIFx0bmV3IFRIUkVFLlZlY3RvcjMoIDUsIC01LCA1ICksXG4gKiBcdG5ldyBUSFJFRS5WZWN0b3IzKCAxMCwgMCwgMTAgKVxuICogXSApO1xuICpcbiAqIGNvbnN0IHBvaW50cyA9IGN1cnZlLmdldFBvaW50cyggNTAgKTtcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG4gKlxuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmYwMDAwIH0gKTtcbiAqXG4gKiAvLyBDcmVhdGUgdGhlIGZpbmFsIG9iamVjdCB0byBhZGQgdG8gdGhlIHNjZW5lXG4gKiBjb25zdCBjdXJ2ZU9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBDdXJ2ZVxuICovXG5jbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IENhdG11bGwtUm9tIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PFZlY3RvcjM+fSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIDNEIHBvaW50cyBkZWZpbmluZyB0aGUgY3VydmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Nsb3NlZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBjdXJ2ZSBpcyBjbG9zZWQgb3Igbm90LlxuXHQgKiBAcGFyYW0geygnY2VudHJpcGV0YWwnfCdjaG9yZGFsJ3wnY2F0bXVsbHJvbScpfSBbY3VydmVUeXBlPSdjZW50cmlwZXRhbCddIC0gVGhlIGN1cnZlIHR5cGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGVuc2lvbj0wLjVdIC0gVGVuc2lvbiBvZiB0aGUgY3VydmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gW10sIGNsb3NlZCA9IGZhbHNlLCBjdXJ2ZVR5cGUgPSAnY2VudHJpcGV0YWwnLCB0ZW5zaW9uID0gMC41ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNDYXRtdWxsUm9tQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIDNEIHBvaW50cyBkZWZpbmluZyB0aGUgY3VydmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8VmVjdG9yMz59XG5cdFx0ICovXG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBjdXJ2ZSBpcyBjbG9zZWQgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmNsb3NlZCA9IGNsb3NlZDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJ2ZSB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeygnY2VudHJpcGV0YWwnfCdjaG9yZGFsJ3wnY2F0bXVsbHJvbScpfVxuXHRcdCAqIEBkZWZhdWx0ICdjZW50cmlwZXRhbCdcblx0XHQgKi9cblx0XHR0aGlzLmN1cnZlVHlwZSA9IGN1cnZlVHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRlbnNpb24gb2YgdGhlIGN1cnZlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwLjVcblx0XHQgKi9cblx0XHR0aGlzLnRlbnNpb24gPSB0ZW5zaW9uO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBBIGludGVycG9sYXRpb24gZmFjdG9yIHJlcHJlc2VudGluZyBhIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS4gTXVzdCBiZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbb3B0aW9uYWxUYXJnZXRdIC0gVGhlIG9wdGlvbmFsIHRhcmdldCB2ZWN0b3IgdGhlIHJlc3VsdCBpcyB3cml0dGVuIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgcG9zaXRpb24gb24gdGhlIGN1cnZlLlxuXHQgKi9cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGNvbnN0IHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0bGV0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gbCApICsgMSApICogbDtcblxuXHRcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHR3ZWlnaHQgPSAxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xuXG5cdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0cDAgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XG5cblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XG5cblx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuXHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcblx0XHRcdHAzID0gdG1wO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG5cdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuXHRcdFx0Y29uc3QgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHRsZXQgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdGxldCBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0bGV0IGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcblxuXHRcdH1cblxuXHRcdHBvaW50LnNldChcblx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblx0XHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuXHRcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ2F0bXVsbFJvbUN1cnZlMyB9O1xuIiwiLy8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG4vKipcbiAqIENvbXB1dGVzIGEgcG9pbnQgb24gYSBDYXRtdWxsLVJvbSBzcGxpbmUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgLSBUaGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gcDAgLSBUaGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwMSAtIFRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwMiAtIFRoZSB0aGlyZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHAzIC0gVGhlIGZvdXJ0aCBjb250cm9sIHBvaW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBwb2ludCBvbiBhIENhdG11bGwtUm9tIHNwbGluZS5cbiAqL1xuZnVuY3Rpb24gQ2F0bXVsbFJvbSggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0Y29uc3QgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcblx0Y29uc3QgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0Y29uc3QgdDMgPSB0ICogdDI7XG5cdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG59XG5cbi8vXG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiB0ICogdCAqIHA7XG5cbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhIHBvaW50IG9uIGEgUXVhZHJhdGljIEJlemllciBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdCAtIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwMCAtIFRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHAxIC0gVGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHAyIC0gVGhlIHRoaXJkIGNvbnRyb2wgcG9pbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjYWxjdWxhdGVkIHBvaW50IG9uIGEgUXVhZHJhdGljIEJlemllciBjdXJ2ZS5cbiAqL1xuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcblx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAyKCB0LCBwICkge1xuXG5cdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDMoIHQsIHAgKSB7XG5cblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhIHBvaW50IG9uIGEgQ3ViaWMgQmV6aWVyIGN1cnZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGludGVycG9sYXRpb24gZmFjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHAwIC0gVGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcDEgLSBUaGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcDIgLSBUaGUgdGhpcmQgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwMyAtIFRoZSBmb3VydGggY29udHJvbCBwb2ludC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNhbGN1bGF0ZWQgcG9pbnQgb24gYSBDdWJpYyBCZXppZXIgY3VydmUuXG4gKi9cbmZ1bmN0aW9uIEN1YmljQmV6aWVyKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRyZXR1cm4gQ3ViaWNCZXppZXJQMCggdCwgcDAgKSArIEN1YmljQmV6aWVyUDEoIHQsIHAxICkgKyBDdWJpY0JlemllclAyKCB0LCBwMiApICtcblx0XHRDdWJpY0JlemllclAzKCB0LCBwMyApO1xuXG59XG5cbmV4cG9ydCB7IENhdG11bGxSb20sIFF1YWRyYXRpY0JlemllciwgQ3ViaWNCZXppZXIgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBDdWJpY0JlemllciB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbi8qKlxuICogQSBjdXJ2ZSByZXByZXNlbnRpbmcgYSAyRCBDdWJpYyBCZXppZXIgY3VydmUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoXG4gKiBcdG5ldyBUSFJFRS5WZWN0b3IyKCAtIDAsIDAgKSxcbiAqIFx0bmV3IFRIUkVFLlZlY3RvcjIoIC0gNSwgMTUgKSxcbiAqIFx0bmV3IFRIUkVFLlZlY3RvcjIoIDIwLCAxNSApLFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggMTAsIDAgKVxuICogKTtcbiAqXG4gKiBjb25zdCBwb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDUwICk7XG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuICpcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmMDAwMCB9ICk7XG4gKlxuICogLy8gQ3JlYXRlIHRoZSBmaW5hbCBvYmplY3QgdG8gYWRkIHRvIHRoZSBzY2VuZVxuICogY29uc3QgY3VydmVPYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQ3VydmVcbiAqL1xuY2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBDdWJpYyBCZXppZXIgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3YwXSAtIFRoZSBzdGFydCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdjFdIC0gVGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3YyXSAtIFRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdjNdIC0gVGhlIGVuZCBwb2ludC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB2MCA9IG5ldyBWZWN0b3IyKCksIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpLCB2MyA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0YXJ0IHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy52MCA9IHYwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKi9cblx0XHR0aGlzLnYxID0gdjE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKi9cblx0XHR0aGlzLnYyID0gdjI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZW5kIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBBIGludGVycG9sYXRpb24gZmFjdG9yIHJlcHJlc2VudGluZyBhIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS4gTXVzdCBiZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9uYWxUYXJnZXRdIC0gVGhlIG9wdGlvbmFsIHRhcmdldCB2ZWN0b3IgdGhlIHJlc3VsdCBpcyB3cml0dGVuIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgcG9zaXRpb24gb24gdGhlIGN1cnZlLlxuXHQgKi9cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG4vKipcbiAqIEEgY3VydmUgcmVwcmVzZW50aW5nIGEgM0QgQ3ViaWMgQmV6aWVyIGN1cnZlLlxuICpcbiAqIEBhdWdtZW50cyBDdXJ2ZVxuICovXG5jbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBDdWJpYyBCZXppZXIgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW3YwXSAtIFRoZSBzdGFydCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbdjFdIC0gVGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW3YyXSAtIFRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbdjNdIC0gVGhlIGVuZCBwb2ludC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB2MCA9IG5ldyBWZWN0b3IzKCksIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpLCB2MyA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3RhcnQgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHQgKi9cblx0XHR0aGlzLnYwID0gdjA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZmlyc3QgY29udHJvbCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudjEgPSB2MTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbmQgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHQgKi9cblx0XHR0aGlzLnYzID0gdjM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIEEgaW50ZXJwb2xhdGlvbiBmYWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gb24gdGhlIGN1cnZlLiBNdXN0IGJlIGluIHRoZSByYW5nZSBgWzAsMV1gLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuXG5cdCAqL1xuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRcdHBvaW50LnNldChcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlMyB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuXG4vKipcbiAqIEEgY3VydmUgcmVwcmVzZW50aW5nIGEgMkQgbGluZSBzZWdtZW50LlxuICpcbiAqIEBhdWdtZW50cyBDdXJ2ZVxuICovXG5jbGFzcyBMaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbGluZSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdjFdIC0gVGhlIHN0YXJ0IHBvaW50LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt2Ml0gLSBUaGUgZW5kIHBvaW50LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3RhcnQgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKi9cblx0XHR0aGlzLnYxID0gdjE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZW5kIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBsaW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIEEgaW50ZXJwb2xhdGlvbiBmYWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gb24gdGhlIGxpbmUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIGBbMCwxXWAuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbmFsVGFyZ2V0XSAtIFRoZSBvcHRpb25hbCB0YXJnZXQgdmVjdG9yIHRoZSByZXN1bHQgaXMgd3JpdHRlbiB0by5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuXHQgKi9cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXHRnZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRyZXR1cm4gb3B0aW9uYWxUYXJnZXQuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTGluZUN1cnZlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5cbi8qKlxuICogQSBjdXJ2ZSByZXByZXNlbnRpbmcgYSAzRCBsaW5lIHNlZ21lbnQuXG4gKlxuICogQGF1Z21lbnRzIEN1cnZlXG4gKi9cbmNsYXNzIExpbmVDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbGluZSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbdjFdIC0gVGhlIHN0YXJ0IHBvaW50LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFt2Ml0gLSBUaGUgZW5kIHBvaW50LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdGFydCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudjEgPSB2MTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbmQgcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKi9cblx0XHR0aGlzLnYyID0gdjI7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGxpbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gQSBpbnRlcnBvbGF0aW9uIGZhY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBvbiB0aGUgbGluZS4gTXVzdCBiZSBpbiB0aGUgcmFuZ2UgYFswLDFdYC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbb3B0aW9uYWxUYXJnZXRdIC0gVGhlIG9wdGlvbmFsIHRhcmdldCB2ZWN0b3IgdGhlIHJlc3VsdCBpcyB3cml0dGVuIHRvLlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgcG9zaXRpb24gb24gdGhlIGxpbmUuXG5cdCAqL1xuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaW5lQ3VydmUzIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuLyoqXG4gKiBBIGN1cnZlIHJlcHJlc2VudGluZyBhIDJEIFF1YWRyYXRpYyBCZXppZXIgY3VydmUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggLSAxMCwgMCApLFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggMjAsIDE1ICksXG4gKiBcdG5ldyBUSFJFRS5WZWN0b3IyKCAxMCwgMCApXG4gKiApXG4gKlxuICogY29uc3QgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCA1MCApO1xuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcbiAqXG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwMDAgfSApO1xuICpcbiAqIC8vIENyZWF0ZSB0aGUgZmluYWwgb2JqZWN0IHRvIGFkZCB0byB0aGUgc2NlbmVcbiAqIGNvbnN0IGN1cnZlT2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIEN1cnZlXG4gKi9cbmNsYXNzIFF1YWRyYXRpY0JlemllckN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFF1YWRyYXRpYyBCZXppZXIgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3YwXSAtIFRoZSBzdGFydCBwb2ludC5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdjFdIC0gVGhlIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3YyXSAtIFRoZSBlbmQgcG9pbnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdGFydCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqL1xuXHRcdHRoaXMudjAgPSB2MDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb250cm9sIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy52MSA9IHYxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVuZCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqL1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gQSBpbnRlcnBvbGF0aW9uIGZhY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIGBbMCwxXWAuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbmFsVGFyZ2V0XSAtIFRoZSBvcHRpb25hbCB0YXJnZXQgdmVjdG9yIHRoZSByZXN1bHQgaXMgd3JpdHRlbiB0by5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS5cblx0ICovXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcblxuXHRcdHBvaW50LnNldChcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBBIGN1cnZlIHJlcHJlc2VudGluZyBhIDNEIFF1YWRyYXRpYyBCZXppZXIgY3VydmUuXG4gKlxuICogQGF1Z21lbnRzIEN1cnZlXG4gKi9cbmNsYXNzIFF1YWRyYXRpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBRdWFkcmF0aWMgQmV6aWVyIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFt2MF0gLSBUaGUgc3RhcnQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW3YxXSAtIFRoZSBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFt2Ml0gLSBUaGUgZW5kIHBvaW50LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHYwID0gbmV3IFZlY3RvcjMoKSwgdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdGFydCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudjAgPSB2MDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb250cm9sIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy52MSA9IHYxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVuZCBwb2ludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxuXHRcdCAqL1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgY3VydmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gQSBpbnRlcnBvbGF0aW9uIGZhY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIGBbMCwxXWAuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW29wdGlvbmFsVGFyZ2V0XSAtIFRoZSBvcHRpb25hbCB0YXJnZXQgdmVjdG9yIHRoZSByZXN1bHQgaXMgd3JpdHRlbiB0by5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS5cblx0ICovXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcblxuXHRcdHBvaW50LnNldChcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55ICksXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUzIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgQ2F0bXVsbFJvbSB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbi8qKlxuICogQSBjdXJ2ZSByZXByZXNlbnRpbmcgYSAyRCBzcGxpbmUgY3VydmUuXG4gKlxuICogYGBganNcbiAqIC8vIENyZWF0ZSBhIHNpbmUtbGlrZSB3YXZlXG4gKiBjb25zdCBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggW1xuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggLTEwLCAwICksXG4gKiBcdG5ldyBUSFJFRS5WZWN0b3IyKCAtNSwgNSApLFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApLFxuICogXHRuZXcgVEhSRUUuVmVjdG9yMiggNSwgLTUgKSxcbiAqIFx0bmV3IFRIUkVFLlZlY3RvcjIoIDEwLCAwIClcbiAqIF0gKTtcbiAqXG4gKiBjb25zdCBwb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDUwICk7XG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuICpcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmMDAwMCB9ICk7XG4gKlxuICogLy8gQ3JlYXRlIHRoZSBmaW5hbCBvYmplY3QgdG8gYWRkIHRvIHRoZSBzY2VuZVxuICogY29uc3Qgc3BsaW5lT2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIEN1cnZlXG4gKi9cbmNsYXNzIFNwbGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IDJEIHNwbGluZSBjdXJ2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IyPn0gW3BvaW50c10gLSAgQW4gYXJyYXkgb2YgMkQgcG9pbnRzIGRlZmluaW5nIHRoZSBjdXJ2ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIDJEIHBvaW50cyBkZWZpbmluZyB0aGUgY3VydmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8VmVjdG9yMj59XG5cdFx0ICovXG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGN1cnZlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIEEgaW50ZXJwb2xhdGlvbiBmYWN0b3IgcmVwcmVzZW50aW5nIGEgcG9zaXRpb24gb24gdGhlIGN1cnZlLiBNdXN0IGJlIGluIHRoZSByYW5nZSBgWzAsMV1gLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuXG5cdCAqL1xuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGNvbnN0IHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0Y29uc3Qgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0Y29uc3QgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0Y29uc3QgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BsaW5lQ3VydmUgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9DdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyBDdXJ2ZXMgZnJvbSAnLi4vY3VydmVzL0N1cnZlcy5qcyc7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGV4dGVuZGluZyB7QGxpbmsgQ3VydmV9LiBgQ3VydmVQYXRoYCBpcyBzaW1wbHkgYW5cbiAqIGFycmF5IG9mIGNvbm5lY3RlZCBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBBUEkgb2YgYSBjdXJ2ZS5cbiAqXG4gKiBAYXVnbWVudHMgQ3VydmVcbiAqL1xuY2xhc3MgQ3VydmVQYXRoIGV4dGVuZHMgQ3VydmUge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGN1cnZlIHBhdGguXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3VydmVQYXRoJztcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIGN1cnZlcyBkZWZpbmluZyB0aGVcblx0XHQgKiBwYXRoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PEN1cnZlPn1cblx0XHQgKi9cblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgcGF0aCBzaG91bGQgYXV0b21hdGljYWxseSBiZSBjbG9zZWRcblx0XHQgKiBieSBhIGxpbmUgY3VydmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY3VydmUgdG8gdGhpcyBjdXJ2ZSBwYXRoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0N1cnZlfSBjdXJ2ZSAtIFRoZSBjdXJ2ZSB0byBhZGQuXG5cdCAqL1xuXHRhZGQoIGN1cnZlICkge1xuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsaW5lIGN1cnZlIHRvIGNsb3NlIHRoZSBwYXRoLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtDdXJ2ZVBhdGh9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY3VydmUgcGF0aC5cblx0ICovXG5cdGNsb3NlUGF0aCgpIHtcblxuXHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHRcdGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG5cdFx0Y29uc3QgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XG5cblx0XHRpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XG5cblx0XHRcdGNvbnN0IGxpbmVUeXBlID0gKCBzdGFydFBvaW50LmlzVmVjdG9yMiA9PT0gdHJ1ZSApID8gJ0xpbmVDdXJ2ZScgOiAnTGluZUN1cnZlMyc7XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyBsaW5lVHlwZSBdKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSB2ZWN0b3IgaW4gMkQgb3IgM0Qgc3BhY2UgKGRlcGVuZGluZyBvbiB0aGUgY3VydmUgZGVmaW5pdGlvbnMpXG5cdCAqIGZvciB0aGUgZ2l2ZW4gaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gQSBpbnRlcnBvbGF0aW9uIGZhY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBvbiB0aGUgY3VydmUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIGBbMCwxXWAuXG5cdCAqIEBwYXJhbSB7KFZlY3RvcjJ8VmVjdG9yMyl9IFtvcHRpb25hbFRhcmdldF0gLSBUaGUgb3B0aW9uYWwgdGFyZ2V0IHZlY3RvciB0aGUgcmVzdWx0IGlzIHdyaXR0ZW4gdG8uXG5cdCAqIEByZXR1cm4gez8oVmVjdG9yMnxWZWN0b3IzKX0gVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZS4gSXQgY2FuIGJlIGEgMkQgb3IgM0QgdmVjdG9yIGRlcGVuZGluZyBvbiB0aGUgY3VydmUgZGVmaW5pdGlvbi5cblx0ICovXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuXHRcdC8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcblx0XHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0XHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdFx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG5cdFx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHRcdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cdFx0Y29uc3QgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuXHRcdGNvbnN0IGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXG5cblx0XHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xuXG5cdFx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcblx0XHRcdFx0Y29uc3QgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0Y29uc3QgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGkgKys7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG5cdH1cblxuXHRnZXRMZW5ndGgoKSB7XG5cblx0XHQvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG5cdFx0Ly8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG5cdFx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5cdFx0Y29uc3QgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xuXG5cdH1cblxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGxpc3Qgb2YgY3VtdWxhdGl2ZSBjdXJ2ZSBsZW5ndGhzIG9mIHRoZSBkZWZpbmVkIGN1cnZlcy5cblx0ICpcblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGN1cnZlIGxlbmd0aHMuXG5cdCAqL1xuXHRnZXRDdXJ2ZUxlbmd0aHMoKSB7XG5cblx0XHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cblx0XHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHRjb25zdCBsZW5ndGhzID0gW107XG5cdFx0bGV0IHN1bXMgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cblx0XHRyZXR1cm4gbGVuZ3RocztcblxuXHR9XG5cblx0Z2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgPSA0MCApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDEyICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cdFx0bGV0IGxhc3Q7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcblx0XHRcdGNvbnN0IHJlc29sdXRpb24gPSBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSA/IGRpdmlzaW9ucyAqIDJcblx0XHRcdFx0OiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApID8gMVxuXHRcdFx0XHRcdDogY3VydmUuaXNTcGxpbmVDdXJ2ZSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcblx0XHRcdFx0XHRcdDogZGl2aXNpb25zO1xuXG5cdFx0XHRjb25zdCBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IHB0c1sgaiBdO1xuXG5cdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuXHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBzb3VyY2UuY3VydmVzWyBpIF07XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0gc291cmNlLmF1dG9DbG9zZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdGRhdGEuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0ganNvbi5jdXJ2ZXNbIGkgXTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBDdXJ2ZVBhdGggfTtcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgQ3VydmVQYXRoIH0gZnJvbSAnLi9DdXJ2ZVBhdGguanMnO1xuaW1wb3J0IHsgRWxsaXBzZUN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0VsbGlwc2VDdXJ2ZS5qcyc7XG5pbXBvcnQgeyBTcGxpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qcyc7XG5pbXBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanMnO1xuaW1wb3J0IHsgTGluZUN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0xpbmVDdXJ2ZS5qcyc7XG5cbi8qKlxuICogQSAyRCBwYXRoIHJlcHJlc2VudGF0aW9uLiBUaGUgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgcGF0aHNcbiAqIGFuZCBjb250b3VycyBvZiAyRCBzaGFwZXMgc2ltaWxhciB0byB0aGUgMkQgQ2FudmFzIEFQSS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG4gKlxuICogcGF0aC5saW5lVG8oIDAsIDAuOCApO1xuICogcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCAwLCAxLCAwLjIsIDEgKTtcbiAqIHBhdGgubGluZVRvKCAxLCAxICk7XG4gKlxuICogY29uc3QgcG9pbnRzID0gcGF0aC5nZXRQb2ludHMoKTtcbiAqXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmIH0gKTtcbiAqXG4gKiBjb25zdCBsaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBsaW5lICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQ3VydmVQYXRoXG4gKi9cbmNsYXNzIFBhdGggZXh0ZW5kcyBDdXJ2ZVBhdGgge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBhdGguXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMj59IFtwb2ludHNdIC0gQW4gYXJyYXkgb2YgMkQgcG9pbnRzIGRlZmluaW5nIHRoZSBwYXRoLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBvaW50cyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGF0aCc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBvZmZzZXQgb2YgdGhlIHBhdGguIEFueSBuZXcgY3VydmUgYWRkZWQgd2lsbCBzdGFydCBoZXJlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcGF0aCBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIHBvaW50cy4gVGhlIHBvaW50cyBhcmUgYWRkZWRcblx0ICogdG8gdGhlIHBhdGggYXMgaW5zdGFuY2VzIG9mIHtAbGluayBMaW5lQ3VydmV9LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PFZlY3RvcjI+fSBwb2ludHMgLSBBbiBhcnJheSBvZiAyRCBwb2ludHMuXG5cdCAqIEByZXR1cm4ge1BhdGh9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGF0aC5cblx0ICovXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubW92ZVRvKCBwb2ludHNbIDAgXS54LCBwb2ludHNbIDAgXS55ICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5saW5lVG8oIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogTW92ZXMge0BsaW5rIFBhdGgjY3VycmVudFBvaW50fSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHtQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHBhdGguXG5cdCAqL1xuXHRtb3ZlVG8oIHgsIHkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTGluZUN1cnZlfSB0byB0aGUgcGF0aCBieSBjb25uZWN0aW5nXG5cdCAqIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuXHQgKiBAcmV0dXJuIHtQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHBhdGguXG5cdCAqL1xuXHRsaW5lVG8oIHgsIHkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUoIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFF1YWRyYXRpY0JlemllckN1cnZlfSB0byB0aGUgcGF0aCBieSBjb25uZWN0aW5nXG5cdCAqIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYUNQeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFZIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuXHQgKiBAcmV0dXJuIHtQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHBhdGguXG5cdCAqL1xuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIHtAbGluayBDdWJpY0JlemllckN1cnZlfSB0byB0aGUgcGF0aCBieSBjb25uZWN0aW5nXG5cdCAqIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDF4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhQ1AyeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cblx0ICogQHJldHVybiB7UGF0aH0gQSByZWZlcmVuY2UgdG8gdGhpcyBwYXRoLlxuXHQgKi9cblx0YmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIHtAbGluayBTcGxpbmVDdXJ2ZX0gdG8gdGhlIHBhdGggYnkgY29ubmVjdGluZ1xuXHQgKiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIHBvaW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IyPn0gcHRzIC0gQW4gYXJyYXkgb2YgcG9pbnRzIGluIDJEIHNwYWNlLlxuXHQgKiBAcmV0dXJuIHtQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHBhdGguXG5cdCAqL1xuXHRzcGxpbmVUaHJ1KCBwdHMgKSB7XG5cblx0XHRjb25zdCBucHRzID0gWyB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpIF0uY29uY2F0KCBwdHMgKTtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFyYyBhcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRWxsaXBzZUN1cnZlfSB0byB0aGUgcGF0aCwgcG9zaXRpb25lZCByZWxhdGl2ZVxuXHQgKiB0byB0aGUgY3VycmVudCBwb2ludC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFYIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBhcmMgb2Zmc2V0dGVkIGZyb20gdGhlIHByZXZpb3VzIGN1cnZlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGFyYyBvZmZzZXR0ZWQgZnJvbSB0aGUgcHJldmlvdXMgY3VydmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhUmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVN0YXJ0QW5nbGUgLSBUaGUgc3RhcnQgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFFbmRBbmdsZSAtIFRoZSBlbmQgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbYUNsb2Nrd2lzZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHN3ZWVwIHRoZSBhcmMgY2xvY2t3aXNlIG9yIG5vdC5cblx0ICogQHJldHVybiB7UGF0aH0gQSByZWZlcmVuY2UgdG8gdGhpcyBwYXRoLlxuXHQgKi9cblx0YXJjKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG5cdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFyYyBhcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRWxsaXBzZUN1cnZlfSB0byB0aGUgcGF0aC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFYIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBhcmMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgYXJjLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFTdGFydEFuZ2xlIC0gVGhlIHN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhRW5kQW5nbGUgLSBUaGUgZW5kIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FDbG9ja3dpc2U9ZmFsc2VdIC0gV2hldGhlciB0byBzd2VlcCB0aGUgYXJjIGNsb2Nrd2lzZSBvciBub3QuXG5cdCAqIEByZXR1cm4ge1BhdGh9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGF0aC5cblx0ICovXG5cdGFic2FyYyggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBlbGxpcHNlIGFzIGFuIGluc3RhbmNlIG9mIHtAbGluayBFbGxpcHNlQ3VydmV9IHRvIHRoZSBwYXRoLCBwb3NpdGlvbmVkIHJlbGF0aXZlXG5cdCAqIHRvIHRoZSBjdXJyZW50IHBvaW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZSBvZmZzZXR0ZWQgZnJvbSB0aGUgcHJldmlvdXMgY3VydmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZSBvZmZzZXR0ZWQgZnJvbSB0aGUgcHJldmlvdXMgY3VydmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4UmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgZWxsaXBzZSBpbiB0aGUgeCBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geVJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHkgYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFTdGFydEFuZ2xlIC0gVGhlIHN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhRW5kQW5nbGUgLSBUaGUgZW5kIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FDbG9ja3dpc2U9ZmFsc2VdIC0gV2hldGhlciB0byBzd2VlcCB0aGUgZWxsaXBzZSBjbG9ja3dpc2Ugb3Igbm90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FSb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgZWxsaXBzZSBpbiByYWRpYW5zLCBjb3VudGVyY2xvY2t3aXNlIGZyb20gdGhlIHBvc2l0aXZlIFggYXhpcy5cblx0ICogQHJldHVybiB7UGF0aH0gQSByZWZlcmVuY2UgdG8gdGhpcyBwYXRoLlxuXHQgKi9cblx0ZWxsaXBzZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxsaXBzZSBhcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRWxsaXBzZUN1cnZlfSB0byB0aGUgcGF0aC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFYIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgYWJzb2x1dGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBhYnNvbHV0ZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4UmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgZWxsaXBzZSBpbiB0aGUgeCBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geVJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHkgYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFTdGFydEFuZ2xlIC0gVGhlIHN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhRW5kQW5nbGUgLSBUaGUgZW5kIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FDbG9ja3dpc2U9ZmFsc2VdIC0gV2hldGhlciB0byBzd2VlcCB0aGUgZWxsaXBzZSBjbG9ja3dpc2Ugb3Igbm90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FSb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgZWxsaXBzZSBpbiByYWRpYW5zLCBjb3VudGVyY2xvY2t3aXNlIGZyb20gdGhlIHBvc2l0aXZlIFggYXhpcy5cblx0ICogQHJldHVybiB7UGF0aH0gQSByZWZlcmVuY2UgdG8gdGhpcyBwYXRoLlxuXHQgKi9cblx0YWJzZWxsaXBzZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG5cdFx0XHRjb25zdCBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xuXG5cdFx0XHRcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0Y29uc3QgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHNvdXJjZS5jdXJyZW50UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBQYXRoIH07XG4iLCJpbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9QYXRoLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJy4uLy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuLyoqXG4gKiBEZWZpbmVzIGFuIGFyYml0cmFyeSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocyB3aXRoIG9wdGlvbmFsIGhvbGVzLiBJdFxuICogY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgRXh0cnVkZUdlb21ldHJ5fSwge0BsaW5rIFNoYXBlR2VvbWV0cnl9LCB0byBnZXRcbiAqIHBvaW50cywgb3IgdG8gZ2V0IHRyaWFuZ3VsYXRlZCBmYWNlcy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaGVhcnRTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICpcbiAqIGhlYXJ0U2hhcGUubW92ZVRvKCAyNSwgMjUgKTtcbiAqIGhlYXJ0U2hhcGUuYmV6aWVyQ3VydmVUbyggMjUsIDI1LCAyMCwgMCwgMCwgMCApO1xuICogaGVhcnRTaGFwZS5iZXppZXJDdXJ2ZVRvKCAtIDMwLCAwLCAtIDMwLCAzNSwgLSAzMCwgMzUgKTtcbiAqIGhlYXJ0U2hhcGUuYmV6aWVyQ3VydmVUbyggLSAzMCwgNTUsIC0gMTAsIDc3LCAyNSwgOTUgKTtcbiAqIGhlYXJ0U2hhcGUuYmV6aWVyQ3VydmVUbyggNjAsIDc3LCA4MCwgNTUsIDgwLCAzNSApO1xuICogaGVhcnRTaGFwZS5iZXppZXJDdXJ2ZVRvKCA4MCwgMzUsIDgwLCAwLCA1MCwgMCApO1xuICogaGVhcnRTaGFwZS5iZXppZXJDdXJ2ZVRvKCAzNSwgMCwgMjUsIDI1LCAyNSwgMjUgKTtcbiAqXG4gKiBjb25zdCBleHRydWRlU2V0dGluZ3MgPSB7XG4gKiBcdGRlcHRoOiA4LFxuICogXHRiZXZlbEVuYWJsZWQ6IHRydWUsXG4gKiBcdGJldmVsU2VnbWVudHM6IDIsXG4gKiBcdHN0ZXBzOiAyLFxuICogXHRiZXZlbFNpemU6IDEsXG4gKiBcdGJldmVsVGhpY2tuZXNzOiAxXG4gKiB9O1xuICpcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggaGVhcnRTaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XG4gKiBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoKSApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIFBhdGhcbiAqL1xuY2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFwZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IyPn0gW3BvaW50c10gLSBBbiBhcnJheSBvZiAyRCBwb2ludHMgZGVmaW5pbmcgdGhlIHNoYXBlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBvaW50cyApIHtcblxuXHRcdHN1cGVyKCBwb2ludHMgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBVVUlEIG9mIHRoZSBzaGFwZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgaG9sZXMgaW4gdGhlIHNoYXBlLiBIb2xlIGRlZmluaXRpb25zIG11c3QgdXNlIHRoZVxuXHRcdCAqIG9wcG9zaXRlIHdpbmRpbmcgb3JkZXIgKENXL0NDVykgdGhhbiB0aGUgb3V0ZXIgc2hhcGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8UGF0aD59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSByZXByZXNlbnRpbmcgZWFjaCBjb250b3VyIG9mIHRoZSBob2xlc1xuXHQgKiBhcyBhIGxpc3Qgb2YgMkQgcG9pbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNpb25zIC0gVGhlIGZpbmVuZXNzIG9mIHRoZSByZXN1bHQuXG5cdCAqIEByZXR1cm4ge0FycmF5PEFycmF5PFZlY3RvcjI+Pn0gVGhlIGhvbGVzIGFzIGEgc2VyaWVzIG9mIDJEIHBvaW50cy5cblx0ICovXG5cdGdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRjb25zdCBob2xlc1B0cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaG9sZXNQdHM7XG5cblx0fVxuXG5cdC8vIGdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhvbGRzIGNvbnRvdXIgZGF0YSBmb3IgdGhlIHNoYXBlIGFuZCBpdHMgaG9sZXMgYXNcblx0ICogYXJyYXlzIG9mIDJEIHBvaW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyAtIFRoZSBmaW5lbmVzcyBvZiB0aGUgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHt7c2hhcGU6QXJyYXk8VmVjdG9yMj4saG9sZXM6QXJyYXk8QXJyYXk8VmVjdG9yMj4+fX0gQW4gb2JqZWN0IHdpdGggY29udG91ciBkYXRhLlxuXHQgKi9cblx0ZXh0cmFjdFBvaW50cyggZGl2aXNpb25zICkge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG5cdFx0fTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzb3VyY2UuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaG9sZSA9IHNvdXJjZS5ob2xlc1sgaSBdO1xuXG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRkYXRhLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhvbGUgPSB0aGlzLmhvbGVzWyBpIF07XG5cdFx0XHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBob2xlID0ganNvbi5ob2xlc1sgaSBdO1xuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKCBuZXcgUGF0aCgpLmZyb21KU09OKCBob2xlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFNoYXBlIH07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gY29weSBvZiBtYXBib3gvZWFyY3V0IHZlcnNpb24gMy4wLjFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0L3RyZWUvdjMuMC4xXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltID0gMikge1xuXG4gICAgY29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgbGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSk7XG4gICAgY29uc3QgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICBsZXQgbWluWCwgbWluWSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgbWluWSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICBsZXQgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpIC8gZGltIHwgMCwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpIC8gZGltIHwgMCwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICBsZXQgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgbGV0IHN0b3AgPSBlYXI7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgY29uc3QgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSwgZWFyLmksIG5leHQuaSk7IC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcyk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIGNvbnN0IGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICBjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveFxuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oYXgsIGJ4LCBjeCksXG4gICAgICAgIHkwID0gTWF0aC5taW4oYXksIGJ5LCBjeSksXG4gICAgICAgIHgxID0gTWF0aC5tYXgoYXgsIGJ4LCBjeCksXG4gICAgICAgIHkxID0gTWF0aC5tYXgoYXksIGJ5LCBjeSk7XG5cbiAgICBsZXQgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGVFeGNlcHRGaXJzdChheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgY29uc3QgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICBjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveFxuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oYXgsIGJ4LCBjeCksXG4gICAgICAgIHkwID0gTWF0aC5taW4oYXksIGJ5LCBjeSksXG4gICAgICAgIHgxID0gTWF0aC5tYXgoYXgsIGJ4LCBjeCksXG4gICAgICAgIHkxID0gTWF0aC5tYXgoYXksIGJ5LCBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIGNvbnN0IG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgbGV0IHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGVFeGNlcHRGaXJzdChheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMpIHtcbiAgICBsZXQgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSwgcC5pLCBiLmkpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgbGV0IGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGxldCBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgbGV0IGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGNvbnN0IGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYWVNsb3BlKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYWVNsb3BlKGEsIGIpIHtcbiAgICBsZXQgcmVzdWx0ID0gYS54IC0gYi54O1xuICAgIC8vIHdoZW4gdGhlIGxlZnQtbW9zdCBwb2ludCBvZiAyIGhvbGVzIG1lZXQgYXQgYSB2ZXJ0ZXgsIHNvcnQgdGhlIGhvbGVzIGNvdW50ZXJjbG9ja3dpc2Ugc28gdGhhdCB3aGVuIHdlIGZpbmRcbiAgICAvLyB0aGUgYnJpZGdlIHRvIHRoZSBvdXRlciBzaGVsbCBpcyBhbHdheXMgdGhlIHBvaW50IHRoYXQgdGhleSBtZWV0IGF0LlxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gYS55IC0gYi55O1xuICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhU2xvcGUgPSAoYS5uZXh0LnkgLSBhLnkpIC8gKGEubmV4dC54IC0gYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGJTbG9wZSA9IChiLm5leHQueSAtIGIueSkgLyAoYi5uZXh0LnggLSBiLngpO1xuICAgICAgICAgICAgcmVzdWx0ID0gYVNsb3BlIC0gYlNsb3BlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBjb25zdCBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgbGV0IHAgPSBvdXRlck5vZGU7XG4gICAgY29uc3QgaHggPSBob2xlLng7XG4gICAgY29uc3QgaHkgPSBob2xlLnk7XG4gICAgbGV0IHF4ID0gLUluZmluaXR5O1xuICAgIGxldCBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICAvLyB1bmxlc3MgdGhleSBpbnRlcnNlY3QgYXQgYSB2ZXJ0ZXgsIHRoZW4gY2hvb3NlIHRoZSB2ZXJ0ZXhcbiAgICBpZiAoZXF1YWxzKGhvbGUsIHApKSByZXR1cm4gcDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChlcXVhbHMoaG9sZSwgcC5uZXh0KSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgZWxzZSBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIGNvbnN0IHN0b3AgPSBtO1xuICAgIGNvbnN0IG14ID0gbS54O1xuICAgIGNvbnN0IG15ID0gbS55O1xuICAgIGxldCB0YW5NaW4gPSBJbmZpbml0eTtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICBjb25zdCB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIGxldCBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICBsZXQgbnVtTWVyZ2VzO1xuICAgIGxldCBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBsZXQgcCA9IGxpc3Q7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgbGV0IHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIGxldCBxID0gcDtcbiAgICAgICAgICAgIGxldCBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIGxldCBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlIGJ1dCBmYWxzZSBpZiBpdHMgZXF1YWwgdG8gdGhlIGZpcnN0IHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuICEoYXggPT09IHB4ICYmIGF5ID09PSBweSkgJiYgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICBjb25zdCBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgY29uc3QgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIGNvbnN0IG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICBjb25zdCBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgbGV0IHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgbGV0IHAgPSBhO1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBjb25zdCBweCA9IChhLnggKyBiLngpIC8gMjtcbiAgICBjb25zdCBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgY29uc3QgYTIgPSBjcmVhdGVOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IGNyZWF0ZU5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIGNvbnN0IHAgPSBjcmVhdGVOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShpLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaSwgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgICAgIHgsIHksIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgICAgICBwcmV2OiBudWxsLCAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgejogMCwgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgICAgICBwcmV2WjogbnVsbCwgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgICAgICBuZXh0WjogbnVsbCxcbiAgICAgICAgc3RlaW5lcjogZmFsc2UgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB9O1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGRldmlhdGlvbihkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICBjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIGxldCBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICBjb25zdCBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgY29uc3QgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufVxuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGRhdGEpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgIGNvbnN0IGhvbGVzID0gW107XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGRhdGFbMF1bMF0ubGVuZ3RoO1xuICAgIGxldCBob2xlSW5kZXggPSAwO1xuICAgIGxldCBwcmV2TGVuID0gMDtcblxuICAgIGZvciAoY29uc3QgcmluZyBvZiBkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiByaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbWVuc2lvbnM7IGQrKykgdmVydGljZXMucHVzaChwW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkxlbikge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IHByZXZMZW47XG4gICAgICAgICAgICBob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkxlbiA9IHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4ge3ZlcnRpY2VzLCBob2xlcywgZGltZW5zaW9uc307XG59XG4iLCJpbXBvcnQgZWFyY3V0IGZyb20gJy4vbGliL2VhcmN1dC5qcyc7XG5cbmNsYXNzIEVhcmN1dCB7XG5cblx0LyoqXG5cdCAqIFRyaWFuZ3VsYXRlcyB0aGUgZ2l2ZW4gc2hhcGUgZGVmaW5pdGlvbiBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdHJpYW5nbGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhdGEgLSBBbiBhcnJheSB3aXRoIDJEIHBvaW50cy5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBob2xlSW5kaWNlcyAtIEFuIGFycmF5IHdpdGggaW5kaWNlcyBkZWZpbmluZyBob2xlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaW09Ml0gLSBUaGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIHBlciB2ZXJ0ZXggaW4gdGhlIGlucHV0IGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHRyaWFuZ3VsYXRlZCBmYWNlcy4gRWFjaCBmYWNlIGlzIGRlZmluZWQgYnkgdGhyZWUgY29uc2VjdXRpdmUgbnVtYmVyc1xuXHQgKiByZXByZXNlbnRpbmcgdmVydGV4IGluZGljZXMuXG5cdCAqL1xuXHRzdGF0aWMgdHJpYW5ndWxhdGUoIGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gPSAyICkge1xuXG5cdFx0cmV0dXJuIGVhcmN1dCggZGF0YSwgaG9sZUluZGljZXMsIGRpbSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBFYXJjdXQgfTtcbiIsImltcG9ydCB7IEVhcmN1dCB9IGZyb20gJy4vRWFyY3V0LmpzJztcblxuLyoqXG4gKiBBIGNsYXNzIGNvbnRhaW5pbmcgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHNoYXBlcy5cbiAqXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFNoYXBlVXRpbHMge1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgYXJlYSBvZiBhICggMkQgKSBjb250b3VyIHBvbHlnb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMj59IGNvbnRvdXIgLSBBbiBhcnJheSBvZiAyRCBwb2ludHMuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWEuXG5cdCAqL1xuXHRzdGF0aWMgYXJlYSggY29udG91ciApIHtcblxuXHRcdGNvbnN0IG4gPSBjb250b3VyLmxlbmd0aDtcblx0XHRsZXQgYSA9IDAuMDtcblxuXHRcdGZvciAoIGxldCBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYSAqIDAuNTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBjb250b3VyIHVzZXMgYSBjbG9ja3dpc2Ugd2luZGluZyBvcmRlci5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IyPn0gcHRzIC0gQW4gYXJyYXkgb2YgMkQgcG9pbnRzIGRlZmluaW5nIGEgcG9seWdvbi5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gY29udG91ciB1c2VzIGEgY2xvY2t3aXNlIHdpbmRpbmcgb3JkZXIgb3Igbm90LlxuXHQgKi9cblx0c3RhdGljIGlzQ2xvY2tXaXNlKCBwdHMgKSB7XG5cblx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlhbmd1bGF0ZXMgdGhlIGdpdmVuIHNoYXBlIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMj59IGNvbnRvdXIgLSBBbiBhcnJheSBvZiAyRCBwb2ludHMgZGVmaW5pbmcgdGhlIGNvbnRvdXIuXG5cdCAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8VmVjdG9yMj4+fSBob2xlcyAtIEFuIGFycmF5IHRoYXQgaG9sZHMgYXJyYXlzIG9mIDJEIHBvaW50cyBkZWZpbmluZyB0aGUgaG9sZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBBbiBhcnJheSB0aGF0IGhvbGRzIGZvciBlYWNoIGZhY2UgZGVmaW5pdGlvbiBhbiBhcnJheSB3aXRoIHRocmVlIGluZGljZXMuXG5cdCAqL1xuXHRzdGF0aWMgdHJpYW5ndWxhdGVTaGFwZSggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXHRcdGNvbnN0IGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xuXHRcdGNvbnN0IGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXG5cblx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcblx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGhvbGVzLmZvckVhY2goIHJlbW92ZUR1cEVuZFB0cyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRob2xlSW5kaWNlcy5wdXNoKCBob2xlSW5kZXggKTtcblx0XHRcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcblx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKCB2ZXJ0aWNlcywgaG9sZUluZGljZXMgKTtcblxuXHRcdC8vXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdGZhY2VzLnB1c2goIHRyaWFuZ2xlcy5zbGljZSggaSwgaSArIDMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhY2VzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcblxuXHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XG5cblx0XHRwb2ludHMucG9wKCk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICkge1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcblx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTaGFwZVV0aWxzIH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCAqIGFzIEN1cnZlcyBmcm9tICcuLi9leHRyYXMvY3VydmVzL0N1cnZlcy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5pbXBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi4vZXh0cmFzL1NoYXBlVXRpbHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxlbmd0aCA9IDEyLCB3aWR0aCA9IDg7XG4gKlxuICogY29uc3Qgc2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAqIHNoYXBlLm1vdmVUbyggMCwwICk7XG4gKiBzaGFwZS5saW5lVG8oIDAsIHdpZHRoICk7XG4gKiBzaGFwZS5saW5lVG8oIGxlbmd0aCwgd2lkdGggKTtcbiAqIHNoYXBlLmxpbmVUbyggbGVuZ3RoLCAwICk7XG4gKiBzaGFwZS5saW5lVG8oIDAsIDAgKTtcbiAqXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHNoYXBlICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMGZmMDAgfSApO1xuICogY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSA7XG4gKiBzY2VuZS5hZGQoIG1lc2ggKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJHZW9tZXRyeVxuICovXG5jbGFzcyBFeHRydWRlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZXh0cnVkZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtTaGFwZXxBcnJheTxTaGFwZT59IFtzaGFwZXNdIC0gQSBzaGFwZSBvciBhbiBhcnJheSBvZiBzaGFwZXMuXG5cdCAqIEBwYXJhbSB7RXh0cnVkZUdlb21ldHJ5fk9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBleHRydWRlIHNldHRpbmdzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAtIDAuNSApLCBuZXcgVmVjdG9yMiggMC41LCAtIDAuNSApIF0gKSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zXG5cdFx0fTtcblxuXHRcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcblx0XHRjb25zdCB1dkFycmF5ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblx0XHRcdGFkZFNoYXBlKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcblxuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdC8vIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xuXG5cdFx0XHRjb25zdCBwbGFjZWhvbGRlciA9IFtdO1xuXG5cdFx0XHQvLyBvcHRpb25zXG5cblx0XHRcdGNvbnN0IGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXHRcdFx0Y29uc3Qgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblx0XHRcdGNvbnN0IGRlcHRoID0gb3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aCA6IDE7XG5cblx0XHRcdGxldCBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlO1xuXHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDAuMjtcblx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDAuMTtcblx0XHRcdGxldCBiZXZlbE9mZnNldCA9IG9wdGlvbnMuYmV2ZWxPZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxPZmZzZXQgOiAwO1xuXHRcdFx0bGV0IGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0XHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblxuXHRcdFx0Y29uc3QgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogV29ybGRVVkdlbmVyYXRvcjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblx0XHRcdGxldCBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XG5cblx0XHRcdGlmICggZXh0cnVkZVBhdGggKSB7XG5cblx0XHRcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG5cdFx0XHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG5cdFx0XHRcdHNwbGluZVR1YmUgPSBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuXHRcdFx0XHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0XHRcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRcdFx0YmV2ZWxTaXplID0gMDtcblx0XHRcdFx0YmV2ZWxPZmZzZXQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG5cdFx0XHRjb25zdCBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdFx0XHRjb25zdCByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG5cdFx0XHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XG5cblx0XHRcdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8qKk1lcmdlcyBpbmRleC1hZGphY2VudCBwb2ludHMgdGhhdCBhcmUgd2l0aGluIGEgdGhyZXNob2xkIGRpc3RhbmNlIG9mIGVhY2ggb3RoZXIuIEFycmF5IGlzIG1vZGlmaWVkIGluLXBsYWNlLiBUaHJlc2hvbGQgZGlzdGFuY2UgaXMgZW1waXJpY2FsLCBhbmQgc2NhbGVkIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgcG9pbnQgY29vcmRpbmF0ZXMuXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5PFZlY3RvcjI+fSBwb2ludHNcblx0XHRcdCovXG5cdFx0XHRmdW5jdGlvbiBtZXJnZU92ZXJsYXBwaW5nUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHRcdFx0Y29uc3QgVEhSRVNIT0xEID0gMWUtMTA7XG5cdFx0XHRcdGNvbnN0IFRIUkVTSE9MRF9TUSA9IFRIUkVTSE9MRCAqIFRIUkVTSE9MRDtcblx0XHRcdFx0bGV0IHByZXZQb3MgPSBwb2ludHNbIDAgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjdXJyZW50SW5kZXggPSBpICUgcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50UG9zID0gcG9pbnRzWyBjdXJyZW50SW5kZXggXTtcblx0XHRcdFx0XHRjb25zdCBkeCA9IGN1cnJlbnRQb3MueCAtIHByZXZQb3MueDtcblx0XHRcdFx0XHRjb25zdCBkeSA9IGN1cnJlbnRQb3MueSAtIHByZXZQb3MueTtcblx0XHRcdFx0XHRjb25zdCBkaXN0U3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuXHRcdFx0XHRcdGNvbnN0IHNjYWxpbmdGYWN0b3JTcXJ0ID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLmFicyggY3VycmVudFBvcy54ICksXG5cdFx0XHRcdFx0XHRNYXRoLmFicyggY3VycmVudFBvcy55ICksXG5cdFx0XHRcdFx0XHRNYXRoLmFicyggcHJldlBvcy54ICksXG5cdFx0XHRcdFx0XHRNYXRoLmFicyggcHJldlBvcy55IClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGNvbnN0IHRocmVzaG9sZFNxU2NhbGVkID0gVEhSRVNIT0xEX1NRICogc2NhbGluZ0ZhY3RvclNxcnQgKiBzY2FsaW5nRmFjdG9yU3FydDtcblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA8PSB0aHJlc2hvbGRTcVNjYWxlZCApIHtcblxuXHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZSggY3VycmVudEluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRpIC0tO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmV2UG9zID0gY3VycmVudFBvcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bWVyZ2VPdmVybGFwcGluZ1BvaW50cyggdmVydGljZXMgKTtcblx0XHRcdGhvbGVzLmZvckVhY2goIG1lcmdlT3ZlcmxhcHBpbmdQb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgbnVtSG9sZXMgPSBob2xlcy5sZW5ndGg7XG5cblx0XHRcdC8qIFZlcnRpY2VzICovXG5cblx0XHRcdGNvbnN0IGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuXHRcdFx0Zm9yICggbGV0IGggPSAwOyBoIDwgbnVtSG9sZXM7IGggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XG5cblx0XHRcdFx0aWYgKCAhIHZlYyApIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gcHQuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3IoIHZlYywgc2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cblxuXHRcdFx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxuXG5cblx0XHRcdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuXHRcdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG5cdFx0XHRcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcblx0XHRcdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG5cdFx0XHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cblx0XHRcdFx0bGV0IHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG5cdFx0XHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cblx0XHRcdFx0Y29uc3Qgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcblx0XHRcdFx0XHR2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xuXHRcdFx0XHRjb25zdCB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxuXHRcdFx0XHRcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cblx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcblx0XHRcdFx0Y29uc3QgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuXHRcdFx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG5cdFx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cdFx0XHRcdFx0Y29uc3Qgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcblxuXHRcdFx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuXHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG5cdFx0XHRcdFx0Y29uc3QgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuXHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG5cdFx0XHRcdFx0Y29uc3QgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblxuXHRcdFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHRjb25zdCBzZiA9ICggKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxuXHRcdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cblx0XHRcdFx0XHRcdCggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuXHRcdFx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcblx0XHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHRcdFx0Y29uc3Qgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG5cdFx0XHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0XHRcdGxldCBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgLy8gYXNzdW1lczogb3Bwb3NpdGVcblxuXHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHRcdFx0dl90cmFuc194ID0gdl9wcmV2X3g7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRjb25zdCBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcblxuXHRcdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGhvbGVzTW92ZW1lbnRzID0gW107XG5cdFx0XHRsZXQgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gbnVtSG9sZXM7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cdFx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IGZhY2VzO1xuXG5cdFx0XHRpZiAoIGJldmVsU2VnbWVudHMgPT09IDAgKSB7XG5cblx0XHRcdFx0ZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIGNvbnRvdXIsIGhvbGVzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgY29udHJhY3RlZENvbnRvdXJWZXJ0aWNlcyA9IFtdO1xuXHRcdFx0XHRjb25zdCBleHBhbmRlZEhvbGVWZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG5cdFx0XHRcdGZvciAoIGxldCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cblx0XHRcdFx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG5cdFx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0ID09PSAwICkgY29udHJhY3RlZENvbnRvdXJWZXJ0aWNlcy5wdXNoKCB2ZXJ0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBudW1Ib2xlczsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblx0XHRcdFx0XHRcdGNvbnN0IG9uZUhvbGVWZXJ0aWNlcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ID09PSAwICkgb25lSG9sZVZlcnRpY2VzLnB1c2goIHZlcnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIHQgPT09IDAgKSBleHBhbmRlZEhvbGVWZXJ0aWNlcy5wdXNoKCBvbmVIb2xlVmVydGljZXMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIGNvbnRyYWN0ZWRDb250b3VyVmVydGljZXMsIGV4cGFuZGVkSG9sZVZlcnRpY2VzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuXHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG5cdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHRcdFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoIC8gc3RlcHMgKiBzICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cblx0XHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcblxuXHRcdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRcdFx0Zm9yICggbGV0IGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xuXG5cdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgeiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKSArIGJldmVsT2Zmc2V0O1xuXG5cdFx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBkZXB0aCArIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvKiBGYWNlcyAqL1xuXG5cdFx0XHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG5cdFx0XHRidWlsZExpZEZhY2VzKCk7XG5cblx0XHRcdC8vIFNpZGVzIGZhY2VzXG5cblx0XHRcdGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuXHRcdFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdFx0XHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXG5cdFx0XHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0XHRcdFx0bGV0IGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHRcdFx0bGV0IG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdGxldCBsYXllcm9mZnNldCA9IDA7XG5cdFx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHQvLywgdHJ1ZVxuXHRcdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAxICk7XG5cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG5cdFx0XHRcdGxldCBpID0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBqID0gaTtcblx0XHRcdFx0XHRsZXQgayA9IGkgLSAxO1xuXHRcdFx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgcyA9IDAsIHNsID0gKCBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyICk7IHMgPCBzbDsgcyArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjEgPSB2bGVuICogcztcblx0XHRcdFx0XHRcdGNvbnN0IHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxuXHRcdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcblx0XHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xuXG5cdFx0XHRcdFx0XHRmNCggYSwgYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB6ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBiICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYyApO1xuXG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcblxuXHRcdFx0XHRhZGRVViggdXZzWyAwIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xuXG5cdFx0XHRcdGFkZFZlcnRleCggYSApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBkICk7XG5cblx0XHRcdFx0YWRkVmVydGV4KCBiICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYyApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcblxuXG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gNiwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xuXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XG5cblx0XHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDAgXSApO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAxIF0gKTtcblx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMiBdICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBhZGRVViggdmVjdG9yMiApIHtcblxuXHRcdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xuXHRcdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XG5cblx0XHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIG9wdGlvbnMsIGRhdGEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5PFNoYXBlPn0gc2hhcGVzIC0gQW4gYXJyYXkgb2Ygc2hhcGVzLlxuXHQgKiBAcmV0dXJuIHtFeHRydWRlR2VvbWV0cnl9IEEgbmV3IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGZyb21KU09OKCBkYXRhLCBzaGFwZXMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeVNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGogXSBdO1xuXG5cdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZXh0cnVkZVBhdGggPSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cblx0XHRpZiAoIGV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG5ldyBDdXJ2ZXNbIGV4dHJ1ZGVQYXRoLnR5cGUgXSgpLmZyb21KU09OKCBleHRydWRlUGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBFeHRydWRlR2VvbWV0cnkoIGdlb21ldHJ5U2hhcGVzLCBkYXRhLm9wdGlvbnMgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgV29ybGRVVkdlbmVyYXRvciA9IHtcblxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcblxuXHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XG5cdFx0Y29uc3QgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcblx0XHRjb25zdCBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xuXHRcdGNvbnN0IGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdG5ldyBWZWN0b3IyKCBhX3gsIGFfeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgYl95ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggY194LCBjX3kgKVxuXHRcdF07XG5cblx0fSxcblxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cblx0XHRjb25zdCBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xuXHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGFfeiA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMiBdO1xuXHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XG5cdFx0Y29uc3QgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYl96ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAyIF07XG5cdFx0Y29uc3QgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcblx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcblx0XHRjb25zdCBjX3ogPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDIgXTtcblx0XHRjb25zdCBkX3ggPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyBdO1xuXHRcdGNvbnN0IGRfeSA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGRfeiA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMiBdO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggYV95IC0gYl95ICkgPCBNYXRoLmFicyggYV94IC0gYl94ICkgKSB7XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3gsIDEgLSBhX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgMSAtIGJfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggY194LCAxIC0gY196ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3gsIDEgLSBkX3ogKVxuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3ksIDEgLSBhX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeSwgMSAtIGJfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggY195LCAxIC0gY196ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3ksIDEgLSBkX3ogKVxuXHRcdFx0XTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICkge1xuXG5cdGRhdGEuc2hhcGVzID0gW107XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XG5cblx0fVxuXG5cdGRhdGEub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBvcHRpb25zICk7XG5cblx0aWYgKCBvcHRpb25zLmV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQgKSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoLnRvSlNPTigpO1xuXG5cdHJldHVybiBkYXRhO1xuXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYG9wdGlvbnNgIHR5cGUgb2YgdGhlIGdlb21ldHJ5J3MgY29uc3RydWN0b3IuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXh0cnVkZUdlb21ldHJ5fk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VydmVTZWdtZW50cz0xMl0gLSBOdW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0ZXBzPTFdIC0gTnVtYmVyIG9mIHBvaW50cyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBhbG9uZyB0aGUgZGVwdGggb2YgdGhlIGV4dHJ1ZGVkIHNwbGluZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVwdGg9MV0gLSBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2JldmVsRW5hYmxlZD10cnVlXSAtIFdoZXRoZXIgdG8gYmV2ZWxpbmcgdG8gdGhlIHNoYXBlIG9yIG5vdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmV2ZWxUaGlja25lc3M9MC4yXSAtIEhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIHRoZSBiZXZlbCBnb2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtiZXZlbFNpemU9YmV2ZWxUaGlja25lc3MtMC4xXSAtIERpc3RhbmNlIGZyb20gdGhlIHNoYXBlIG91dGxpbmUgdGhhdCB0aGUgYmV2ZWwgZXh0ZW5kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmV2ZWxPZmZzZXQ9MF0gLSBEaXN0YW5jZSBmcm9tIHRoZSBzaGFwZSBvdXRsaW5lIHRoYXQgdGhlIGJldmVsIHN0YXJ0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmV2ZWxTZWdtZW50cz0zXSAtIE51bWJlciBvZiBiZXZlbCBsYXllcnMuXG4gKiBAcHJvcGVydHkgez9DdXJ2ZX0gW2V4dHJ1ZGVQYXRoPW51bGxdIC0gQSAzRCBzcGxpbmUgcGF0aCBhbG9uZyB3aGljaCB0aGUgc2hhcGUgc2hvdWxkIGJlIGV4dHJ1ZGVkLiBCZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb24uXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1VWR2VuZXJhdG9yXSAtIEFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnMgZm9yIGN1c3RvbSBVViBnZW5lcmF0aW9uLlxuICoqL1xuXG5leHBvcnQgeyBFeHRydWRlR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFBvbHloZWRyb25HZW9tZXRyeSB9IGZyb20gJy4vUG9seWhlZHJvbkdlb21ldHJ5LmpzJztcblxuLyoqXG4gKiBBIGdlb21ldHJ5IGNsYXNzIGZvciByZXByZXNlbnRpbmcgYW4gaWNvc2FoZWRyb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gKiBjb25zdCBpY29zYWhlZHJvbiA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggaWNvc2FoZWRyb24gKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBQb2x5aGVkcm9uR2VvbWV0cnlcbiAqL1xuY2xhc3MgSWNvc2FoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaWNvc2FoZWRyb24gZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gUmFkaXVzIG9mIHRoZSBpY29zYWhlZHJvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWw9MF0gLSBTZXR0aW5nIHRoaXMgdG8gYSB2YWx1ZSBncmVhdGVyIHRoYW4gYDBgIGFkZHMgdmVydGljZXMgbWFraW5nIGl0IG5vIGxvbmdlciBhIGljb3NhaGVkcm9uLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdC0gMSwgdCwgMCwgXHQxLCB0LCAwLCBcdC0gMSwgLSB0LCAwLCBcdDEsIC0gdCwgMCxcblx0XHRcdDAsIC0gMSwgdCwgXHQwLCAxLCB0LFx0MCwgLSAxLCAtIHQsIFx0MCwgMSwgLSB0LFxuXHRcdFx0dCwgMCwgLSAxLCBcdHQsIDAsIDEsIFx0LSB0LCAwLCAtIDEsIFx0LSB0LCAwLCAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQwLCAxMSwgNSwgXHQwLCA1LCAxLCBcdDAsIDEsIDcsIFx0MCwgNywgMTAsIFx0MCwgMTAsIDExLFxuXHRcdFx0MSwgNSwgOSwgXHQ1LCAxMSwgNCxcdDExLCAxMCwgMixcdDEwLCA3LCA2LFx0NywgMSwgOCxcblx0XHRcdDMsIDksIDQsIFx0MywgNCwgMixcdDMsIDIsIDYsXHQzLCA2LCA4LFx0MywgOCwgOSxcblx0XHRcdDQsIDksIDUsIFx0MiwgNCwgMTEsXHQ2LCAyLCAxMCxcdDgsIDYsIDcsXHQ5LCA4LCAxXG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge0ljb3NhaGVkcm9uR2VvbWV0cnl9IEEgbmV3IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBJY29zYWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIG1lc2hlcyB3aXRoIGF4aWFsIHN5bW1ldHJ5IGxpa2UgdmFzZXMuIFRoZSBsYXRoZSByb3RhdGVzIGFyb3VuZCB0aGUgWSBheGlzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwb2ludHMgPSBbXTtcbiAqIGZvciAoIGxldCBpID0gMDsgaSA8IDEwOyBpICsrICkge1xuICogXHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIE1hdGguc2luKCBpICogMC4yICkgKiAxMCArIDUsICggaSAtIDUgKSAqIDIgKSApO1xuICogfVxuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuTGF0aGVHZW9tZXRyeSggcG9pbnRzICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICogY29uc3QgbGF0aGUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBzY2VuZS5hZGQoIGxhdGhlICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsYXRoZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxWZWN0b3IyfFZlY3RvcjM+fSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIHBvaW50cyBpbiAyRCBzcGFjZS4gVGhlIHgtY29vcmRpbmF0ZSBvZiBlYWNoIHBvaW50XG5cdCAqIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc2VnbWVudHM9MTJdIC0gVGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGdlbmVyYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3BoaVN0YXJ0PTBdIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcGhpTGVuZ3RoPU1hdGguUEkqMl0gLSBUaGUgcmFkaWFuICgwIHRvIDJQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uIDJQSSBpcyBhXG5cdCAqIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gWyBuZXcgVmVjdG9yMiggMCwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgMCApLCBuZXcgVmVjdG9yMiggMCwgMC41ICkgXSwgc2VnbWVudHMgPSAxMiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKTtcblxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cblxuXHRcdHBoaUxlbmd0aCA9IGNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbml0Tm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY3VyTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwcmV2Tm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgZHggPSAwO1xuXHRcdGxldCBkeSA9IDA7XG5cblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0c3dpdGNoICggaiApIHtcblxuXHRcdFx0XHRjYXNlIDA6XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICggcG9pbnRzLmxlbmd0aCAtIDEgKTpcdC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGxhc3QgVmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIHByZXZOb3JtYWwueCwgcHJldk5vcm1hbC55LCBwcmV2Tm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XHRcdFx0Ly8gZGVmYXVsdCBoYW5kbGluZyBmb3IgYWxsIHZlcnRpY2VzIGluIGJldHdlZW5cblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdGN1ck5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ICs9IHByZXZOb3JtYWwueDtcblx0XHRcdFx0XHRub3JtYWwueSArPSBwcmV2Tm9ybWFsLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xuXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KCBjdXJOb3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIHV2cyBhbmQgbm9ybWFsc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCBwaGkgKTtcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCBwaGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XG5cdFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y29uc3QgeCA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIHNpbjtcblx0XHRcdFx0Y29uc3QgeSA9IGluaXROb3JtYWxzWyAzICogaiArIDEgXTtcblx0XHRcdFx0Y29uc3QgeiA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIGNvcztcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRjb25zdCBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XG5cdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcmV0dXJuIHtMYXRoZUdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgTGF0aGVHZW9tZXRyeSggZGF0YS5wb2ludHMsIGRhdGEuc2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgTGF0aGVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIEEgZ2VvbWV0cnkgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhbiBvY3RhaGVkcm9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gKiBjb25zdCBvY3RhaGVkcm9uID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBvY3RhaGVkcm9uICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgUG9seWhlZHJvbkdlb21ldHJ5XG4gKi9cbmNsYXNzIE9jdGFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgb2N0YWhlZHJvbiBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLSBSYWRpdXMgb2YgdGhlIG9jdGFoZWRyb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGV0YWlsPTBdIC0gU2V0dGluZyB0aGlzIHRvIGEgdmFsdWUgZ3JlYXRlciB0aGFuIGAwYCBhZGRzIHZlcnRpY2VzIG1ha2luZyBpdCBubyBsb25nZXIgYSBvY3RhaGVkcm9uLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDAsIDAsIFx0LSAxLCAwLCAwLFx0MCwgMSwgMCxcblx0XHRcdDAsIC0gMSwgMCwgXHQwLCAwLCAxLFx0MCwgMCwgLSAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQwLCAyLCA0LFx0MCwgNCwgMyxcdDAsIDMsIDUsXG5cdFx0XHQwLCA1LCAyLFx0MSwgMiwgNSxcdDEsIDUsIDMsXG5cdFx0XHQxLCAzLCA0LFx0MSwgNCwgMlxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge09jdGFoZWRyb25HZW9tZXRyeX0gQSBuZXcgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE9jdGFoZWRyb25HZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5cbi8qKlxuICogQSBnZW9tZXRyeSBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgcGxhbmUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoIDEsIDEgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCwgc2lkZTogVEhSRUUuRG91YmxlU2lkZSB9ICk7XG4gKiBjb25zdCBwbGFuZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggcGxhbmUgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJHZW9tZXRyeVxuICovXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBsYW5lIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTFdIC0gVGhlIHdpZHRoIGFsb25nIHRoZSBYIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodCBhbG9uZyB0aGUgWSBheGlzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhTZWdtZW50cz0xXSAtIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgYWxvbmcgdGhlIFggYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRTZWdtZW50cz0xXSAtIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgYWxvbmcgdGhlIFkgYXhpcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIHdpZHRoU2VnbWVudHMgPSAxLCBoZWlnaHRTZWdtZW50cyA9IDEgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdGNvbnN0IHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdFx0Y29uc3QgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdFx0Y29uc3QgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICk7XG5cdFx0Y29uc3QgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApO1xuXG5cdFx0Y29uc3QgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblxuXHRcdGNvbnN0IHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdGNvbnN0IHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgLSB5LCAwICk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcblx0XHRcdFx0dXZzLnB1c2goIDEgLSAoIGl5IC8gZ3JpZFkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdGNvbnN0IGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0Y29uc3QgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcmV0dXJuIHtQbGFuZUdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUGxhbmVHZW9tZXRyeSggZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQsIGRhdGEud2lkdGhTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBQbGFuZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbi8qKlxuICogQSBjbGFzcyBmb3IgZ2VuZXJhdGluZyBhIHR3by1kaW1lbnNpb25hbCByaW5nIGdlb21ldHJ5LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoIDEsIDUsIDMyICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAsIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUgfSApO1xuICogY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggbWVzaCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckdlb21ldHJ5XG4gKi9cbmNsYXNzIFJpbmdHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyByaW5nIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2lubmVyUmFkaXVzPTAuNV0gLSBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSByaW5nLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW291dGVyUmFkaXVzPTFdIC0gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgcmluZy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YVNlZ21lbnRzPTMyXSAtIE51bWJlciBvZiBzZWdtZW50cy4gQSBoaWdoZXIgbnVtYmVyIG1lYW5zIHRoZSByaW5nIHdpbGwgYmUgbW9yZSByb3VuZC4gTWluaW11bSBpcyBgM2AuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcGhpU2VnbWVudHM9MV0gLSBOdW1iZXIgb2Ygc2VnbWVudHMgcGVyIHJpbmcgc2VnbWVudC4gTWluaW11bSBpcyBgMWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGFTdGFydD0wXSAtIFN0YXJ0aW5nIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGFMZW5ndGg9TWF0aC5QSSoyXSAtIENlbnRyYWwgYW5nbGUgaW4gcmFkaWFucy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBpbm5lclJhZGl1cyA9IDAuNSwgb3V0ZXJSYWRpdXMgPSAxLCB0aGV0YVNlZ21lbnRzID0gMzIsIHBoaVNlZ21lbnRzID0gMSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR0aGV0YVNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKTtcblx0XHRwaGlTZWdtZW50cyA9IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gc29tZSBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgcmFkaXVzID0gaW5uZXJSYWRpdXM7XG5cdFx0Y29uc3QgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdGhldGFTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcblx0XHRcdFx0dXYueSA9ICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG5cblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmNyZWFzZSB0aGUgcmFkaXVzIGZvciBuZXh0IHJvdyBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuXHRcdH1cblxuXHRcdC8vIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcblxuXHRcdFx0XHRjb25zdCBhID0gc2VnbWVudDtcblx0XHRcdFx0Y29uc3QgYiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcblx0XHRcdFx0Y29uc3QgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblx0XHRcdFx0Y29uc3QgZCA9IHNlZ21lbnQgKyAxO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge1JpbmdHZW9tZXRyeX0gQSBuZXcgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFJpbmdHZW9tZXRyeSggZGF0YS5pbm5lclJhZGl1cywgZGF0YS5vdXRlclJhZGl1cywgZGF0YS50aGV0YVNlZ21lbnRzLCBkYXRhLnBoaVNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBSaW5nR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5pbXBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi4vZXh0cmFzL1NoYXBlVXRpbHMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gb25lIG9yIG1vcmUgcGF0aCBzaGFwZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGFyY1NoYXBlID0gbmV3IFRIUkVFLlNoYXBlKClcbiAqXHQubW92ZVRvKCA1LCAxIClcbiAqXHQuYWJzYXJjKCAxLCAxLCA0LCAwLCBNYXRoLlBJICogMiwgZmFsc2UgKTtcbiAqXG4gKiBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCBhcmNTaGFwZSApO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MDBmZjAwLCBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlIH0gKTtcbiAqIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkgO1xuICogc2NlbmUuYWRkKCBtZXNoICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgU2hhcGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFwZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtTaGFwZXxBcnJheTxTaGFwZT59IFtzaGFwZXNdIC0gQSBzaGFwZSBvciBhbiBhcnJheSBvZiBzaGFwZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY3VydmVTZWdtZW50cz0xMl0gLSBOdW1iZXIgb2Ygc2VnbWVudHMgcGVyIHNoYXBlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMCwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgLSAwLjUgKSBdICksIGN1cnZlU2VnbWVudHMgPSAxMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcblx0XHRcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcblx0XHR9O1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcInNoYXBlc1wiIHBhcmFtZXRlclxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGFkZFNoYXBlKCBzaGFwZXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XG5cblx0XHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSApOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblx0XHRcdFx0Z3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xuXG5cdFx0XHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZVZlcnRpY2VzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVIb2xlICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzaGFwZUhvbGVzWyBpIF0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xuXG5cdFx0XHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoIHNoYXBlSG9sZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IHNoYXBlVmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIDAgKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0XHRcdHV2cy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnkgKTsgLy8gd29ybGQgdXZzXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0Y29uc3QgYiA9IGZhY2VbIDEgXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBjID0gZmFjZVsgMiBdICsgaW5kZXhPZmZzZXQ7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5PFNoYXBlPn0gc2hhcGVzIC0gQW4gYXJyYXkgb2Ygc2hhcGVzLlxuXHQgKiBAcmV0dXJuIHtTaGFwZUdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBqIF0gXTtcblxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSggZ2VvbWV0cnlTaGFwZXMsIGRhdGEuY3VydmVTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgZGF0YSApIHtcblxuXHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcblxufVxuXG5leHBvcnQgeyBTaGFwZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG4vKipcbiAqIEEgY2xhc3MgZm9yIGdlbmVyYXRpbmcgYSBzcGhlcmUgZ2VvbWV0cnkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCAxNSwgMzIsIDE2ICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICogY29uc3Qgc3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBzcGhlcmUgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBCdWZmZXJHZW9tZXRyeVxuICovXG5jbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzcGhlcmUgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gVGhlIHNwaGVyZSByYWRpdXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhTZWdtZW50cz0zMl0gLSBUaGUgbnVtYmVyIG9mIGhvcml6b250YWwgc2VnbWVudHMuIE1pbmltdW0gdmFsdWUgaXMgYDNgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodFNlZ21lbnRzPTE2XSAtIFRoZSBudW1iZXIgb2YgdmVydGljYWwgc2VnbWVudHMuIE1pbmltdW0gdmFsdWUgaXMgYDJgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3BoaVN0YXJ0PTBdIC0gVGhlIGhvcml6b250YWwgc3RhcnRpbmcgYW5nbGUgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtwaGlMZW5ndGg9TWF0aC5QSSoyXSAtIFRoZSBob3Jpem9udGFsIHN3ZWVwIGFuZ2xlIHNpemUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGFTdGFydD0wXSAtIFRoZSB2ZXJ0aWNhbCBzdGFydGluZyBhbmdsZSBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3RoZXRhTGVuZ3RoPU1hdGguUEldIC0gVGhlIHZlcnRpY2FsIHN3ZWVwIGFuZ2xlIHNpemUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgd2lkdGhTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDE2LCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApICk7XG5cblx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKCB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGgsIE1hdGguUEkgKTtcblxuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0Y29uc3QgZ3JpZCA9IFtdO1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG5cdFx0XHRjb25zdCB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcG9sZXNcblxuXHRcdFx0bGV0IHVPZmZzZXQgPSAwO1xuXG5cdFx0XHRpZiAoIGl5ID09PSAwICYmIHRoZXRhU3RhcnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dU9mZnNldCA9IDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGl5ID09PSBoZWlnaHRTZWdtZW50cyAmJiB0aGV0YUVuZCA9PT0gTWF0aC5QSSApIHtcblxuXHRcdFx0XHR1T2Zmc2V0ID0gLSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwuY29weSggdmVydGV4ICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUgKyB1T2Zmc2V0LCAxIC0gdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgd2lkdGhTZWdtZW50czsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xuXHRcdFx0XHRjb25zdCBiID0gZ3JpZFsgaXkgXVsgaXggXTtcblx0XHRcdFx0Y29uc3QgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xuXHRcdFx0XHRjb25zdCBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xuXG5cdFx0XHRcdGlmICggaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge1NwaGVyZUdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgU3BoZXJlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BoZXJlR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFBvbHloZWRyb25HZW9tZXRyeSB9IGZyb20gJy4vUG9seWhlZHJvbkdlb21ldHJ5LmpzJztcblxuLyoqXG4gKiBBIGdlb21ldHJ5IGNsYXNzIGZvciByZXByZXNlbnRpbmcgYW4gdGV0cmFoZWRyb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gKiBjb25zdCB0ZXRyYWhlZHJvbiA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggdGV0cmFoZWRyb24gKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBQb2x5aGVkcm9uR2VvbWV0cnlcbiAqL1xuY2xhc3MgVGV0cmFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdGV0cmFoZWRyb24gZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIC0gUmFkaXVzIG9mIHRoZSB0ZXRyYWhlZHJvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWw9MF0gLSBTZXR0aW5nIHRoaXMgdG8gYSB2YWx1ZSBncmVhdGVyIHRoYW4gYDBgIGFkZHMgdmVydGljZXMgbWFraW5nIGl0IG5vIGxvbmdlciBhIHRldHJhaGVkcm9uLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDEsIDEsIFx0LSAxLCAtIDEsIDEsIFx0LSAxLCAxLCAtIDEsIFx0MSwgLSAxLCAtIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDIsIDEsIDAsIFx0MCwgMywgMixcdDEsIDMsIDAsXHQyLCAzLCAxXG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge1RldHJhaGVkcm9uR2VvbWV0cnl9IEEgbmV3IGluc3RhbmNlLlxuXHQgKi9cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUZXRyYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgVGV0cmFoZWRyb25HZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBBIGdlb21ldHJ5IGNsYXNzIGZvciByZXByZXNlbnRpbmcgYW4gdG9ydXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoIDEwLCAzLCAxNiwgMTAwICk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICogY29uc3QgdG9ydXMgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKiBzY2VuZS5hZGQoIHRvcnVzICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgVG9ydXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyB0b3J1cyBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLSBSYWRpdXMgb2YgdGhlIHRvcnVzLCBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHRvcnVzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHR1YmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdHViZT0wLjRdIC0gUmFkaXVzIG9mIHRoZSB0dWJlLiBNdXN0IGJlIHNtYWxsZXIgdGhhbiBgcmFkaXVzYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz0xMl0gLSBUaGUgbnVtYmVyIG9mIHJhZGlhbCBzZWdtZW50cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0dWJ1bGFyU2VnbWVudHM9NDhdIC0gVGhlIG51bWJlciBvZiB0dWJ1bGFyIHNlZ21lbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FyYz1NYXRoLlBJKjJdIC0gQ2VudHJhbCBhbmdsZSBpbiByYWRpYW5zLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHR1YmUgPSAwLjQsIHJhZGlhbFNlZ21lbnRzID0gMTIsIHR1YnVsYXJTZWdtZW50cyA9IDQ4LCBhcmMgPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgY29uc3RydWN0b3IgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdlb21ldHJ5LiBBbnkgbW9kaWZpY2F0aW9uXG5cdFx0ICogYWZ0ZXIgaW5zdGFudGlhdGlvbiBkb2VzIG5vdCBjaGFuZ2UgdGhlIGdlb21ldHJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdGFyYzogYXJjXG5cdFx0fTtcblxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG5cdFx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRjb25zdCBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG5cdFx0XHRcdGNvbnN0IGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuXHRcdFx0XHRjb25zdCBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXHRcdFx0XHRjb25zdCBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gdGhlIGdpdmVuXG5cdCAqIEpTT04gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemVkIGdlb21ldHJ5LlxuXHQgKiBAcmV0dXJuIHtUb3J1c0dlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEuYXJjICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRvcnVzR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRvcnVzIGtub3QsIHRoZSBwYXJ0aWN1bGFyIHNoYXBlIG9mIHdoaWNoIGlzIGRlZmluZWQgYnkgYSBwYWlyXG4gKiBvZiBjb3ByaW1lIGludGVnZXJzLCBwIGFuZCBxLiBJZiBwIGFuZCBxIGFyZSBub3QgY29wcmltZSwgdGhlIHJlc3VsdCB3aWxsXG4gKiBiZSBhIHRvcnVzIGxpbmsuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KCAxMCwgMywgMTAwLCAxNiApO1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKTtcbiAqIGNvbnN0IHRvcnVzS25vdCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggdG9ydXNLbm90ICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgVG9ydXNLbm90R2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdG9ydXMga25vdCBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLSBSYWRpdXMgb2YgdGhlIHRvcnVzIGtub3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdHViZT0wLjRdIC0gUmFkaXVzIG9mIHRoZSB0dWJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02NF0gLSBUaGUgbnVtYmVyIG9mIHR1YnVsYXIgc2VnbWVudHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF0gLSBUaGUgbnVtYmVyIG9mIHJhZGlhbCBzZWdtZW50cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtwPTJdIC0gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzLCBob3cgbWFueSB0aW1lcyB0aGUgZ2VvbWV0cnkgd2luZHMgYXJvdW5kIGl0cyBheGlzIG9mIHJvdGF0aW9uYWwgc3ltbWV0cnkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcT0zXSAtIFRoaXMgdmFsdWUgZGV0ZXJtaW5lcywgaG93IG1hbnkgdGltZXMgdGhlIGdlb21ldHJ5IHdpbmRzIGFyb3VuZCBhIGNpcmNsZSBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIHRvcnVzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHR1YmUgPSAwLjQsIHR1YnVsYXJTZWdtZW50cyA9IDY0LCByYWRpYWxTZWdtZW50cyA9IDgsIHAgPSAyLCBxID0gMyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW5cblx0XHQgKiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnZW9tZXRyeS4gQW55IG1vZGlmaWNhdGlvblxuXHRcdCAqIGFmdGVyIGluc3RhbnRpYXRpb24gZG9lcyBub3QgY2hhbmdlIHRoZSBnZW9tZXRyeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR0dWJlOiB0dWJlLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRwOiBwLFxuXHRcdFx0cTogcVxuXHRcdH07XG5cblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCBQMSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgUDIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgQiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgVCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgTiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyArKyBpICkge1xuXG5cdFx0XHQvLyB0aGUgcmFkaWFuIFwidVwiIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmUgb2YgdGhlIGN1cnJlbnQgdHVidWxhciBzZWdtZW50XG5cblx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHQvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cblx0XHRcdC8vIHRoZXNlIHBvaW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsIFwiY29vcmRpbmF0ZSBzcGFjZVwiLCB3aGljaCBpcyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHZlcnRleCBwb3NpdGlvbnNcblxuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIFAxICk7XG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBvcnRob25vcm1hbCBiYXNpc1xuXG5cdFx0XHRULnN1YlZlY3RvcnMoIFAyLCBQMSApO1xuXHRcdFx0Ti5hZGRWZWN0b3JzKCBQMiwgUDEgKTtcblx0XHRcdEIuY3Jvc3NWZWN0b3JzKCBULCBOICk7XG5cdFx0XHROLmNyb3NzVmVjdG9ycyggQiwgVCApO1xuXG5cdFx0XHQvLyBub3JtYWxpemUgQiwgTi4gVCBjYW4gYmUgaWdub3JlZCwgd2UgZG9uJ3QgdXNlIGl0XG5cblx0XHRcdEIubm9ybWFsaXplKCk7XG5cdFx0XHROLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XG5cblx0XHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgdmVydGljZXMuIHRoZXkgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGFuIGV4dHJ1c2lvbiBvZiB0aGUgdG9ydXMgY3VydmUuXG5cdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZXh0cnVkZSBhIHNoYXBlIGluIHRoZSB4eS1wbGFuZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgYSB6LXZhbHVlLlxuXG5cdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblx0XHRcdFx0Y29uc3QgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApO1xuXHRcdFx0XHRjb25zdCBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cblx0XHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9ycywgdGhlbiB3ZSBhZGQgaXQgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlXG5cblx0XHRcdFx0dmVydGV4LnggPSBQMS54ICsgKCBjeCAqIE4ueCArIGN5ICogQi54ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gUDEueSArICggY3ggKiBOLnkgKyBjeSAqIEIueSApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IFAxLnogKyAoIGN4ICogTi56ICsgY3kgKiBCLnogKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsIChQMSBpcyBhbHdheXMgdGhlIGNlbnRlci9vcmlnaW4gb2YgdGhlIGV4dHJ1c2lvbiwgdGh1cyB3ZSBjYW4gdXNlIGl0IHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsKVxuXG5cdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIFAxICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0XHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0Y29uc3QgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XG5cdFx0XHRcdGNvbnN0IGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcblx0XHRcdFx0Y29uc3QgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblx0XHRcdFx0Y29uc3QgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcblxuXHRcdGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBwb3NpdGlvbiApIHtcblxuXHRcdFx0Y29uc3QgY3UgPSBNYXRoLmNvcyggdSApO1xuXHRcdFx0Y29uc3Qgc3UgPSBNYXRoLnNpbiggdSApO1xuXHRcdFx0Y29uc3QgcXVPdmVyUCA9IHEgLyBwICogdTtcblx0XHRcdGNvbnN0IGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcblxuXHRcdFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcblx0XHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG5cdFx0XHRwb3NpdGlvbi56ID0gcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge1RvcnVzS25vdEdlb21ldHJ5fSBBIG5ldyBpbnN0YW5jZS5cblx0ICovXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLnAsIGRhdGEucSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBUb3J1c0tub3RHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgKiBhcyBDdXJ2ZXMgZnJvbSAnLi4vZXh0cmFzL2N1cnZlcy9DdXJ2ZXMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdHViZSB0aGF0IGV4dHJ1ZGVzIGFsb25nIGEgM0QgY3VydmUuXG4gKlxuICogYGBganNcbiAqIGNsYXNzIEN1c3RvbVNpbkN1cnZlIGV4dGVuZHMgVEhSRUUuQ3VydmUge1xuICpcbiAqIFx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSApIHtcbiAqXG4gKiBcdFx0Y29uc3QgdHggPSB0ICogMyAtIDEuNTtcbiAqIFx0XHRjb25zdCB0eSA9IE1hdGguc2luKCAyICogTWF0aC5QSSAqIHQgKTtcbiAqIFx0XHRjb25zdCB0eiA9IDA7XG4gKlxuICogXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zZXQoIHR4LCB0eSwgdHogKTtcbiAqIFx0fVxuICpcbiAqIH1cbiAqXG4gKiBjb25zdCBwYXRoID0gbmV3IEN1c3RvbVNpbkN1cnZlKCAxMCApO1xuICogY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5KCBwYXRoLCAyMCwgMiwgOCwgZmFsc2UgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDAwZmYwMCB9ICk7XG4gKiBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICogc2NlbmUuYWRkKCBtZXNoICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgQnVmZmVyR2VvbWV0cnlcbiAqL1xuY2xhc3MgVHViZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHR1YmUgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q3VydmV9IFtwYXRoPVF1YWRyYXRpY0JlemllckN1cnZlM10gLSBBIDNEIGN1cnZlIGRlZmluaW5nIHRoZSBwYXRoIG9mIHRoZSB0dWJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02NF0gLSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCB0aGUgdHViZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLVRoZSByYWRpdXMgb2YgdGhlIHR1YmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF0gLSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCB0aGUgY3Jvc3Mtc2VjdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBbY2xvc2VkPWZhbHNlXSAtIFdoZXRoZXIgdGhlIHR1YmUgaXMgY2xvc2VkIG9yIG5vdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXRoID0gbmV3IEN1cnZlc1sgJ1F1YWRyYXRpY0JlemllckN1cnZlMycgXSggbmV3IFZlY3RvcjMoIC0gMSwgLSAxLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSApLCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaXVzID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBjbG9zZWQgPSBmYWxzZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0Y2xvc2VkOiBjbG9zZWRcblx0XHR9O1xuXG5cdFx0Y29uc3QgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCB0dWJ1bGFyU2VnbWVudHMsIGNsb3NlZCApO1xuXG5cdFx0Ly8gZXhwb3NlIGludGVybmFsc1xuXG5cdFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcblx0XHR0aGlzLm5vcm1hbHMgPSBmcmFtZXMubm9ybWFscztcblx0XHR0aGlzLmJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGxldCBQID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGJ1ZmZlclxuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cblx0XHRnZW5lcmF0ZUJ1ZmZlckRhdGEoKTtcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0Ly8gZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRnZW5lcmF0ZVNlZ21lbnQoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXG5cdFx0XHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXG5cblx0XHRcdGdlbmVyYXRlU2VnbWVudCggKCBjbG9zZWQgPT09IGZhbHNlICkgPyB0dWJ1bGFyU2VnbWVudHMgOiAwICk7XG5cblx0XHRcdC8vIHV2cyBhcmUgZ2VuZXJhdGVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdFx0XHQvLyB0aGlzIG1ha2VzIGl0IGVhc3kgY29tcHV0ZSBjb3JyZWN0IHZhbHVlcyBmb3IgY2xvc2VkIGdlb21ldHJpZXNcblxuXHRcdFx0Z2VuZXJhdGVVVnMoKTtcblxuXHRcdFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcblxuXHRcdFx0Z2VuZXJhdGVJbmRpY2VzKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoIGkgKSB7XG5cblx0XHRcdC8vIHdlIHVzZSBnZXRQb2ludEF0IHRvIHNhbXBsZSBldmVubHkgZGlzdHJpYnV0ZWQgcG9pbnRzIGZyb20gdGhlIGdpdmVuIHBhdGhcblxuXHRcdFx0UCA9IHBhdGguZ2V0UG9pbnRBdCggaSAvIHR1YnVsYXJTZWdtZW50cywgUCApO1xuXG5cdFx0XHQvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcblxuXHRcdFx0Y29uc3QgTiA9IGZyYW1lcy5ub3JtYWxzWyBpIF07XG5cdFx0XHRjb25zdCBCID0gZnJhbWVzLmJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSBub3JtYWxzIGFuZCB2ZXJ0aWNlcyBmb3IgdGhlIGN1cnJlbnQgc2VnbWVudFxuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCB2ICk7XG5cdFx0XHRcdGNvbnN0IGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwueCA9ICggY29zICogTi54ICsgc2luICogQi54ICk7XG5cdFx0XHRcdG5vcm1hbC55ID0gKCBjb3MgKiBOLnkgKyBzaW4gKiBCLnkgKTtcblx0XHRcdFx0bm9ybWFsLnogPSAoIGNvcyAqIE4ueiArIHNpbiAqIEIueiApO1xuXHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcblx0XHRcdFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcblx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlSW5kaWNlcygpIHtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcblx0XHRcdFx0XHRjb25zdCBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblx0XHRcdFx0XHRjb25zdCBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcblx0XHRcdFx0XHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBhdGggPSB0aGlzLnBhcmFtZXRlcnMucGF0aC50b0pTT04oKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZnJvbSB0aGUgZ2l2ZW5cblx0ICogSlNPTiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgZ2VvbWV0cnkuXG5cdCAqIEByZXR1cm4ge1R1YmVHZW9tZXRyeX0gQSBuZXcgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHQvLyBUaGlzIG9ubHkgd29ya3MgZm9yIGJ1aWx0LWluIGN1cnZlcyAoZS5nLiBDYXRtdWxsUm9tQ3VydmUzKS5cblx0XHQvLyBVc2VyIGRlZmluZWQgY3VydmVzIG9yIGluc3RhbmNlcyBvZiBDdXJ2ZVBhdGggd2lsbCBub3QgYmUgZGVzZXJpYWxpemVkLlxuXHRcdHJldHVybiBuZXcgVHViZUdlb21ldHJ5KFxuXHRcdFx0bmV3IEN1cnZlc1sgZGF0YS5wYXRoLnR5cGUgXSgpLmZyb21KU09OKCBkYXRhLnBhdGggKSxcblx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0ZGF0YS5jbG9zZWRcblx0XHQpO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFR1YmVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBDYW4gYmUgdXNlZCBhcyBhIGhlbHBlciBvYmplY3QgdG8gdmlzdWFsaXplIGEgZ2VvbWV0cnkgYXMgYSB3aXJlZnJhbWUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCk7XG4gKlxuICogY29uc3Qgd2lyZWZyYW1lID0gbmV3IFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuICpcbiAqIGNvbnN0IGxpbmUgPSBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKCB3aXJlZnJhbWUgKTtcbiAqIGxpbmUubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICogbGluZS5tYXRlcmlhbC5vcGFjaXR5ID0gMC4yNTtcbiAqIGxpbmUubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICpcbiAqIHNjZW5lLmFkZCggbGluZSApO1xuICogYGBgXG4gKlxuICogTm90ZTogSXQgaXMgbm90IHlldCBwb3NzaWJsZSB0byBzZXJpYWxpemUvZGVzZXJpYWxpemUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG4gKlxuICogQGF1Z21lbnRzIEJ1ZmZlckdlb21ldHJ5XG4gKi9cbmNsYXNzIFdpcmVmcmFtZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHdpcmVmcmFtZSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHs/QnVmZmVyR2VvbWV0cnl9IFtnZW9tZXRyeT1udWxsXSAtIFRoZSBnZW9tZXRyeS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG51bGwgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1dpcmVmcmFtZUdlb21ldHJ5JztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2VvbWV0cnkuIEFueSBtb2RpZmljYXRpb25cblx0XHQgKiBhZnRlciBpbnN0YW50aWF0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgZ2VvbWV0cnkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeVxuXHRcdH07XG5cblx0XHRpZiAoIGdlb21ldHJ5ICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBidWZmZXJcblxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IGVkZ2VzID0gbmV3IFNldCgpO1xuXG5cdFx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRsZXQgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGdyb3VwcyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMuY291bnQsIG1hdGVyaWFsSW5kZXg6IDAgfSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZGdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIG8gXTtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IGdyb3VwU3RhcnQsIGwgPSAoIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICk7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gaW5kaWNlcy5nZXRYKCBpICsgaiApO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XG5cblx0XHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xuXHRcdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueiApO1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIGVuZC54LCBlbmQueSwgZW5kLnogKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gKCBwb3NpdGlvbi5jb3VudCAvIDMgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxuXHRcdFx0XHRcdFx0Ly8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXG5cblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MSA9IDMgKiBpICsgajtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDMgKiBpICsgKCAoIGogKyAxICkgJSAzICk7XG5cblx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcblx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdGlmICggaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnogKTtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggZW5kLngsIGVuZC55LCBlbmQueiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGlzVW5pcXVlRWRnZSggc3RhcnQsIGVuZCwgZWRnZXMgKSB7XG5cblx0Y29uc3QgaGFzaDEgPSBgJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen0tJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen1gO1xuXHRjb25zdCBoYXNoMiA9IGAke2VuZC54fSwke2VuZC55fSwke2VuZC56fS0ke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fWA7IC8vIGNvaW5jaWRlbnQgZWRnZVxuXG5cdGlmICggZWRnZXMuaGFzKCBoYXNoMSApID09PSB0cnVlIHx8IGVkZ2VzLmhhcyggaGFzaDIgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0ZWRnZXMuYWRkKCBoYXNoMSApO1xuXHRcdGVkZ2VzLmFkZCggaGFzaDIgKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBXaXJlZnJhbWVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5cbi8qKlxuICogVGhpcyBtYXRlcmlhbCBjYW4gcmVjZWl2ZSBzaGFkb3dzLCBidXQgb3RoZXJ3aXNlIGlzIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoIDIwMDAsIDIwMDAgKTtcbiAqIGdlb21ldHJ5LnJvdGF0ZVgoIC0gTWF0aC5QSSAvIDIgKTtcbiAqXG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkb3dNYXRlcmlhbCgpO1xuICogbWF0ZXJpYWwub3BhY2l0eSA9IDAuMjtcbiAqXG4gKiBjb25zdCBwbGFuZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHBsYW5lLnBvc2l0aW9uLnkgPSAtMjAwO1xuICogcGxhbmUucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gKiBzY2VuZS5hZGQoIHBsYW5lICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTWF0ZXJpYWxcbiAqL1xuY2xhc3MgU2hhZG93TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2hhZG93IG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhZG93TWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29sb3Igb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcndyaXR0ZW4gc2luY2Ugc2hhZG93IG1hdGVyaWFscyBhcmUgdHJhbnNwYXJlbnRcblx0XHQgKiBieSBkZWZhdWx0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgYWZmZWN0ZWQgYnkgZm9nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU2hhZG93TWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsIH0gZnJvbSAnLi9TaGFkZXJNYXRlcmlhbC5qcyc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyB3b3JrcyBqdXN0IGxpa2Uge0BsaW5rIFNoYWRlck1hdGVyaWFsfSwgZXhjZXB0IHRoYXQgZGVmaW5pdGlvbnNcbiAqIG9mIGJ1aWx0LWluIHVuaWZvcm1zIGFuZCBhdHRyaWJ1dGVzIGFyZSBub3QgYXV0b21hdGljYWxseSBwcmVwZW5kZWQgdG8gdGhlXG4gKiBHTFNMIHNoYWRlciBjb2RlLlxuICpcbiAqIGBSYXdTaGFkZXJNYXRlcmlhbGAgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBXZWJHTFJlbmRlcmVyfS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhZGVyTWF0ZXJpYWxcbiAqL1xuY2xhc3MgUmF3U2hhZGVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcmF3IHNoYWRlciBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJzICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUmF3U2hhZGVyTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcblxuLyoqXG4gKiBBIHN0YW5kYXJkIHBoeXNpY2FsbHkgYmFzZWQgbWF0ZXJpYWwsIHVzaW5nIE1ldGFsbGljLVJvdWdobmVzcyB3b3JrZmxvdy5cbiAqXG4gKiBQaHlzaWNhbGx5IGJhc2VkIHJlbmRlcmluZyAoUEJSKSBoYXMgcmVjZW50bHkgYmVjb21lIHRoZSBzdGFuZGFyZCBpbiBtYW55XG4gKiAzRCBhcHBsaWNhdGlvbnMsIHN1Y2ggYXMgW1VuaXR5XXtAbGluayBodHRwczovL2Jsb2dzLnVuaXR5M2QuY29tLzIwMTQvMTAvMjkvcGh5c2ljYWxseS1iYXNlZC1zaGFkaW5nLWluLXVuaXR5LTUtYS1wcmltZXIvfSxcbiAqIFtVbnJlYWxde0BsaW5rIGh0dHBzOi8vZG9jcy51bnJlYWxlbmdpbmUuY29tL2xhdGVzdC9JTlQvRW5naW5lL1JlbmRlcmluZy9NYXRlcmlhbHMvUGh5c2ljYWxseUJhc2VkL30gYW5kXG4gKiBbM0QgU3R1ZGlvIE1heF17QGxpbmsgaHR0cDovL2FyZWEuYXV0b2Rlc2suY29tL2Jsb2dzL3RoZS0zZHMtbWF4LWJsb2cvd2hhdDAzOXMtbmV3LWZvci1yZW5kZXJpbmctaW4tM2RzLW1heC0yMDE3fS5cbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGRpZmZlcnMgZnJvbSBvbGRlciBhcHByb2FjaGVzIGluIHRoYXQgaW5zdGVhZCBvZiB1c2luZ1xuICogYXBwcm94aW1hdGlvbnMgZm9yIHRoZSB3YXkgaW4gd2hpY2ggbGlnaHQgaW50ZXJhY3RzIHdpdGggYSBzdXJmYWNlLCBhXG4gKiBwaHlzaWNhbGx5IGNvcnJlY3QgbW9kZWwgaXMgdXNlZC4gVGhlIGlkZWEgaXMgdGhhdCwgaW5zdGVhZCBvZiB0d2Vha2luZ1xuICogbWF0ZXJpYWxzIHRvIGxvb2sgZ29vZCB1bmRlciBzcGVjaWZpYyBsaWdodGluZywgYSBtYXRlcmlhbCBjYW4gYmUgY3JlYXRlZFxuICogdGhhdCB3aWxsIHJlYWN0ICdjb3JyZWN0bHknIHVuZGVyIGFsbCBsaWdodGluZyBzY2VuYXJpb3MuXG4gKlxuICogSW4gcHJhY3RpY2UgdGhpcyBnaXZlcyBhIG1vcmUgYWNjdXJhdGUgYW5kIHJlYWxpc3RpYyBsb29raW5nIHJlc3VsdCB0aGFuXG4gKiB0aGUge0BsaW5rIE1lc2hMYW1iZXJ0TWF0ZXJpYWx9IG9yIHtAbGluayBNZXNoUGhvbmdNYXRlcmlhbH0sIGF0IHRoZSBjb3N0IG9mXG4gKiBiZWluZyBzb21ld2hhdCBtb3JlIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUuIGBNZXNoU3RhbmRhcmRNYXRlcmlhbGAgdXNlcyBwZXItZnJhZ21lbnRcbiAqIHNoYWRpbmcuXG4gKlxuICogTm90ZSB0aGF0IGZvciBiZXN0IHJlc3VsdHMgeW91IHNob3VsZCBhbHdheXMgc3BlY2lmeSBhbiBlbnZpcm9ubWVudCBtYXAgd2hlbiB1c2luZyB0aGlzIG1hdGVyaWFsLlxuICpcbiAqIEZvciBhIG5vbi10ZWNobmljYWwgaW50cm9kdWN0aW9uIHRvIHRoZSBjb25jZXB0IG9mIFBCUiBhbmQgaG93IHRvIHNldCB1cCBhXG4gKiBQQlIgbWF0ZXJpYWwsIGNoZWNrIG91dCB0aGVzZSBhcnRpY2xlcyBieSB0aGUgcGVvcGxlIGF0IFttYXJtb3NldF17QGxpbmsgaHR0cHM6Ly93d3cubWFybW9zZXQuY299OlxuICpcbiAqIC0gW0Jhc2ljIFRoZW9yeSBvZiBQaHlzaWNhbGx5IEJhc2VkIFJlbmRlcmluZ117QGxpbmsgaHR0cHM6Ly93d3cubWFybW9zZXQuY28vcG9zdHMvYmFzaWMtdGhlb3J5LW9mLXBoeXNpY2FsbHktYmFzZWQtcmVuZGVyaW5nL31cbiAqIC0gW1BoeXNpY2FsbHkgQmFzZWQgUmVuZGVyaW5nIGFuZCBZb3UgQ2FuIFRvb117QGxpbmsgaHR0cHM6Ly93d3cubWFybW9zZXQuY28vcG9zdHMvcGh5c2ljYWxseS1iYXNlZC1yZW5kZXJpbmctYW5kLXlvdS1jYW4tdG9vL31cbiAqXG4gKiBUZWNobmljYWwgZGV0YWlscyBvZiB0aGUgYXBwcm9hY2ggdXNlZCBpbiB0aHJlZS5qcyAoYW5kIG1vc3Qgb3RoZXIgUEJSIHN5c3RlbXMpIGNhbiBiZSBmb3VuZCBpcyB0aGlzXG4gKiBbcGFwZXIgZnJvbSBEaXNuZXlde0BsaW5rIGh0dHBzOi8vbWVkaWEuZGlzbmV5YW5pbWF0aW9uLmNvbS91cGxvYWRzL3Byb2R1Y3Rpb24vcHVibGljYXRpb25fYXNzZXQvNDgvYXNzZXQvczIwMTJfcGJzX2Rpc25leV9icmRmX25vdGVzX3YzLnBkZn1cbiAqIChwZGYpLCBieSBCcmVudCBCdXJsZXkuXG4gKlxuICogQGF1Z21lbnRzIE1hdGVyaWFsXG4gKi9cbmNsYXNzIE1lc2hTdGFuZGFyZE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc2ggc3RhbmRhcmQgbWF0ZXJpYWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBBbiBvYmplY3Qgd2l0aCBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzXG5cdCAqIGRlZmluaW5nIHRoZSBtYXRlcmlhbCdzIGFwcGVhcmFuY2UuIEFueSBwcm9wZXJ0eSBvZiB0aGUgbWF0ZXJpYWxcblx0ICogKGluY2x1ZGluZyBhbnkgcHJvcGVydHkgZnJvbSBpbmhlcml0ZWQgbWF0ZXJpYWxzKSBjYW4gYmUgcGFzc2VkXG5cdCAqIGluIGhlcmUuIENvbG9yIHZhbHVlcyBjYW4gYmUgcGFzc2VkIGFueSB0eXBlIG9mIHZhbHVlIGFjY2VwdGVkXG5cdCAqIGJ5IHtAbGluayBDb2xvciNzZXR9LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XG5cblx0XHQvKipcblx0XHQgKiBDb2xvciBvZiB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICogQGRlZmF1bHQgKDEsMSwxKVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyByb3VnaCB0aGUgbWF0ZXJpYWwgYXBwZWFycy4gYDAuMGAgbWVhbnMgYSBzbW9vdGggbWlycm9yIHJlZmxlY3Rpb24sIGAxLjBgXG5cdFx0ICogbWVhbnMgZnVsbHkgZGlmZnVzZS4gSWYgYHJvdWdobmVzc01hcGAgaXMgYWxzbyBwcm92aWRlZCxcblx0XHQgKiBib3RoIHZhbHVlcyBhcmUgbXVsdGlwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMucm91Z2huZXNzID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIG1hdGVyaWFsIGlzIGxpa2UgYSBtZXRhbC4gTm9uLW1ldGFsbGljIG1hdGVyaWFscyBzdWNoIGFzIHdvb2Rcblx0XHQgKiBvciBzdG9uZSB1c2UgYDAuMGAsIG1ldGFsbGljIHVzZSBgMS4wYCwgd2l0aCBub3RoaW5nICh1c3VhbGx5KSBpbiBiZXR3ZWVuLlxuXHRcdCAqIEEgdmFsdWUgYmV0d2VlbiBgMC4wYCBhbmQgYDEuMGAgY291bGQgYmUgdXNlZCBmb3IgYSBydXN0eSBtZXRhbCBsb29rLlxuXHRcdCAqIElmIGBtZXRhbG5lc3NNYXBgIGlzIGFsc28gcHJvdmlkZWQsIGJvdGggdmFsdWVzIGFyZSBtdWx0aXBsaWVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5tZXRhbG5lc3MgPSAwLjA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY29sb3IgbWFwLiBNYXkgb3B0aW9uYWxseSBpbmNsdWRlIGFuIGFscGhhIGNoYW5uZWwsIHR5cGljYWxseSBjb21iaW5lZFxuXHRcdCAqIHdpdGgge0BsaW5rIE1hdGVyaWFsI3RyYW5zcGFyZW50fSBvciB7QGxpbmsgTWF0ZXJpYWwjYWxwaGFUZXN0fS4gVGhlIHRleHR1cmUgbWFwXG5cdFx0ICogY29sb3IgaXMgbW9kdWxhdGVkIGJ5IHRoZSBkaWZmdXNlIGBjb2xvcmAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaWdodCBtYXAuIFJlcXVpcmVzIGEgc2Vjb25kIHNldCBvZiBVVnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZW5zaXR5IG9mIHRoZSBiYWtlZCBsaWdodC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVkIGNoYW5uZWwgb2YgdGhpcyB0ZXh0dXJlIGlzIHVzZWQgYXMgdGhlIGFtYmllbnQgb2NjbHVzaW9uIG1hcC5cblx0XHQgKiBSZXF1aXJlcyBhIHNlY29uZCBzZXQgb2YgVVZzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVuc2l0eSBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24gZWZmZWN0LiBSYW5nZSBpcyBgWzAsMV1gLCB3aGVyZSBgMGBcblx0XHQgKiBkaXNhYmxlcyBhbWJpZW50IG9jY2x1c2lvbi4gV2hlcmUgaW50ZW5zaXR5IGlzIGAxYCBhbmQgdGhlIEFPIG1hcCdzXG5cdFx0ICogcmVkIGNoYW5uZWwgaXMgYWxzbyBgMWAsIGFtYmllbnQgbGlnaHQgaXMgZnVsbHkgb2NjbHVkZWQgb24gYSBzdXJmYWNlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIEVtaXNzaXZlIChsaWdodCkgY29sb3Igb2YgdGhlIG1hdGVyaWFsLCBlc3NlbnRpYWxseSBhIHNvbGlkIGNvbG9yXG5cdFx0ICogdW5hZmZlY3RlZCBieSBvdGhlciBsaWdodGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMCwwLDApXG5cdFx0ICovXG5cdFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVuc2l0eSBvZiB0aGUgZW1pc3NpdmUgbGlnaHQuIE1vZHVsYXRlcyB0aGUgZW1pc3NpdmUgY29sb3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0IGVtaXNzaXZlIChnbG93KSBtYXAuIFRoZSBlbWlzc2l2ZSBtYXAgY29sb3IgaXMgbW9kdWxhdGVkIGJ5IHRoZVxuXHRcdCAqIGVtaXNzaXZlIGNvbG9yIGFuZCB0aGUgZW1pc3NpdmUgaW50ZW5zaXR5LiBJZiB5b3UgaGF2ZSBhbiBlbWlzc2l2ZSBtYXAsXG5cdFx0ICogYmUgc3VyZSB0byBzZXQgdGhlIGVtaXNzaXZlIGNvbG9yIHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGJsYWNrLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0dXJlIHRvIGNyZWF0ZSBhIGJ1bXAgbWFwLiBUaGUgYmxhY2sgYW5kIHdoaXRlIHZhbHVlcyBtYXAgdG8gdGhlXG5cdFx0ICogcGVyY2VpdmVkIGRlcHRoIGluIHJlbGF0aW9uIHRvIHRoZSBsaWdodHMuIEJ1bXAgZG9lc24ndCBhY3R1YWxseSBhZmZlY3Rcblx0XHQgKiB0aGUgZ2VvbWV0cnkgb2YgdGhlIG9iamVjdCwgb25seSB0aGUgbGlnaHRpbmcuIElmIGEgbm9ybWFsIG1hcCBpcyBkZWZpbmVkXG5cdFx0ICogdGhpcyB3aWxsIGJlIGlnbm9yZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgYnVtcCBtYXAgYWZmZWN0cyB0aGUgbWF0ZXJpYWwuIFR5cGljYWwgcmFuZ2UgaXMgYFswLDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0dXJlIHRvIGNyZWF0ZSBhIG5vcm1hbCBtYXAuIFRoZSBSR0IgdmFsdWVzIGFmZmVjdCB0aGUgc3VyZmFjZVxuXHRcdCAqIG5vcm1hbCBmb3IgZWFjaCBwaXhlbCBmcmFnbWVudCBhbmQgY2hhbmdlIHRoZSB3YXkgdGhlIGNvbG9yIGlzIGxpdC4gTm9ybWFsXG5cdFx0ICogbWFwcyBkbyBub3QgY2hhbmdlIHRoZSBhY3R1YWwgc2hhcGUgb2YgdGhlIHN1cmZhY2UsIG9ubHkgdGhlIGxpZ2h0aW5nLiBJblxuXHRcdCAqIGNhc2UgdGhlIG1hdGVyaWFsIGhhcyBhIG5vcm1hbCBtYXAgYXV0aG9yZWQgdXNpbmcgdGhlIGxlZnQgaGFuZGVkXG5cdFx0ICogY29udmVudGlvbiwgdGhlIGB5YCBjb21wb25lbnQgb2YgYG5vcm1hbFNjYWxlYCBzaG91bGQgYmUgbmVnYXRlZCB0byBjb21wZW5zYXRlXG5cdFx0ICogZm9yIHRoZSBkaWZmZXJlbnQgaGFuZGVkbmVzcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2Ygbm9ybWFsIG1hcC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoVGFuZ2VudFNwYWNlTm9ybWFsTWFwfE9iamVjdFNwYWNlTm9ybWFsTWFwKX1cblx0XHQgKiBAZGVmYXVsdCBUYW5nZW50U3BhY2VOb3JtYWxNYXBcblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgbm9ybWFsIG1hcCBhZmZlY3RzIHRoZSBtYXRlcmlhbC4gVHlwaWNhbCB2YWx1ZSByYW5nZSBpcyBgWzAsMV1gLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICogQGRlZmF1bHQgKDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkaXNwbGFjZW1lbnQgbWFwIGFmZmVjdHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBtZXNoJ3MgdmVydGljZXMuIFVubGlrZVxuXHRcdCAqIG90aGVyIG1hcHMgd2hpY2ggb25seSBhZmZlY3QgdGhlIGxpZ2h0IGFuZCBzaGFkZSBvZiB0aGUgbWF0ZXJpYWwgdGhlXG5cdFx0ICogZGlzcGxhY2VkIHZlcnRpY2VzIGNhbiBjYXN0IHNoYWRvd3MsIGJsb2NrIG90aGVyIG9iamVjdHMsIGFuZCBvdGhlcndpc2Vcblx0XHQgKiBhY3QgYXMgcmVhbCBnZW9tZXRyeS4gVGhlIGRpc3BsYWNlbWVudCB0ZXh0dXJlIGlzIGFuIGltYWdlIHdoZXJlIHRoZSB2YWx1ZVxuXHRcdCAqIG9mIGVhY2ggcGl4ZWwgKHdoaXRlIGJlaW5nIHRoZSBoaWdoZXN0KSBpcyBtYXBwZWQgYWdhaW5zdCwgYW5kXG5cdFx0ICogcmVwb3NpdGlvbnMsIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgbWVzaC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIGRpc3BsYWNlbWVudCBtYXAgYWZmZWN0cyB0aGUgbWVzaCAod2hlcmUgYmxhY2sgaXMgbm9cblx0XHQgKiBkaXNwbGFjZW1lbnQsIGFuZCB3aGl0ZSBpcyBtYXhpbXVtIGRpc3BsYWNlbWVudCkuIFdpdGhvdXQgYSBkaXNwbGFjZW1lbnRcblx0XHQgKiBtYXAgc2V0LCB0aGlzIHZhbHVlIGlzIG5vdCBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2Zmc2V0IG9mIHRoZSBkaXNwbGFjZW1lbnQgbWFwJ3MgdmFsdWVzIG9uIHRoZSBtZXNoJ3MgdmVydGljZXMuXG5cdFx0ICogVGhlIGJpYXMgaXMgYWRkZWQgdG8gdGhlIHNjYWxlZCBzYW1wbGUgb2YgdGhlIGRpc3BsYWNlbWVudCBtYXAuXG5cdFx0ICogV2l0aG91dCBhIGRpc3BsYWNlbWVudCBtYXAgc2V0LCB0aGlzIHZhbHVlIGlzIG5vdCBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBncmVlbiBjaGFubmVsIG9mIHRoaXMgdGV4dHVyZSBpcyB1c2VkIHRvIGFsdGVyIHRoZSByb3VnaG5lc3Mgb2YgdGhlXG5cdFx0ICogbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBibHVlIGNoYW5uZWwgb2YgdGhpcyB0ZXh0dXJlIGlzIHVzZWQgdG8gYWx0ZXIgdGhlIG1ldGFsbmVzcyBvZiB0aGVcblx0XHQgKiBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIG1hcCBpcyBhIGdyYXlzY2FsZSB0ZXh0dXJlIHRoYXQgY29udHJvbHMgdGhlIG9wYWNpdHkgYWNyb3NzIHRoZVxuXHRcdCAqIHN1cmZhY2UgKGJsYWNrOiBmdWxseSB0cmFuc3BhcmVudDsgd2hpdGU6IGZ1bGx5IG9wYXF1ZSkuXG5cdFx0ICpcblx0XHQgKiBPbmx5IHRoZSBjb2xvciBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkLCBpZ25vcmluZyB0aGUgYWxwaGEgY2hhbm5lbCBpZiBvbmVcblx0XHQgKiBleGlzdHMuIEZvciBSR0IgYW5kIFJHQkEgdGV4dHVyZXMsIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgZ3JlZW4gY2hhbm5lbFxuXHRcdCAqIHdoZW4gc2FtcGxpbmcgdGhpcyB0ZXh0dXJlIGR1ZSB0byB0aGUgZXh0cmEgYml0IG9mIHByZWNpc2lvbiBwcm92aWRlZCBmb3Jcblx0XHQgKiBncmVlbiBpbiBEWFQtY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIFJHQiA1NjUgZm9ybWF0cy4gTHVtaW5hbmNlLW9ubHkgYW5kXG5cdFx0ICogbHVtaW5hbmNlL2FscGhhIHRleHR1cmVzIHdpbGwgYWxzbyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbnZpcm9ubWVudCBtYXAuIFRvIGVuc3VyZSBhIHBoeXNpY2FsbHkgY29ycmVjdCByZW5kZXJpbmcsIGVudmlyb25tZW50IG1hcHNcblx0XHQgKiBhcmUgaW50ZXJuYWxseSBwcmUtcHJvY2Vzc2VkIHdpdGgge0BsaW5rIFBNUkVNR2VuZXJhdG9yfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvdGF0aW9uIG9mIHRoZSBlbnZpcm9ubWVudCBtYXAgaW4gcmFkaWFucy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtFdWxlcn1cblx0XHQgKiBAZGVmYXVsdCAoMCwwLDApXG5cdFx0ICovXG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogU2NhbGVzIHRoZSBlZmZlY3Qgb2YgdGhlIGVudmlyb25tZW50IG1hcCBieSBtdWx0aXBseWluZyBpdHMgY29sb3IuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlcnMgdGhlIGdlb21ldHJ5IGFzIGEgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGFwcGVhcmFuY2Ugb2Ygd2lyZWZyYW1lIGVuZHMuXG5cdFx0ICpcblx0XHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGgge0BsaW5rIFNWR1JlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoJ3JvdW5kJ3wnYmV2ZWwnfCdtaXRlcicpfVxuXHRcdCAqIEBkZWZhdWx0ICdyb3VuZCdcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhcHBlYXJhbmNlIG9mIHdpcmVmcmFtZSBqb2ludHMuXG5cdFx0ICpcblx0XHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGgge0BsaW5rIFNWR1JlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoJ3JvdW5kJ3wnYmV2ZWwnfCdtaXRlcicpfVxuXHRcdCAqIEBkZWZhdWx0ICdyb3VuZCdcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIHJlbmRlcmVkIHdpdGggZmxhdCBzaGFkaW5nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgYWZmZWN0ZWQgYnkgZm9nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdFx0dGhpcy5yb3VnaG5lc3MgPSBzb3VyY2Uucm91Z2huZXNzO1xuXHRcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcblxuXHRcdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE1lc2hTdGFuZGFyZE1hdGVyaWFsIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IE1lc2hTdGFuZGFyZE1hdGVyaWFsIH0gZnJvbSAnLi9NZXNoU3RhbmRhcmRNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSB7QGxpbmsgTWVzaFN0YW5kYXJkTWF0ZXJpYWx9LCBwcm92aWRpbmcgbW9yZSBhZHZhbmNlZFxuICogcGh5c2ljYWxseS1iYXNlZCByZW5kZXJpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIEFuaXNvdHJvcHk6IEFiaWxpdHkgdG8gcmVwcmVzZW50IHRoZSBhbmlzb3Ryb3BpYyBwcm9wZXJ0eSBvZiBtYXRlcmlhbHNcbiAqIGFzIG9ic2VydmFibGUgd2l0aCBicnVzaGVkIG1ldGFscy5cbiAqIC0gQ2xlYXJjb2F0OiBTb21lIG1hdGVyaWFscyDigJQgbGlrZSBjYXIgcGFpbnRzLCBjYXJib24gZmliZXIsIGFuZCB3ZXQgc3VyZmFjZXMg4oCUIHJlcXVpcmVcbiAqIGEgY2xlYXIsIHJlZmxlY3RpdmUgbGF5ZXIgb24gdG9wIG9mIGFub3RoZXIgbGF5ZXIgdGhhdCBtYXkgYmUgaXJyZWd1bGFyIG9yIHJvdWdoLlxuICogQ2xlYXJjb2F0IGFwcHJveGltYXRlcyB0aGlzIGVmZmVjdCwgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBzZXBhcmF0ZSB0cmFuc3BhcmVudCBzdXJmYWNlLlxuICogLSBJcmlkZXNjZW5jZTogQWxsb3dzIHRvIHJlbmRlciB0aGUgZWZmZWN0IHdoZXJlIGh1ZSB2YXJpZXMgIGRlcGVuZGluZyBvbiB0aGUgdmlld2luZ1xuICogYW5nbGUgYW5kIGlsbHVtaW5hdGlvbiBhbmdsZS4gVGhpcyBjYW4gYmUgc2VlbiBvbiBzb2FwIGJ1YmJsZXMsIG9pbCBmaWxtcywgb3Igb24gdGhlXG4gKiB3aW5ncyBvZiBtYW55IGluc2VjdHMuXG4gKiAtIFBoeXNpY2FsbHktYmFzZWQgdHJhbnNwYXJlbmN5OiBPbmUgbGltaXRhdGlvbiBvZiB7QGxpbmsgTWF0ZXJpYWwjb3BhY2l0eX0gaXMgdGhhdCBoaWdobHlcbiAqIHRyYW5zcGFyZW50IG1hdGVyaWFscyBhcmUgbGVzcyByZWZsZWN0aXZlLiBQaHlzaWNhbGx5LWJhc2VkIHRyYW5zbWlzc2lvbiBwcm92aWRlcyBhIG1vcmVcbiAqIHJlYWxpc3RpYyBvcHRpb24gZm9yIHRoaW4sIHRyYW5zcGFyZW50IHN1cmZhY2VzIGxpa2UgZ2xhc3MuXG4gKiAtIEFkdmFuY2VkIHJlZmxlY3Rpdml0eTogTW9yZSBmbGV4aWJsZSByZWZsZWN0aXZpdHkgZm9yIG5vbi1tZXRhbGxpYyBtYXRlcmlhbHMuXG4gKiAtIFNoZWVuOiBDYW4gYmUgdXNlZCBmb3IgcmVwcmVzZW50aW5nIGNsb3RoIGFuZCBmYWJyaWMgbWF0ZXJpYWxzLlxuICpcbiAqIEFzIGEgcmVzdWx0IG9mIHRoZXNlIGNvbXBsZXggc2hhZGluZyBmZWF0dXJlcywgYE1lc2hQaHlzaWNhbE1hdGVyaWFsYCBoYXMgYVxuICogaGlnaGVyIHBlcmZvcm1hbmNlIGNvc3QsIHBlciBwaXhlbCwgdGhhbiBvdGhlciB0aHJlZS5qcyBtYXRlcmlhbHMuIE1vc3RcbiAqIGVmZmVjdHMgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFuZCBhZGQgY29zdCBhcyB0aGV5IGFyZSBlbmFibGVkLiBGb3JcbiAqIGJlc3QgcmVzdWx0cywgYWx3YXlzIHNwZWNpZnkgYW4gZW52aXJvbm1lbnQgbWFwIHdoZW4gdXNpbmcgdGhpcyBtYXRlcmlhbC5cbiAqXG4gKiBAYXVnbWVudHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWxcbiAqL1xuY2xhc3MgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgZXh0ZW5kcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbWVzaCBwaHlzaWNhbCBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0ge1xuXG5cdFx0XHQnU1RBTkRBUkQnOiAnJyxcblx0XHRcdCdQSFlTSUNBTCc6ICcnXG5cblx0XHR9O1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYW5pc290cm9weSBpbiB0YW5nZW50LCBiaXRhbmdlbnQgc3BhY2UsIG1lYXN1cmVkIGluIHJhZGlhbnNcblx0XHQgKiBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIHRoZSB0YW5nZW50LiBXaGVuIGBhbmlzb3Ryb3B5TWFwYCBpcyBwcmVzZW50LCB0aGlzXG5cdFx0ICogcHJvcGVydHkgcHJvdmlkZXMgYWRkaXRpb25hbCByb3RhdGlvbiB0byB0aGUgdmVjdG9ycyBpbiB0aGUgdGV4dHVyZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYW5pc290cm9weVJvdGF0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZCBhbmQgZ3JlZW4gY2hhbm5lbHMgcmVwcmVzZW50IHRoZSBhbmlzb3Ryb3B5IGRpcmVjdGlvbiBpbiBgWy0xLCAxXWAgdGFuZ2VudCxcblx0XHQgKiBiaXRhbmdlbnQgc3BhY2UsIHRvIGJlIHJvdGF0ZWQgYnkgYGFuaXNvdHJvcHlSb3RhdGlvbmAuIFRoZSBibHVlIGNoYW5uZWxcblx0XHQgKiBjb250YWlucyBzdHJlbmd0aCBhcyBgWzAsIDFdYCB0byBiZSBtdWx0aXBsaWVkIGJ5IGBhbmlzb3Ryb3B5YC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5hbmlzb3Ryb3B5TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZWQgY2hhbm5lbCBvZiB0aGlzIHRleHR1cmUgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGBjbGVhcmNvYXRgLFxuXHRcdCAqIGZvciBwZXItcGl4ZWwgY29udHJvbCBvdmVyIGEgY29hdGluZydzIGludGVuc2l0eS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcmNvYXRNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogUm91Z2huZXNzIG9mIHRoZSBjbGVhciBjb2F0IGxheWVyLCBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZ3JlZW4gY2hhbm5lbCBvZiB0aGlzIHRleHR1cmUgaXMgbXVsdGlwbGllZCBhZ2FpbnN0XG5cdFx0ICogYGNsZWFyY29hdFJvdWdobmVzc2AsIGZvciBwZXItcGl4ZWwgY29udHJvbCBvdmVyIGEgY29hdGluZydzIHJvdWdobmVzcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggYGNsZWFyY29hdE5vcm1hbE1hcGAgYWZmZWN0cyB0aGUgY2xlYXIgY29hdCBsYXllciwgZnJvbVxuXHRcdCAqIGAoMCwwKWAgdG8gYCgxLDEpYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBDYW4gYmUgdXNlZCB0byBlbmFibGUgaW5kZXBlbmRlbnQgbm9ybWFscyBmb3IgdGhlIGNsZWFyIGNvYXQgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGV4LW9mLXJlZnJhY3Rpb24gZm9yIG5vbi1tZXRhbGxpYyBtYXRlcmlhbHMsIGZyb20gYDEuMGAgdG8gYDIuMzMzYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMS41XG5cdFx0ICovXG5cdFx0dGhpcy5pb3IgPSAxLjU7XG5cblx0XHQvKipcblx0XHQgKiBEZWdyZWUgb2YgcmVmbGVjdGl2aXR5LCBmcm9tIGAwLjBgIHRvIGAxLjBgLiBEZWZhdWx0IGlzIGAwLjVgLCB3aGljaFxuXHRcdCAqIGNvcnJlc3BvbmRzIHRvIGFuIGluZGV4LW9mLXJlZnJhY3Rpb24gb2YgYDEuNWAuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1vZGVscyB0aGUgcmVmbGVjdGl2aXR5IG9mIG5vbi1tZXRhbGxpYyBtYXRlcmlhbHMuIEl0IGhhcyBubyBlZmZlY3Rcblx0XHQgKiB3aGVuIGBtZXRhbG5lc3NgIGlzIGAxLjBgXG5cdFx0ICpcblx0XHQgKiBAbmFtZSBNZXNoUGh5c2ljYWxNYXRlcmlhbCNyZWZsZWN0aXZpdHlcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDAuNVxuXHRcdCAqL1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3JlZmxlY3Rpdml0eScsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiAoIGNsYW1wKCAyLjUgKiAoIHRoaXMuaW9yIC0gMSApIC8gKCB0aGlzLmlvciArIDEgKSwgMCwgMSApICk7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggcmVmbGVjdGl2aXR5ICkge1xuXG5cdFx0XHRcdHRoaXMuaW9yID0gKCAxICsgMC40ICogcmVmbGVjdGl2aXR5ICkgLyAoIDEgLSAwLjQgKiByZWZsZWN0aXZpdHkgKTtcblxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZWQgY2hhbm5lbCBvZiB0aGlzIHRleHR1cmUgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGBpcmlkZXNjZW5jZWAsIGZvciBwZXItcGl4ZWxcblx0XHQgKiBjb250cm9sIG92ZXIgaXJpZGVzY2VuY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogU3RyZW5ndGggb2YgdGhlIGlyaWRlc2NlbmNlIFJHQiBjb2xvciBzaGlmdCBlZmZlY3QsIHJlcHJlc2VudGVkIGJ5IGFuIGluZGV4LW9mLXJlZnJhY3Rpb24uXG5cdFx0ICogQmV0d2VlbiBgMS4wYCB0byBgMi4zMzNgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxLjNcblx0XHQgKi9cblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gMS4zO1xuXG5cdFx0LyoqXG5cdFx0ICpBcnJheSBvZiBleGFjdGx5IDIgZWxlbWVudHMsIHNwZWNpZnlpbmcgbWluaW11bSBhbmQgbWF4aW11bSB0aGlja25lc3Mgb2YgdGhlIGlyaWRlc2NlbmNlIGxheWVyLlxuXHRcdCBUaGlja25lc3Mgb2YgaXJpZGVzY2VuY2UgbGF5ZXIgaGFzIGFuIGVxdWl2YWxlbnQgZWZmZWN0IG9mIHRoZSBvbmUgYHRoaWNrbmVzc2AgaGFzIG9uIGBpb3JgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PG51bWJlcixudW1iZXI+fVxuXHRcdCAqIEBkZWZhdWx0IFsxMDAsNDAwXVxuXHRcdCAqL1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsgMTAwLCA0MDAgXTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgdGV4dHVyZSB0aGF0IGRlZmluZXMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgaXJpZGVzY2VuY2UgbGF5ZXIsIHN0b3JlZCBpbiB0aGUgZ3JlZW4gY2hhbm5lbC5cblx0XHQgKiBNaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBvZiB0aGlja25lc3MgYXJlIGRlZmluZWQgYnkgYGlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VgIGFycmF5OlxuXHRcdCAqIC0gYDAuMGAgaW4gdGhlIGdyZWVuIGNoYW5uZWwgd2lsbCByZXN1bHQgaW4gdGhpY2tuZXNzIGVxdWFsIHRvIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuXHRcdCAqIC0gYDEuMGAgaW4gdGhlIGdyZWVuIGNoYW5uZWwgd2lsbCByZXN1bHQgaW4gdGhpY2tuZXNzIGVxdWFsIHRvIHNlY29uZCBlbGVtZW50IG9mIHRoZSBhcnJheS5cblx0XHQgKiAtIFZhbHVlcyBpbi1iZXR3ZWVuIHdpbGwgbGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzaGVlbiB0aW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHQgKi9cblx0XHR0aGlzLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgUkdCIGNoYW5uZWxzIG9mIHRoaXMgdGV4dHVyZSBhcmUgbXVsdGlwbGllZCBhZ2FpbnN0ICBgc2hlZW5Db2xvcmAsIGZvciBwZXItcGl4ZWwgY29udHJvbFxuXHRcdCAqIG92ZXIgc2hlZW4gdGludC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zaGVlbkNvbG9yTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFJvdWdobmVzcyBvZiB0aGUgc2hlZW4gbGF5ZXIsIGZyb20gYDAuMGAgdG8gYDEuMGAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIGNoYW5uZWwgb2YgdGhpcyB0ZXh0dXJlIGlzIG11bHRpcGxpZWQgYWdhaW5zdCBgc2hlZW5Sb3VnaG5lc3NgLCBmb3IgcGVyLXBpeGVsIGNvbnRyb2xcblx0XHQgKiBvdmVyIHNoZWVuIHJvdWdobmVzcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zaGVlblJvdWdobmVzc01hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVkIGNoYW5uZWwgb2YgdGhpcyB0ZXh0dXJlIGlzIG11bHRpcGxpZWQgYWdhaW5zdCBgdHJhbnNtaXNzaW9uYCwgZm9yIHBlci1waXhlbCBjb250cm9sIG92ZXJcblx0XHQgKiBvcHRpY2FsIHRyYW5zcGFyZW5jeS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRoaWNrbmVzcyBvZiB0aGUgdm9sdW1lIGJlbmVhdGggdGhlIHN1cmZhY2UuIFRoZSB2YWx1ZSBpcyBnaXZlbiBpbiB0aGVcblx0XHQgKiBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBtZXNoLiBJZiB0aGUgdmFsdWUgaXMgYDBgIHRoZSBtYXRlcmlhbCBpc1xuXHRcdCAqIHRoaW4td2FsbGVkLiBPdGhlcndpc2UgdGhlIG1hdGVyaWFsIGlzIGEgdm9sdW1lIGJvdW5kYXJ5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy50aGlja25lc3MgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB0ZXh0dXJlIHRoYXQgZGVmaW5lcyB0aGUgdGhpY2tuZXNzLCBzdG9yZWQgaW4gdGhlIGdyZWVuIGNoYW5uZWwuIFRoaXMgd2lsbFxuXHRcdCAqIGJlIG11bHRpcGxpZWQgYnkgYHRoaWNrbmVzc2AuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudGhpY2tuZXNzTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERlbnNpdHkgb2YgdGhlIG1lZGl1bSBnaXZlbiBhcyB0aGUgYXZlcmFnZSBkaXN0YW5jZSB0aGF0IGxpZ2h0IHRyYXZlbHMgaW5cblx0XHQgKiB0aGUgbWVkaXVtIGJlZm9yZSBpbnRlcmFjdGluZyB3aXRoIGEgcGFydGljbGUuIFRoZSB2YWx1ZSBpcyBnaXZlbiBpbiB3b3JsZFxuXHRcdCAqIHNwYWNlIHVuaXRzLCBhbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgSW5maW5pdHlcblx0XHQgKi9cblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciB0aGF0IHdoaXRlIGxpZ2h0IHR1cm5zIGludG8gZHVlIHRvIGFic29ycHRpb24gd2hlbiByZWFjaGluZyB0aGVcblx0XHQgKiBhdHRlbnVhdGlvbiBkaXN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKCAxLCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBBIGZsb2F0IHRoYXQgc2NhbGVzIHRoZSBhbW91bnQgb2Ygc3BlY3VsYXIgcmVmbGVjdGlvbiBmb3Igbm9uLW1ldGFscyBvbmx5LlxuXHRcdCAqIFdoZW4gc2V0IHRvIHplcm8sIHRoZSBtb2RlbCBpcyBlZmZlY3RpdmVseSBMYW1iZXJ0aWFuLiBGcm9tIGAwLjBgIHRvIGAxLjBgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbHBoYSBjaGFubmVsIG9mIHRoaXMgdGV4dHVyZSBpcyBtdWx0aXBsaWVkIGFnYWluc3QgYHNwZWN1bGFySW50ZW5zaXR5YCxcblx0XHQgKiBmb3IgcGVyLXBpeGVsIGNvbnRyb2wgb3ZlciBzcGVjdWxhciBpbnRlbnNpdHkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGludHMgdGhlIHNwZWN1bGFyIHJlZmxlY3Rpb24gYXQgbm9ybWFsIGluY2lkZW5jZSBmb3Igbm9uLW1ldGFscyBvbmx5LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoIDEsIDEsIDEgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBSR0IgY2hhbm5lbHMgb2YgdGhpcyB0ZXh0dXJlIGFyZSBtdWx0aXBsaWVkIGFnYWluc3QgYHNwZWN1bGFyQ29sb3JgLFxuXHRcdCAqIGZvciBwZXItcGl4ZWwgY29udHJvbCBvdmVyIHNwZWN1bGFyIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5fYW5pc290cm9weSA9IDA7XG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gMDtcblx0XHR0aGlzLl9kaXNwZXJzaW9uID0gMDtcblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IDA7XG5cdFx0dGhpcy5fc2hlZW4gPSAwLjA7XG5cdFx0dGhpcy5fdHJhbnNtaXNzaW9uID0gMDtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYW5pc290cm9weSBzdHJlbmd0aC5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKi9cblx0Z2V0IGFuaXNvdHJvcHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fYW5pc290cm9weTtcblxuXHR9XG5cblx0c2V0IGFuaXNvdHJvcHkoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl9hbmlzb3Ryb3B5ID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9hbmlzb3Ryb3B5ID0gdmFsdWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGNsZWFyIGNvYXQgbGF5ZXIsIGZyb20gYDAuMGAgdG8gYDEuMGAuIFVzZVxuXHQgKiBjbGVhciBjb2F0IHJlbGF0ZWQgcHJvcGVydGllcyB0byBlbmFibGUgbXVsdGlsYXllciBtYXRlcmlhbHMgdGhhdCBoYXZlIGFcblx0ICogdGhpbiB0cmFuc2x1Y2VudCBsYXllciBvdmVyIHRoZSBiYXNlIGxheWVyLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRnZXQgY2xlYXJjb2F0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NsZWFyY29hdDtcblxuXHR9XG5cblx0c2V0IGNsZWFyY29hdCggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2NsZWFyY29hdCA+IDAgIT09IHZhbHVlID4gMCApIHtcblxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXJjb2F0ID0gdmFsdWU7XG5cblx0fVxuXHQvKipcblx0ICogVGhlIGludGVuc2l0eSBvZiB0aGUgaXJpZGVzY2VuY2UgbGF5ZXIsIHNpbXVsYXRpbmcgUkdCIGNvbG9yIHNoaWZ0IGJhc2VkIG9uIHRoZSBhbmdsZSBiZXR3ZWVuXG5cdCAqIHRoZSBzdXJmYWNlIGFuZCB0aGUgdmlld2VyLCBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRnZXQgaXJpZGVzY2VuY2UoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5faXJpZGVzY2VuY2U7XG5cblx0fVxuXG5cdHNldCBpcmlkZXNjZW5jZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lyaWRlc2NlbmNlID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgc3RyZW5ndGggb2YgdGhlIGFuZ3VsYXIgc2VwYXJhdGlvbiBvZiBjb2xvcnMgKGNocm9tYXRpYyBhYmVycmF0aW9uKSB0cmFuc21pdHRpbmdcblx0ICogdGhyb3VnaCBhIHJlbGF0aXZlbHkgY2xlYXIgdm9sdW1lLiBBbnkgdmFsdWUgemVybyBvciBsYXJnZXIgaXMgdmFsaWQsIHRoZSB0eXBpY2FsIHJhbmdlIG9mXG5cdCAqIHJlYWxpc3RpYyB2YWx1ZXMgaXMgYFswLCAxXWAuIFRoaXMgcHJvcGVydHkgY2FuIGJlIG9ubHkgYmUgdXNlZCB3aXRoIHRyYW5zbWlzc2l2ZSBvYmplY3RzLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRnZXQgZGlzcGVyc2lvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9kaXNwZXJzaW9uO1xuXG5cdH1cblxuXHRzZXQgZGlzcGVyc2lvbiggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2Rpc3BlcnNpb24gPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX2Rpc3BlcnNpb24gPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBpbnRlbnNpdHkgb2YgdGhlIHNoZWVuIGxheWVyLCBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRnZXQgc2hlZW4oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2hlZW47XG5cblx0fVxuXG5cdHNldCBzaGVlbiggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXMuX3NoZWVuID4gMCAhPT0gdmFsdWUgPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9zaGVlbiA9IHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVncmVlIG9mIHRyYW5zbWlzc2lvbiAob3Igb3B0aWNhbCB0cmFuc3BhcmVuY3kpLCBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuXHQgKlxuXHQgKiBUaGluLCB0cmFuc3BhcmVudCBvciBzZW1pdHJhbnNwYXJlbnQsIHBsYXN0aWMgb3IgZ2xhc3MgbWF0ZXJpYWxzIHJlbWFpblxuXHQgKiBsYXJnZWx5IHJlZmxlY3RpdmUgZXZlbiBpZiB0aGV5IGFyZSBmdWxseSB0cmFuc21pc3NpdmUuIFRoZSB0cmFuc21pc3Npb25cblx0ICogcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gbW9kZWwgdGhlc2UgbWF0ZXJpYWxzLlxuXHQgKlxuXHQgKiBXaGVuIHRyYW5zbWlzc2lvbiBpcyBub24temVybywgYG9wYWNpdHlgIHNob3VsZCBiZSAgc2V0IHRvIGAxYC5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKi9cblx0Z2V0IHRyYW5zbWlzc2lvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLl90cmFuc21pc3Npb247XG5cblx0fVxuXG5cdHNldCB0cmFuc21pc3Npb24oIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl90cmFuc21pc3Npb24gPiAwICE9PSB2YWx1ZSA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVyc2lvbiArKztcblxuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IHZhbHVlO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHtcblxuXHRcdFx0J1NUQU5EQVJEJzogJycsXG5cdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xuXHRcdHRoaXMuYW5pc290cm9weVJvdGF0aW9uID0gc291cmNlLmFuaXNvdHJvcHlSb3RhdGlvbjtcblx0XHR0aGlzLmFuaXNvdHJvcHlNYXAgPSBzb3VyY2UuYW5pc290cm9weU1hcDtcblxuXHRcdHRoaXMuY2xlYXJjb2F0ID0gc291cmNlLmNsZWFyY29hdDtcblx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IHNvdXJjZS5jbGVhcmNvYXRNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCA9IHNvdXJjZS5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS5jb3B5KCBzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGVyc2lvbiA9IHNvdXJjZS5kaXNwZXJzaW9uO1xuXHRcdHRoaXMuaW9yID0gc291cmNlLmlvcjtcblxuXHRcdHRoaXMuaXJpZGVzY2VuY2UgPSBzb3VyY2UuaXJpZGVzY2VuY2U7XG5cdFx0dGhpcy5pcmlkZXNjZW5jZU1hcCA9IHNvdXJjZS5pcmlkZXNjZW5jZU1hcDtcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gc291cmNlLmlyaWRlc2NlbmNlSU9SO1xuXHRcdHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsgLi4uc291cmNlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgXTtcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gc291cmNlLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xuXG5cdFx0dGhpcy5zaGVlbiA9IHNvdXJjZS5zaGVlbjtcblx0XHR0aGlzLnNoZWVuQ29sb3IuY29weSggc291cmNlLnNoZWVuQ29sb3IgKTtcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBzb3VyY2Uuc2hlZW5Db2xvck1hcDtcblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gc291cmNlLnNoZWVuUm91Z2huZXNzO1xuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NNYXAgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3NNYXA7XG5cblx0XHR0aGlzLnRyYW5zbWlzc2lvbiA9IHNvdXJjZS50cmFuc21pc3Npb247XG5cdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBzb3VyY2UudHJhbnNtaXNzaW9uTWFwO1xuXG5cdFx0dGhpcy50aGlja25lc3MgPSBzb3VyY2UudGhpY2tuZXNzO1xuXHRcdHRoaXMudGhpY2tuZXNzTWFwID0gc291cmNlLnRoaWNrbmVzc01hcDtcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBzb3VyY2UuYXR0ZW51YXRpb25EaXN0YW5jZTtcblx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3IuY29weSggc291cmNlLmF0dGVudWF0aW9uQ29sb3IgKTtcblxuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eU1hcDtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3IuY29weSggc291cmNlLnNwZWN1bGFyQ29sb3IgKTtcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBzb3VyY2Uuc3BlY3VsYXJDb2xvck1hcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNZXNoUGh5c2ljYWxNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgTXVsdGlwbHlPcGVyYXRpb24sIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcblxuLyoqXG4gKiBBIG1hdGVyaWFsIGZvciBzaGlueSBzdXJmYWNlcyB3aXRoIHNwZWN1bGFyIGhpZ2hsaWdodHMuXG4gKlxuICogVGhlIG1hdGVyaWFsIHVzZXMgYSBub24tcGh5c2ljYWxseSBiYXNlZCBbQmxpbm4tUGhvbmdde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JsaW5uLVBob25nX3NoYWRpbmdfbW9kZWx9XG4gKiBtb2RlbCBmb3IgY2FsY3VsYXRpbmcgcmVmbGVjdGFuY2UuIFVubGlrZSB0aGUgTGFtYmVydGlhbiBtb2RlbCB1c2VkIGluIHRoZVxuICoge0BsaW5rIE1lc2hMYW1iZXJ0TWF0ZXJpYWx9IHRoaXMgY2FuIHNpbXVsYXRlIHNoaW55IHN1cmZhY2VzIHdpdGggc3BlY3VsYXJcbiAqIGhpZ2hsaWdodHMgKHN1Y2ggYXMgdmFybmlzaGVkIHdvb2QpLiBgTWVzaFBob25nTWF0ZXJpYWxgIHVzZXMgcGVyLWZyYWdtZW50IHNoYWRpbmcuXG4gKlxuICogUGVyZm9ybWFuY2Ugd2lsbCBnZW5lcmFsbHkgYmUgZ3JlYXRlciB3aGVuIHVzaW5nIHRoaXMgbWF0ZXJpYWwgb3ZlciB0aGVcbiAqIHtAbGluayBNZXNoU3RhbmRhcmRNYXRlcmlhbH0gb3Ige0BsaW5rIE1lc2hQaHlzaWNhbE1hdGVyaWFsfSwgYXQgdGhlIGNvc3Qgb2ZcbiAqIHNvbWUgZ3JhcGhpY2FsIGFjY3VyYWN5LlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBNZXNoUGhvbmdNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtZXNoIHBob25nIG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29sb3Igb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cblx0XHQvKipcblx0XHQgKiBTcGVjdWxhciBjb2xvciBvZiB0aGUgbWF0ZXJpYWwuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIHNldCB0byBgMHgxMTExMTFgICh2ZXJ5IGRhcmsgZ3JleSlcblx0XHQgKlxuXHRcdCAqIFRoaXMgZGVmaW5lcyBob3cgc2hpbnkgdGhlIG1hdGVyaWFsIGlzIGFuZCB0aGUgY29sb3Igb2YgaXRzIHNoaW5lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqL1xuXHRcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDB4MTExMTExICk7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgc2hpbnkgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodCBpczsgYSBoaWdoZXIgdmFsdWUgZ2l2ZXMgYSBzaGFycGVyIGhpZ2hsaWdodC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMzBcblx0XHQgKi9cblx0XHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIG1hcC4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhbiBhbHBoYSBjaGFubmVsLCB0eXBpY2FsbHkgY29tYmluZWRcblx0XHQgKiB3aXRoIHtAbGluayBNYXRlcmlhbCN0cmFuc3BhcmVudH0gb3Ige0BsaW5rIE1hdGVyaWFsI2FscGhhVGVzdH0uIFRoZSB0ZXh0dXJlIG1hcFxuXHRcdCAqIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGUgZGlmZnVzZSBgY29sb3JgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlnaHQgbWFwLiBSZXF1aXJlcyBhIHNlY29uZCBzZXQgb2YgVVZzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVuc2l0eSBvZiB0aGUgYmFrZWQgbGlnaHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlZCBjaGFubmVsIG9mIHRoaXMgdGV4dHVyZSBpcyB1c2VkIGFzIHRoZSBhbWJpZW50IG9jY2x1c2lvbiBtYXAuXG5cdFx0ICogUmVxdWlyZXMgYSBzZWNvbmQgc2V0IG9mIFVWcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uIGVmZmVjdC4gUmFuZ2UgaXMgYFswLDFdYCwgd2hlcmUgYDBgXG5cdFx0ICogZGlzYWJsZXMgYW1iaWVudCBvY2NsdXNpb24uIFdoZXJlIGludGVuc2l0eSBpcyBgMWAgYW5kIHRoZSBBTyBtYXAnc1xuXHRcdCAqIHJlZCBjaGFubmVsIGlzIGFsc28gYDFgLCBhbWJpZW50IGxpZ2h0IGlzIGZ1bGx5IG9jY2x1ZGVkIG9uIGEgc3VyZmFjZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHQvKipcblx0XHQgKiBFbWlzc2l2ZSAobGlnaHQpIGNvbG9yIG9mIHRoZSBtYXRlcmlhbCwgZXNzZW50aWFsbHkgYSBzb2xpZCBjb2xvclxuXHRcdCAqIHVuYWZmZWN0ZWQgYnkgb3RoZXIgbGlnaHRpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCwwKVxuXHRcdCAqL1xuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGVtaXNzaXZlIGxpZ2h0LiBNb2R1bGF0ZXMgdGhlIGVtaXNzaXZlIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBlbWlzc2l2ZSAoZ2xvdykgbWFwLiBUaGUgZW1pc3NpdmUgbWFwIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGVcblx0XHQgKiBlbWlzc2l2ZSBjb2xvciBhbmQgdGhlIGVtaXNzaXZlIGludGVuc2l0eS4gSWYgeW91IGhhdmUgYW4gZW1pc3NpdmUgbWFwLFxuXHRcdCAqIGJlIHN1cmUgdG8gc2V0IHRoZSBlbWlzc2l2ZSBjb2xvciB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBibGFjay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBidW1wIG1hcC4gVGhlIGJsYWNrIGFuZCB3aGl0ZSB2YWx1ZXMgbWFwIHRvIHRoZVxuXHRcdCAqIHBlcmNlaXZlZCBkZXB0aCBpbiByZWxhdGlvbiB0byB0aGUgbGlnaHRzLiBCdW1wIGRvZXNuJ3QgYWN0dWFsbHkgYWZmZWN0XG5cdFx0ICogdGhlIGdlb21ldHJ5IG9mIHRoZSBvYmplY3QsIG9ubHkgdGhlIGxpZ2h0aW5nLiBJZiBhIG5vcm1hbCBtYXAgaXMgZGVmaW5lZFxuXHRcdCAqIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIGJ1bXAgbWFwIGFmZmVjdHMgdGhlIG1hdGVyaWFsLiBUeXBpY2FsIHJhbmdlIGlzIGBbMCwxXWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBub3JtYWwgbWFwLiBUaGUgUkdCIHZhbHVlcyBhZmZlY3QgdGhlIHN1cmZhY2Vcblx0XHQgKiBub3JtYWwgZm9yIGVhY2ggcGl4ZWwgZnJhZ21lbnQgYW5kIGNoYW5nZSB0aGUgd2F5IHRoZSBjb2xvciBpcyBsaXQuIE5vcm1hbFxuXHRcdCAqIG1hcHMgZG8gbm90IGNoYW5nZSB0aGUgYWN0dWFsIHNoYXBlIG9mIHRoZSBzdXJmYWNlLCBvbmx5IHRoZSBsaWdodGluZy4gSW5cblx0XHQgKiBjYXNlIHRoZSBtYXRlcmlhbCBoYXMgYSBub3JtYWwgbWFwIGF1dGhvcmVkIHVzaW5nIHRoZSBsZWZ0IGhhbmRlZFxuXHRcdCAqIGNvbnZlbnRpb24sIHRoZSBgeWAgY29tcG9uZW50IG9mIGBub3JtYWxTY2FsZWAgc2hvdWxkIGJlIG5lZ2F0ZWQgdG8gY29tcGVuc2F0ZVxuXHRcdCAqIGZvciB0aGUgZGlmZmVyZW50IGhhbmRlZG5lc3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIG5vcm1hbCBtYXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFRhbmdlbnRTcGFjZU5vcm1hbE1hcHxPYmplY3RTcGFjZU5vcm1hbE1hcCl9XG5cdFx0ICogQGRlZmF1bHQgVGFuZ2VudFNwYWNlTm9ybWFsTWFwXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIG5vcm1hbCBtYXAgYWZmZWN0cyB0aGUgbWF0ZXJpYWwuIFR5cGljYWwgdmFsdWUgcmFuZ2UgaXMgYFswLDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVzaCdzIHZlcnRpY2VzLiBVbmxpa2Vcblx0XHQgKiBvdGhlciBtYXBzIHdoaWNoIG9ubHkgYWZmZWN0IHRoZSBsaWdodCBhbmQgc2hhZGUgb2YgdGhlIG1hdGVyaWFsIHRoZVxuXHRcdCAqIGRpc3BsYWNlZCB2ZXJ0aWNlcyBjYW4gY2FzdCBzaGFkb3dzLCBibG9jayBvdGhlciBvYmplY3RzLCBhbmQgb3RoZXJ3aXNlXG5cdFx0ICogYWN0IGFzIHJlYWwgZ2VvbWV0cnkuIFRoZSBkaXNwbGFjZW1lbnQgdGV4dHVyZSBpcyBhbiBpbWFnZSB3aGVyZSB0aGUgdmFsdWVcblx0XHQgKiBvZiBlYWNoIHBpeGVsICh3aGl0ZSBiZWluZyB0aGUgaGlnaGVzdCkgaXMgbWFwcGVkIGFnYWluc3QsIGFuZFxuXHRcdCAqIHJlcG9zaXRpb25zLCB0aGUgdmVydGljZXMgb2YgdGhlIG1lc2guXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBkaXNwbGFjZW1lbnQgbWFwIGFmZmVjdHMgdGhlIG1lc2ggKHdoZXJlIGJsYWNrIGlzIG5vXG5cdFx0ICogZGlzcGxhY2VtZW50LCBhbmQgd2hpdGUgaXMgbWF4aW11bSBkaXNwbGFjZW1lbnQpLiBXaXRob3V0IGEgZGlzcGxhY2VtZW50XG5cdFx0ICogbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9mZnNldCBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcCdzIHZhbHVlcyBvbiB0aGUgbWVzaCdzIHZlcnRpY2VzLlxuXHRcdCAqIFRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBzY2FsZWQgc2FtcGxlIG9mIHRoZSBkaXNwbGFjZW1lbnQgbWFwLlxuXHRcdCAqIFdpdGhvdXQgYSBkaXNwbGFjZW1lbnQgbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3BlY3VsYXIgbWFwIHZhbHVlIGFmZmVjdHMgYm90aCBob3cgbXVjaCB0aGUgc3BlY3VsYXIgc3VyZmFjZVxuXHRcdCAqIGhpZ2hsaWdodCBjb250cmlidXRlcyBhbmQgaG93IG11Y2ggb2YgdGhlIGVudmlyb25tZW50IG1hcCBhZmZlY3RzIHRoZVxuXHRcdCAqIHN1cmZhY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIG1hcCBpcyBhIGdyYXlzY2FsZSB0ZXh0dXJlIHRoYXQgY29udHJvbHMgdGhlIG9wYWNpdHkgYWNyb3NzIHRoZVxuXHRcdCAqIHN1cmZhY2UgKGJsYWNrOiBmdWxseSB0cmFuc3BhcmVudDsgd2hpdGU6IGZ1bGx5IG9wYXF1ZSkuXG5cdFx0ICpcblx0XHQgKiBPbmx5IHRoZSBjb2xvciBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkLCBpZ25vcmluZyB0aGUgYWxwaGEgY2hhbm5lbCBpZiBvbmVcblx0XHQgKiBleGlzdHMuIEZvciBSR0IgYW5kIFJHQkEgdGV4dHVyZXMsIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgZ3JlZW4gY2hhbm5lbFxuXHRcdCAqIHdoZW4gc2FtcGxpbmcgdGhpcyB0ZXh0dXJlIGR1ZSB0byB0aGUgZXh0cmEgYml0IG9mIHByZWNpc2lvbiBwcm92aWRlZCBmb3Jcblx0XHQgKiBncmVlbiBpbiBEWFQtY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIFJHQiA1NjUgZm9ybWF0cy4gTHVtaW5hbmNlLW9ubHkgYW5kXG5cdFx0ICogbHVtaW5hbmNlL2FscGhhIHRleHR1cmVzIHdpbGwgYWxzbyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbnZpcm9ubWVudCBtYXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBvZiB0aGUgZW52aXJvbm1lbnQgbWFwIGluIHJhZGlhbnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RXVsZXJ9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCwwKVxuXHRcdCAqL1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0byBjb21iaW5lIHRoZSByZXN1bHQgb2YgdGhlIHN1cmZhY2UncyBjb2xvciB3aXRoIHRoZSBlbnZpcm9ubWVudCBtYXAsIGlmIGFueS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGBNaXhPcGVyYXRpb25gLCB0aGUge0BsaW5rIE1lc2hCYXNpY01hdGVyaWFsI3JlZmxlY3Rpdml0eX0gaXMgdXNlZCB0b1xuXHRcdCAqIGJsZW5kIGJldHdlZW4gdGhlIHR3byBjb2xvcnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE11bHRpcGx5T3BlcmF0aW9ufE1peE9wZXJhdGlvbnxBZGRPcGVyYXRpb24pfVxuXHRcdCAqIEBkZWZhdWx0IE11bHRpcGx5T3BlcmF0aW9uXG5cdFx0ICovXG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZW52aXJvbm1lbnQgbWFwIGFmZmVjdHMgdGhlIHN1cmZhY2UuXG5cdFx0ICogVGhlIHZhbGlkIHJhbmdlIGlzIGJldHdlZW4gYDBgIChubyByZWZsZWN0aW9ucykgYW5kIGAxYCAoZnVsbCByZWZsZWN0aW9ucykuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW5kZXggb2YgcmVmcmFjdGlvbiAoSU9SKSBvZiBhaXIgKGFwcHJveGltYXRlbHkgMSkgZGl2aWRlZCBieSB0aGVcblx0XHQgKiBpbmRleCBvZiByZWZyYWN0aW9uIG9mIHRoZSBtYXRlcmlhbC4gSXQgaXMgdXNlZCB3aXRoIGVudmlyb25tZW50IG1hcHBpbmdcblx0XHQgKiBtb2RlcyB7QGxpbmsgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nfSBhbmQge0BsaW5rIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nfS5cblx0XHQgKiBUaGUgcmVmcmFjdGlvbiByYXRpbyBzaG91bGQgbm90IGV4Y2VlZCBgMWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDAuOThcblx0XHQgKi9cblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXJzIHRoZSBnZW9tZXRyeSBhcyBhIHdpcmVmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIENvbnRyb2xzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHdpcmVmcmFtZS5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgU1ZHUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhcHBlYXJhbmNlIG9mIHdpcmVmcmFtZSBlbmRzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdyb3VuZCd8J2JldmVsJ3wnbWl0ZXInKX1cblx0XHQgKiBAZGVmYXVsdCAncm91bmQnXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgYXBwZWFyYW5jZSBvZiB3aXJlZnJhbWUgam9pbnRzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdyb3VuZCd8J2JldmVsJ3wnbWl0ZXInKX1cblx0XHQgKiBAZGVmYXVsdCAncm91bmQnXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBtYXRlcmlhbCBpcyByZW5kZXJlZCB3aXRoIGZsYXQgc2hhZGluZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGFmZmVjdGVkIGJ5IGZvZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHRcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG5cdFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNZXNoUGhvbmdNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgVGFuZ2VudFNwYWNlTm9ybWFsTWFwIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5cbi8qKlxuICogQSBtYXRlcmlhbCBpbXBsZW1lbnRpbmcgdG9vbiBzaGFkaW5nLlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBNZXNoVG9vbk1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc2ggdG9vbiBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaFRvb25NYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdUT09OJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIENvbG9yIG9mIHRoZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBtYXAuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYW4gYWxwaGEgY2hhbm5lbCwgdHlwaWNhbGx5IGNvbWJpbmVkXG5cdFx0ICogd2l0aCB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yIHtAbGluayBNYXRlcmlhbCNhbHBoYVRlc3R9LiBUaGUgdGV4dHVyZSBtYXBcblx0XHQgKiBjb2xvciBpcyBtb2R1bGF0ZWQgYnkgdGhlIGRpZmZ1c2UgYGNvbG9yYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogR3JhZGllbnQgbWFwIGZvciB0b29uIHNoYWRpbmcuIEl0J3MgcmVxdWlyZWQgdG8gc2V0XG5cdFx0ICoge0BsaW5rIFRleHR1cmUjbWluRmlsdGVyfSBhbmQge0BsaW5rIFRleHR1cmUjbWFnRmlsdGVyfSB0byB7QGxpbmtOZWFyZXN0RmlsdGVyfVxuXHRcdCAqIHdoZW4gdXNpbmcgdGhpcyB0eXBlIG9mIHRleHR1cmUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpZ2h0IG1hcC4gUmVxdWlyZXMgYSBzZWNvbmQgc2V0IG9mIFVWcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGJha2VkIGxpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZWQgY2hhbm5lbCBvZiB0aGlzIHRleHR1cmUgaXMgdXNlZCBhcyB0aGUgYW1iaWVudCBvY2NsdXNpb24gbWFwLlxuXHRcdCAqIFJlcXVpcmVzIGEgc2Vjb25kIHNldCBvZiBVVnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZW5zaXR5IG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbiBlZmZlY3QuIFJhbmdlIGlzIGBbMCwxXWAsIHdoZXJlIGAwYFxuXHRcdCAqIGRpc2FibGVzIGFtYmllbnQgb2NjbHVzaW9uLiBXaGVyZSBpbnRlbnNpdHkgaXMgYDFgIGFuZCB0aGUgQU8gbWFwJ3Ncblx0XHQgKiByZWQgY2hhbm5lbCBpcyBhbHNvIGAxYCwgYW1iaWVudCBsaWdodCBpcyBmdWxseSBvY2NsdWRlZCBvbiBhIHN1cmZhY2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogRW1pc3NpdmUgKGxpZ2h0KSBjb2xvciBvZiB0aGUgbWF0ZXJpYWwsIGVzc2VudGlhbGx5IGEgc29saWQgY29sb3Jcblx0XHQgKiB1bmFmZmVjdGVkIGJ5IG90aGVyIGxpZ2h0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgwLDAsMClcblx0XHQgKi9cblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZW5zaXR5IG9mIHRoZSBlbWlzc2l2ZSBsaWdodC4gTW9kdWxhdGVzIHRoZSBlbWlzc2l2ZSBjb2xvci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHQvKipcblx0XHQgKiBTZXQgZW1pc3NpdmUgKGdsb3cpIG1hcC4gVGhlIGVtaXNzaXZlIG1hcCBjb2xvciBpcyBtb2R1bGF0ZWQgYnkgdGhlXG5cdFx0ICogZW1pc3NpdmUgY29sb3IgYW5kIHRoZSBlbWlzc2l2ZSBpbnRlbnNpdHkuIElmIHlvdSBoYXZlIGFuIGVtaXNzaXZlIG1hcCxcblx0XHQgKiBiZSBzdXJlIHRvIHNldCB0aGUgZW1pc3NpdmUgY29sb3IgdG8gc29tZXRoaW5nIG90aGVyIHRoYW4gYmxhY2suXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHR1cmUgdG8gY3JlYXRlIGEgYnVtcCBtYXAuIFRoZSBibGFjayBhbmQgd2hpdGUgdmFsdWVzIG1hcCB0byB0aGVcblx0XHQgKiBwZXJjZWl2ZWQgZGVwdGggaW4gcmVsYXRpb24gdG8gdGhlIGxpZ2h0cy4gQnVtcCBkb2Vzbid0IGFjdHVhbGx5IGFmZmVjdFxuXHRcdCAqIHRoZSBnZW9tZXRyeSBvZiB0aGUgb2JqZWN0LCBvbmx5IHRoZSBsaWdodGluZy4gSWYgYSBub3JtYWwgbWFwIGlzIGRlZmluZWRcblx0XHQgKiB0aGlzIHdpbGwgYmUgaWdub3JlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBidW1wIG1hcCBhZmZlY3RzIHRoZSBtYXRlcmlhbC4gVHlwaWNhbCByYW5nZSBpcyBgWzAsMV1gLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHR1cmUgdG8gY3JlYXRlIGEgbm9ybWFsIG1hcC4gVGhlIFJHQiB2YWx1ZXMgYWZmZWN0IHRoZSBzdXJmYWNlXG5cdFx0ICogbm9ybWFsIGZvciBlYWNoIHBpeGVsIGZyYWdtZW50IGFuZCBjaGFuZ2UgdGhlIHdheSB0aGUgY29sb3IgaXMgbGl0LiBOb3JtYWxcblx0XHQgKiBtYXBzIGRvIG5vdCBjaGFuZ2UgdGhlIGFjdHVhbCBzaGFwZSBvZiB0aGUgc3VyZmFjZSwgb25seSB0aGUgbGlnaHRpbmcuIEluXG5cdFx0ICogY2FzZSB0aGUgbWF0ZXJpYWwgaGFzIGEgbm9ybWFsIG1hcCBhdXRob3JlZCB1c2luZyB0aGUgbGVmdCBoYW5kZWRcblx0XHQgKiBjb252ZW50aW9uLCB0aGUgYHlgIGNvbXBvbmVudCBvZiBgbm9ybWFsU2NhbGVgIHNob3VsZCBiZSBuZWdhdGVkIHRvIGNvbXBlbnNhdGVcblx0XHQgKiBmb3IgdGhlIGRpZmZlcmVudCBoYW5kZWRuZXNzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBub3JtYWwgbWFwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhUYW5nZW50U3BhY2VOb3JtYWxNYXB8T2JqZWN0U3BhY2VOb3JtYWxNYXApfVxuXHRcdCAqIEBkZWZhdWx0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBub3JtYWwgbWFwIGFmZmVjdHMgdGhlIG1hdGVyaWFsLiBUeXBpY2FsIHZhbHVlIHJhbmdlIGlzIGBbMCwxXWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxKVxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3BsYWNlbWVudCBtYXAgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lc2gncyB2ZXJ0aWNlcy4gVW5saWtlXG5cdFx0ICogb3RoZXIgbWFwcyB3aGljaCBvbmx5IGFmZmVjdCB0aGUgbGlnaHQgYW5kIHNoYWRlIG9mIHRoZSBtYXRlcmlhbCB0aGVcblx0XHQgKiBkaXNwbGFjZWQgdmVydGljZXMgY2FuIGNhc3Qgc2hhZG93cywgYmxvY2sgb3RoZXIgb2JqZWN0cywgYW5kIG90aGVyd2lzZVxuXHRcdCAqIGFjdCBhcyByZWFsIGdlb21ldHJ5LiBUaGUgZGlzcGxhY2VtZW50IHRleHR1cmUgaXMgYW4gaW1hZ2Ugd2hlcmUgdGhlIHZhbHVlXG5cdFx0ICogb2YgZWFjaCBwaXhlbCAod2hpdGUgYmVpbmcgdGhlIGhpZ2hlc3QpIGlzIG1hcHBlZCBhZ2FpbnN0LCBhbmRcblx0XHQgKiByZXBvc2l0aW9ucywgdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBtZXNoICh3aGVyZSBibGFjayBpcyBub1xuXHRcdCAqIGRpc3BsYWNlbWVudCwgYW5kIHdoaXRlIGlzIG1heGltdW0gZGlzcGxhY2VtZW50KS4gV2l0aG91dCBhIGRpc3BsYWNlbWVudFxuXHRcdCAqIG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvZmZzZXQgb2YgdGhlIGRpc3BsYWNlbWVudCBtYXAncyB2YWx1ZXMgb24gdGhlIG1lc2gncyB2ZXJ0aWNlcy5cblx0XHQgKiBUaGUgYmlhcyBpcyBhZGRlZCB0byB0aGUgc2NhbGVkIHNhbXBsZSBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcC5cblx0XHQgKiBXaXRob3V0IGEgZGlzcGxhY2VtZW50IG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIG1hcCBpcyBhIGdyYXlzY2FsZSB0ZXh0dXJlIHRoYXQgY29udHJvbHMgdGhlIG9wYWNpdHkgYWNyb3NzIHRoZVxuXHRcdCAqIHN1cmZhY2UgKGJsYWNrOiBmdWxseSB0cmFuc3BhcmVudDsgd2hpdGU6IGZ1bGx5IG9wYXF1ZSkuXG5cdFx0ICpcblx0XHQgKiBPbmx5IHRoZSBjb2xvciBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkLCBpZ25vcmluZyB0aGUgYWxwaGEgY2hhbm5lbCBpZiBvbmVcblx0XHQgKiBleGlzdHMuIEZvciBSR0IgYW5kIFJHQkEgdGV4dHVyZXMsIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgZ3JlZW4gY2hhbm5lbFxuXHRcdCAqIHdoZW4gc2FtcGxpbmcgdGhpcyB0ZXh0dXJlIGR1ZSB0byB0aGUgZXh0cmEgYml0IG9mIHByZWNpc2lvbiBwcm92aWRlZCBmb3Jcblx0XHQgKiBncmVlbiBpbiBEWFQtY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIFJHQiA1NjUgZm9ybWF0cy4gTHVtaW5hbmNlLW9ubHkgYW5kXG5cdFx0ICogbHVtaW5hbmNlL2FscGhhIHRleHR1cmVzIHdpbGwgYWxzbyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlcnMgdGhlIGdlb21ldHJ5IGFzIGEgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgd2lyZWZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGFwcGVhcmFuY2Ugb2Ygd2lyZWZyYW1lIGVuZHMuXG5cdFx0ICpcblx0XHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGgge0BsaW5rIFNWR1JlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoJ3JvdW5kJ3wnYmV2ZWwnfCdtaXRlcicpfVxuXHRcdCAqIEBkZWZhdWx0ICdyb3VuZCdcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhcHBlYXJhbmNlIG9mIHdpcmVmcmFtZSBqb2ludHMuXG5cdFx0ICpcblx0XHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGgge0BsaW5rIFNWR1JlbmRlcmVyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoJ3JvdW5kJ3wnYmV2ZWwnfCdtaXRlcicpfVxuXHRcdCAqIEBkZWZhdWx0ICdyb3VuZCdcblx0XHQgKi9cblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGFmZmVjdGVkIGJ5IGZvZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE1lc2hUb29uTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbi8qKlxuICogQSBtYXRlcmlhbCB0aGF0IG1hcHMgdGhlIG5vcm1hbCB2ZWN0b3JzIHRvIFJHQiBjb2xvcnMuXG4gKlxuICogQGF1Z21lbnRzIE1hdGVyaWFsXG4gKi9cbmNsYXNzIE1lc2hOb3JtYWxNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtZXNoIG5vcm1hbCBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHR1cmUgdG8gY3JlYXRlIGEgYnVtcCBtYXAuIFRoZSBibGFjayBhbmQgd2hpdGUgdmFsdWVzIG1hcCB0byB0aGVcblx0XHQgKiBwZXJjZWl2ZWQgZGVwdGggaW4gcmVsYXRpb24gdG8gdGhlIGxpZ2h0cy4gQnVtcCBkb2Vzbid0IGFjdHVhbGx5IGFmZmVjdFxuXHRcdCAqIHRoZSBnZW9tZXRyeSBvZiB0aGUgb2JqZWN0LCBvbmx5IHRoZSBsaWdodGluZy4gSWYgYSBub3JtYWwgbWFwIGlzIGRlZmluZWRcblx0XHQgKiB0aGlzIHdpbGwgYmUgaWdub3JlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBidW1wIG1hcCBhZmZlY3RzIHRoZSBtYXRlcmlhbC4gVHlwaWNhbCByYW5nZSBpcyBgWzAsMV1gLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHR1cmUgdG8gY3JlYXRlIGEgbm9ybWFsIG1hcC4gVGhlIFJHQiB2YWx1ZXMgYWZmZWN0IHRoZSBzdXJmYWNlXG5cdFx0ICogbm9ybWFsIGZvciBlYWNoIHBpeGVsIGZyYWdtZW50IGFuZCBjaGFuZ2UgdGhlIHdheSB0aGUgY29sb3IgaXMgbGl0LiBOb3JtYWxcblx0XHQgKiBtYXBzIGRvIG5vdCBjaGFuZ2UgdGhlIGFjdHVhbCBzaGFwZSBvZiB0aGUgc3VyZmFjZSwgb25seSB0aGUgbGlnaHRpbmcuIEluXG5cdFx0ICogY2FzZSB0aGUgbWF0ZXJpYWwgaGFzIGEgbm9ybWFsIG1hcCBhdXRob3JlZCB1c2luZyB0aGUgbGVmdCBoYW5kZWRcblx0XHQgKiBjb252ZW50aW9uLCB0aGUgYHlgIGNvbXBvbmVudCBvZiBgbm9ybWFsU2NhbGVgIHNob3VsZCBiZSBuZWdhdGVkIHRvIGNvbXBlbnNhdGVcblx0XHQgKiBmb3IgdGhlIGRpZmZlcmVudCBoYW5kZWRuZXNzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBub3JtYWwgbWFwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgeyhUYW5nZW50U3BhY2VOb3JtYWxNYXB8T2JqZWN0U3BhY2VOb3JtYWxNYXApfVxuXHRcdCAqIEBkZWZhdWx0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBub3JtYWwgbWFwIGFmZmVjdHMgdGhlIG1hdGVyaWFsLiBUeXBpY2FsIHZhbHVlIHJhbmdlIGlzIGBbMCwxXWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxKVxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3BsYWNlbWVudCBtYXAgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lc2gncyB2ZXJ0aWNlcy4gVW5saWtlXG5cdFx0ICogb3RoZXIgbWFwcyB3aGljaCBvbmx5IGFmZmVjdCB0aGUgbGlnaHQgYW5kIHNoYWRlIG9mIHRoZSBtYXRlcmlhbCB0aGVcblx0XHQgKiBkaXNwbGFjZWQgdmVydGljZXMgY2FuIGNhc3Qgc2hhZG93cywgYmxvY2sgb3RoZXIgb2JqZWN0cywgYW5kIG90aGVyd2lzZVxuXHRcdCAqIGFjdCBhcyByZWFsIGdlb21ldHJ5LiBUaGUgZGlzcGxhY2VtZW50IHRleHR1cmUgaXMgYW4gaW1hZ2Ugd2hlcmUgdGhlIHZhbHVlXG5cdFx0ICogb2YgZWFjaCBwaXhlbCAod2hpdGUgYmVpbmcgdGhlIGhpZ2hlc3QpIGlzIG1hcHBlZCBhZ2FpbnN0LCBhbmRcblx0XHQgKiByZXBvc2l0aW9ucywgdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBtZXNoICh3aGVyZSBibGFjayBpcyBub1xuXHRcdCAqIGRpc3BsYWNlbWVudCwgYW5kIHdoaXRlIGlzIG1heGltdW0gZGlzcGxhY2VtZW50KS4gV2l0aG91dCBhIGRpc3BsYWNlbWVudFxuXHRcdCAqIG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvZmZzZXQgb2YgdGhlIGRpc3BsYWNlbWVudCBtYXAncyB2YWx1ZXMgb24gdGhlIG1lc2gncyB2ZXJ0aWNlcy5cblx0XHQgKiBUaGUgYmlhcyBpcyBhZGRlZCB0byB0aGUgc2NhbGVkIHNhbXBsZSBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcC5cblx0XHQgKiBXaXRob3V0IGEgZGlzcGxhY2VtZW50IG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVycyB0aGUgZ2VvbWV0cnkgYXMgYSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBDb250cm9scyB0aGUgdGhpY2tuZXNzIG9mIHRoZSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBXZWJHTCBhbmQgV2ViR1BVIGlnbm9yZSB0aGlzIHByb3BlcnR5IGFuZCBhbHdheXMgcmVuZGVyXG5cdFx0ICogMSBwaXhlbCB3aWRlIGxpbmVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgcmVuZGVyZWQgd2l0aCBmbGF0IHNoYWRpbmcgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNZXNoTm9ybWFsTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IE11bHRpcGx5T3BlcmF0aW9uLCBUYW5nZW50U3BhY2VOb3JtYWxNYXAgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcbmltcG9ydCB7IEV1bGVyIH0gZnJvbSAnLi4vbWF0aC9FdWxlci5qcyc7XG5cbi8qKlxuICogQSBtYXRlcmlhbCBmb3Igbm9uLXNoaW55IHN1cmZhY2VzLCB3aXRob3V0IHNwZWN1bGFyIGhpZ2hsaWdodHMuXG4gKlxuICogVGhlIG1hdGVyaWFsIHVzZXMgYSBub24tcGh5c2ljYWxseSBiYXNlZCBbTGFtYmVydGlhbl17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFtYmVydGlhbl9yZWZsZWN0YW5jZX1cbiAqIG1vZGVsIGZvciBjYWxjdWxhdGluZyByZWZsZWN0YW5jZS4gVGhpcyBjYW4gc2ltdWxhdGUgc29tZSBzdXJmYWNlcyAoc3VjaFxuICogYXMgdW50cmVhdGVkIHdvb2Qgb3Igc3RvbmUpIHdlbGwsIGJ1dCBjYW5ub3Qgc2ltdWxhdGUgc2hpbnkgc3VyZmFjZXMgd2l0aFxuICogc3BlY3VsYXIgaGlnaGxpZ2h0cyAoc3VjaCBhcyB2YXJuaXNoZWQgd29vZCkuIGBNZXNoTGFtYmVydE1hdGVyaWFsYCB1c2VzIHBlci1mcmFnbWVudFxuICogc2hhZGluZy5cbiAqXG4gKiBEdWUgdG8gdGhlIHNpbXBsaWNpdHkgb2YgdGhlIHJlZmxlY3RhbmNlIGFuZCBpbGx1bWluYXRpb24gbW9kZWxzLFxuICogcGVyZm9ybWFuY2Ugd2lsbCBiZSBncmVhdGVyIHdoZW4gdXNpbmcgdGhpcyBtYXRlcmlhbCBvdmVyIHRoZVxuICoge0BsaW5rIE1lc2hQaG9uZ01hdGVyaWFsfSwge0BsaW5rIE1lc2hTdGFuZGFyZE1hdGVyaWFsfSBvclxuICoge0BsaW5rIE1lc2hQaHlzaWNhbE1hdGVyaWFsfSwgYXQgdGhlIGNvc3Qgb2Ygc29tZSBncmFwaGljYWwgYWNjdXJhY3kuXG4gKlxuICogQGF1Z21lbnRzIE1hdGVyaWFsXG4gKi9cbmNsYXNzIE1lc2hMYW1iZXJ0TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbWVzaCBsYW1iZXJ0IG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIENvbG9yIG9mIHRoZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cblx0XHQgKiBAZGVmYXVsdCAoMSwxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIG1hcC4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhbiBhbHBoYSBjaGFubmVsLCB0eXBpY2FsbHkgY29tYmluZWRcblx0XHQgKiB3aXRoIHtAbGluayBNYXRlcmlhbCN0cmFuc3BhcmVudH0gb3Ige0BsaW5rIE1hdGVyaWFsI2FscGhhVGVzdH0uIFRoZSB0ZXh0dXJlIG1hcFxuXHRcdCAqIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGUgZGlmZnVzZSBgY29sb3JgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlnaHQgbWFwLiBSZXF1aXJlcyBhIHNlY29uZCBzZXQgb2YgVVZzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVuc2l0eSBvZiB0aGUgYmFrZWQgbGlnaHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlZCBjaGFubmVsIG9mIHRoaXMgdGV4dHVyZSBpcyB1c2VkIGFzIHRoZSBhbWJpZW50IG9jY2x1c2lvbiBtYXAuXG5cdFx0ICogUmVxdWlyZXMgYSBzZWNvbmQgc2V0IG9mIFVWcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uIGVmZmVjdC4gUmFuZ2UgaXMgYFswLDFdYCwgd2hlcmUgYDBgXG5cdFx0ICogZGlzYWJsZXMgYW1iaWVudCBvY2NsdXNpb24uIFdoZXJlIGludGVuc2l0eSBpcyBgMWAgYW5kIHRoZSBBTyBtYXAnc1xuXHRcdCAqIHJlZCBjaGFubmVsIGlzIGFsc28gYDFgLCBhbWJpZW50IGxpZ2h0IGlzIGZ1bGx5IG9jY2x1ZGVkIG9uIGEgc3VyZmFjZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHQvKipcblx0XHQgKiBFbWlzc2l2ZSAobGlnaHQpIGNvbG9yIG9mIHRoZSBtYXRlcmlhbCwgZXNzZW50aWFsbHkgYSBzb2xpZCBjb2xvclxuXHRcdCAqIHVuYWZmZWN0ZWQgYnkgb3RoZXIgbGlnaHRpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Q29sb3J9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCwwKVxuXHRcdCAqL1xuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlbnNpdHkgb2YgdGhlIGVtaXNzaXZlIGxpZ2h0LiBNb2R1bGF0ZXMgdGhlIGVtaXNzaXZlIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBlbWlzc2l2ZSAoZ2xvdykgbWFwLiBUaGUgZW1pc3NpdmUgbWFwIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGVcblx0XHQgKiBlbWlzc2l2ZSBjb2xvciBhbmQgdGhlIGVtaXNzaXZlIGludGVuc2l0eS4gSWYgeW91IGhhdmUgYW4gZW1pc3NpdmUgbWFwLFxuXHRcdCAqIGJlIHN1cmUgdG8gc2V0IHRoZSBlbWlzc2l2ZSBjb2xvciB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBibGFjay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBidW1wIG1hcC4gVGhlIGJsYWNrIGFuZCB3aGl0ZSB2YWx1ZXMgbWFwIHRvIHRoZVxuXHRcdCAqIHBlcmNlaXZlZCBkZXB0aCBpbiByZWxhdGlvbiB0byB0aGUgbGlnaHRzLiBCdW1wIGRvZXNuJ3QgYWN0dWFsbHkgYWZmZWN0XG5cdFx0ICogdGhlIGdlb21ldHJ5IG9mIHRoZSBvYmplY3QsIG9ubHkgdGhlIGxpZ2h0aW5nLiBJZiBhIG5vcm1hbCBtYXAgaXMgZGVmaW5lZFxuXHRcdCAqIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIGJ1bXAgbWFwIGFmZmVjdHMgdGhlIG1hdGVyaWFsLiBUeXBpY2FsIHJhbmdlIGlzIGBbMCwxXWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBub3JtYWwgbWFwLiBUaGUgUkdCIHZhbHVlcyBhZmZlY3QgdGhlIHN1cmZhY2Vcblx0XHQgKiBub3JtYWwgZm9yIGVhY2ggcGl4ZWwgZnJhZ21lbnQgYW5kIGNoYW5nZSB0aGUgd2F5IHRoZSBjb2xvciBpcyBsaXQuIE5vcm1hbFxuXHRcdCAqIG1hcHMgZG8gbm90IGNoYW5nZSB0aGUgYWN0dWFsIHNoYXBlIG9mIHRoZSBzdXJmYWNlLCBvbmx5IHRoZSBsaWdodGluZy4gSW5cblx0XHQgKiBjYXNlIHRoZSBtYXRlcmlhbCBoYXMgYSBub3JtYWwgbWFwIGF1dGhvcmVkIHVzaW5nIHRoZSBsZWZ0IGhhbmRlZFxuXHRcdCAqIGNvbnZlbnRpb24sIHRoZSBgeWAgY29tcG9uZW50IG9mIGBub3JtYWxTY2FsZWAgc2hvdWxkIGJlIG5lZ2F0ZWQgdG8gY29tcGVuc2F0ZVxuXHRcdCAqIGZvciB0aGUgZGlmZmVyZW50IGhhbmRlZG5lc3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIG5vcm1hbCBtYXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFRhbmdlbnRTcGFjZU5vcm1hbE1hcHxPYmplY3RTcGFjZU5vcm1hbE1hcCl9XG5cdFx0ICogQGRlZmF1bHQgVGFuZ2VudFNwYWNlTm9ybWFsTWFwXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIG5vcm1hbCBtYXAgYWZmZWN0cyB0aGUgbWF0ZXJpYWwuIFR5cGljYWwgdmFsdWUgcmFuZ2UgaXMgYFswLDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVzaCdzIHZlcnRpY2VzLiBVbmxpa2Vcblx0XHQgKiBvdGhlciBtYXBzIHdoaWNoIG9ubHkgYWZmZWN0IHRoZSBsaWdodCBhbmQgc2hhZGUgb2YgdGhlIG1hdGVyaWFsIHRoZVxuXHRcdCAqIGRpc3BsYWNlZCB2ZXJ0aWNlcyBjYW4gY2FzdCBzaGFkb3dzLCBibG9jayBvdGhlciBvYmplY3RzLCBhbmQgb3RoZXJ3aXNlXG5cdFx0ICogYWN0IGFzIHJlYWwgZ2VvbWV0cnkuIFRoZSBkaXNwbGFjZW1lbnQgdGV4dHVyZSBpcyBhbiBpbWFnZSB3aGVyZSB0aGUgdmFsdWVcblx0XHQgKiBvZiBlYWNoIHBpeGVsICh3aGl0ZSBiZWluZyB0aGUgaGlnaGVzdCkgaXMgbWFwcGVkIGFnYWluc3QsIGFuZFxuXHRcdCAqIHJlcG9zaXRpb25zLCB0aGUgdmVydGljZXMgb2YgdGhlIG1lc2guXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBkaXNwbGFjZW1lbnQgbWFwIGFmZmVjdHMgdGhlIG1lc2ggKHdoZXJlIGJsYWNrIGlzIG5vXG5cdFx0ICogZGlzcGxhY2VtZW50LCBhbmQgd2hpdGUgaXMgbWF4aW11bSBkaXNwbGFjZW1lbnQpLiBXaXRob3V0IGEgZGlzcGxhY2VtZW50XG5cdFx0ICogbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9mZnNldCBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcCdzIHZhbHVlcyBvbiB0aGUgbWVzaCdzIHZlcnRpY2VzLlxuXHRcdCAqIFRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBzY2FsZWQgc2FtcGxlIG9mIHRoZSBkaXNwbGFjZW1lbnQgbWFwLlxuXHRcdCAqIFdpdGhvdXQgYSBkaXNwbGFjZW1lbnQgbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjdWxhciBtYXAgdXNlZCBieSB0aGUgbWF0ZXJpYWwuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhIG1hcCBpcyBhIGdyYXlzY2FsZSB0ZXh0dXJlIHRoYXQgY29udHJvbHMgdGhlIG9wYWNpdHkgYWNyb3NzIHRoZVxuXHRcdCAqIHN1cmZhY2UgKGJsYWNrOiBmdWxseSB0cmFuc3BhcmVudDsgd2hpdGU6IGZ1bGx5IG9wYXF1ZSkuXG5cdFx0ICpcblx0XHQgKiBPbmx5IHRoZSBjb2xvciBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkLCBpZ25vcmluZyB0aGUgYWxwaGEgY2hhbm5lbCBpZiBvbmVcblx0XHQgKiBleGlzdHMuIEZvciBSR0IgYW5kIFJHQkEgdGV4dHVyZXMsIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgZ3JlZW4gY2hhbm5lbFxuXHRcdCAqIHdoZW4gc2FtcGxpbmcgdGhpcyB0ZXh0dXJlIGR1ZSB0byB0aGUgZXh0cmEgYml0IG9mIHByZWNpc2lvbiBwcm92aWRlZCBmb3Jcblx0XHQgKiBncmVlbiBpbiBEWFQtY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIFJHQiA1NjUgZm9ybWF0cy4gTHVtaW5hbmNlLW9ubHkgYW5kXG5cdFx0ICogbHVtaW5hbmNlL2FscGhhIHRleHR1cmVzIHdpbGwgYWxzbyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbnZpcm9ubWVudCBtYXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBvZiB0aGUgZW52aXJvbm1lbnQgbWFwIGluIHJhZGlhbnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RXVsZXJ9XG5cdFx0ICogQGRlZmF1bHQgKDAsMCwwKVxuXHRcdCAqL1xuXHRcdHRoaXMuZW52TWFwUm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyB0byBjb21iaW5lIHRoZSByZXN1bHQgb2YgdGhlIHN1cmZhY2UncyBjb2xvciB3aXRoIHRoZSBlbnZpcm9ubWVudCBtYXAsIGlmIGFueS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGBNaXhPcGVyYXRpb25gLCB0aGUge0BsaW5rIE1lc2hCYXNpY01hdGVyaWFsI3JlZmxlY3Rpdml0eX0gaXMgdXNlZCB0b1xuXHRcdCAqIGJsZW5kIGJldHdlZW4gdGhlIHR3byBjb2xvcnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE11bHRpcGx5T3BlcmF0aW9ufE1peE9wZXJhdGlvbnxBZGRPcGVyYXRpb24pfVxuXHRcdCAqIEBkZWZhdWx0IE11bHRpcGx5T3BlcmF0aW9uXG5cdFx0ICovXG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZW52aXJvbm1lbnQgbWFwIGFmZmVjdHMgdGhlIHN1cmZhY2UuXG5cdFx0ICogVGhlIHZhbGlkIHJhbmdlIGlzIGJldHdlZW4gYDBgIChubyByZWZsZWN0aW9ucykgYW5kIGAxYCAoZnVsbCByZWZsZWN0aW9ucykuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW5kZXggb2YgcmVmcmFjdGlvbiAoSU9SKSBvZiBhaXIgKGFwcHJveGltYXRlbHkgMSkgZGl2aWRlZCBieSB0aGVcblx0XHQgKiBpbmRleCBvZiByZWZyYWN0aW9uIG9mIHRoZSBtYXRlcmlhbC4gSXQgaXMgdXNlZCB3aXRoIGVudmlyb25tZW50IG1hcHBpbmdcblx0XHQgKiBtb2RlcyB7QGxpbmsgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nfSBhbmQge0BsaW5rIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nfS5cblx0XHQgKiBUaGUgcmVmcmFjdGlvbiByYXRpbyBzaG91bGQgbm90IGV4Y2VlZCBgMWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDAuOThcblx0XHQgKi9cblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXJzIHRoZSBnZW9tZXRyeSBhcyBhIHdpcmVmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIENvbnRyb2xzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHdpcmVmcmFtZS5cblx0XHQgKlxuXHRcdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgU1ZHUmVuZGVyZXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhcHBlYXJhbmNlIG9mIHdpcmVmcmFtZSBlbmRzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdyb3VuZCd8J2JldmVsJ3wnbWl0ZXInKX1cblx0XHQgKiBAZGVmYXVsdCAncm91bmQnXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgYXBwZWFyYW5jZSBvZiB3aXJlZnJhbWUgam9pbnRzLlxuXHRcdCAqXG5cdFx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIHtAbGluayBTVkdSZW5kZXJlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdyb3VuZCd8J2JldmVsJ3wnbWl0ZXInKX1cblx0XHQgKiBAZGVmYXVsdCAncm91bmQnXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBtYXRlcmlhbCBpcyByZW5kZXJlZCB3aXRoIGZsYXQgc2hhZGluZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGFmZmVjdGVkIGJ5IGZvZyBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5lbnZNYXBSb3RhdGlvbi5jb3B5KCBzb3VyY2UuZW52TWFwUm90YXRpb24gKTtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNZXNoTGFtYmVydE1hdGVyaWFsIH07XG4iLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEEgbWF0ZXJpYWwgZm9yIGRyYXdpbmcgZ2VvbWV0cnkgYnkgZGVwdGguIERlcHRoIGlzIGJhc2VkIG9mZiBvZiB0aGUgY2FtZXJhXG4gKiBuZWFyIGFuZCBmYXIgcGxhbmUuIFdoaXRlIGlzIG5lYXJlc3QsIGJsYWNrIGlzIGZhcnRoZXN0LlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBNZXNoRGVwdGhNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtZXNoIGRlcHRoIG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNNZXNoRGVwdGhNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogVHlwZSBmb3IgZGVwdGggcGFja2luZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoQmFzaWNEZXB0aFBhY2tpbmd8UkdCQURlcHRoUGFja2luZ3xSR0JEZXB0aFBhY2tpbmd8UkdEZXB0aFBhY2tpbmcpfVxuXHRcdCAqIEBkZWZhdWx0IEJhc2ljRGVwdGhQYWNraW5nXG5cdFx0ICovXG5cdFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBtYXAuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYW4gYWxwaGEgY2hhbm5lbCwgdHlwaWNhbGx5IGNvbWJpbmVkXG5cdFx0ICogd2l0aCB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yIHtAbGluayBNYXRlcmlhbCNhbHBoYVRlc3R9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYWxwaGEgbWFwIGlzIGEgZ3JheXNjYWxlIHRleHR1cmUgdGhhdCBjb250cm9scyB0aGUgb3BhY2l0eSBhY3Jvc3MgdGhlXG5cdFx0ICogc3VyZmFjZSAoYmxhY2s6IGZ1bGx5IHRyYW5zcGFyZW50OyB3aGl0ZTogZnVsbHkgb3BhcXVlKS5cblx0XHQgKlxuXHRcdCAqIE9ubHkgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQsIGlnbm9yaW5nIHRoZSBhbHBoYSBjaGFubmVsIGlmIG9uZVxuXHRcdCAqIGV4aXN0cy4gRm9yIFJHQiBhbmQgUkdCQSB0ZXh0dXJlcywgdGhlIHJlbmRlcmVyIHdpbGwgdXNlIHRoZSBncmVlbiBjaGFubmVsXG5cdFx0ICogd2hlbiBzYW1wbGluZyB0aGlzIHRleHR1cmUgZHVlIHRvIHRoZSBleHRyYSBiaXQgb2YgcHJlY2lzaW9uIHByb3ZpZGVkIGZvclxuXHRcdCAqIGdyZWVuIGluIERYVC1jb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgUkdCIDU2NSBmb3JtYXRzLiBMdW1pbmFuY2Utb25seSBhbmRcblx0XHQgKiBsdW1pbmFuY2UvYWxwaGEgdGV4dHVyZXMgd2lsbCBhbHNvIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3BsYWNlbWVudCBtYXAgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lc2gncyB2ZXJ0aWNlcy4gVW5saWtlXG5cdFx0ICogb3RoZXIgbWFwcyB3aGljaCBvbmx5IGFmZmVjdCB0aGUgbGlnaHQgYW5kIHNoYWRlIG9mIHRoZSBtYXRlcmlhbCB0aGVcblx0XHQgKiBkaXNwbGFjZWQgdmVydGljZXMgY2FuIGNhc3Qgc2hhZG93cywgYmxvY2sgb3RoZXIgb2JqZWN0cywgYW5kIG90aGVyd2lzZVxuXHRcdCAqIGFjdCBhcyByZWFsIGdlb21ldHJ5LiBUaGUgZGlzcGxhY2VtZW50IHRleHR1cmUgaXMgYW4gaW1hZ2Ugd2hlcmUgdGhlIHZhbHVlXG5cdFx0ICogb2YgZWFjaCBwaXhlbCAod2hpdGUgYmVpbmcgdGhlIGhpZ2hlc3QpIGlzIG1hcHBlZCBhZ2FpbnN0LCBhbmRcblx0XHQgKiByZXBvc2l0aW9ucywgdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBtZXNoICh3aGVyZSBibGFjayBpcyBub1xuXHRcdCAqIGRpc3BsYWNlbWVudCwgYW5kIHdoaXRlIGlzIG1heGltdW0gZGlzcGxhY2VtZW50KS4gV2l0aG91dCBhIGRpc3BsYWNlbWVudFxuXHRcdCAqIG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvZmZzZXQgb2YgdGhlIGRpc3BsYWNlbWVudCBtYXAncyB2YWx1ZXMgb24gdGhlIG1lc2gncyB2ZXJ0aWNlcy5cblx0XHQgKiBUaGUgYmlhcyBpcyBhZGRlZCB0byB0aGUgc2NhbGVkIHNhbXBsZSBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcC5cblx0XHQgKiBXaXRob3V0IGEgZGlzcGxhY2VtZW50IG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVycyB0aGUgZ2VvbWV0cnkgYXMgYSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBDb250cm9scyB0aGUgdGhpY2tuZXNzIG9mIHRoZSB3aXJlZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBXZWJHTCBhbmQgV2ViR1BVIGlnbm9yZSB0aGlzIHByb3BlcnR5IGFuZCBhbHdheXMgcmVuZGVyXG5cdFx0ICogMSBwaXhlbCB3aWRlIGxpbmVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmRlcHRoUGFja2luZyA9IHNvdXJjZS5kZXB0aFBhY2tpbmc7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE1lc2hEZXB0aE1hdGVyaWFsIH07XG4iLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuXG4vKipcbiAqIEEgbWF0ZXJpYWwgdXNlZCBpbnRlcm5hbGx5IGZvciBpbXBsZW1lbnRpbmcgc2hhZG93IG1hcHBpbmcgd2l0aFxuICogcG9pbnQgbGlnaHRzLlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSBzaGFkb3cgY2FzdGluZyBvZiBhbiBvYmplY3QgYnkgYXNzaWduaW5nXG4gKiBhbiBpbnN0YW5jZSBvZiBgTWVzaERpc3RhbmNlTWF0ZXJpYWxgIHRvIHtAbGluayBPYmplY3QzRCNjdXN0b21EaXN0YW5jZU1hdGVyaWFsfS5cbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgZGVtb25zdHJhdGVzIHRoaXMgYXBwcm9hY2ggaW4gb3JkZXIgdG8gZW5zdXJlXG4gKiB0cmFuc3BhcmVudCBwYXJ0cyBvZiBvYmplY3RzIGRvIG5vIGNhc3Qgc2hhZG93cy5cbiAqXG4gKiBAYXVnbWVudHMgTWF0ZXJpYWxcbiAqL1xuY2xhc3MgTWVzaERpc3RhbmNlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbWVzaCBkaXN0YW5jZSBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBtYXAuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYW4gYWxwaGEgY2hhbm5lbCwgdHlwaWNhbGx5IGNvbWJpbmVkXG5cdFx0ICogd2l0aCB7QGxpbmsgTWF0ZXJpYWwjdHJhbnNwYXJlbnR9IG9yIHtAbGluayBNYXRlcmlhbCNhbHBoYVRlc3R9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYWxwaGEgbWFwIGlzIGEgZ3JheXNjYWxlIHRleHR1cmUgdGhhdCBjb250cm9scyB0aGUgb3BhY2l0eSBhY3Jvc3MgdGhlXG5cdFx0ICogc3VyZmFjZSAoYmxhY2s6IGZ1bGx5IHRyYW5zcGFyZW50OyB3aGl0ZTogZnVsbHkgb3BhcXVlKS5cblx0XHQgKlxuXHRcdCAqIE9ubHkgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQsIGlnbm9yaW5nIHRoZSBhbHBoYSBjaGFubmVsIGlmIG9uZVxuXHRcdCAqIGV4aXN0cy4gRm9yIFJHQiBhbmQgUkdCQSB0ZXh0dXJlcywgdGhlIHJlbmRlcmVyIHdpbGwgdXNlIHRoZSBncmVlbiBjaGFubmVsXG5cdFx0ICogd2hlbiBzYW1wbGluZyB0aGlzIHRleHR1cmUgZHVlIHRvIHRoZSBleHRyYSBiaXQgb2YgcHJlY2lzaW9uIHByb3ZpZGVkIGZvclxuXHRcdCAqIGdyZWVuIGluIERYVC1jb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgUkdCIDU2NSBmb3JtYXRzLiBMdW1pbmFuY2Utb25seSBhbmRcblx0XHQgKiBsdW1pbmFuY2UvYWxwaGEgdGV4dHVyZXMgd2lsbCBhbHNvIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3BsYWNlbWVudCBtYXAgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lc2gncyB2ZXJ0aWNlcy4gVW5saWtlXG5cdFx0ICogb3RoZXIgbWFwcyB3aGljaCBvbmx5IGFmZmVjdCB0aGUgbGlnaHQgYW5kIHNoYWRlIG9mIHRoZSBtYXRlcmlhbCB0aGVcblx0XHQgKiBkaXNwbGFjZWQgdmVydGljZXMgY2FuIGNhc3Qgc2hhZG93cywgYmxvY2sgb3RoZXIgb2JqZWN0cywgYW5kIG90aGVyd2lzZVxuXHRcdCAqIGFjdCBhcyByZWFsIGdlb21ldHJ5LiBUaGUgZGlzcGxhY2VtZW50IHRleHR1cmUgaXMgYW4gaW1hZ2Ugd2hlcmUgdGhlIHZhbHVlXG5cdFx0ICogb2YgZWFjaCBwaXhlbCAod2hpdGUgYmVpbmcgdGhlIGhpZ2hlc3QpIGlzIG1hcHBlZCBhZ2FpbnN0LCBhbmRcblx0XHQgKiByZXBvc2l0aW9ucywgdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbXVjaCB0aGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBtZXNoICh3aGVyZSBibGFjayBpcyBub1xuXHRcdCAqIGRpc3BsYWNlbWVudCwgYW5kIHdoaXRlIGlzIG1heGltdW0gZGlzcGxhY2VtZW50KS4gV2l0aG91dCBhIGRpc3BsYWNlbWVudFxuXHRcdCAqIG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvZmZzZXQgb2YgdGhlIGRpc3BsYWNlbWVudCBtYXAncyB2YWx1ZXMgb24gdGhlIG1lc2gncyB2ZXJ0aWNlcy5cblx0XHQgKiBUaGUgYmlhcyBpcyBhZGRlZCB0byB0aGUgc2NhbGVkIHNhbXBsZSBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcC5cblx0XHQgKiBXaXRob3V0IGEgZGlzcGxhY2VtZW50IG1hcCBzZXQsIHRoaXMgdmFsdWUgaXMgbm90IGFwcGxpZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTWVzaERpc3RhbmNlTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuXG4vKipcbiAqIFRoaXMgbWF0ZXJpYWwgaXMgZGVmaW5lZCBieSBhIE1hdENhcCAob3IgTGl0IFNwaGVyZSkgdGV4dHVyZSwgd2hpY2ggZW5jb2RlcyB0aGVcbiAqIG1hdGVyaWFsIGNvbG9yIGFuZCBzaGFkaW5nLlxuICpcbiAqIGBNZXNoTWF0Y2FwTWF0ZXJpYWxgIGRvZXMgbm90IHJlc3BvbmQgdG8gbGlnaHRzIHNpbmNlIHRoZSBtYXRjYXAgaW1hZ2UgZmlsZSBlbmNvZGVzXG4gKiBiYWtlZCBsaWdodGluZy4gSXQgd2lsbCBjYXN0IGEgc2hhZG93IG9udG8gYW4gb2JqZWN0IHRoYXQgcmVjZWl2ZXMgc2hhZG93c1xuICogKGFuZCBzaGFkb3cgY2xpcHBpbmcgd29ya3MpLCBidXQgaXQgd2lsbCBub3Qgc2VsZi1zaGFkb3cgb3IgcmVjZWl2ZVxuICogc2hhZG93cy5cbiAqXG4gKiBAYXVnbWVudHMgTWF0ZXJpYWxcbiAqL1xuY2xhc3MgTWVzaE1hdGNhcE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc2ggbWF0Y2FwIG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gQW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgcHJvcGVydGllc1xuXHQgKiBkZWZpbmluZyB0aGUgbWF0ZXJpYWwncyBhcHBlYXJhbmNlLiBBbnkgcHJvcGVydHkgb2YgdGhlIG1hdGVyaWFsXG5cdCAqIChpbmNsdWRpbmcgYW55IHByb3BlcnR5IGZyb20gaW5oZXJpdGVkIG1hdGVyaWFscykgY2FuIGJlIHBhc3NlZFxuXHQgKiBpbiBoZXJlLiBDb2xvciB2YWx1ZXMgY2FuIGJlIHBhc3NlZCBhbnkgdHlwZSBvZiB2YWx1ZSBhY2NlcHRlZFxuXHQgKiBieSB7QGxpbmsgQ29sb3Ijc2V0fS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnTUFUQ0FQJzogJycgfTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTWF0Y2FwTWF0ZXJpYWwnO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29sb3Igb2YgdGhlIG1hdGVyaWFsLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEsMSlcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF0Y2FwIG1hcC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/VGV4dHVyZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXRjYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIG1hcC4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhbiBhbHBoYSBjaGFubmVsLCB0eXBpY2FsbHkgY29tYmluZWRcblx0XHQgKiB3aXRoIHtAbGluayBNYXRlcmlhbCN0cmFuc3BhcmVudH0gb3Ige0BsaW5rIE1hdGVyaWFsI2FscGhhVGVzdH0uIFRoZSB0ZXh0dXJlIG1hcFxuXHRcdCAqIGNvbG9yIGlzIG1vZHVsYXRlZCBieSB0aGUgZGlmZnVzZSBgY29sb3JgLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBidW1wIG1hcC4gVGhlIGJsYWNrIGFuZCB3aGl0ZSB2YWx1ZXMgbWFwIHRvIHRoZVxuXHRcdCAqIHBlcmNlaXZlZCBkZXB0aCBpbiByZWxhdGlvbiB0byB0aGUgbGlnaHRzLiBCdW1wIGRvZXNuJ3QgYWN0dWFsbHkgYWZmZWN0XG5cdFx0ICogdGhlIGdlb21ldHJ5IG9mIHRoZSBvYmplY3QsIG9ubHkgdGhlIGxpZ2h0aW5nLiBJZiBhIG5vcm1hbCBtYXAgaXMgZGVmaW5lZFxuXHRcdCAqIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9UZXh0dXJlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIGJ1bXAgbWFwIGFmZmVjdHMgdGhlIG1hdGVyaWFsLiBUeXBpY2FsIHJhbmdlIGlzIGBbMCwxXWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVyZSB0byBjcmVhdGUgYSBub3JtYWwgbWFwLiBUaGUgUkdCIHZhbHVlcyBhZmZlY3QgdGhlIHN1cmZhY2Vcblx0XHQgKiBub3JtYWwgZm9yIGVhY2ggcGl4ZWwgZnJhZ21lbnQgYW5kIGNoYW5nZSB0aGUgd2F5IHRoZSBjb2xvciBpcyBsaXQuIE5vcm1hbFxuXHRcdCAqIG1hcHMgZG8gbm90IGNoYW5nZSB0aGUgYWN0dWFsIHNoYXBlIG9mIHRoZSBzdXJmYWNlLCBvbmx5IHRoZSBsaWdodGluZy4gSW5cblx0XHQgKiBjYXNlIHRoZSBtYXRlcmlhbCBoYXMgYSBub3JtYWwgbWFwIGF1dGhvcmVkIHVzaW5nIHRoZSBsZWZ0IGhhbmRlZFxuXHRcdCAqIGNvbnZlbnRpb24sIHRoZSBgeWAgY29tcG9uZW50IG9mIGBub3JtYWxTY2FsZWAgc2hvdWxkIGJlIG5lZ2F0ZWQgdG8gY29tcGVuc2F0ZVxuXHRcdCAqIGZvciB0aGUgZGlmZmVyZW50IGhhbmRlZG5lc3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIG5vcm1hbCBtYXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFRhbmdlbnRTcGFjZU5vcm1hbE1hcHxPYmplY3RTcGFjZU5vcm1hbE1hcCl9XG5cdFx0ICogQGRlZmF1bHQgVGFuZ2VudFNwYWNlTm9ybWFsTWFwXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG11Y2ggdGhlIG5vcm1hbCBtYXAgYWZmZWN0cyB0aGUgbWF0ZXJpYWwuIFR5cGljYWwgdmFsdWUgcmFuZ2UgaXMgYFswLDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqIEBkZWZhdWx0ICgxLDEpXG5cdFx0ICovXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGlzcGxhY2VtZW50IG1hcCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVzaCdzIHZlcnRpY2VzLiBVbmxpa2Vcblx0XHQgKiBvdGhlciBtYXBzIHdoaWNoIG9ubHkgYWZmZWN0IHRoZSBsaWdodCBhbmQgc2hhZGUgb2YgdGhlIG1hdGVyaWFsIHRoZVxuXHRcdCAqIGRpc3BsYWNlZCB2ZXJ0aWNlcyBjYW4gY2FzdCBzaGFkb3dzLCBibG9jayBvdGhlciBvYmplY3RzLCBhbmQgb3RoZXJ3aXNlXG5cdFx0ICogYWN0IGFzIHJlYWwgZ2VvbWV0cnkuIFRoZSBkaXNwbGFjZW1lbnQgdGV4dHVyZSBpcyBhbiBpbWFnZSB3aGVyZSB0aGUgdmFsdWVcblx0XHQgKiBvZiBlYWNoIHBpeGVsICh3aGl0ZSBiZWluZyB0aGUgaGlnaGVzdCkgaXMgbWFwcGVkIGFnYWluc3QsIGFuZFxuXHRcdCAqIHJlcG9zaXRpb25zLCB0aGUgdmVydGljZXMgb2YgdGhlIG1lc2guXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvdyBtdWNoIHRoZSBkaXNwbGFjZW1lbnQgbWFwIGFmZmVjdHMgdGhlIG1lc2ggKHdoZXJlIGJsYWNrIGlzIG5vXG5cdFx0ICogZGlzcGxhY2VtZW50LCBhbmQgd2hpdGUgaXMgbWF4aW11bSBkaXNwbGFjZW1lbnQpLiBXaXRob3V0IGEgZGlzcGxhY2VtZW50XG5cdFx0ICogbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9mZnNldCBvZiB0aGUgZGlzcGxhY2VtZW50IG1hcCdzIHZhbHVlcyBvbiB0aGUgbWVzaCdzIHZlcnRpY2VzLlxuXHRcdCAqIFRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBzY2FsZWQgc2FtcGxlIG9mIHRoZSBkaXNwbGFjZW1lbnQgbWFwLlxuXHRcdCAqIFdpdGhvdXQgYSBkaXNwbGFjZW1lbnQgbWFwIHNldCwgdGhpcyB2YWx1ZSBpcyBub3QgYXBwbGllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYWxwaGEgbWFwIGlzIGEgZ3JheXNjYWxlIHRleHR1cmUgdGhhdCBjb250cm9scyB0aGUgb3BhY2l0eSBhY3Jvc3MgdGhlXG5cdFx0ICogc3VyZmFjZSAoYmxhY2s6IGZ1bGx5IHRyYW5zcGFyZW50OyB3aGl0ZTogZnVsbHkgb3BhcXVlKS5cblx0XHQgKlxuXHRcdCAqIE9ubHkgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQsIGlnbm9yaW5nIHRoZSBhbHBoYSBjaGFubmVsIGlmIG9uZVxuXHRcdCAqIGV4aXN0cy4gRm9yIFJHQiBhbmQgUkdCQSB0ZXh0dXJlcywgdGhlIHJlbmRlcmVyIHdpbGwgdXNlIHRoZSBncmVlbiBjaGFubmVsXG5cdFx0ICogd2hlbiBzYW1wbGluZyB0aGlzIHRleHR1cmUgZHVlIHRvIHRoZSBleHRyYSBiaXQgb2YgcHJlY2lzaW9uIHByb3ZpZGVkIGZvclxuXHRcdCAqIGdyZWVuIGluIERYVC1jb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgUkdCIDU2NSBmb3JtYXRzLiBMdW1pbmFuY2Utb25seSBhbmRcblx0XHQgKiBsdW1pbmFuY2UvYWxwaGEgdGV4dHVyZXMgd2lsbCBhbHNvIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbWF0ZXJpYWwgaXMgcmVuZGVyZWQgd2l0aCBmbGF0IHNoYWRpbmcgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBtYXRlcmlhbCBpcyBhZmZlY3RlZCBieSBmb2cgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdNQVRDQVAnOiAnJyB9O1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWF0Y2FwID0gc291cmNlLm1hdGNhcDtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNZXNoTWF0Y2FwTWF0ZXJpYWwgfTtcbiIsImltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5cbi8qKlxuICogQSBtYXRlcmlhbCBmb3IgcmVuZGVyaW5nIGxpbmUgcHJpbWl0aXZlcy5cbiAqXG4gKiBNYXRlcmlhbHMgZGVmaW5lIHRoZSBhcHBlYXJhbmNlIG9mIHJlbmRlcmFibGUgM0Qgb2JqZWN0cy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKCB7XG4gKiBcdGNvbG9yOiAweGZmZmZmZixcbiAqIFx0c2NhbGU6IDEsXG4gKiBcdGRhc2hTaXplOiAzLFxuICogXHRnYXBTaXplOiAxLFxuICogfSApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpbmVCYXNpY01hdGVyaWFsXG4gKi9cbmNsYXNzIExpbmVEYXNoZWRNYXRlcmlhbCBleHRlbmRzIExpbmVCYXNpY01hdGVyaWFsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaW5lIGRhc2hlZCBtYXRlcmlhbC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIEFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIHByb3BlcnRpZXNcblx0ICogZGVmaW5pbmcgdGhlIG1hdGVyaWFsJ3MgYXBwZWFyYW5jZS4gQW55IHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbFxuXHQgKiAoaW5jbHVkaW5nIGFueSBwcm9wZXJ0eSBmcm9tIGluaGVyaXRlZCBtYXRlcmlhbHMpIGNhbiBiZSBwYXNzZWRcblx0ICogaW4gaGVyZS4gQ29sb3IgdmFsdWVzIGNhbiBiZSBwYXNzZWQgYW55IHR5cGUgb2YgdmFsdWUgYWNjZXB0ZWRcblx0ICogYnkge0BsaW5rIENvbG9yI3NldH0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblx0XHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzY2FsZSBvZiB0aGUgZGFzaGVkIHBhcnQgb2YgYSBsaW5lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2l6ZSBvZiB0aGUgZGFzaC4gVGhpcyBpcyBib3RoIHRoZSBnYXAgd2l0aCB0aGUgc3Ryb2tlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAzXG5cdFx0ICovXG5cdFx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2l6ZSBvZiB0aGUgZ2FwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5nYXBTaXplID0gMTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcblx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHRcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IExpbmVEYXNoZWRNYXRlcmlhbCB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheXxBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheS5jb25zdHJ1Y3Rvcn0gdHlwZSAtIFRoZSBjb25zdHJ1Y3RvciBvZiBhIHR5cGVkIGFycmF5IHRoYXQgZGVmaW5lcyB0aGUgbmV3IHR5cGUuXG4gKiBAcmV0dXJuIHtUeXBlZEFycmF5fSBUaGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QXJyYXkoIGFycmF5LCB0eXBlICkge1xuXG5cdGlmICggISBhcnJheSB8fCBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSApIHJldHVybiBhcnJheTtcblxuXHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcblxuXHRcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XG5cblx0fVxuXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthbnl9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNUeXBlZEFycmF5KCBvYmplY3QgKSB7XG5cblx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiYgISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRpbWVzIC0gVGhlIGtleWZyYW1lIHRpbWUgdmFsdWVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApIHtcblxuXHRmdW5jdGlvbiBjb21wYXJlVGltZSggaSwgaiApIHtcblxuXHRcdHJldHVybiB0aW1lc1sgaSBdIC0gdGltZXNbIGogXTtcblxuXHR9XG5cblx0Y29uc3QgbiA9IHRpbWVzLmxlbmd0aDtcblx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCBuICk7XG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcblxuXHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8qKlxuICogU29ydHMgdGhlIGdpdmVuIGFycmF5IGJ5IHRoZSBwcmV2aW91c2x5IGNvbXB1dGVkIG9yZGVyIHZpYSBgZ2V0S2V5ZnJhbWVPcmRlcigpYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gc29ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmRlciAtIFRoZSBzb3J0IG9yZGVyLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHNvcnRlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNvcnRlZEFycmF5KCB2YWx1ZXMsIHN0cmlkZSwgb3JkZXIgKSB7XG5cblx0Y29uc3QgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoIG5WYWx1ZXMgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcblxuXHRcdGNvbnN0IHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8qKlxuICogVXNlZCBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGpzb25LZXlzIC0gQSBsaXN0IG9mIEpTT04ga2V5ZnJhbWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB0aW1lcyAtIFRoaXMgYXJyYXkgd2lsbCBiZSBmaWxsZWQgd2l0aCBrZXlmcmFtZSB0aW1lcyBieSB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZXMgLSBUaGlzIGFycmF5IHdpbGwgYmUgZmlsbGVkIHdpdGgga2V5ZnJhbWUgdmFsdWVzIGJ5IHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVQcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuSlNPTigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xuXG5cdGxldCBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcblxuXHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHR9XG5cblx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdGxldCB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCAuLi52YWx1ZSApOyAvLyBwdXNoIGFsbCBlbGVtZW50c1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHR9IGVsc2UgaWYgKCB2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcblxuXHRcdGRvIHtcblxuXHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHR2YWx1ZS50b0FycmF5KCB2YWx1ZXMsIHZhbHVlcy5sZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXG5cblx0XHRkbyB7XG5cblx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY2xpcCwgY29udGFpbmluZyBvbmx5IHRoZSBzZWdtZW50IG9mIHRoZSBvcmlnaW5hbCBjbGlwIGJldHdlZW4gdGhlIGdpdmVuIGZyYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0FuaW1hdGlvbkNsaXB9IHNvdXJjZUNsaXAgLSBUaGUgdmFsdWVzIHRvIHNvcnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGlwLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0RnJhbWUgLSBUaGUgc3RhcnQgZnJhbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kRnJhbWUgLSBUaGUgZW5kIGZyYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcHM9MzBdIC0gVGhlIEZQUy5cbiAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IFRoZSBuZXcgc3ViIGNsaXAuXG4gKi9cbmZ1bmN0aW9uIHN1YmNsaXAoIHNvdXJjZUNsaXAsIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgPSAzMCApIHtcblxuXHRjb25zdCBjbGlwID0gc291cmNlQ2xpcC5jbG9uZSgpO1xuXG5cdGNsaXAubmFtZSA9IG5hbWU7XG5cblx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2xpcC50cmFja3MubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Y29uc3QgdHJhY2sgPSBjbGlwLnRyYWNrc1sgaSBdO1xuXHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRyYWNrLnRpbWVzLmxlbmd0aDsgKysgaiApIHtcblxuXHRcdFx0Y29uc3QgZnJhbWUgPSB0cmFjay50aW1lc1sgaiBdICogZnBzO1xuXG5cdFx0XHRpZiAoIGZyYW1lIDwgc3RhcnRGcmFtZSB8fCBmcmFtZSA+PSBlbmRGcmFtZSApIGNvbnRpbnVlO1xuXG5cdFx0XHR0aW1lcy5wdXNoKCB0cmFjay50aW1lc1sgaiBdICk7XG5cblx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8IHZhbHVlU2l6ZTsgKysgayApIHtcblxuXHRcdFx0XHR2YWx1ZXMucHVzaCggdHJhY2sudmFsdWVzWyBqICogdmFsdWVTaXplICsgayBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGltZXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHR0cmFjay50aW1lcyA9IGNvbnZlcnRBcnJheSggdGltZXMsIHRyYWNrLnRpbWVzLmNvbnN0cnVjdG9yICk7XG5cdFx0dHJhY2sudmFsdWVzID0gY29udmVydEFycmF5KCB2YWx1ZXMsIHRyYWNrLnZhbHVlcy5jb25zdHJ1Y3RvciApO1xuXG5cdFx0dHJhY2tzLnB1c2goIHRyYWNrICk7XG5cblx0fVxuXG5cdGNsaXAudHJhY2tzID0gdHJhY2tzO1xuXG5cdC8vIGZpbmQgbWluaW11bSAudGltZXMgdmFsdWUgYWNyb3NzIGFsbCB0cmFja3MgaW4gdGhlIHRyaW1tZWQgY2xpcFxuXG5cdGxldCBtaW5TdGFydFRpbWUgPSBJbmZpbml0eTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRpZiAoIG1pblN0YXJ0VGltZSA+IGNsaXAudHJhY2tzWyBpIF0udGltZXNbIDAgXSApIHtcblxuXHRcdFx0bWluU3RhcnRUaW1lID0gY2xpcC50cmFja3NbIGkgXS50aW1lc1sgMCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBzaGlmdCBhbGwgdHJhY2tzIHN1Y2ggdGhhdCBjbGlwIGJlZ2lucyBhdCB0PTBcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRjbGlwLnRyYWNrc1sgaSBdLnNoaWZ0KCAtIDEgKiBtaW5TdGFydFRpbWUgKTtcblxuXHR9XG5cblx0Y2xpcC5yZXNldER1cmF0aW9uKCk7XG5cblx0cmV0dXJuIGNsaXA7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUga2V5ZnJhbWVzIG9mIHRoZSBnaXZlbiBhbmltYXRpb24gY2xpcCB0byBhbiBhZGRpdGl2ZSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtBbmltYXRpb25DbGlwfSB0YXJnZXRDbGlwIC0gVGhlIGNsaXAgdG8gbWFrZSBhZGRpdGl2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmVmZXJlbmNlRnJhbWU9MF0gLSBUaGUgcmVmZXJlbmNlIGZyYW1lLlxuICogQHBhcmFtIHtBbmltYXRpb25DbGlwfSBbcmVmZXJlbmNlQ2xpcD10YXJnZXRDbGlwXSAtIFRoZSByZWZlcmVuY2UgY2xpcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnBzPTMwXSAtIFRoZSBGUFMuXG4gKiBAcmV0dXJuIHtBbmltYXRpb25DbGlwfSBUaGUgdXBkYXRlZCBjbGlwIHdoaWNoIGlzIG5vdyBhZGRpdGl2ZS5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaXBBZGRpdGl2ZSggdGFyZ2V0Q2xpcCwgcmVmZXJlbmNlRnJhbWUgPSAwLCByZWZlcmVuY2VDbGlwID0gdGFyZ2V0Q2xpcCwgZnBzID0gMzAgKSB7XG5cblx0aWYgKCBmcHMgPD0gMCApIGZwcyA9IDMwO1xuXG5cdGNvbnN0IG51bVRyYWNrcyA9IHJlZmVyZW5jZUNsaXAudHJhY2tzLmxlbmd0aDtcblx0Y29uc3QgcmVmZXJlbmNlVGltZSA9IHJlZmVyZW5jZUZyYW1lIC8gZnBzO1xuXG5cdC8vIE1ha2UgZWFjaCB0cmFjaydzIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgdmFsdWVzIGF0IHRoZSByZWZlcmVuY2UgZnJhbWVcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtVHJhY2tzOyArKyBpICkge1xuXG5cdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2sgPSByZWZlcmVuY2VDbGlwLnRyYWNrc1sgaSBdO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrVHlwZSA9IHJlZmVyZW5jZVRyYWNrLlZhbHVlVHlwZU5hbWU7XG5cblx0XHQvLyBTa2lwIHRoaXMgdHJhY2sgaWYgaXQncyBub24tbnVtZXJpY1xuXHRcdGlmICggcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnYm9vbCcgfHwgcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnc3RyaW5nJyApIGNvbnRpbnVlO1xuXG5cdFx0Ly8gRmluZCB0aGUgdHJhY2sgaW4gdGhlIHRhcmdldCBjbGlwIHdob3NlIG5hbWUgYW5kIHR5cGUgbWF0Y2hlcyB0aGUgcmVmZXJlbmNlIHRyYWNrXG5cdFx0Y29uc3QgdGFyZ2V0VHJhY2sgPSB0YXJnZXRDbGlwLnRyYWNrcy5maW5kKCBmdW5jdGlvbiAoIHRyYWNrICkge1xuXG5cdFx0XHRyZXR1cm4gdHJhY2submFtZSA9PT0gcmVmZXJlbmNlVHJhY2submFtZVxuXHRcdFx0XHQmJiB0cmFjay5WYWx1ZVR5cGVOYW1lID09PSByZWZlcmVuY2VUcmFja1R5cGU7XG5cblx0XHR9ICk7XG5cblx0XHRpZiAoIHRhcmdldFRyYWNrID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdGxldCByZWZlcmVuY2VPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVZhbHVlU2l6ZSA9IHJlZmVyZW5jZVRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0aWYgKCByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcblxuXHRcdFx0cmVmZXJlbmNlT2Zmc2V0ID0gcmVmZXJlbmNlVmFsdWVTaXplIC8gMztcblxuXHRcdH1cblxuXHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHRhcmdldFZhbHVlU2l6ZSA9IHRhcmdldFRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0aWYgKCB0YXJnZXRUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcblxuXHRcdFx0dGFyZ2V0T2Zmc2V0ID0gdGFyZ2V0VmFsdWVTaXplIC8gMztcblxuXHRcdH1cblxuXHRcdGNvbnN0IGxhc3RJbmRleCA9IHJlZmVyZW5jZVRyYWNrLnRpbWVzLmxlbmd0aCAtIDE7XG5cdFx0bGV0IHJlZmVyZW5jZVZhbHVlO1xuXG5cdFx0Ly8gRmluZCB0aGUgdmFsdWUgdG8gc3VidHJhY3Qgb3V0IG9mIHRoZSB0cmFja1xuXHRcdGlmICggcmVmZXJlbmNlVGltZSA8PSByZWZlcmVuY2VUcmFjay50aW1lc1sgMCBdICkge1xuXG5cdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgZWFybGllciB0aGFuIHRoZSBmaXJzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGZpcnN0IGtleWZyYW1lXG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IHJlZmVyZW5jZVRyYWNrLnZhbHVlcy5zbGljZSggc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcblxuXHRcdH0gZWxzZSBpZiAoIHJlZmVyZW5jZVRpbWUgPj0gcmVmZXJlbmNlVHJhY2sudGltZXNbIGxhc3RJbmRleCBdICkge1xuXG5cdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgYWZ0ZXIgdGhlIGxhc3Qga2V5ZnJhbWUsIHNvIGp1c3QgdXNlIHRoZSBsYXN0IGtleWZyYW1lXG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gbGFzdEluZGV4ICogcmVmZXJlbmNlVmFsdWVTaXplICsgcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0cmVmZXJlbmNlVmFsdWUgPSByZWZlcmVuY2VUcmFjay52YWx1ZXMuc2xpY2UoIHN0YXJ0SW5kZXgsIGVuZEluZGV4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJbnRlcnBvbGF0ZSB0byB0aGUgcmVmZXJlbmNlIHZhbHVlXG5cdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50KCk7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRpbnRlcnBvbGFudC5ldmFsdWF0ZSggcmVmZXJlbmNlVGltZSApO1xuXHRcdFx0cmVmZXJlbmNlVmFsdWUgPSBpbnRlcnBvbGFudC5yZXN1bHRCdWZmZXIuc2xpY2UoIHN0YXJ0SW5kZXgsIGVuZEluZGV4ICk7XG5cblx0XHR9XG5cblx0XHQvLyBDb25qdWdhdGUgdGhlIHF1YXRlcm5pb25cblx0XHRpZiAoIHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nICkge1xuXG5cdFx0XHRjb25zdCByZWZlcmVuY2VRdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIHJlZmVyZW5jZVZhbHVlICkubm9ybWFsaXplKCkuY29uanVnYXRlKCk7XG5cdFx0XHRyZWZlcmVuY2VRdWF0LnRvQXJyYXkoIHJlZmVyZW5jZVZhbHVlICk7XG5cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYWxsIG9mIHRoZSB0cmFjayB2YWx1ZXNcblxuXHRcdGNvbnN0IG51bVRpbWVzID0gdGFyZ2V0VHJhY2sudGltZXMubGVuZ3RoO1xuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG51bVRpbWVzOyArKyBqICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZVN0YXJ0ID0gaiAqIHRhcmdldFZhbHVlU2l6ZSArIHRhcmdldE9mZnNldDtcblxuXHRcdFx0aWYgKCByZWZlcmVuY2VUcmFja1R5cGUgPT09ICdxdWF0ZXJuaW9uJyApIHtcblxuXHRcdFx0XHQvLyBNdWx0aXBseSB0aGUgY29uanVnYXRlIGZvciBxdWF0ZXJuaW9uIHRyYWNrIHR5cGVzXG5cdFx0XHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoXG5cdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzLFxuXHRcdFx0XHRcdHZhbHVlU3RhcnQsXG5cdFx0XHRcdFx0cmVmZXJlbmNlVmFsdWUsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR0YXJnZXRUcmFjay52YWx1ZXMsXG5cdFx0XHRcdFx0dmFsdWVTdGFydFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlRW5kID0gdGFyZ2V0VmFsdWVTaXplIC0gdGFyZ2V0T2Zmc2V0ICogMjtcblxuXHRcdFx0XHQvLyBTdWJ0cmFjdCBlYWNoIHZhbHVlIGZvciBhbGwgb3RoZXIgbnVtZXJpYyB0cmFjayB0eXBlc1xuXHRcdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCB2YWx1ZUVuZDsgKysgayApIHtcblxuXHRcdFx0XHRcdHRhcmdldFRyYWNrLnZhbHVlc1sgdmFsdWVTdGFydCArIGsgXSAtPSByZWZlcmVuY2VWYWx1ZVsgayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0YXJnZXRDbGlwLmJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuXG5cdHJldHVybiB0YXJnZXRDbGlwO1xuXG59XG5cbi8qKlxuICogQSBjbGFzcyB3aXRoIHZhcmlvdXMgbWV0aG9kcyB0byBhc3Npc3Qgd2l0aCBhbmltYXRpb25zLlxuICpcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQW5pbWF0aW9uVXRpbHMge1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl8QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGNvbnZlcnQuXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheS5jb25zdHJ1Y3Rvcn0gdHlwZSAtIFRoZSBjb25zdHJ1Y3RvciBvZiBhIHR5cGUgYXJyYXkuXG5cdCAqIEByZXR1cm4ge1R5cGVkQXJyYXl9IFRoZSBjb252ZXJ0ZWQgYXJyYXlcblx0ICovXG5cdHN0YXRpYyBjb252ZXJ0QXJyYXkoIGFycmF5LCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIGNvbnZlcnRBcnJheSggYXJyYXksIHR5cGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB0eXBlZCBhcnJheS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge2FueX0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBjaGVjay5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdHlwZWQgYXJyYXkuXG5cdCAqL1xuXHRzdGF0aWMgaXNUeXBlZEFycmF5KCBvYmplY3QgKSB7XG5cblx0XHRyZXR1cm4gaXNUeXBlZEFycmF5KCBvYmplY3QgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdGltZXMgLSBUaGUga2V5ZnJhbWUgdGltZSB2YWx1ZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBhcnJheS5cblx0ICovXG5cdHN0YXRpYyBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApIHtcblxuXHRcdHJldHVybiBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU29ydHMgdGhlIGdpdmVuIGFycmF5IGJ5IHRoZSBwcmV2aW91c2x5IGNvbXB1dGVkIG9yZGVyIHZpYSBgZ2V0S2V5ZnJhbWVPcmRlcigpYC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gc29ydC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFRoZSBzdHJpZGUuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JkZXIgLSBUaGUgc29ydCBvcmRlci5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHNvcnRlZCB2YWx1ZXMuXG5cdCAqL1xuXHRzdGF0aWMgc29ydGVkQXJyYXkoIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcblxuXHRcdHJldHVybiBzb3J0ZWRBcnJheSggdmFsdWVzLCBzdHJpZGUsIG9yZGVyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0ganNvbktleXMgLSBBIGxpc3Qgb2YgSlNPTiBrZXlmcmFtZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdGltZXMgLSBUaGlzIGFycmF5IHdpbGwgYmUgZmlsbGVkIHdpdGgga2V5ZnJhbWUgdGltZXMgYnkgdGhpcyBtZXRob2QuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmFsdWVzIC0gVGhpcyBhcnJheSB3aWxsIGJlIGZpbGxlZCB3aXRoIGtleWZyYW1lIHZhbHVlcyBieSB0aGlzIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlUHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHVzZS5cblx0ICovXG5cdHN0YXRpYyBmbGF0dGVuSlNPTigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xuXG5cdFx0ZmxhdHRlbkpTT04oIGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBjbGlwLCBjb250YWluaW5nIG9ubHkgdGhlIHNlZ21lbnQgb2YgdGhlIG9yaWdpbmFsIGNsaXAgYmV0d2VlbiB0aGUgZ2l2ZW4gZnJhbWVzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQ2xpcH0gc291cmNlQ2xpcCAtIFRoZSB2YWx1ZXMgdG8gc29ydC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2xpcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0RnJhbWUgLSBUaGUgc3RhcnQgZnJhbWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlbmRGcmFtZSAtIFRoZSBlbmQgZnJhbWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZnBzPTMwXSAtIFRoZSBGUFMuXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IFRoZSBuZXcgc3ViIGNsaXAuXG5cdCAqL1xuXHRzdGF0aWMgc3ViY2xpcCggc291cmNlQ2xpcCwgbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyA9IDMwICkge1xuXG5cdFx0cmV0dXJuIHN1YmNsaXAoIHNvdXJjZUNsaXAsIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBrZXlmcmFtZXMgb2YgdGhlIGdpdmVuIGFuaW1hdGlvbiBjbGlwIHRvIGFuIGFkZGl0aXZlIGZvcm1hdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbkNsaXB9IHRhcmdldENsaXAgLSBUaGUgY2xpcCB0byBtYWtlIGFkZGl0aXZlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZUZyYW1lPTBdIC0gVGhlIHJlZmVyZW5jZSBmcmFtZS5cblx0ICogQHBhcmFtIHtBbmltYXRpb25DbGlwfSBbcmVmZXJlbmNlQ2xpcD10YXJnZXRDbGlwXSAtIFRoZSByZWZlcmVuY2UgY2xpcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmcHM9MzBdIC0gVGhlIEZQUy5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQ2xpcH0gVGhlIHVwZGF0ZWQgY2xpcCB3aGljaCBpcyBub3cgYWRkaXRpdmUuXG5cdCAqL1xuXHRzdGF0aWMgbWFrZUNsaXBBZGRpdGl2ZSggdGFyZ2V0Q2xpcCwgcmVmZXJlbmNlRnJhbWUgPSAwLCByZWZlcmVuY2VDbGlwID0gdGFyZ2V0Q2xpcCwgZnBzID0gMzAgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUNsaXBBZGRpdGl2ZSggdGFyZ2V0Q2xpcCwgcmVmZXJlbmNlRnJhbWUsIHJlZmVyZW5jZUNsaXAsIGZwcyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQge1xuXHRjb252ZXJ0QXJyYXksXG5cdGlzVHlwZWRBcnJheSxcblx0Z2V0S2V5ZnJhbWVPcmRlcixcblx0c29ydGVkQXJyYXksXG5cdGZsYXR0ZW5KU09OLFxuXHRzdWJjbGlwLFxuXHRtYWtlQ2xpcEFkZGl0aXZlLFxuXHRBbmltYXRpb25VdGlsc1xufTtcbiIsIi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXG4gKlxuICogVGhlIHBhcmFtZXRlciBkb21haW4gaXMgb25lIGRpbWVuc2lvbmFsLCB0eXBpY2FsbHkgdGhlIHRpbWUgb3IgYSBwYXRoXG4gKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXG4gKlxuICogVGhlIHNhbXBsZSB2YWx1ZXMgY2FuIGhhdmUgYW55IGRpbWVuc2lvbmFsaXR5IGFuZCBkZXJpdmVkIGNsYXNzZXMgbWF5XG4gKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHRoZSBpbnRlcnZhbCBzZWVrIGluIGEgVGVtcGxhdGUgTWV0aG9kLCBkZWZlcnJpbmdcbiAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXG4gKlxuICogVGltZSBjb21wbGV4aXR5IGlzIE8oMSkgZm9yIGxpbmVhciBhY2Nlc3MgY3Jvc3NpbmcgYXQgbW9zdCB0d28gcG9pbnRzXG4gKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXG4gKlxuICogUmVmZXJlbmNlczoge0BsaW5rIGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWx9XG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEludGVycG9sYW50IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnRlcnBvbGFudC5cblx0ICpcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBwYXJhbWV0ZXJQb3NpdGlvbnMgLSBUaGUgcGFyYW1ldGVyIHBvc2l0aW9ucyBob2xkIHRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvcnMuXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gc2FtcGxlVmFsdWVzIC0gVGhlIHNhbXBsZSB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVTaXplIC0gVGhlIHNhbXBsZSBzaXplXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gW3Jlc3VsdEJ1ZmZlcl0gLSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBhcmFtZXRlciBwb3NpdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcblxuXHRcdC8qKlxuXHRcdCAqIEEgY2FjaGUgaW5kZXguXG5cdFx0ICpcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXN1bHQgYnVmZmVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1R5cGVkQXJyYXl9XG5cdFx0ICovXG5cdFx0dGhpcy5yZXN1bHRCdWZmZXIgPSByZXN1bHRCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHJlc3VsdEJ1ZmZlciA6IG5ldyBzYW1wbGVWYWx1ZXMuY29uc3RydWN0b3IoIHNhbXBsZVNpemUgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzYW1wbGUgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1R5cGVkQXJyYXl9XG5cdFx0ICovXG5cdFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdmFsdWUgc2l6ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtUeXBlZEFycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbnRlcnBvbGF0aW9uIHNldHRpbmdzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9PYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgc2V0dGluZ3Mgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlIHRoZSBpbnRlcnBvbGFudCBhdCBwb3NpdGlvbiBgdGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIGludGVycG9sYXRpb24gZmFjdG9yLlxuXHQgKiBAcmV0dXJuIHtUeXBlZEFycmF5fSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICovXG5cdGV2YWx1YXRlKCB0ICkge1xuXG5cdFx0Y29uc3QgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRsZXQgaTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblx0XHRcdHQxID0gcHBbIGkxIF0sXG5cdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cblx0XHRcdHNlZWs6IHtcblxuXHRcdFx0XHRsZXQgcmlnaHQ7XG5cblx0XHRcdFx0bGluZWFyX3NjYW46IHtcblxuXHRcdFx0XHRcdC8vLSBTZWUgaHR0cDovL2pzcGVyZi5jb20vY29tcGFyaXNvbi10by11bmRlZmluZWQvM1xuXHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcblx0XHRcdFx0XHQvLy1cblx0XHRcdFx0XHQvLy0gXHRcdFx0XHRpZiAoIHQgPj0gdDEgfHwgdDEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZ2l2ZVVwQXQgPSBpMSArIDI7IDsgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciBlbmRcblxuXHRcdFx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XG5cdFx0XHRcdFx0XHRcdHQxID0gcHBbICsrIGkxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdHJpZ2h0ID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0Ly8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhICggdCA+PSB0MCApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBsb29waW5nP1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0MWdsb2JhbCA9IHBwWyAxIF07XG5cblx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xuXG5cdFx0XHRcdFx0XHRcdGkxID0gMjsgLy8gKyAxLCB1c2luZyB0aGUgc2NhbiBmb3IgdGhlIGRldGFpbHNcblx0XHRcdFx0XHRcdFx0dDAgPSB0MWdsb2JhbDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBnaXZlVXBBdCA9IGkxIC0gMjsgOyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCAwICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQxID0gdDA7XG5cdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdCA+PSB0MCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuXHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xuXG5cdFx0XHRcdH0gLy8gbGluZWFyIHNjYW5cblxuXHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXG5cblx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbWlkID0gKCBpMSArIHJpZ2h0ICkgPj4+IDE7XG5cblx0XHRcdFx0XHRpZiAoIHQgPCBwcFsgbWlkIF0gKSB7XG5cblx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aTEgPSBtaWQgKyAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0MSA9IHBwWyBpMSBdO1xuXHRcdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdFx0XHQvLyBjaGVjayBib3VuZGFyeSBjYXNlcywgYWdhaW5cblxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oIGkxIC0gMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSAvLyBzZWVrXG5cblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cblx0XHRcdHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApO1xuXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbnRlcnBvbGF0aW9uIHNldHRpbmdzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnRlcnBvbGF0aW9uIHNldHRpbmdzLlxuXHQgKi9cblx0Z2V0U2V0dGluZ3NfKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MgfHwgdGhpcy5EZWZhdWx0U2V0dGluZ3NfO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBbiBpbmRleCBpbnRvIHRoZSBzYW1wbGUgdmFsdWUgYnVmZmVyLlxuXHQgKiBAcmV0dXJuIHtUeXBlZEFycmF5fSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICovXG5cdGNvcHlTYW1wbGVWYWx1ZV8oIGluZGV4ICkge1xuXG5cdFx0Ly8gY29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyXG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFic3RyYWN0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMSAtIEFuIGluZGV4IGludG8gdGhlIHNhbXBsZSB2YWx1ZSBidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0MCAtIFRoZSBwcmV2aW91cyBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBUaGUgY3VycmVudCBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHQxIC0gVGhlIG5leHQgaW50ZXJwb2xhdGlvbiBmYWN0b3IuXG5cdCAqIEByZXR1cm4ge1R5cGVkQXJyYXl9IFRoZSByZXN1bHQgYnVmZmVyLlxuXHQgKi9cblx0aW50ZXJwb2xhdGVfKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnY2FsbCB0byBhYnN0cmFjdCBtZXRob2QnICk7XG5cdFx0Ly8gaW1wbGVtZW50YXRpb25zIHNoYWxsIHJldHVybiB0aGlzLnJlc3VsdEJ1ZmZlclxuXG5cdH1cblxuXHQvKipcblx0ICogT3B0aW9uYWwgbWV0aG9kIHRoYXQgaXMgZXhlY3V0ZWQgd2hlbiB0aGUgaW50ZXJ2YWwgaGFzIGNoYW5nZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpMSAtIEFuIGluZGV4IGludG8gdGhlIHNhbXBsZSB2YWx1ZSBidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0MCAtIFRoZSBwcmV2aW91cyBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBUaGUgY3VycmVudCBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cblx0ICovXG5cdGludGVydmFsQ2hhbmdlZF8oIC8qIGkxLCB0MCwgdDEgKi8gKSB7XG5cblx0XHQvLyBlbXB0eVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBJbnRlcnBvbGFudCB9O1xuIiwiaW1wb3J0IHsgWmVyb0N1cnZhdHVyZUVuZGluZywgV3JhcEFyb3VuZEVuZGluZywgWmVyb1Nsb3BlRW5kaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEludGVycG9sYW50IH0gZnJvbSAnLi4vSW50ZXJwb2xhbnQuanMnO1xuXG4vKipcbiAqIEZhc3QgYW5kIHNpbXBsZSBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhbnQuXG4gKlxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxuICogYXQgZWFjaCBzYW1wbGUgcG9zaXRpb24gdG8gdGhlIGxpbmVhciBzbG9wZSBiZXR3ZWVuIG5laWdoYm9yaW5nIHBvc2l0aW9uc1xuICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXG4gKlxuICogQGF1Z21lbnRzIEludGVycG9sYW50XG4gKi9cbmNsYXNzIEN1YmljSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY3ViaWMgaW50ZXJwb2xhbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gcGFyYW1ldGVyUG9zaXRpb25zIC0gVGhlIHBhcmFtZXRlciBwb3NpdGlvbnMgaG9sZCB0aGUgaW50ZXJwb2xhdGlvbiBmYWN0b3JzLlxuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHNhbXBsZVZhbHVlcyAtIFRoZSBzYW1wbGUgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlU2l6ZSAtIFRoZSBzYW1wbGUgc2l6ZVxuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IFtyZXN1bHRCdWZmZXJdIC0gVGhlIHJlc3VsdCBidWZmZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gLSAwO1xuXHRcdHRoaXMuX29mZnNldFByZXYgPSAtIDA7XG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0gMDtcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gLSAwO1xuXG5cdFx0dGhpcy5EZWZhdWx0U2V0dGluZ3NfID0ge1xuXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0fTtcblxuXHR9XG5cblx0aW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApIHtcblxuXHRcdGNvbnN0IHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0bGV0IGlQcmV2ID0gaTEgLSAyLFxuXHRcdFx0aU5leHQgPSBpMSArIDEsXG5cblx0XHRcdHRQcmV2ID0gcHBbIGlQcmV2IF0sXG5cdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xuXG5cdFx0aWYgKCB0UHJldiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0ICkge1xuXG5cdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gZicodDApID0gMFxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XG5cdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcblx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdHRQcmV2ID0gdDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdE5leHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQgKSB7XG5cblx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cblx0XHRcdFx0XHQvLyBmJyh0TikgPSAwXG5cdFx0XHRcdFx0aU5leHQgPSBpMTtcblx0XHRcdFx0XHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0aU5leHQgPSAxO1xuXHRcdFx0XHRcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcblx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBoYWxmRHQgPSAoIHQxIC0gdDAgKSAqIDAuNSxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuXG5cdFx0dGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICggdDAgLSB0UHJldiApO1xuXHRcdHRoaXMuX3dlaWdodE5leHQgPSBoYWxmRHQgLyAoIHROZXh0IC0gdDEgKTtcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XG5cdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IGlOZXh0ICogc3RyaWRlO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdG8xID0gaTEgKiBzdHJpZGUsXHRcdG8wID0gbzEgLSBzdHJpZGUsXG5cdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxuXHRcdFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxuXG5cdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuXHRcdFx0cHAgPSBwICogcCxcblx0XHRcdHBwcCA9IHBwICogcDtcblxuXHRcdC8vIGV2YWx1YXRlIHBvbHlub21pYWxzXG5cblx0XHRjb25zdCBzUCA9IC0gd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcblx0XHRjb25zdCBzMCA9ICggMSArIHdQICkgKiBwcHAgKyAoIC0gMS41IC0gMiAqIHdQICkgKiBwcCArICggLSAwLjUgKyB3UCApICogcCArIDE7XG5cdFx0Y29uc3QgczEgPSAoIC0gMSAtIHdOICkgKiBwcHAgKyAoIDEuNSArIHdOICkgKiBwcCArIDAuNSAqIHA7XG5cdFx0Y29uc3Qgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7XG5cblx0XHQvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9XG5cdFx0XHRcdFx0c1AgKiB2YWx1ZXNbIG9QICsgaSBdICtcblx0XHRcdFx0XHRzMCAqIHZhbHVlc1sgbzAgKyBpIF0gK1xuXHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXG5cdFx0XHRcdFx0c04gKiB2YWx1ZXNbIG9OICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ3ViaWNJbnRlcnBvbGFudCB9O1xuIiwiaW1wb3J0IHsgSW50ZXJwb2xhbnQgfSBmcm9tICcuLi9JbnRlcnBvbGFudC5qcyc7XG5cbi8qKlxuICogQSBiYXNpYyBsaW5lYXIgaW50ZXJwb2xhbnQuXG4gKlxuICogQGF1Z21lbnRzIEludGVycG9sYW50XG4gKi9cbmNsYXNzIExpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpbmVhciBpbnRlcnBvbGFudC5cblx0ICpcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBwYXJhbWV0ZXJQb3NpdGlvbnMgLSBUaGUgcGFyYW1ldGVyIHBvc2l0aW9ucyBob2xkIHRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvcnMuXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gc2FtcGxlVmFsdWVzIC0gVGhlIHNhbXBsZSB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVTaXplIC0gVGhlIHNhbXBsZSBzaXplXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gW3Jlc3VsdEJ1ZmZlcl0gLSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG5cdFx0XHRvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcblxuXHRcdFx0d2VpZ2h0MSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcblx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9XG5cdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXG5cdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQxICsgaSBdICogd2VpZ2h0MTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgTGluZWFySW50ZXJwb2xhbnQgfTtcbiIsImltcG9ydCB7IEludGVycG9sYW50IH0gZnJvbSAnLi4vSW50ZXJwb2xhbnQuanMnO1xuXG4vKipcbiAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZGluZ1xuICogdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAYXVnbWVudHMgSW50ZXJwb2xhbnRcbiAqL1xuY2xhc3MgRGlzY3JldGVJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkaXNjcmV0ZSBpbnRlcnBvbGFudC5cblx0ICpcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBwYXJhbWV0ZXJQb3NpdGlvbnMgLSBUaGUgcGFyYW1ldGVyIHBvc2l0aW9ucyBob2xkIHRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvcnMuXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gc2FtcGxlVmFsdWVzIC0gVGhlIHNhbXBsZSB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVTaXplIC0gVGhlIHNhbXBsZSBzaXplXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gW3Jlc3VsdEJ1ZmZlcl0gLSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0aW50ZXJwb2xhdGVfKCBpMSAvKiwgdDAsIHQsIHQxICovICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRGlzY3JldGVJbnRlcnBvbGFudCB9O1xuIiwiaW1wb3J0IHtcblx0SW50ZXJwb2xhdGVMaW5lYXIsXG5cdEludGVycG9sYXRlU21vb3RoLFxuXHRJbnRlcnBvbGF0ZURpc2NyZXRlXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDdWJpY0ludGVycG9sYW50IH0gZnJvbSAnLi4vbWF0aC9pbnRlcnBvbGFudHMvQ3ViaWNJbnRlcnBvbGFudC5qcyc7XG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGFudCB9IGZyb20gJy4uL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzJztcbmltcG9ydCB7IERpc2NyZXRlSW50ZXJwb2xhbnQgfSBmcm9tICcuLi9tYXRoL2ludGVycG9sYW50cy9EaXNjcmV0ZUludGVycG9sYW50LmpzJztcbmltcG9ydCAqIGFzIEFuaW1hdGlvblV0aWxzIGZyb20gJy4vQW5pbWF0aW9uVXRpbHMuanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgcyBhIHRpbWVkIHNlcXVlbmNlIG9mIGtleWZyYW1lcywgd2hpY2ggYXJlIGNvbXBvc2VkIG9mIGxpc3RzIG9mXG4gKiB0aW1lcyBhbmQgcmVsYXRlZCB2YWx1ZXMsIGFuZCB3aGljaCBhcmUgdXNlZCB0byBhbmltYXRlIGEgc3BlY2lmaWMgcHJvcGVydHlcbiAqIG9mIGFuIG9iamVjdC5cbiAqL1xuY2xhc3MgS2V5ZnJhbWVUcmFjayB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcga2V5ZnJhbWUgdHJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGtleWZyYW1lIHRyYWNrJ3MgbmFtZS5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB0aW1lcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB0aW1lcy5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZXMgLSBBIGxpc3Qgb2Yga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKiBAcGFyYW0geyhJbnRlcnBvbGF0ZUxpbmVhcnxJbnRlcnBvbGF0ZURpc2NyZXRlfEludGVycG9sYXRlU21vb3RoKX0gW2ludGVycG9sYXRpb25dIC0gVGhlIGludGVycG9sYXRpb24gdHlwZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayBuYW1lIGlzIHVuZGVmaW5lZCcgKTtcblx0XHRpZiAoIHRpbWVzID09PSB1bmRlZmluZWQgfHwgdGltZXMubGVuZ3RoID09PSAwICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogbm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkICcgKyBuYW1lICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHJhY2sncyBuYW1lIGNhbiByZWZlciB0byBtb3JwaCB0YXJnZXRzIG9yIGJvbmVzIG9yXG5cdFx0ICogcG9zc2libHkgb3RoZXIgdmFsdWVzIHdpdGhpbiBhbiBhbmltYXRlZCBvYmplY3QuIFNlZSB7QGxpbmsgUHJvcGVydHlCaW5kaW5nI3BhcnNlVHJhY2tOYW1lfVxuXHRcdCAqIGZvciB0aGUgZm9ybXMgb2Ygc3RyaW5ncyB0aGF0IGNhbiBiZSBwYXJzZWQgZm9yIHByb3BlcnR5IGJpbmRpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUga2V5ZnJhbWUgdGltZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRpbWVzLCB0aGlzLlRpbWVCdWZmZXJUeXBlICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUga2V5ZnJhbWUgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0Zsb2F0MzJBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSApO1xuXG5cdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBrZXlmcmFtZSB0cmFjayB0byBKU09OLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7S2V5ZnJhbWVUcmFja30gdHJhY2sgLSBUaGUga2V5ZnJhbWUgdHJhY2sgdG8gc2VyaWFsaXplLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBzZXJpYWxpemVkIGtleWZyYW1lIHRyYWNrIGFzIEpTT04uXG5cdCAqL1xuXHRzdGF0aWMgdG9KU09OKCB0cmFjayApIHtcblxuXHRcdGNvbnN0IHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXG5cdFx0bGV0IGpzb247XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cdFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB0aGlzLnRvSlNPTiApIHtcblxuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcblx0XHRcdGpzb24gPSB7XG5cblx0XHRcdFx0J25hbWUnOiB0cmFjay5uYW1lLFxuXHRcdFx0XHQndGltZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnRpbWVzLCBBcnJheSApLFxuXHRcdFx0XHQndmFsdWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcblxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRqc29uLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcblxuXHRcdHJldHVybiBqc29uO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGRpc2NyZXRlIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gW3Jlc3VsdF0gLSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICogQHJldHVybiB7RGlzY3JldGVJbnRlcnBvbGFudH0gVGhlIG5ldyBpbnRlcnBvbGFudC5cblx0ICovXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBsaW5lYXIgaW50ZXJwb2xhbnQuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBbcmVzdWx0XSAtIFRoZSByZXN1bHQgYnVmZmVyLlxuXHQgKiBAcmV0dXJuIHtMaW5lYXJJbnRlcnBvbGFudH0gVGhlIG5ldyBpbnRlcnBvbGFudC5cblx0ICovXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBMaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IHNtb290aCBpbnRlcnBvbGFudC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IFtyZXN1bHRdIC0gVGhlIHJlc3VsdCBidWZmZXIuXG5cdCAqIEByZXR1cm4ge0N1YmljSW50ZXJwb2xhbnR9IFRoZSBuZXcgaW50ZXJwb2xhbnQuXG5cdCAqL1xuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGgoIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgQ3ViaWNJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgaW50ZXJwb2xhdGlvbiBmYWN0b3IgbWV0aG9kIGZvciB0aGlzIGtleWZyYW1lIHRyYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhJbnRlcnBvbGF0ZUxpbmVhcnxJbnRlcnBvbGF0ZURpc2NyZXRlfEludGVycG9sYXRlU21vb3RoKX0gaW50ZXJwb2xhdGlvbiAtIFRoZSBpbnRlcnBvbGF0aW9uIHR5cGUuXG5cdCAqIEByZXR1cm4ge0tleWZyYW1lVHJhY2t9IEEgcmVmZXJlbmNlIHRvIHRoaXMga2V5ZnJhbWUgdHJhY2suXG5cdCAqL1xuXHRzZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0bGV0IGZhY3RvcnlNZXRob2Q7XG5cblx0XHRzd2l0Y2ggKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG5cblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgSW50ZXJwb2xhdGVMaW5lYXI6XG5cblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdGlmICggZmFjdG9yeU1ldGhvZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBtZXNzYWdlID0gJ3Vuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICcgK1xuXHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyAnIGtleWZyYW1lIHRyYWNrIG5hbWVkICcgKyB0aGlzLm5hbWU7XG5cblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGludGVycG9sYXRpb24gdHlwZS5cblx0ICpcblx0ICogQHJldHVybiB7KEludGVycG9sYXRlTGluZWFyfEludGVycG9sYXRlRGlzY3JldGV8SW50ZXJwb2xhdGVTbW9vdGgpfSBUaGUgaW50ZXJwb2xhdGlvbiB0eXBlLlxuXHQgKi9cblx0Z2V0SW50ZXJwb2xhdGlvbigpIHtcblxuXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcblxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcblxuXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6XG5cblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgc2l6ZS5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgc2l6ZS5cblx0ICovXG5cdGdldFZhbHVlU2l6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1vdmVzIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmQgb3IgYmFja3dhcmQgaW4gdGltZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVPZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIG1vdmUgdGhlIHRpbWUgdmFsdWVzLlxuXHQgKiBAcmV0dXJuIHtLZXlmcmFtZVRyYWNrfSBBIHJlZmVyZW5jZSB0byB0aGlzIGtleWZyYW1lIHRyYWNrLlxuXHQgKi9cblx0c2hpZnQoIHRpbWVPZmZzZXQgKSB7XG5cblx0XHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcblxuXHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSAtIHNlY29uZHMgY29udmVyc2lvbnMpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlIC0gVGhlIHRpbWUgc2NhbGUuXG5cdCAqIEByZXR1cm4ge0tleWZyYW1lVHJhY2t9IEEgcmVmZXJlbmNlIHRvIHRoaXMga2V5ZnJhbWUgdHJhY2suXG5cdCAqL1xuXHRzY2FsZSggdGltZVNjYWxlICkge1xuXG5cdFx0aWYgKCB0aW1lU2NhbGUgIT09IDEuMCApIHtcblxuXHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dGltZXNbIGkgXSAqPSB0aW1lU2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgZGVmaW5lZCB0aW1lIHJhbmdlLlxuXHQgKlxuXHQgKiBOb3RlOiBUaGUgbWV0aG9kIGRvZXMgbm90IHNoaWZ0IGFyb3VuZCBrZXlzIHRvIHRoZSBzdGFydCBvZiB0aGUgdHJhY2sgdGltZSwgYmVjYXVzZSBmb3IgaW50ZXJwb2xhdGVkXG5cdCAqIGtleXMgdGhpcyB3aWxsIGNoYW5nZSB0aGVpciB2YWx1ZXNcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cblx0ICogQHJldHVybiB7S2V5ZnJhbWVUcmFja30gQSByZWZlcmVuY2UgdG8gdGhpcyBrZXlmcmFtZSB0cmFjay5cblx0ICovXG5cdHRyaW0oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcblxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG5cdFx0bGV0IGZyb20gPSAwLFxuXHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cblx0XHR3aGlsZSAoIGZyb20gIT09IG5LZXlzICYmIHRpbWVzWyBmcm9tIF0gPCBzdGFydFRpbWUgKSB7XG5cblx0XHRcdCsrIGZyb207XG5cblx0XHR9XG5cblx0XHR3aGlsZSAoIHRvICE9PSAtIDEgJiYgdGltZXNbIHRvIF0gPiBlbmRUaW1lICkge1xuXG5cdFx0XHQtLSB0bztcblxuXHRcdH1cblxuXHRcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cblx0XHRpZiAoIGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzICkge1xuXG5cdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcblx0XHRcdGlmICggZnJvbSA+PSB0byApIHtcblxuXHRcdFx0XHR0byA9IE1hdGgubWF4KCB0bywgMSApO1xuXHRcdFx0XHRmcm9tID0gdG8gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0XHR0aGlzLnRpbWVzID0gdGltZXMuc2xpY2UoIGZyb20sIHRvICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzLnNsaWNlKCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBtaW5pbWFsIHZhbGlkYXRpb24gb24gdGhlIGtleWZyYW1lIHRyYWNrLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzXG5cdCAqIGFyZSB2YWxpZC5cblx0ICpcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUga2V5ZnJhbWVzIGFyZSB2YWxpZCBvciBub3QuXG5cdCAqL1xuXHR2YWxpZGF0ZSgpIHtcblxuXHRcdGxldCB2YWxpZCA9IHRydWU7XG5cblx0XHRjb25zdCB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBJbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2suJywgdGhpcyApO1xuXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcblxuXHRcdGlmICggbktleXMgPT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUcmFjayBpcyBlbXB0eS4nLCB0aGlzICk7XG5cdFx0XHR2YWxpZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHByZXZUaW1lID0gbnVsbDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnJUaW1lID0gdGltZXNbIGkgXTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCBjdXJyVGltZSApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHByZXZUaW1lICE9PSBudWxsICYmIHByZXZUaW1lID4gY3VyclRpbWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLicsIHRoaXMsIGksIGN1cnJUaW1lLCBwcmV2VGltZSApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIHZhbHVlcyApICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkO1xuXG5cdH1cblxuXHQvKipcblx0ICogT3B0aW1pemVzIHRoaXMga2V5ZnJhbWUgdHJhY2sgYnkgcmVtb3ZpbmcgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgKHdoaWNoIGFyZVxuXHQgKiBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlcykuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGNsaXAuXG5cdCAqL1xuXHRvcHRpbWl6ZSgpIHtcblxuXHRcdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXG5cblx0XHQvLyB0aW1lcyBvciB2YWx1ZXMgbWF5IGJlIHNoYXJlZCB3aXRoIG90aGVyIHRyYWNrcywgc28gb3ZlcndyaXRpbmcgaXMgdW5zYWZlXG5cdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLnNsaWNlKCksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcy5zbGljZSgpLFxuXHRcdFx0c3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKSxcblxuXHRcdFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcblxuXHRcdFx0bGFzdEluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcblxuXHRcdGxldCB3cml0ZUluZGV4ID0gMTtcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgKysgaSApIHtcblxuXHRcdFx0bGV0IGtlZXAgPSBmYWxzZTtcblxuXHRcdFx0Y29uc3QgdGltZSA9IHRpbWVzWyBpIF07XG5cdFx0XHRjb25zdCB0aW1lTmV4dCA9IHRpbWVzWyBpICsgMSBdO1xuXG5cdFx0XHQvLyByZW1vdmUgYWRqYWNlbnQga2V5ZnJhbWVzIHNjaGVkdWxlZCBhdCB0aGUgc2FtZSB0aW1lXG5cblx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVzWyAwIF0gKSApIHtcblxuXHRcdFx0XHRpZiAoICEgc21vb3RoSW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBrZXlmcmFtZXMgc2FtZSBhcyB0aGVpciBuZWlnaGJvcnNcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgb2Zmc2V0ICsgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB2YWx1ZXNbIG9mZnNldFAgKyBqIF0gfHxcblx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcblxuXHRcdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cblxuXHRcdFx0aWYgKCBrZWVwICkge1xuXG5cdFx0XHRcdGlmICggaSAhPT0gd3JpdGVJbmRleCApIHtcblxuXHRcdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0Y29uc3QgcmVhZE9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Kysgd3JpdGVJbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcblxuXHRcdGlmICggbGFzdEluZGV4ID4gMCApIHtcblxuXHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0Zm9yICggbGV0IHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHR9XG5cblx0XHRpZiAoIHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy50aW1lcyA9IHRpbWVzLnNsaWNlKCAwLCB3cml0ZUluZGV4ICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcy5zbGljZSggMCwgd3JpdGVJbmRleCAqIHN0cmlkZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy50aW1lcyA9IHRpbWVzO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcga2V5ZnJhbWUgdHJhY2sgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7S2V5ZnJhbWVUcmFja30gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMuc2xpY2UoKTtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlcy5zbGljZSgpO1xuXG5cdFx0Y29uc3QgVHlwZWRLZXlmcmFtZVRyYWNrID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soIHRoaXMubmFtZSwgdGltZXMsIHZhbHVlcyApO1xuXG5cdFx0Ly8gSW50ZXJwb2xhbnQgYXJndW1lbnQgdG8gY29uc3RydWN0b3IgaXMgbm90IHNhdmVkLCBzbyBjb3B5IHRoZSBmYWN0b3J5IG1ldGhvZCBkaXJlY3RseS5cblx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQ7XG5cblx0XHRyZXR1cm4gdHJhY2s7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGhlIHZhbHVlIHR5cGUgbmFtZS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJydcbiAqL1xuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICcnO1xuXG4vKipcbiAqIFRoZSB0aW1lIGJ1ZmZlciB0eXBlIG9mIHRoaXMga2V5ZnJhbWUgdHJhY2suXG4gKlxuICogQHR5cGUge1R5cGVkQXJyYXl8QXJyYXl9XG4gKiBAZGVmYXVsdCBGbG9hdDMyQXJyYXkuY29uc3RydWN0b3JcbiAqL1xuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5cbi8qKlxuICogVGhlIHZhbHVlIGJ1ZmZlciB0eXBlIG9mIHRoaXMga2V5ZnJhbWUgdHJhY2suXG4gKlxuICogQHR5cGUge1R5cGVkQXJyYXl8QXJyYXl9XG4gKiBAZGVmYXVsdCBGbG9hdDMyQXJyYXkuY29uc3RydWN0b3JcbiAqL1xuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gRmxvYXQzMkFycmF5O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSBvZiB0aGlzIGtleWZyYW1lIHRyYWNrLlxuICpcbiAqIEB0eXBlIHsoSW50ZXJwb2xhdGVMaW5lYXJ8SW50ZXJwb2xhdGVEaXNjcmV0ZXxJbnRlcnBvbGF0ZVNtb290aCl9XG4gKiBAZGVmYXVsdCBJbnRlcnBvbGF0ZUxpbmVhclxuICovXG5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlTGluZWFyO1xuXG5leHBvcnQgeyBLZXlmcmFtZVRyYWNrIH07XG4iLCJpbXBvcnQgeyBJbnRlcnBvbGF0ZURpc2NyZXRlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuLi9LZXlmcmFtZVRyYWNrLmpzJztcblxuLyoqXG4gKiBBIHRyYWNrIGZvciBib29sZWFuIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKiBAYXVnbWVudHMgS2V5ZnJhbWVUcmFja1xuICovXG5jbGFzcyBCb29sZWFuS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJvb2xlYW4ga2V5ZnJhbWUgdHJhY2suXG5cdCAqXG5cdCAqIFRoaXMga2V5ZnJhbWUgdHJhY2sgdHlwZSBoYXMgbm8gYGludGVycG9sYXRpb25gIHBhcmFtZXRlciBiZWNhdXNlIHRoZVxuXHQgKiBpbnRlcnBvbGF0aW9uIGlzIGFsd2F5cyBkaXNjcmV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUga2V5ZnJhbWUgdHJhY2sncyBuYW1lLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRpbWVzIC0gQSBsaXN0IG9mIGtleWZyYW1lIHRpbWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGltZXMsIHZhbHVlcyApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0aW1lcywgdmFsdWVzICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGhlIHZhbHVlIHR5cGUgbmFtZS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ2Jvb2wnXG4gKi9cbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2Jvb2wnO1xuXG4vKipcbiAqIFRoZSB2YWx1ZSBidWZmZXIgdHlwZSBvZiB0aGlzIGtleWZyYW1lIHRyYWNrLlxuICpcbiAqIEB0eXBlIHtUeXBlZEFycmF5fEFycmF5fVxuICogQGRlZmF1bHQgQXJyYXkuY29uc3RydWN0b3JcbiAqL1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEFycmF5O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSBvZiB0aGlzIGtleWZyYW1lIHRyYWNrLlxuICpcbiAqIEB0eXBlIHsoSW50ZXJwb2xhdGVMaW5lYXJ8SW50ZXJwb2xhdGVEaXNjcmV0ZXxJbnRlcnBvbGF0ZVNtb290aCl9XG4gKiBAZGVmYXVsdCBJbnRlcnBvbGF0ZURpc2NyZXRlXG4gKi9cbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlRGlzY3JldGU7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgQm9vbGVhbktleWZyYW1lVHJhY2sgfTtcbiIsImltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuLi9LZXlmcmFtZVRyYWNrLmpzJztcblxuLyoqXG4gKiBBIHRyYWNrIGZvciBjb2xvciBrZXlmcmFtZSB2YWx1ZXMuXG4gKlxuICogQGF1Z21lbnRzIEtleWZyYW1lVHJhY2tcbiAqL1xuY2xhc3MgQ29sb3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29sb3Iga2V5ZnJhbWUgdHJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGtleWZyYW1lIHRyYWNrJ3MgbmFtZS5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB0aW1lcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB0aW1lcy5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZXMgLSBBIGxpc3Qgb2Yga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKiBAcGFyYW0geyhJbnRlcnBvbGF0ZUxpbmVhcnxJbnRlcnBvbGF0ZURpc2NyZXRlfEludGVycG9sYXRlU21vb3RoKX0gW2ludGVycG9sYXRpb25dIC0gVGhlIGludGVycG9sYXRpb24gdHlwZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBUaGUgdmFsdWUgdHlwZSBuYW1lLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnY29sb3InXG4gKi9cbkNvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdjb2xvcic7XG4vLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG4vLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxuZXhwb3J0IHsgQ29sb3JLZXlmcmFtZVRyYWNrIH07XG4iLCJpbXBvcnQgeyBLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi4vS2V5ZnJhbWVUcmFjay5qcyc7XG5cbi8qKlxuICogQSB0cmFjayBmb3IgbnVtZXJpYyBrZXlmcmFtZSB2YWx1ZXMuXG4gKlxuICogQGF1Z21lbnRzIEtleWZyYW1lVHJhY2tcbiAqL1xuY2xhc3MgTnVtYmVyS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG51bWJlciBrZXlmcmFtZSB0cmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUga2V5ZnJhbWUgdHJhY2sncyBuYW1lLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRpbWVzIC0gQSBsaXN0IG9mIGtleWZyYW1lIHRpbWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7KEludGVycG9sYXRlTGluZWFyfEludGVycG9sYXRlRGlzY3JldGV8SW50ZXJwb2xhdGVTbW9vdGgpfSBbaW50ZXJwb2xhdGlvbl0gLSBUaGUgaW50ZXJwb2xhdGlvbiB0eXBlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRzdXBlciggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSB0eXBlIG5hbWUuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdudW1iZXInXG4gKi9cbk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnbnVtYmVyJztcbi8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcbi8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG5leHBvcnQgeyBOdW1iZXJLZXlmcmFtZVRyYWNrIH07XG4iLCJpbXBvcnQgeyBJbnRlcnBvbGFudCB9IGZyb20gJy4uL0ludGVycG9sYW50LmpzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9RdWF0ZXJuaW9uLmpzJztcblxuLyoqXG4gKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cbiAqXG4gKiBAYXVnbWVudHMgSW50ZXJwb2xhbnRcbiAqL1xuY2xhc3MgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFNMRVJQIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHBhcmFtZXRlclBvc2l0aW9ucyAtIFRoZSBwYXJhbWV0ZXIgcG9zaXRpb25zIGhvbGQgdGhlIGludGVycG9sYXRpb24gZmFjdG9ycy5cblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBzYW1wbGVWYWx1ZXMgLSBUaGUgc2FtcGxlIHZhbHVlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVNpemUgLSBUaGUgc2FtcGxlIHNpemVcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBbcmVzdWx0QnVmZmVyXSAtIFRoZSByZXN1bHQgYnVmZmVyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdGFscGhhID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApO1xuXG5cdFx0bGV0IG9mZnNldCA9IGkxICogc3RyaWRlO1xuXG5cdFx0Zm9yICggbGV0IGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0ICkge1xuXG5cdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLCB2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCB9O1xuIiwiaW1wb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4uL0tleWZyYW1lVHJhY2suanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50IH0gZnJvbSAnLi4vLi4vbWF0aC9pbnRlcnBvbGFudHMvUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LmpzJztcblxuLyoqXG4gKiBBIHRyYWNrIGZvciBRdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKiBAYXVnbWVudHMgS2V5ZnJhbWVUcmFja1xuICovXG5jbGFzcyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFF1YXRlcm5pb24ga2V5ZnJhbWUgdHJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGtleWZyYW1lIHRyYWNrJ3MgbmFtZS5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB0aW1lcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB0aW1lcy5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZXMgLSBBIGxpc3Qgb2Yga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKiBAcGFyYW0geyhJbnRlcnBvbGF0ZUxpbmVhcnxJbnRlcnBvbGF0ZURpc2NyZXRlfEludGVycG9sYXRlU21vb3RoKX0gW2ludGVycG9sYXRpb25dIC0gVGhlIGludGVycG9sYXRpb24gdHlwZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0c3VwZXIoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJ3cml0dGVuIHNvIHRoZSBtZXRob2QgcmV0dXJucyBRdWF0ZXJuaW9uIGJhc2VkIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gW3Jlc3VsdF0gLSBUaGUgcmVzdWx0IGJ1ZmZlci5cblx0ICogQHJldHVybiB7UXVhdGVybmlvbkxpbmVhckludGVycG9sYW50fSBUaGUgbmV3IGludGVycG9sYW50LlxuXHQgKi9cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyKCByZXN1bHQgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSB0eXBlIG5hbWUuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdxdWF0ZXJuaW9uJ1xuICovXG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdxdWF0ZXJuaW9uJztcbi8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcbi8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZDtcblF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIH07XG4iLCJpbXBvcnQgeyBJbnRlcnBvbGF0ZURpc2NyZXRlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuLi9LZXlmcmFtZVRyYWNrLmpzJztcblxuLyoqXG4gKiBBIHRyYWNrIGZvciBzdHJpbmcga2V5ZnJhbWUgdmFsdWVzLlxuICpcbiAqIEBhdWdtZW50cyBLZXlmcmFtZVRyYWNrXG4gKi9cbmNsYXNzIFN0cmluZ0tleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzdHJpbmcga2V5ZnJhbWUgdHJhY2suXG5cdCAqXG5cdCAqIFRoaXMga2V5ZnJhbWUgdHJhY2sgdHlwZSBoYXMgbm8gYGludGVycG9sYXRpb25gIHBhcmFtZXRlciBiZWNhdXNlIHRoZVxuXHQgKiBpbnRlcnBvbGF0aW9uIGlzIGFsd2F5cyBkaXNjcmV0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUga2V5ZnJhbWUgdHJhY2sncyBuYW1lLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRpbWVzIC0gQSBsaXN0IG9mIGtleWZyYW1lIHRpbWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIEEgbGlzdCBvZiBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGltZXMsIHZhbHVlcyApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0aW1lcywgdmFsdWVzICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGhlIHZhbHVlIHR5cGUgbmFtZS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0cmluZydcbiAqL1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdzdHJpbmcnO1xuXG4vKipcbiAqIFRoZSB2YWx1ZSBidWZmZXIgdHlwZSBvZiB0aGlzIGtleWZyYW1lIHRyYWNrLlxuICpcbiAqIEB0eXBlIHtUeXBlZEFycmF5fEFycmF5fVxuICogQGRlZmF1bHQgQXJyYXkuY29uc3RydWN0b3JcbiAqL1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlIG9mIHRoaXMga2V5ZnJhbWUgdHJhY2suXG4gKlxuICogQHR5cGUgeyhJbnRlcnBvbGF0ZUxpbmVhcnxJbnRlcnBvbGF0ZURpc2NyZXRlfEludGVycG9sYXRlU21vb3RoKX1cbiAqIEBkZWZhdWx0IEludGVycG9sYXRlRGlzY3JldGVcbiAqL1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBTdHJpbmdLZXlmcmFtZVRyYWNrIH07XG4iLCJpbXBvcnQgeyBLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi4vS2V5ZnJhbWVUcmFjay5qcyc7XG5cbi8qKlxuICogQSB0cmFjayBmb3IgdmVjdG9yIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKiBAYXVnbWVudHMgS2V5ZnJhbWVUcmFja1xuICovXG5jbGFzcyBWZWN0b3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdmVjdG9yIGtleWZyYW1lIHRyYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBrZXlmcmFtZSB0cmFjaydzIG5hbWUuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdGltZXMgLSBBIGxpc3Qgb2Yga2V5ZnJhbWUgdGltZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmFsdWVzIC0gQSBsaXN0IG9mIGtleWZyYW1lIHZhbHVlcy5cblx0ICogQHBhcmFtIHsoSW50ZXJwb2xhdGVMaW5lYXJ8SW50ZXJwb2xhdGVEaXNjcmV0ZXxJbnRlcnBvbGF0ZVNtb290aCl9IFtpbnRlcnBvbGF0aW9uXSAtIFRoZSBpbnRlcnBvbGF0aW9uIHR5cGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdHN1cGVyKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGhlIHZhbHVlIHR5cGUgbmFtZS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3ZlY3RvcidcbiAqL1xuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICd2ZWN0b3InO1xuLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuLy8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXG5cbmV4cG9ydCB7IFZlY3RvcktleWZyYW1lVHJhY2sgfTtcbiIsImltcG9ydCAqIGFzIEFuaW1hdGlvblV0aWxzIGZyb20gJy4vQW5pbWF0aW9uVXRpbHMuanMnO1xuaW1wb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vS2V5ZnJhbWVUcmFjay5qcyc7XG5pbXBvcnQgeyBCb29sZWFuS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL0Jvb2xlYW5LZXlmcmFtZVRyYWNrLmpzJztcbmltcG9ydCB7IENvbG9yS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL0NvbG9yS2V5ZnJhbWVUcmFjay5qcyc7XG5pbXBvcnQgeyBOdW1iZXJLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi90cmFja3MvTnVtYmVyS2V5ZnJhbWVUcmFjay5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL1F1YXRlcm5pb25LZXlmcmFtZVRyYWNrLmpzJztcbmltcG9ydCB7IFN0cmluZ0tleWZyYW1lVHJhY2sgfSBmcm9tICcuL3RyYWNrcy9TdHJpbmdLZXlmcmFtZVRyYWNrLmpzJztcbmltcG9ydCB7IFZlY3RvcktleWZyYW1lVHJhY2sgfSBmcm9tICcuL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQSByZXVzYWJsZSBzZXQgb2Yga2V5ZnJhbWUgdHJhY2tzIHdoaWNoIHJlcHJlc2VudCBhbiBhbmltYXRpb24uXG4gKi9cbmNsYXNzIEFuaW1hdGlvbkNsaXAge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFuaW1hdGlvbiBjbGlwLlxuXHQgKlxuXHQgKiBOb3RlOiBJbnN0ZWFkIG9mIGluc3RhbnRpYXRpbmcgYW4gQW5pbWF0aW9uQ2xpcCBkaXJlY3RseSB3aXRoIHRoZSBjb25zdHJ1Y3RvciwgeW91IGNhblxuXHQgKiB1c2UgdGhlIHN0YXRpYyBpbnRlcmZhY2Ugb2YgdGhpcyBjbGFzcyBmb3IgY3JlYXRpbmcgY2xpcHMuIEluIG1vc3QgY2FzZXMgdGhvdWdoLCBhbmltYXRpb24gY2xpcHNcblx0ICogd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNyZWF0ZWQgYnkgbG9hZGVycyB3aGVuIGltcG9ydGluZyBhbmltYXRlZCAzRCBhc3NldHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nJ10gLSBUaGUgY2xpcCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249LTFdIC0gVGhlIGNsaXAncyBkdXJhdGlvbiBpbiBzZWNvbmRzLiBJZiBhIG5lZ2F0aXZlIHZhbHVlIGlzIHBhc3NlZCxcblx0ICogdGhlIGR1cmF0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBwYXNzZWQga2V5ZnJhbWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5PEtleWZyYW1lVHJhY2s+fSB0cmFja3MgLSBBbiBhcnJheSBvZiBrZXlmcmFtZSB0cmFja3MuXG5cdCAqIEBwYXJhbSB7KE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZXxBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSl9IFtibGVuZE1vZGU9Tm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlXSAtIERlZmluZXMgaG93IHRoZSBhbmltYXRpb25cblx0ICogaXMgYmxlbmRlZC9jb21iaW5lZCB3aGVuIHR3byBvciBtb3JlIGFuaW1hdGlvbnMgYXJlIHNpbXVsdGFuZW91c2x5IHBsYXllZC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBuYW1lID0gJycsIGR1cmF0aW9uID0gLSAxLCB0cmFja3MgPSBbXSwgYmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNsaXAncyBuYW1lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0LyoqXG5cdFx0ICogIEFuIGFycmF5IG9mIGtleWZyYW1lIHRyYWNrcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxLZXlmcmFtZVRyYWNrPn1cblx0XHQgKi9cblx0XHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjbGlwJ3MgZHVyYXRpb24gaW4gc2Vjb25kcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBob3cgdGhlIGFuaW1hdGlvbiBpcyBibGVuZGVkL2NvbWJpbmVkIHdoZW4gdHdvIG9yIG1vcmUgYW5pbWF0aW9uc1xuXHRcdCAqIGFyZSBzaW11bHRhbmVvdXNseSBwbGF5ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZXxBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSl9XG5cdFx0ICovXG5cdFx0dGhpcy5ibGVuZE1vZGUgPSBibGVuZE1vZGU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgVVVJRCBvZiB0aGUgYW5pbWF0aW9uIGNsaXAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xuXHRcdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XG5cblx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGFuaW1hdGlvbiBjbGlwIGZyb20gdGhlIGdpdmVuIEpTT04uXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgc2VyaWFsaXplZCBhbmltYXRpb24gY2xpcC5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQ2xpcH0gVGhlIG5ldyBhbmltYXRpb24gY2xpcC5cblx0ICovXG5cdHN0YXRpYyBwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxuXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxuXHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR0cmFja3MucHVzaCggcGFyc2VLZXlmcmFtZVRyYWNrKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNsaXAgPSBuZXcgdGhpcygganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MsIGpzb24uYmxlbmRNb2RlICk7XG5cdFx0Y2xpcC51dWlkID0ganNvbi51dWlkO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBhbmltYXRpb24gY2xpcCBpbnRvIEpTT04uXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtBbmltYXRpb25DbGlwfSBjbGlwIC0gVGhlIGFuaW1hdGlvbiBjbGlwIHRvIHNlcmlhbGl6ZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgSlNPTiBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgdG9KU09OKCBjbGlwICkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW10sXG5cdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XG5cblx0XHRjb25zdCBqc29uID0ge1xuXG5cdFx0XHQnbmFtZSc6IGNsaXAubmFtZSxcblx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXG5cdFx0XHQndHJhY2tzJzogdHJhY2tzLFxuXHRcdFx0J3V1aWQnOiBjbGlwLnV1aWQsXG5cdFx0XHQnYmxlbmRNb2RlJzogY2xpcC5ibGVuZE1vZGVcblxuXHRcdH07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dHJhY2tzLnB1c2goIEtleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGFuaW1hdGlvbiBjbGlwIGZyb20gdGhlIHBhc3NlZCBtb3JwaCB0YXJnZXRzIGFycmF5IG9mIGFcblx0ICogZ2VvbWV0cnksIHRha2luZyBhIG5hbWUgYW5kIHRoZSBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmQuXG5cdCAqXG5cdCAqIE5vdGU6IFRoZSBmcHMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLCBidXQgdGhlIGFuaW1hdGlvbiBzcGVlZCBjYW4gYmVcblx0ICogb3ZlcnJpZGRlbiB2aWEge0BsaW5rIEFuaW1hdGlvbkFjdGlvbiNzZXREdXJhdGlvbn0uXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNsaXAuXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gbW9ycGhUYXJnZXRTZXF1ZW5jZSAtIEEgc2VxdWVuY2Ugb2YgbW9ycGggdGFyZ2V0cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZwcyAtIFRoZSBGcmFtZXMtUGVyLVNlY29uZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBub0xvb3AgLSBXaGV0aGVyIHRoZSBjbGlwIHNob3VsZCBiZSBubyBsb29wIG9yIG5vdC5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQ2xpcH0gVGhlIG5ldyBhbmltYXRpb24gY2xpcC5cblx0ICovXG5cdHN0YXRpYyBDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzLCBub0xvb3AgKSB7XG5cblx0XHRjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcblx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0bGV0IHRpbWVzID0gW107XG5cdFx0XHRsZXQgdmFsdWVzID0gW107XG5cblx0XHRcdHRpbWVzLnB1c2goXG5cdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0aSxcblx0XHRcdFx0KCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzICk7XG5cblx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XG5cblx0XHRcdGNvbnN0IG9yZGVyID0gQW5pbWF0aW9uVXRpbHMuZ2V0S2V5ZnJhbWVPcmRlciggdGltZXMgKTtcblx0XHRcdHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHRpbWVzLCAxLCBvcmRlciApO1xuXHRcdFx0dmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHZhbHVlcywgMSwgb3JkZXIgKTtcblxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlXG5cdFx0XHQvLyBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cblx0XHRcdGlmICggISBub0xvb3AgJiYgdGltZXNbIDAgXSA9PT0gMCApIHtcblxuXHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlc1sgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dHJhY2tzLnB1c2goXG5cdFx0XHRcdG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKFxuXHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcblx0XHRcdFx0XHR0aW1lcywgdmFsdWVzXG5cdFx0XHRcdCkuc2NhbGUoIDEuMCAvIGZwcyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMoIG5hbWUsIC0gMSwgdHJhY2tzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hlcyBmb3IgYW4gYW5pbWF0aW9uIGNsaXAgYnkgbmFtZSwgdGFraW5nIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXJcblx0ICogZWl0aGVyIGFuIGFycmF5IG9mIGNsaXBzLCBvciBhIG1lc2ggb3IgZ2VvbWV0cnkgdGhhdCBjb250YWlucyBhblxuXHQgKiBhcnJheSBuYW1lZCBcImFuaW1hdGlvbnNcIiBwcm9wZXJ0eS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0geyhBcnJheTxBbmltYXRpb25DbGlwPnxPYmplY3QzRCl9IG9iamVjdE9yQ2xpcEFycmF5IC0gVGhlIGFycmF5IG9yIG9iamVjdCB0byBzZWFyY2ggdGhyb3VnaC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSB0byBzZWFyY2ggZm9yLlxuXHQgKiBAcmV0dXJuIHs/QW5pbWF0aW9uQ2xpcH0gVGhlIGZvdW5kIGFuaW1hdGlvbiBjbGlwLiBSZXR1cm5zIGBudWxsYCBpZiBubyBjbGlwIGhhcyBiZWVuIGZvdW5kLlxuXHQgKi9cblx0c3RhdGljIGZpbmRCeU5hbWUoIG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lICkge1xuXG5cdFx0bGV0IGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXG5cdFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIG9iamVjdE9yQ2xpcEFycmF5ICkgKSB7XG5cblx0XHRcdGNvbnN0IG8gPSBvYmplY3RPckNsaXBBcnJheTtcblx0XHRcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXBBcnJheS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggY2xpcEFycmF5WyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXcgQW5pbWF0aW9uQ2xpcHMgY3JlYXRlZCBmcm9tIHRoZSBtb3JwaCB0YXJnZXRcblx0ICogc2VxdWVuY2VzIG9mIGEgZ2VvbWV0cnksIHRyeWluZyB0byBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvXG5cdCAqIGFuaW1hdGlvbi1ncm91cC1iYXNlZCBwYXR0ZXJucyBsaWtlIFwiV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyLi4uXCIuXG5cdCAqXG5cdCAqIFNlZSB7QGxpbmsgTUQyTG9hZGVyI3BhcnNlfSBhcyBhbiBleGFtcGxlIGZvciBob3cgdGhlIG1ldGhvZCBzaG91bGQgYmUgdXNlZC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IG1vcnBoVGFyZ2V0cyAtIEEgc2VxdWVuY2Ugb2YgbW9ycGggdGFyZ2V0cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZwcyAtIFRoZSBGcmFtZXMtUGVyLVNlY29uZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBub0xvb3AgLSBXaGV0aGVyIHRoZSBjbGlwIHNob3VsZCBiZSBubyBsb29wIG9yIG5vdC5cblx0ICogQHJldHVybiB7QXJyYXk8QW5pbWF0aW9uQ2xpcD59IEFuIGFycmF5IG9mIG5ldyBhbmltYXRpb24gY2xpcHMuXG5cdCAqL1xuXHRzdGF0aWMgQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuXHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXHRcdGNvbnN0IHBhdHRlcm4gPSAvXihbXFx3LV0qPykoW1xcZF0rKSQvO1xuXG5cdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXG5cdFx0Ly8gcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuXHRcdFx0Y29uc3QgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cblx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRjb25zdCBuYW1lID0gcGFydHNbIDEgXTtcblxuXHRcdFx0XHRsZXQgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoICEgYW5pbWF0aW9uTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhbmltYXRpb25Nb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2xpcHMgPSBbXTtcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGNsaXBzLnB1c2goIHRoaXMuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0sIGZwcywgbm9Mb29wICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjbGlwcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgYGFuaW1hdGlvbi5oaWVyYXJjaHlgIGZvcm1hdCBhbmQgcmV0dXJucyBhIG5ldyBhbmltYXRpb24gY2xpcC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSByMTc1LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uIC0gQSBzZXJpYWxpemVkIGFuaW1hdGlvbiBjbGlwIGFzIEpTT04uXG5cdCAqIEBwYXJhbSB7QXJyYXk8Qm9uZXM+fSBib25lcyAtIEFuIGFycmF5IG9mIGJvbmVzLlxuXHQgKiBAcmV0dXJuIHs/QW5pbWF0aW9uQ2xpcH0gVGhlIG5ldyBhbmltYXRpb24gY2xpcC5cblx0ICovXG5cdHN0YXRpYyBwYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uLCBib25lcyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkNsaXA6IHBhcnNlQW5pbWF0aW9uKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHdpdGggcjE4NScgKTtcblxuXHRcdGlmICggISBhbmltYXRpb24gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uICggdHJhY2tUeXBlLCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgZGVzdFRyYWNrcyApIHtcblxuXHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbktleXMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdEFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUgKTtcblxuXHRcdFx0XHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG5cdFx0XHRcdGlmICggdGltZXMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdFx0ZGVzdFRyYWNrcy5wdXNoKCBuZXcgdHJhY2tUeXBlKCB0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0Y29uc3QgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XG5cdFx0Y29uc3QgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcblx0XHRjb25zdCBibGVuZE1vZGUgPSBhbmltYXRpb24uYmxlbmRNb2RlO1xuXG5cdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG5cdFx0bGV0IGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtIDE7XG5cblx0XHRjb25zdCBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xuXG5cdFx0Zm9yICggbGV0IGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0Y29uc3QgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XG5cblx0XHRcdC8vIHNraXAgZW1wdHkgdHJhY2tzXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHNcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xuXHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldE5hbWVzID0ge307XG5cblx0XHRcdFx0bGV0IGs7XG5cblx0XHRcdFx0Zm9yICggayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdIF0gPSAtIDE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cblx0XHRcdFx0Ly8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2hcblx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxuXHRcdFx0XHRmb3IgKCBjb25zdCBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbSA9IDA7IG0gIT09IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzWyBrIF07XG5cblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGFuaW1hdGlvbktleS50aW1lICk7XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqIGZwcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXG5cblx0XHRcdFx0Y29uc3QgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XG5cblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcblx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxuXHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MgKTtcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXG5cdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xuXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcblx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjbGlwID0gbmV3IHRoaXMoIGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzLCBibGVuZE1vZGUgKTtcblxuXHRcdHJldHVybiBjbGlwO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZHVyYXRpb24gb2YgdGhpcyBjbGlwIHRvIHRoZSBkdXJhdGlvbiBvZiBpdHMgbG9uZ2VzdCBrZXlmcmFtZSB0cmFjay5cblx0ICpcblx0ICogQHJldHVybiB7QW5pbWF0aW9uQ2xpcH0gQSByZWZlcmVuY2UgdG8gdGhpcyBhbmltYXRpb24gY2xpcC5cblx0ICovXG5cdHJlc2V0RHVyYXRpb24oKSB7XG5cblx0XHRjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcblx0XHRsZXQgZHVyYXRpb24gPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmltcyBhbGwgdHJhY2tzIHRvIHRoZSBjbGlwJ3MgZHVyYXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGNsaXAuXG5cdCAqL1xuXHR0cmltKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgbWluaW1hbCB2YWxpZGF0aW9uIG9uIGVhY2ggdHJhY2sgaW4gdGhlIGNsaXAuIFJldHVybnMgYHRydWVgIGlmIGFsbFxuXHQgKiB0cmFja3MgYXJlIHZhbGlkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjbGlwJ3Mga2V5ZnJhbWVzIGFyZSB2YWxpZCBvciBub3QuXG5cdCAqL1xuXHR2YWxpZGF0ZSgpIHtcblxuXHRcdGxldCB2YWxpZCA9IHRydWU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhbGlkID0gdmFsaWQgJiYgdGhpcy50cmFja3NbIGkgXS52YWxpZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkO1xuXG5cdH1cblxuXHQvKipcblx0ICogT3B0aW1pemVzIGVhY2ggdHJhY2sgYnkgcmVtb3ZpbmcgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgKHdoaWNoIGFyZVxuXHQgKiBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlcykuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGNsaXAuXG5cdCAqL1xuXHRvcHRpbWl6ZSgpIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGFuaW1hdGlvbiBjbGlwIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkNsaXB9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRyYWNrcy5wdXNoKCB0aGlzLnRyYWNrc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5uYW1lLCB0aGlzLmR1cmF0aW9uLCB0cmFja3MsIHRoaXMuYmxlbmRNb2RlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIHRoaXMgYW5pbWF0aW9uIGNsaXAgaW50byBKU09OLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBKU09OIG9iamVjdC5cblx0ICovXG5cdHRvSlNPTigpIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvSlNPTiggdGhpcyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKCB0eXBlTmFtZSApIHtcblxuXHRzd2l0Y2ggKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0Y2FzZSAnc2NhbGFyJzpcblx0XHRjYXNlICdkb3VibGUnOlxuXHRcdGNhc2UgJ2Zsb2F0Jzpcblx0XHRjYXNlICdudW1iZXInOlxuXHRcdGNhc2UgJ2ludGVnZXInOlxuXG5cdFx0XHRyZXR1cm4gTnVtYmVyS2V5ZnJhbWVUcmFjaztcblxuXHRcdGNhc2UgJ3ZlY3Rvcic6XG5cdFx0Y2FzZSAndmVjdG9yMic6XG5cdFx0Y2FzZSAndmVjdG9yMyc6XG5cdFx0Y2FzZSAndmVjdG9yNCc6XG5cblx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAnY29sb3InOlxuXG5cdFx0XHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cblx0XHRcdHJldHVybiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblxuXHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXG5cdFx0XHRyZXR1cm4gQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cblx0XHRjYXNlICdzdHJpbmcnOlxuXG5cdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblxuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6ICcgKyB0eXBlTmFtZSApO1xuXG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5ZnJhbWVUcmFjaygganNvbiApIHtcblxuXHRpZiAoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UnICk7XG5cblx0fVxuXG5cdGNvbnN0IHRyYWNrVHlwZSA9IGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG5cdGlmICgganNvbi50aW1lcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Y29uc3QgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cblx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTigganNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnICk7XG5cblx0XHRqc29uLnRpbWVzID0gdGltZXM7XG5cdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0fVxuXG5cdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxuXHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2Vcblx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZSgganNvbi5uYW1lLCBqc29uLnRpbWVzLCBqc29uLnZhbHVlcywganNvbi5pbnRlcnBvbGF0aW9uICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFuaW1hdGlvbkNsaXAgfTtcbiIsIi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEEgc2ltcGxlIGNhY2hpbmcgc3lzdGVtLCB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIEZpbGVMb2FkZXJ9LlxuICogVG8gZW5hYmxlIGNhY2hpbmcgYWNyb3NzIGFsbCBsb2FkZXJzIHRoYXQgdXNlIHtAbGluayBGaWxlTG9hZGVyfSwgYWRkIGBUSFJFRS5DYWNoZS5lbmFibGVkID0gdHJ1ZS5gIG9uY2UgaW4geW91ciBhcHAuXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IENhY2hlID0ge1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIGNhY2hpbmcgaXMgZW5hYmxlZCBvciBub3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRlbmFibGVkOiBmYWxzZSxcblxuXHQvKipcblx0ICogQSBkaWN0aW9uYXJ5IHRoYXQgaG9sZHMgY2FjaGVkIGZpbGVzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLE9iamVjdD59XG5cdCAqL1xuXHRmaWxlczoge30sXG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjYWNoZSBlbnRyeSB3aXRoIGEga2V5IHRvIHJlZmVyZW5jZSB0aGUgZmlsZS4gSWYgdGhpcyBrZXkgYWxyZWFkeVxuXHQgKiBob2xkcyBhIGZpbGUsIGl0IGlzIG92ZXJ3cml0dGVuLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHJlZmVyZW5jZSB0aGUgY2FjaGVkIGZpbGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIC0gIFRoZSBmaWxlIHRvIGJlIGNhY2hlZC5cblx0ICovXG5cdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XG5cblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cblx0XHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XG5cblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHJlZmVyZW5jZSB0aGUgY2FjaGVkIGZpbGUuXG5cdCAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRoZSBjYWNoZWQgZmlsZS4gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cblx0ICovXG5cdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuXHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjYWNoZWQgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byByZWZlcmVuY2UgdGhlIGNhY2hlZCBmaWxlLlxuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHZhbHVlcyBmcm9tIHRoZSBjYWNoZS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZmlsZXMgPSB7fTtcblxuXHR9XG5cbn07XG5cblxuZXhwb3J0IHsgQ2FjaGUgfTtcbiIsIi8qKlxuICogSGFuZGxlcyBhbmQga2VlcHMgdHJhY2sgb2YgbG9hZGVkIGFuZCBwZW5kaW5nIGRhdGEuIEEgZGVmYXVsdCBnbG9iYWxcbiAqIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBhbmQgdXNlZCBieSBsb2FkZXJzIGlmIG5vdCBzdXBwbGllZFxuICogbWFudWFsbHkuXG4gKlxuICogSW4gZ2VuZXJhbCB0aGF0IHNob3VsZCBiZSBzdWZmaWNpZW50LCBob3dldmVyIHRoZXJlIGFyZSB0aW1lcyB3aGVuIGl0IGNhblxuICogYmUgdXNlZnVsIHRvIGhhdmUgc2VwYXJhdGUgbG9hZGVycyAtIGZvciBleGFtcGxlIGlmIHlvdSB3YW50IHRvIHNob3dcbiAqIHNlcGFyYXRlIGxvYWRpbmcgYmFycyBmb3Igb2JqZWN0cyBhbmQgdGV4dHVyZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcbiAqIG1hbmFnZXIub25Mb2FkID0gKCkgPT4gY29uc29sZS5sb2coICdMb2FkaW5nIGNvbXBsZXRlIScgKTtcbiAqXG4gKiBjb25zdCBsb2FkZXIxID0gbmV3IE9CSkxvYWRlciggbWFuYWdlciApO1xuICogY29uc3QgbG9hZGVyMiA9IG5ldyBDb2xsYWRhTG9hZGVyKCBtYW5hZ2VyICk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgTG9hZGluZ01hbmFnZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxvYWRpbmcgbWFuYWdlci5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBFeGVjdXRlcyB3aGVuIGFsbCBpdGVtcyBoYXZlIGJlZW4gbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gLSBFeGVjdXRlcyB3aGVuIHNpbmdsZSBpdGVtcyBoYXZlIGJlZW4gbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBFeGVjdXRlcyB3aGVuIGFuIGVycm9yIG9jY3Vycy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRsZXQgaXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0bGV0IGl0ZW1zTG9hZGVkID0gMDtcblx0XHRsZXQgaXRlbXNUb3RhbCA9IDA7XG5cdFx0bGV0IHVybE1vZGlmaWVyID0gdW5kZWZpbmVkO1xuXHRcdGNvbnN0IGhhbmRsZXJzID0gW107XG5cblx0XHQvLyBSZWZlciB0byAjNTY4OSBmb3IgdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3Qgc2V0IC5vblN0YXJ0XG5cdFx0Ly8gaW4gdGhlIGNvbnN0cnVjdG9yXG5cblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyB3aGVuIGFuIGl0ZW0gc3RhcnRzIGxvYWRpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb258dW5kZWZpbmVkfVxuXHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIHdoZW4gYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb258dW5kZWZpbmVkfVxuXHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xuXG5cdFx0LyoqXG5cdFx0ICogRXhlY3V0ZXMgd2hlbiBzaW5nbGUgaXRlbXMgaGF2ZSBiZWVuIGxvYWRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbnx1bmRlZmluZWR9XG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcblxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufHVuZGVmaW5lZH1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBsb2FkZXIgdXNpbmcgdGhlIG1hbmFnZXIgd2hlbiB0aGUgbG9hZGVyXG5cdFx0ICogc3RhcnRzIGxvYWRpbmcgYW4gaXRlbS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIGxvYWQuXG5cdFx0ICovXG5cdFx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aXRlbXNUb3RhbCArKztcblxuXHRcdFx0aWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpc0xvYWRpbmcgPSB0cnVlO1xuXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgbG9hZGVyIHVzaW5nIHRoZSBtYW5hZ2VyIHdoZW4gdGhlIGxvYWRlclxuXHRcdCAqIGVuZGVkIGxvYWRpbmcgYW4gaXRlbS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0XHQgKi9cblx0XHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aXRlbXNMb2FkZWQgKys7XG5cblx0XHRcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xuXG5cdFx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5vbkxvYWQoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgYW55IGxvYWRlciB1c2luZyB0aGUgbWFuYWdlciB3aGVuIHRoZSBsb2FkZXJcblx0XHQgKiBlbmNvdW50ZXJzIGFuIGVycm9yIHdoZW4gbG9hZGluZyBhbiBpdGVtLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGl0ZW0gdGhhdCBwcm9kdWNlcyBhbiBlcnJvci5cblx0XHQgKi9cblx0XHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5vbkVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEdpdmVuIGEgVVJMLCB1c2VzIHRoZSBVUkwgbW9kaWZpZXIgY2FsbGJhY2sgKGlmIGFueSkgYW5kIHJldHVybnMgYVxuXHRcdCAqIHJlc29sdmVkIFVSTC4gSWYgbm8gVVJMIG1vZGlmaWVyIGlzIHNldCwgcmV0dXJucyB0aGUgb3JpZ2luYWwgVVJMLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gbG9hZC5cblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZXNvbHZlZCBVUkwuXG5cdFx0ICovXG5cdFx0dGhpcy5yZXNvbHZlVVJMID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGlmICggdXJsTW9kaWZpZXIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHVybE1vZGlmaWVyKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXJsO1xuXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgZWFjaCByZXNvdXJjZSBVUkwgYmVmb3JlIGFcblx0XHQgKiByZXF1ZXN0IGlzIHNlbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuIHRoZSBvcmlnaW5hbCBVUkwsIG9yIGEgbmV3IFVSTCB0b1xuXHRcdCAqIG92ZXJyaWRlIGxvYWRpbmcgYmVoYXZpb3IuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHVzZWQgdG8gbG9hZCBhc3NldHMgZnJvbVxuXHRcdCAqIC5aSVAgZmlsZXMsIGRyYWctYW5kLWRyb3AgQVBJcywgYW5kIERhdGEgVVJJcy5cblx0XHQgKlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogY29uc3QgYmxvYnMgPSB7J2Zpc2guZ2x0Zic6IGJsb2IxLCAnZGlmZnVzZS5wbmcnOiBibG9iMiwgJ25vcm1hbC5wbmcnOiBibG9iM307XG5cdFx0ICpcblx0XHQgKiBjb25zdCBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBJbml0aWFsaXplIGxvYWRpbmcgbWFuYWdlciB3aXRoIFVSTCBjYWxsYmFjay5cblx0XHQgKiBjb25zdCBvYmplY3RVUkxzID0gW107XG5cdFx0ICogbWFuYWdlci5zZXRVUkxNb2RpZmllciggKCB1cmwgKSA9PiB7XG5cdFx0ICpcblx0XHQgKiBcdHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2JzWyB1cmwgXSApO1xuXHRcdCAqIFx0b2JqZWN0VVJMcy5wdXNoKCB1cmwgKTtcblx0XHQgKiBcdHJldHVybiB1cmw7XG5cdFx0ICpcblx0XHQgKiB9ICk7XG5cdFx0ICpcblx0XHQgKiAvLyBMb2FkIGFzIHVzdWFsLCB0aGVuIHJldm9rZSB0aGUgYmxvYiBVUkxzLlxuXHRcdCAqIGNvbnN0IGxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCBtYW5hZ2VyICk7XG5cdFx0ICogbG9hZGVyLmxvYWQoICdmaXNoLmdsdGYnLCAoZ2x0ZikgPT4ge1xuXHRcdCAqXG5cdFx0ICogXHRzY2VuZS5hZGQoIGdsdGYuc2NlbmUgKTtcblx0XHQgKiBcdG9iamVjdFVSTHMuZm9yRWFjaCggKCB1cmwgKSA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKCB1cmwgKSApO1xuXHRcdCAqXG5cdFx0ICogfSApO1xuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOnN0cmluZ30gdHJhbnNmb3JtIC0gVVJMIG1vZGlmaWVyIGNhbGxiYWNrLiBDYWxsZWQgd2l0aCBhbiBVUkwgYW5kIG11c3QgcmV0dXJuIGEgcmVzb2x2ZWQgVVJMLlxuXHRcdCAqIEByZXR1cm4ge0xvYWRpbmdNYW5hZ2VyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGxvYWRpbmcgbWFuYWdlci5cblx0XHQgKi9cblx0XHR0aGlzLnNldFVSTE1vZGlmaWVyID0gZnVuY3Rpb24gKCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgYSBsb2FkZXIgd2l0aCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLiBDYW4gYmUgdXNlZCB0b1xuXHRcdCAqIGRlZmluZSB3aGF0IGxvYWRlciBzaG91bGQgYmUgdXNlZCBpbiBvcmRlciB0byBsb2FkIHNwZWNpZmljIGZpbGVzLiBBXG5cdFx0ICogdHlwaWNhbCB1c2UgY2FzZSBpcyB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbG9hZGVyIGZvciB0ZXh0dXJlcy5cblx0XHQgKlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogLy8gYWRkIGhhbmRsZXIgZm9yIFRHQSB0ZXh0dXJlc1xuXHRcdCAqIG1hbmFnZXIuYWRkSGFuZGxlciggL1xcLnRnYSQvaSwgbmV3IFRHQUxvYWRlcigpICk7XG5cdFx0ICogYGBgXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcmVnZXggLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0XHQgKiBAcGFyYW0ge0xvYWRlcn0gbG9hZGVyIC0gQSBsb2FkZXIgdGhhdCBzaG91bGQgaGFuZGxlIG1hdGNoZWQgY2FzZXMuXG5cdFx0ICogQHJldHVybiB7TG9hZGluZ01hbmFnZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbG9hZGluZyBtYW5hZ2VyLlxuXHRcdCAqL1xuXHRcdHRoaXMuYWRkSGFuZGxlciA9IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuXHRcdFx0aGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBsb2FkZXIgZm9yIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcmVnZXggLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0XHQgKiBAcmV0dXJuIHtMb2FkaW5nTWFuYWdlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBsb2FkaW5nIG1hbmFnZXIuXG5cdFx0ICovXG5cdFx0dGhpcy5yZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKCByZWdleCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKCByZWdleCApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBpbmRleCwgMiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENhbiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSByZWdpc3RlcmVkIGxvYWRlciBmb3IgdGhlIGdpdmVuIGZpbGUgcGF0aC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIC0gVGhlIGZpbGUgcGF0aC5cblx0XHQgKiBAcmV0dXJuIHs/TG9hZGVyfSBUaGUgcmVnaXN0ZXJlZCBsb2FkZXIuIFJldHVybnMgYG51bGxgIGlmIG5vIGxvYWRlciB3YXMgZm91bmQuXG5cdFx0ICovXG5cdFx0dGhpcy5nZXRIYW5kbGVyID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XG5cblx0XHRcdFx0Y29uc3QgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBsb2FkZXIgPSBoYW5kbGVyc1sgaSArIDEgXTtcblxuXHRcdFx0XHRpZiAoIHJlZ2V4Lmdsb2JhbCApIHJlZ2V4Lmxhc3RJbmRleCA9IDA7IC8vIHNlZSAjMTc5MjBcblxuXHRcdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBsb2FkZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBUaGUgZ2xvYmFsIGRlZmF1bHQgbG9hZGluZyBtYW5hZ2VyLlxuICpcbiAqIEBjb25zdGFudFxuICogQHR5cGUge0xvYWRpbmdNYW5hZ2VyfVxuICovXG5jb25zdCBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuXG5leHBvcnQgeyBEZWZhdWx0TG9hZGluZ01hbmFnZXIsIExvYWRpbmdNYW5hZ2VyIH07XG4iLCJpbXBvcnQgeyBEZWZhdWx0TG9hZGluZ01hbmFnZXIgfSBmcm9tICcuL0xvYWRpbmdNYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBsb2FkZXJzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxvYWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtMb2FkaW5nTWFuYWdlcn0gW21hbmFnZXJdIC0gVGhlIGxvYWRpbmcgbWFuYWdlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRpbmcgbWFuYWdlci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtMb2FkaW5nTWFuYWdlcn1cblx0XHQgKiBAZGVmYXVsdCBEZWZhdWx0TG9hZGluZ01hbmFnZXJcblx0XHQgKi9cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjcm9zc09yaWdpbiBzdHJpbmcgdG8gaW1wbGVtZW50IENPUlMgZm9yIGxvYWRpbmcgdGhlIHVybCBmcm9tIGFcblx0XHQgKiBkaWZmZXJlbnQgZG9tYWluIHRoYXQgYWxsb3dzIENPUlMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdhbm9ueW1vdXMnXG5cdFx0ICovXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgWE1MSHR0cFJlcXVlc3QgdXNlcyBjcmVkZW50aWFscy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBiYXNlIHBhdGggZnJvbSB3aGljaCB0aGUgYXNzZXQgd2lsbCBiZSBsb2FkZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMucGF0aCA9ICcnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGJhc2UgcGF0aCBmcm9tIHdoaWNoIGFkZGl0aW9uYWwgcmVzb3VyY2VzIGxpa2UgdGV4dHVyZXMgd2lsbCBiZSBsb2FkZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gJyc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgW3JlcXVlc3QgaGVhZGVyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L1JlcXVlc3RfaGVhZGVyfVxuXHRcdCAqIHVzZWQgaW4gSFRUUCByZXF1ZXN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdDxzdHJpbmcsIGFueT59XG5cdFx0ICovXG5cdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0ge307XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhbGwgY29uY3JldGUgbG9hZGVycy4gSXQgaG9sZHMgdGhlXG5cdCAqIGxvZ2ljIGZvciBsb2FkaW5nIGFzc2V0cyBmcm9tIHRoZSBiYWNrZW5kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHBhdGgvVVJMIG9mIHRoZSBmaWxlIHRvIGJlIGxvYWRlZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb25Mb2FkIC0gRXhlY3V0ZWQgd2hlbiB0aGUgbG9hZGluZyBwcm9jZXNzIGhhcyBiZWVuIGZpbmlzaGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gW29uUHJvZ3Jlc3NdIC0gRXhlY3V0ZWQgd2hpbGUgdGhlIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3MuXG5cdCAqIEBwYXJhbSB7b25FcnJvckNhbGxiYWNrfSBbb25FcnJvcl0gLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICovXG5cdGxvYWQoIC8qIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICovICkge31cblxuXHQvKipcblx0ICogQSBhc3luYyB2ZXJzaW9uIG9mIHtAbGluayBMb2FkZXIjbG9hZH0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gW29uUHJvZ3Jlc3NdIC0gRXhlY3V0ZWQgd2hpbGUgdGhlIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3MuXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFzc2V0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICovXG5cdGxvYWRBc3luYyggdXJsLCBvblByb2dyZXNzICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0c2NvcGUubG9hZCggdXJsLCByZXNvbHZlLCBvblByb2dyZXNzLCByZWplY3QgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGFsbCBjb25jcmV0ZSBsb2FkZXJzLiBJdCBob2xkcyB0aGVcblx0ICogbG9naWMgZm9yIHBhcnNpbmcgdGhlIGFzc2V0IGludG8gdGhyZWUuanMgZW50aXRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YW55fSBkYXRhIC0gVGhlIGRhdGEgdG8gcGFyc2UuXG5cdCAqL1xuXHRwYXJzZSggLyogZGF0YSAqLyApIHt9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGBjcm9zc09yaWdpbmAgU3RyaW5nIHRvIGltcGxlbWVudCBDT1JTIGZvciBsb2FkaW5nIHRoZSBVUkxcblx0ICogZnJvbSBhIGRpZmZlcmVudCBkb21haW4gdGhhdCBhbGxvd3MgQ09SUy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNyb3NzT3JpZ2luIC0gVGhlIGBjcm9zc09yaWdpbmAgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0xvYWRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIFhNTEh0dHBSZXF1ZXN0IHVzZXMgY3JlZGVudGlhbHMgc3VjaCBhcyBjb29raWVzLCBhdXRob3JpemF0aW9uXG5cdCAqIGhlYWRlcnMgb3IgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZXMsIHNlZSBbWE1MSHR0cFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvd2l0aENyZWRlbnRpYWxzfS5cblx0ICpcblx0ICogTm90ZTogVGhpcyBzZXR0aW5nIGhhcyBubyBlZmZlY3QgaWYgeW91IGFyZSBsb2FkaW5nIGZpbGVzIGxvY2FsbHkgb3IgZnJvbSB0aGUgc2FtZSBkb21haW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUaGUgYHdpdGhDcmVkZW50aWFsc2AgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0xvYWRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldFdpdGhDcmVkZW50aWFscyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgYmFzZSBwYXRoIGZvciB0aGUgYXNzZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGJhc2UgcGF0aC5cblx0ICogQHJldHVybiB7TG9hZGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0UGF0aCggcGF0aCApIHtcblxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBiYXNlIHBhdGggZm9yIGRlcGVuZGVudCByZXNvdXJjZXMgbGlrZSB0ZXh0dXJlcy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlUGF0aCAtIFRoZSByZXNvdXJjZSBwYXRoLlxuXHQgKiBAcmV0dXJuIHtMb2FkZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRSZXNvdXJjZVBhdGgoIHJlc291cmNlUGF0aCApIHtcblxuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gcmVzb3VyY2VQYXRoO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gcmVxdWVzdCBoZWFkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0SGVhZGVyIC0gQSBbcmVxdWVzdCBoZWFkZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvUmVxdWVzdF9oZWFkZXJ9XG5cdCAqIGZvciBjb25maWd1cmluZyB0aGUgSFRUUCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtMb2FkZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRSZXF1ZXN0SGVhZGVyKCByZXF1ZXN0SGVhZGVyICkge1xuXG5cdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0gcmVxdWVzdEhlYWRlcjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igb25Qcm9ncmVzcyBpbiBsb2FkZXJzLlxuICpcbiAqIEBjYWxsYmFjayBvblByb2dyZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnQgLSBBbiBpbnN0YW5jZSBvZiBgUHJvZ3Jlc3NFdmVudGAgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdHVzLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIG9uRXJyb3IgaW4gbG9hZGVycy5cbiAqXG4gKiBAY2FsbGJhY2sgb25FcnJvckNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBlcnJvciB3aGljaCBvY2N1cnJlZCBkdXJpbmcgdGhlIGxvYWRpbmcgcHJvY2Vzcy5cbiAqL1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1hdGVyaWFsIG5hbWUgdGhhdCBpcyB1c2VkIGJ5IGxvYWRlcnNcbiAqIHdoZW4gY3JlYXRpbmcgbWF0ZXJpYWxzIGZvciBsb2FkZWQgM0Qgb2JqZWN0cy5cbiAqXG4gKiBOb3RlOiBOb3QgYWxsIGxvYWRlcnMgbWlnaHQgaG9ub3IgdGhpcyBzZXR0aW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCAnX19ERUZBVUxUJ1xuICovXG5Mb2FkZXIuREVGQVVMVF9NQVRFUklBTF9OQU1FID0gJ19fREVGQVVMVCc7XG5cbmV4cG9ydCB7IExvYWRlciB9O1xuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcblxuY29uc3QgbG9hZGluZyA9IHt9O1xuXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cblx0Y29uc3RydWN0b3IoIG1lc3NhZ2UsIHJlc3BvbnNlICkge1xuXG5cdFx0c3VwZXIoIG1lc3NhZ2UgKTtcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQSBsb3cgbGV2ZWwgY2xhc3MgZm9yIGxvYWRpbmcgcmVzb3VyY2VzIHdpdGggdGhlIEZldGNoIEFQSSwgdXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBtb3N0IGxvYWRlcnMuIEl0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgdG8gbG9hZCBhbnkgZmlsZSB0eXBlIHRoYXQgZG9lc1xuICogbm90IGhhdmUgYSBsb2FkZXIuXG4gKlxuICogVGhpcyBsb2FkZXIgc3VwcG9ydHMgY2FjaGluZy4gSWYgeW91IHdhbnQgdG8gdXNlIGl0LCBhZGQgYFRIUkVFLkNhY2hlLmVuYWJsZWQgPSB0cnVlO2BcbiAqIG9uY2UgdG8geW91ciBhcHBsaWNhdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbG9hZGVyID0gbmV3IFRIUkVFLkZpbGVMb2FkZXIoKTtcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCAnZXhhbXBsZS50eHQnICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTG9hZGVyXG4gKi9cbmNsYXNzIEZpbGVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZpbGUgbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xvYWRpbmdNYW5hZ2VyfSBbbWFuYWdlcl0gLSBUaGUgbG9hZGluZyBtYW5hZ2VyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV4cGVjdGVkIG1pbWUgdHlwZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5taW1lVHlwZSA9ICcnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV4cGVjdGVkIHJlc3BvbnNlIHR5cGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KCdhcnJheWJ1ZmZlcid8J2Jsb2InfCdkb2N1bWVudCd8J2pzb24nfCcnKX1cblx0XHQgKiBAZGVmYXVsdCAnJ1xuXHRcdCAqL1xuXHRcdHRoaXMucmVzcG9uc2VUeXBlID0gJyc7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3MgdGhlIGxvYWRlZCByZXNwb25zZSB0byB0aGUgYG9uTG9hZCgpYCBjYWxsYmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBwYXRoL1VSTCBvZiB0aGUgZmlsZSB0byBiZSBsb2FkZWQuIFRoaXMgY2FuIGFsc28gYmUgYSBkYXRhIFVSSS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihhbnkpfSBvbkxvYWQgLSBFeGVjdXRlZCB3aGVuIHRoZSBsb2FkaW5nIHByb2Nlc3MgaGFzIGJlZW4gZmluaXNoZWQuXG5cdCAqIEBwYXJhbSB7b25Qcm9ncmVzc0NhbGxiYWNrfSBbb25Qcm9ncmVzc10gLSBFeGVjdXRlZCB3aGlsZSB0aGUgbG9hZGluZyBpcyBpbiBwcm9ncmVzcy5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IFtvbkVycm9yXSAtIEV4ZWN1dGVkIHdoZW4gZXJyb3JzIG9jY3VyLlxuXHQgKiBAcmV0dXJuIHthbnl8dW5kZWZpbmVkfSBUaGUgY2FjaGVkIHJlc291cmNlIGlmIGF2YWlsYWJsZS5cblx0ICovXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0c2V0VGltZW91dCggKCkgPT4ge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgZHVwbGljYXRlXG5cblx0XHRpZiAoIGxvYWRpbmdbIHVybCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcblxuXHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcblx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpc2UgYXJyYXkgZm9yIGR1cGxpY2F0ZSByZXF1ZXN0c1xuXHRcdGxvYWRpbmdbIHVybCBdID0gW107XG5cblx0XHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XG5cdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXG5cdFx0XHRvbkVycm9yOiBvbkVycm9yLFxuXHRcdH0gKTtcblxuXHRcdC8vIGNyZWF0ZSByZXF1ZXN0XG5cdFx0Y29uc3QgcmVxID0gbmV3IFJlcXVlc3QoIHVybCwge1xuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMoIHRoaXMucmVxdWVzdEhlYWRlciApLFxuXHRcdFx0Y3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXG5cdFx0fSApO1xuXG5cdFx0Ly8gcmVjb3JkIHN0YXRlcyAoIGF2b2lkIGRhdGEgcmFjZSApXG5cdFx0Y29uc3QgbWltZVR5cGUgPSB0aGlzLm1pbWVUeXBlO1xuXHRcdGNvbnN0IHJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuXG5cdFx0Ly8gc3RhcnQgdGhlIGZldGNoXG5cdFx0ZmV0Y2goIHJlcSApXG5cdFx0XHQudGhlbiggcmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRcdGlmICggcmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gSFRUUCBTdGF0dXMgMCB3aGVuIHVzaW5nIG5vbi1odHRwIHByb3RvY29sXG5cdFx0XHRcdFx0Ly8gZS5nLiAnZmlsZTovLycgb3IgJ2RhdGE6Ly8nLiBIYW5kbGUgYXMgc3VjY2Vzcy5cblxuXHRcdFx0XHRcdGlmICggcmVzcG9uc2Uuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdvcmthcm91bmQ6IENoZWNraW5nIGlmIHJlc3BvbnNlLmJvZHkgPT09IHVuZGVmaW5lZCBmb3IgQWxpcGF5IGJyb3dzZXIgIzIzNTQ4XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cblx0XHRcdFx0XHQvLyBOZ2lueCBuZWVkcyBYLUZpbGUtU2l6ZSBjaGVja1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy80ODI4NzUvd2h5LWRvZXMtbmdpbngtcmVtb3ZlLWNvbnRlbnQtbGVuZ3RoLWhlYWRlci1mb3ItY2h1bmtlZC1jb250ZW50XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCAnWC1GaWxlLVNpemUnICkgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoICdDb250ZW50LUxlbmd0aCcgKTtcblx0XHRcdFx0XHRjb25zdCB0b3RhbCA9IGNvbnRlbnRMZW5ndGggPyBwYXJzZUludCggY29udGVudExlbmd0aCApIDogMDtcblx0XHRcdFx0XHRjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT09IDA7XG5cdFx0XHRcdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRcdFx0XHQvLyBwZXJpb2RpY2FsbHkgcmVhZCBkYXRhIGludG8gdGhlIG5ldyBzdHJlYW0gdHJhY2tpbmcgd2hpbGUgZG93bmxvYWQgcHJvZ3Jlc3Ncblx0XHRcdFx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oIHtcblx0XHRcdFx0XHRcdHN0YXJ0KCBjb250cm9sbGVyICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlYWREYXRhKCk7XG5cblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gcmVhZERhdGEoKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oICggeyBkb25lLCB2YWx1ZSB9ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRvbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoICdwcm9ncmVzcycsIHsgbGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCB9ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Qcm9ncmVzcyApIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZSggdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZERhdGEoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSwgKCBlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmVycm9yKCBlICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKCBzdHJlYW0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEh0dHBFcnJvciggYGZldGNoIGZvciBcIiR7cmVzcG9uc2UudXJsfVwiIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IClcblx0XHRcdC50aGVuKCByZXNwb25zZSA9PiB7XG5cblx0XHRcdFx0c3dpdGNoICggcmVzcG9uc2VUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuXHRcdFx0XHRcdGNhc2UgJ2Jsb2InOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpXG5cdFx0XHRcdFx0XHRcdC50aGVuKCB0ZXh0ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgbWltZVR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRjYXNlICdqc29uJzpcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGlmICggbWltZVR5cGUgPT09ICcnICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc25pZmYgZW5jb2Rpbmdcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmUgPSAvY2hhcnNldD1cIj8oW147XCJcXHNdKilcIj8vaTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZXhlYyA9IHJlLmV4ZWMoIG1pbWVUeXBlICk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxhYmVsID0gZXhlYyAmJiBleGVjWyAxIF0gPyBleGVjWyAxIF0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlciggbGFiZWwgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkudGhlbiggYWIgPT4gZGVjb2Rlci5kZWNvZGUoIGFiICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApXG5cdFx0XHQudGhlbiggZGF0YSA9PiB7XG5cblx0XHRcdFx0Ly8gQWRkIHRvIGNhY2hlIG9ubHkgb24gSFRUUCBzdWNjZXNzLCBzbyB0aGF0IHdlIGRvIG5vdCBjYWNoZVxuXHRcdFx0XHQvLyBlcnJvciByZXNwb25zZSBib2RpZXMgYXMgcHJvcGVyIHJlc3BvbnNlcyB0byByZXF1ZXN0cy5cblx0XHRcdFx0Q2FjaGUuYWRkKCB1cmwsIGRhdGEgKTtcblxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcblx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IClcblx0XHRcdC5jYXRjaCggZXJyID0+IHtcblxuXHRcdFx0XHQvLyBBYm9ydCBlcnJvcnMgYW5kIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCB0aGUgc2FtZVxuXG5cdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdGlmICggY2FsbGJhY2tzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXaGVuIG9uTG9hZCB3YXMgY2FsbGVkIGFuZCB1cmwgd2FzIGRlbGV0ZWQgaW4gYGxvYWRpbmdgXG5cdFx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgbG9hZGluZ1sgdXJsIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXJyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9IClcblx0XHRcdC5maW5hbGx5KCAoKSA9PiB7XG5cblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGV4cGVjdGVkIHJlc3BvbnNlIHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KCdhcnJheWJ1ZmZlcid8J2Jsb2InfCdkb2N1bWVudCd8J2pzb24nfCcnKX0gdmFsdWUgLSBUaGUgcmVzcG9uc2UgdHlwZS5cblx0ICogQHJldHVybiB7RmlsZUxvYWRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBmaWxlIGxvYWRlci5cblx0ICovXG5cdHNldFJlc3BvbnNlVHlwZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZXhwZWN0ZWQgbWltZSB0eXBlIG9mIHRoZSBsb2FkZWQgZmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIG1pbWUgdHlwZS5cblx0ICogQHJldHVybiB7RmlsZUxvYWRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBmaWxlIGxvYWRlci5cblx0ICovXG5cdHNldE1pbWVUeXBlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBGaWxlTG9hZGVyIH07XG4iLCJpbXBvcnQgeyBBbmltYXRpb25DbGlwIH0gZnJvbSAnLi4vYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanMnO1xuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGxvYWRpbmcgYW5pbWF0aW9uIGNsaXBzIGluIHRoZSBKU09OIGZvcm1hdC4gVGhlIGZpbGVzIGFyZSBpbnRlcm5hbGx5XG4gKiBsb2FkZWQgdmlhIHtAbGluayBGaWxlTG9hZGVyfS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbG9hZGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbkxvYWRlcigpO1xuICogY29uc3QgYW5pbWF0aW9ucyA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoICdhbmltYXRpb25zL2FuaW1hdGlvbi5qcycgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMb2FkZXJcbiAqL1xuY2xhc3MgQW5pbWF0aW9uTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhbmltYXRpb24gbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xvYWRpbmdNYW5hZ2VyfSBbbWFuYWdlcl0gLSBUaGUgbG9hZGluZyBtYW5hZ2VyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGxvYWRpbmcgZnJvbSB0aGUgZ2l2ZW4gVVJMIGFuZCBwYXNzIHRoZSBsb2FkZWQgYW5pbWF0aW9ucyBhcyBhbiBhcnJheVxuXHQgKiBob2xkaW5nIGluc3RhbmNlcyBvZiB7QGxpbmsgQW5pbWF0aW9uQ2xpcH0gdG8gdGhlIGBvbkxvYWQoKWAgY2FsbGJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGEgZGF0YSBVUkkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXk8QW5pbWF0aW9uQ2xpcD4pfSBvbkxvYWQgLSBFeGVjdXRlZCB3aGVuIHRoZSBsb2FkaW5nIHByb2Nlc3MgaGFzIGJlZW4gZmluaXNoZWQuXG5cdCAqIEBwYXJhbSB7b25Qcm9ncmVzc0NhbGxiYWNrfSBvblByb2dyZXNzIC0gRXhlY3V0ZWQgd2hpbGUgdGhlIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3MuXG5cdCAqIEBwYXJhbSB7b25FcnJvckNhbGxiYWNrfSBvbkVycm9yIC0gRXhlY3V0ZWQgd2hlbiBlcnJvcnMgb2NjdXIuXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTiBvYmplY3QgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYW5pbWF0aW9uIGNsaXBzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBzZXJpYWxpemVkIGFuaW1hdGlvbiBjbGlwcy5cblx0ICogQHJldHVybiB7QXJyYXk8QW5pbWF0aW9uQ2xpcD59IFRoZSBwYXJzZWQgYW5pbWF0aW9uIGNsaXBzLlxuXHQgKi9cblx0cGFyc2UoIGpzb24gKSB7XG5cblx0XHRjb25zdCBhbmltYXRpb25zID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xuXG5cdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEFuaW1hdGlvbkxvYWRlciB9O1xuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xuaW1wb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgbG9hZGluZyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0cyBTM1RDLCBBU1RDIG9yIEVUQy5cbiAqIFRleHR1cmVzIGFyZSBpbnRlcm5hbGx5IGxvYWRlZCB2aWEge0BsaW5rIEZpbGVMb2FkZXJ9LlxuICpcbiAqIERlcml2ZWQgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgYHBhcnNlKClgIG1ldGhvZCB3aGljaCBob2xkcyB0aGUgcGFyc2luZ1xuICogZm9yIHRoZSByZXNwZWN0aXZlIGZvcm1hdC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyBMb2FkZXJcbiAqL1xuY2xhc3MgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbXByZXNzZWQgdGV4dHVyZSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3NlcyB0aGUgbG9hZGVkIGNvbXByZXNzZWQgdGV4dHVyZVxuXHQgKiB0byB0aGUgYG9uTG9hZCgpYCBjYWxsYmFjay4gVGhlIG1ldGhvZCBhbHNvIHJldHVybnMgYSBuZXcgdGV4dHVyZSBvYmplY3Qgd2hpY2ggY2FuXG5cdCAqIGRpcmVjdGx5IGJlIHVzZWQgZm9yIG1hdGVyaWFsIGNyZWF0aW9uLiBJZiB5b3UgZG8gaXQgdGhpcyB3YXksIHRoZSB0ZXh0dXJlXG5cdCAqIG1heSBwb3AgdXAgaW4geW91ciBzY2VuZSBvbmNlIHRoZSByZXNwZWN0aXZlIGxvYWRpbmcgcHJvY2VzcyBpcyBmaW5pc2hlZC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBwYXRoL1VSTCBvZiB0aGUgZmlsZSB0byBiZSBsb2FkZWQuIFRoaXMgY2FuIGFsc28gYmUgYSBkYXRhIFVSSS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihDb21wcmVzc2VkVGV4dHVyZSl9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gdGhlIGxvYWRpbmcgcHJvY2VzcyBoYXMgYmVlbiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtvblByb2dyZXNzQ2FsbGJhY2t9IG9uUHJvZ3Jlc3MgLSBFeGVjdXRlZCB3aGlsZSB0aGUgbG9hZGluZyBpcyBpbiBwcm9ncmVzcy5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICogQHJldHVybiB7Q29tcHJlc3NlZFRleHR1cmV9IFRoZSBjb21wcmVzc2VkIHRleHR1cmUuXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGltYWdlcyA9IFtdO1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcblx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG5cdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG5cdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGxvYWRlZCArPSAxO1xuXG5cdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwczogW10gfTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSByZXN1bHQgb2JqZWN0IHR5cGUgb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXJ+VGV4RGF0YVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBiYXNlIG1pcC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgd2lkdGggb2YgdGhlIGJhc2UgbWlwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0N1YmVtYXAgLSBXaGV0aGVyIHRoZSBkYXRhIHJlcHJlc2VudCBhIGN1YmVtYXAgb3Igbm90LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pcG1hcENvdW50IC0gVGhlIG1pcG1hcCBjb3VudC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8e2RhdGE6VHlwZWRBcnJheSx3aWR0aDpudW1iZXIsaGVpZ2h0Om51bWJlcn0+fSBtaXBtYXBzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgbWlwbWFwcy5cbiAqIEVhY2ggZW50cnkgaG9sZHMgdGhlIGRhdGEgYW5kIHRoZSBkaW1lbnNpb25zIGZvciBlYWNoIGxldmVsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZvcm1hdCAtIFRoZSB0ZXh0dXJlIGZvcm1hdC5cbiAqKi9cblxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgfTtcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50TlMgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBsb2FkZXIgZm9yIGxvYWRpbmcgaW1hZ2VzLiBUaGUgY2xhc3MgbG9hZHMgaW1hZ2VzIHdpdGggdGhlIEhUTUwgYEltYWdlYCBBUEkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuICogY29uc3QgaW1hZ2UgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCAnaW1hZ2UucG5nJyApO1xuICogYGBgXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBJbWFnZUxvYWRlcmAgaGFzIGRyb3BwZWQgc3VwcG9ydCBmb3IgcHJvZ3Jlc3NcbiAqIGV2ZW50cyBpbiBgcjg0YC4gRm9yIGFuIGBJbWFnZUxvYWRlcmAgdGhhdCBzdXBwb3J0cyBwcm9ncmVzcyBldmVudHMsIHNlZVxuICogW3RoaXMgdGhyZWFkXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xMDQzOSNpc3N1ZWNvbW1lbnQtMjc1Nzg1NjM5fS5cbiAqXG4gKiBAYXVnbWVudHMgTG9hZGVyXG4gKi9cbmNsYXNzIEltYWdlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbWFnZSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3NlcyB0aGUgbG9hZGVkIGltYWdlXG5cdCAqIHRvIHRoZSBgb25Mb2FkKClgIGNhbGxiYWNrLiBUaGUgbWV0aG9kIGFsc28gcmV0dXJucyBhIG5ldyBgSW1hZ2VgIG9iamVjdCB3aGljaCBjYW5cblx0ICogZGlyZWN0bHkgYmUgdXNlZCBmb3IgdGV4dHVyZSBjcmVhdGlvbi4gSWYgeW91IGRvIGl0IHRoaXMgd2F5LCB0aGUgdGV4dHVyZVxuXHQgKiBtYXkgcG9wIHVwIGluIHlvdXIgc2NlbmUgb25jZSB0aGUgcmVzcGVjdGl2ZSBsb2FkaW5nIHByb2Nlc3MgaXMgZmluaXNoZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGEgZGF0YSBVUkkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oSW1hZ2UpfSBvbkxvYWQgLSBFeGVjdXRlZCB3aGVuIHRoZSBsb2FkaW5nIHByb2Nlc3MgaGFzIGJlZW4gZmluaXNoZWQuXG5cdCAqIEBwYXJhbSB7b25Qcm9ncmVzc0NhbGxiYWNrfSBvblByb2dyZXNzIC0gVW5zdXBwb3J0ZWQgaW4gdGhpcyBsb2FkZXIuXG5cdCAqIEBwYXJhbSB7b25FcnJvckNhbGxiYWNrfSBvbkVycm9yIC0gRXhlY3V0ZWQgd2hlbiBlcnJvcnMgb2NjdXIuXG5cdCAqIEByZXR1cm4ge0ltYWdlfSBUaGUgaW1hZ2UuXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xuXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIDAgKTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGltYWdlID0gY3JlYXRlRWxlbWVudE5TKCAnaW1nJyApO1xuXG5cdFx0ZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG5cblx0XHRcdHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cblx0XHRcdENhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkltYWdlRXJyb3IoIGV2ZW50ICkge1xuXG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG5cblx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgb25JbWFnZUxvYWQsIGZhbHNlICk7XG5cdFx0XHRpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCBvbkltYWdlRXJyb3IsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIG9uSW1hZ2VMb2FkLCBmYWxzZSApO1xuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UgKTtcblxuXHRcdGlmICggdXJsLnNsaWNlKCAwLCA1ICkgIT09ICdkYXRhOicgKSB7XG5cblx0XHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEltYWdlTG9hZGVyIH07XG4iLCJpbXBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJy4vSW1hZ2VMb2FkZXIuanMnO1xuaW1wb3J0IHsgQ3ViZVRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGxvYWRpbmcgY3ViZSB0ZXh0dXJlcy4gSW1hZ2VzIGFyZSBpbnRlcm5hbGx5IGxvYWRlZCB2aWEge0BsaW5rIEltYWdlTG9hZGVyfS5cbiAqXG4gKiBUaGUgbG9hZGVyIHJldHVybnMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEN1YmVUZXh0dXJlfSBhbmQgZXhwZWN0cyB0aGUgY3ViZSBtYXAgdG9cbiAqIGJlIGRlZmluZWQgYXMgc2l4IHNlcGFyYXRlIGltYWdlcyByZXByZXNlbnRpbmcgdGhlIHNpZGVzIG9mIGEgY3ViZS4gT3RoZXIgY3ViZSBtYXAgZGVmaW5pdGlvbnNcbiAqIGxpa2UgdmVydGljYWwgYW5kIGhvcml6b250YWwgY3Jvc3MsIGNvbHVtbiBhbmQgcm93IGxheW91dHMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogTm90ZSB0aGF0LCBieSBjb252ZW50aW9uLCBjdWJlIG1hcHMgYXJlIHNwZWNpZmllZCBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBpbiB3aGljaCBwb3NpdGl2ZS14IGlzIHRvIHRoZSByaWdodCB3aGVuIGxvb2tpbmcgdXAgdGhlIHBvc2l0aXZlLXogYXhpcyAtLVxuICogaW4gb3RoZXIgd29yZHMsIHVzaW5nIGEgbGVmdC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIFNpbmNlIHRocmVlLmpzIHVzZXNcbiAqIGEgcmlnaHQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLCBlbnZpcm9ubWVudCBtYXBzIHVzZWQgaW4gdGhyZWUuanMgd2lsbFxuICogaGF2ZSBwb3MteCBhbmQgbmVnLXggc3dhcHBlZC5cbiAqXG4gKiBUaGUgbG9hZGVkIGN1YmUgdGV4dHVyZSBpcyBpbiBzUkdCIGNvbG9yIHNwYWNlLiBNZWFuaW5nIHtAbGluayBUZXh0dXJlI2NvbG9yU3BhY2V9XG4gKiBpcyBzZXQgdG8gYFNSR0JDb2xvclNwYWNlYCBieSBkZWZhdWx0LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKS5zZXRQYXRoKCAndGV4dHVyZXMvY3ViZU1hcHMvJyApO1xuICogY29uc3QgY3ViZVRleHR1cmUgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCBbXG4gKiBcdCdweC5wbmcnLCAnbngucG5nJywgJ3B5LnBuZycsICdueS5wbmcnLCAncHoucG5nJywgJ256LnBuZydcbiAqIF0gKTtcbiAqIHNjZW5lLmJhY2tncm91bmQgPSBjdWJlVGV4dHVyZTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMb2FkZXJcbiAqL1xuY2xhc3MgQ3ViZVRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGN1YmUgdGV4dHVyZSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3MgdGhlIGZ1bGx5IGxvYWRlZCBjdWJlIHRleHR1cmVcblx0ICogdG8gdGhlIGBvbkxvYWQoKWAgY2FsbGJhY2suIFRoZSBtZXRob2QgYWxzbyByZXR1cm5zIGEgbmV3IGN1YmUgdGV4dHVyZSBvYmplY3Qgd2hpY2ggY2FuXG5cdCAqIGRpcmVjdGx5IGJlIHVzZWQgZm9yIG1hdGVyaWFsIGNyZWF0aW9uLiBJZiB5b3UgZG8gaXQgdGhpcyB3YXksIHRoZSBjdWJlIHRleHR1cmVcblx0ICogbWF5IHBvcCB1cCBpbiB5b3VyIHNjZW5lIG9uY2UgdGhlIHJlc3BlY3RpdmUgbG9hZGluZyBwcm9jZXNzIGlzIGZpbmlzaGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHMgLSBBcnJheSBvZiA2IFVSTHMgdG8gaW1hZ2VzLCBvbmUgZm9yIGVhY2ggc2lkZSBvZiB0aGVcblx0ICogY3ViZSB0ZXh0dXJlLiBUaGUgdXJscyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IHBvcy14LFxuXHQgKiBuZWcteCwgcG9zLXksIG5lZy15LCBwb3MteiwgbmVnLXouIEFuIGFycmF5IG9mIGRhdGEgVVJJcyBhcmUgYWxsb3dlZCBhcyB3ZWxsLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKEN1YmVUZXh0dXJlKX0gb25Mb2FkIC0gRXhlY3V0ZWQgd2hlbiB0aGUgbG9hZGluZyBwcm9jZXNzIGhhcyBiZWVuIGZpbmlzaGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gb25Qcm9ncmVzcyAtIFVuc3VwcG9ydGVkIGluIHRoaXMgbG9hZGVyLlxuXHQgKiBAcGFyYW0ge29uRXJyb3JDYWxsYmFja30gb25FcnJvciAtIEV4ZWN1dGVkIHdoZW4gZXJyb3JzIG9jY3VyLlxuXHQgKiBAcmV0dXJuIHtDdWJlVGV4dHVyZX0gVGhlIGN1YmUgdGV4dHVyZS5cblx0ICovXG5cdGxvYWQoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblx0XHR0ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXG5cdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XG5cblx0XHRcdFx0bG9hZGVkICsrO1xuXG5cdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEN1YmVUZXh0dXJlTG9hZGVyIH07XG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgQ2xhbXBUb0VkZ2VXcmFwcGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAnLi9GaWxlTG9hZGVyLmpzJztcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGxvYWRpbmcgYmluYXJ5IHRleHR1cmUgZm9ybWF0cyBSR0JFLCBFWFIgb3IgVEdBLlxuICogVGV4dHVyZXMgYXJlIGludGVybmFsbHkgbG9hZGVkIHZpYSB7QGxpbmsgRmlsZUxvYWRlcn0uXG4gKlxuICogRGVyaXZlZCBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBgcGFyc2UoKWAgbWV0aG9kIHdoaWNoIGhvbGRzIHRoZSBwYXJzaW5nXG4gKiBmb3IgdGhlIHJlc3BlY3RpdmUgZm9ybWF0LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIExvYWRlclxuICovXG5jbGFzcyBEYXRhVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGF0YSB0ZXh0dXJlIGxvYWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtMb2FkaW5nTWFuYWdlcn0gW21hbmFnZXJdIC0gVGhlIGxvYWRpbmcgbWFuYWdlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBsb2FkaW5nIGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgcGFzc2VzIHRoZSBsb2FkZWQgZGF0YSB0ZXh0dXJlXG5cdCAqIHRvIHRoZSBgb25Mb2FkKClgIGNhbGxiYWNrLiBUaGUgbWV0aG9kIGFsc28gcmV0dXJucyBhIG5ldyB0ZXh0dXJlIG9iamVjdCB3aGljaCBjYW5cblx0ICogZGlyZWN0bHkgYmUgdXNlZCBmb3IgbWF0ZXJpYWwgY3JlYXRpb24uIElmIHlvdSBkbyBpdCB0aGlzIHdheSwgdGhlIHRleHR1cmVcblx0ICogbWF5IHBvcCB1cCBpbiB5b3VyIHNjZW5lIG9uY2UgdGhlIHJlc3BlY3RpdmUgbG9hZGluZyBwcm9jZXNzIGlzIGZpbmlzaGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHBhdGgvVVJMIG9mIHRoZSBmaWxlIHRvIGJlIGxvYWRlZC4gVGhpcyBjYW4gYWxzbyBiZSBhIGRhdGEgVVJJLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFUZXh0dXJlKX0gb25Mb2FkIC0gRXhlY3V0ZWQgd2hlbiB0aGUgbG9hZGluZyBwcm9jZXNzIGhhcyBiZWVuIGZpbmlzaGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gb25Qcm9ncmVzcyAtIEV4ZWN1dGVkIHdoaWxlIHRoZSBsb2FkaW5nIGlzIGluIHByb2dyZXNzLlxuXHQgKiBAcGFyYW0ge29uRXJyb3JDYWxsYmFja30gb25FcnJvciAtIEV4ZWN1dGVkIHdoZW4gZXJyb3JzIG9jY3VyLlxuXHQgKiBAcmV0dXJuIHtEYXRhVGV4dHVyZX0gVGhlIGRhdGEgdGV4dHVyZS5cblx0ICovXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRsZXQgdGV4RGF0YTtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHR0ZXhEYXRhID0gc2NvcGUucGFyc2UoIGJ1ZmZlciApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXhEYXRhLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleERhdGEuZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS53cmFwUyA9IHRleERhdGEud3JhcFMgIT09IHVuZGVmaW5lZCA/IHRleERhdGEud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0dGV4dHVyZS53cmFwVCA9IHRleERhdGEud3JhcFQgIT09IHVuZGVmaW5lZCA/IHRleERhdGEud3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleERhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gdGV4RGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXG5cdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0ZXhEYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XG5cblx0XHRcdGlmICggdGV4RGF0YS5jb2xvclNwYWNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5jb2xvclNwYWNlID0gdGV4RGF0YS5jb2xvclNwYWNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRleHR1cmUuZmxpcFkgPSB0ZXhEYXRhLmZsaXBZO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5mb3JtYXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS50eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5taXBtYXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjsgLy8gcHJlc3VtYWJseS4uLlxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4RGF0YS5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcztcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmVzdWx0IG9iamVjdCB0eXBlIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERhdGFUZXh0dXJlTG9hZGVyflRleERhdGFcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbaW1hZ2VdIC0gQW4gb2JqZWN0IGhvbGRpbmcgd2lkdGgsIGhlaWdodCBhbmQgdGhlIHRleHR1cmUgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIC0gVGhlIHdpZHRoIG9mIHRoZSBiYXNlIG1pcC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0XSAtIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSBtaXAuXG4gKiBAcHJvcGVydHkge1R5cGVkQXJyYXl9IFtkYXRhXSAtIFRoZSB0ZXh0dXJlIGRhdGEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Zvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIC0gVGhlIHRleHR1cmUgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZsaXBZXSAtIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0ZXh0dXJlIGlzIGZsaXBwZWQgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgd2hlbiB1cGxvYWRlZCB0byB0aGUgR1BVLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwUz1DbGFtcFRvRWRnZVdyYXBwaW5nXSAtIFRoZSB3cmFwUyB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFQ9Q2xhbXBUb0VkZ2VXcmFwcGluZ10gLSBUaGUgd3JhcFQgdmFsdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FuaXNvdHJvcHk9MV0gLSBUaGUgYW5pc290cm9weSB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dlbmVyYXRlTWlwbWFwc10gLSBXaGV0aGVyIHRvIGdlbmVyYXRlIG1pcG1hcHMgb3Igbm90LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvclNwYWNlXSAtIFRoZSBjb2xvciBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFnRmlsdGVyXSAtIFRoZSBtYWcgZmlsdGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5GaWx0ZXJdIC0gVGhlIG1pbiBmaWx0ZXIuXG4gKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IFttaXBtYXBzXSAtIFRoZSBtaXBtYXBzLlxuICoqL1xuXG5leHBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciB9O1xuIiwiaW1wb3J0IHsgSW1hZ2VMb2FkZXIgfSBmcm9tICcuL0ltYWdlTG9hZGVyLmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9UZXh0dXJlLmpzJztcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgbG9hZGluZyB0ZXh0dXJlcy4gSW1hZ2VzIGFyZSBpbnRlcm5hbGx5XG4gKiBsb2FkZWQgdmlhIHtAbGluayBJbWFnZUxvYWRlcn0uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG4gKiBjb25zdCB0ZXh0dXJlID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyggJ3RleHR1cmVzL2xhbmRfb2NlYW5faWNlX2Nsb3VkXzIwNDguanBnJyApO1xuICpcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IG1hcDp0ZXh0dXJlIH0gKTtcbiAqIGBgYFxuICogUGxlYXNlIG5vdGUgdGhhdCBgVGV4dHVyZUxvYWRlcmAgaGFzIGRyb3BwZWQgc3VwcG9ydCBmb3IgcHJvZ3Jlc3NcbiAqIGV2ZW50cyBpbiBgcjg0YC4gRm9yIGEgYFRleHR1cmVMb2FkZXJgIHRoYXQgc3VwcG9ydHMgcHJvZ3Jlc3MgZXZlbnRzLCBzZWVcbiAqIFt0aGlzIHRocmVhZF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTA0MzkjaXNzdWVjb21tZW50LTI5MzI2MDE0NX0uXG4gKlxuICogQGF1Z21lbnRzIExvYWRlclxuICovXG5jbGFzcyBUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyB0ZXh0dXJlIGxvYWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtMb2FkaW5nTWFuYWdlcn0gW21hbmFnZXJdIC0gVGhlIGxvYWRpbmcgbWFuYWdlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBsb2FkaW5nIGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgcGFzcyB0aGUgZnVsbHkgbG9hZGVkIHRleHR1cmVcblx0ICogdG8gdGhlIGBvbkxvYWQoKWAgY2FsbGJhY2suIFRoZSBtZXRob2QgYWxzbyByZXR1cm5zIGEgbmV3IHRleHR1cmUgb2JqZWN0IHdoaWNoIGNhblxuXHQgKiBkaXJlY3RseSBiZSB1c2VkIGZvciBtYXRlcmlhbCBjcmVhdGlvbi4gSWYgeW91IGRvIGl0IHRoaXMgd2F5LCB0aGUgdGV4dHVyZVxuXHQgKiBtYXkgcG9wIHVwIGluIHlvdXIgc2NlbmUgb25jZSB0aGUgcmVzcGVjdGl2ZSBsb2FkaW5nIHByb2Nlc3MgaXMgZmluaXNoZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGEgZGF0YSBVUkkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oVGV4dHVyZSl9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gdGhlIGxvYWRpbmcgcHJvY2VzcyBoYXMgYmVlbiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtvblByb2dyZXNzQ2FsbGJhY2t9IG9uUHJvZ3Jlc3MgLSBVbnN1cHBvcnRlZCBpbiB0aGlzIGxvYWRlci5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgVGV4dHVyZUxvYWRlciB9O1xuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgbGlnaHRzIC0gYWxsIG90aGVyIGxpZ2h0IHR5cGVzIGluaGVyaXQgdGhlXG4gKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGRlc2NyaWJlZCBoZXJlLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIExpZ2h0IGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpZ2h0LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8Q29sb3J8c3RyaW5nKX0gW2NvbG9yPTB4ZmZmZmZmXSAtIFRoZSBsaWdodCdzIGNvbG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2ludGVuc2l0eT0xXSAtIFRoZSBsaWdodCdzIHN0cmVuZ3RoL2ludGVuc2l0eS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5ID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpZ2h0JztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaWdodCdzIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlnaHQncyBpbnRlbnNpdHkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZyZWVzIHRoZSBHUFUtcmVsYXRlZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpc1xuXHQgKiBtZXRob2Qgd2hlbmV2ZXIgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgdXNlZCBpbiB5b3VyIGFwcC5cblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHQvLyBFbXB0eSBoZXJlIGluIGJhc2UgY2xhc3M7IHNvbWUgc3ViY2xhc3NlcyBvdmVycmlkZS5cblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cblx0XHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblx0XHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0XHRpZiAoIHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYTtcblxuXHRcdGlmICggdGhpcy5zaGFkb3cgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnNoYWRvdyA9IHRoaXMuc2hhZG93LnRvSlNPTigpO1xuXHRcdGlmICggdGhpcy50YXJnZXQgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnRhcmdldCA9IHRoaXMudGFyZ2V0LnV1aWQ7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTGlnaHQgfTtcbiIsImltcG9ydCB7IExpZ2h0IH0gZnJvbSAnLi9MaWdodC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcblxuLyoqXG4gKiBBIGxpZ2h0IHNvdXJjZSBwb3NpdGlvbmVkIGRpcmVjdGx5IGFib3ZlIHRoZSBzY2VuZSwgd2l0aCBjb2xvciBmYWRpbmcgZnJvbVxuICogdGhlIHNreSBjb2xvciB0byB0aGUgZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFRoaXMgbGlnaHQgY2Fubm90IGJlIHVzZWQgdG8gY2FzdCBzaGFkb3dzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIDB4ZmZmZmJiLCAweDA4MDgyMCwgMSApO1xuICogc2NlbmUuYWRkKCBsaWdodCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIEhlbWlzcGhlcmVMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBoZW1pc3BoZXJlIGxpZ2h0LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8Q29sb3J8c3RyaW5nKX0gW3NreUNvbG9yPTB4ZmZmZmZmXSAtIFRoZSBsaWdodCdzIHNreSBjb2xvci5cblx0ICogQHBhcmFtIHsobnVtYmVyfENvbG9yfHN0cmluZyl9IFtncm91bmRDb2xvcj0weGZmZmZmZl0gLSBUaGUgbGlnaHQncyBncm91bmQgY29sb3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZW5zaXR5PTFdIC0gVGhlIGxpZ2h0J3Mgc3RyZW5ndGgvaW50ZW5zaXR5LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0c3VwZXIoIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNIZW1pc3BoZXJlTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRFRkFVTFRfVVAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpZ2h0J3MgZ3JvdW5kIGNvbG9yLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqL1xuXHRcdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoIGdyb3VuZENvbG9yICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH07XG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vbWF0aC9WZWN0b3I0LmpzJztcbmltcG9ydCB7IEZydXN0dW0gfSBmcm9tICcuLi9tYXRoL0ZydXN0dW0uanMnO1xuaW1wb3J0IHsgVW5zaWduZWRCeXRlVHlwZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9sb29rVGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGxpZ2h0IHNoYWRvdyBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzXG4gKiByZXByZXNlbnQgdGhlIHNoYWRvdyBjb25maWd1cmF0aW9uIGZvciBkaWZmZXJlbnQgbGlnaHQgdHlwZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIExpZ2h0U2hhZG93IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaWdodCBzaGFkb3cuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbGlnaHQncyB2aWV3IG9mIHRoZSB3b3JsZC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBjYW1lcmEgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlnaHQncyB2aWV3IG9mIHRoZSB3b3JsZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDYW1lcmF9XG5cdFx0ICovXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW50ZW5zaXR5IG9mIHRoZSBzaGFkb3cuIFRoZSBkZWZhdWx0IGlzIGAxYC5cblx0XHQgKiBWYWxpZCB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBgWzAsIDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuaW50ZW5zaXR5ID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFNoYWRvdyBtYXAgYmlhcywgaG93IG11Y2ggdG8gYWRkIG9yIHN1YnRyYWN0IGZyb20gdGhlIG5vcm1hbGl6ZWQgZGVwdGhcblx0XHQgKiB3aGVuIGRlY2lkaW5nIHdoZXRoZXIgYSBzdXJmYWNlIGlzIGluIHNoYWRvdy5cblx0XHQgKlxuXHRcdCAqIFRoZSBkZWZhdWx0IGlzIGAwYC4gVmVyeSB0aW55IGFkanVzdG1lbnRzIGhlcmUgKGluIHRoZSBvcmRlciBvZiBgMC4wMDAxYClcblx0XHQgKiBtYXkgaGVscCByZWR1Y2UgYXJ0aWZhY3RzIGluIHNoYWRvd3MuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmJpYXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBob3cgbXVjaCB0aGUgcG9zaXRpb24gdXNlZCB0byBxdWVyeSB0aGUgc2hhZG93IG1hcCBpcyBvZmZzZXQgYWxvbmdcblx0XHQgKiB0aGUgb2JqZWN0IG5vcm1hbC4gVGhlIGRlZmF1bHQgaXMgYDBgLiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIGJlIHVzZWQgdG9cblx0XHQgKiByZWR1Y2Ugc2hhZG93IGFjbmUgZXNwZWNpYWxseSBpbiBsYXJnZSBzY2VuZXMgd2hlcmUgbGlnaHQgc2hpbmVzIG9udG9cblx0XHQgKiBnZW9tZXRyeSBhdCBhIHNoYWxsb3cgYW5nbGUuIFRoZSBjb3N0IGlzIHRoYXQgc2hhZG93cyBtYXkgYXBwZWFyIGRpc3RvcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMubm9ybWFsQmlhcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBTZXR0aW5nIHRoaXMgdG8gdmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgYmx1ciB0aGUgZWRnZXMgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBIaWdoIHZhbHVlcyB3aWxsIGNhdXNlIHVud2FudGVkIGJhbmRpbmcgZWZmZWN0cyBpbiB0aGUgc2hhZG93cyAtIGEgZ3JlYXRlclxuXHRcdCAqIG1hcCBzaXplIHdpbGwgYWxsb3cgZm9yIGEgaGlnaGVyIHZhbHVlIHRvIGJlIHVzZWQgaGVyZSBiZWZvcmUgdGhlc2UgZWZmZWN0c1xuXHRcdCAqIGJlY29tZSB2aXNpYmxlLlxuXHRcdCAqXG5cdFx0ICogVGhlIHByb3BlcnR5IGhhcyBubyBlZmZlY3Qgd2hlbiB0aGUgc2hhZG93IG1hcCB0eXBlIGlzIGBQQ0ZTb2Z0U2hhZG93TWFwYCBhbmRcblx0XHQgKiBhbmQgaXQgaXMgcmVjb21tZW5kZWQgdG8gaW5jcmVhc2Ugc29mdG5lc3MgYnkgZGVjcmVhc2luZyB0aGUgc2hhZG93IG1hcCBzaXplIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgcHJvcGVydHkgaGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBzaGFkb3cgbWFwIHR5cGUgaXMgYEJhc2ljU2hhZG93TWFwYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMucmFkaXVzID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyB0byB1c2Ugd2hlbiBibHVycmluZyBhIFZTTSBzaGFkb3cgbWFwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCA4XG5cdFx0ICovXG5cdFx0dGhpcy5ibHVyU2FtcGxlcyA9IDg7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzaGFkb3cgbWFwLiBIaWdoZXIgdmFsdWVzIGdpdmUgYmV0dGVyIHF1YWxpdHlcblx0XHQgKiBzaGFkb3dzIGF0IHRoZSBjb3N0IG9mIGNvbXB1dGF0aW9uIHRpbWUuIFZhbHVlcyBtdXN0IGJlIHBvd2VycyBvZiB0d28uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yMn1cblx0XHQgKiBAZGVmYXVsdCAoNTEyLDUxMilcblx0XHQgKi9cblx0XHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMiggNTEyLCA1MTIgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHNoYWRvdyB0ZXh0dXJlLiBUaGUgZGVmYXVsdCBpcyBgVW5zaWduZWRCeXRlVHlwZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IFVuc2lnbmVkQnl0ZVR5cGVcblx0XHQgKi9cblx0XHR0aGlzLm1hcFR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlcHRoIG1hcCBnZW5lcmF0ZWQgdXNpbmcgdGhlIGludGVybmFsIGNhbWVyYTsgYSBsb2NhdGlvbiBiZXlvbmQgYVxuXHRcdCAqIHBpeGVsJ3MgZGVwdGggaXMgaW4gc2hhZG93LiBDb21wdXRlZCBpbnRlcm5hbGx5IGR1cmluZyByZW5kZXJpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1JlbmRlclRhcmdldH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRpc3RyaWJ1dGlvbiBtYXAgZ2VuZXJhdGVkIHVzaW5nIHRoZSBpbnRlcm5hbCBjYW1lcmE7IGFuIG9jY2x1c2lvbiBpc1xuXHRcdCAqIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpc3RyaWJ1dGlvbiBvZiBkZXB0aHMuIENvbXB1dGVkIGludGVybmFsbHkgZHVyaW5nXG5cdFx0ICogcmVuZGVyaW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgez9SZW5kZXJUYXJnZXR9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWFwUGFzcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBNb2RlbCB0byBzaGFkb3cgY2FtZXJhIHNwYWNlLCB0byBjb21wdXRlIGxvY2F0aW9uIGFuZCBkZXB0aCBpbiBzaGFkb3cgbWFwLlxuXHRcdCAqIFRoaXMgaXMgY29tcHV0ZWQgaW50ZXJuYWxseSBkdXJpbmcgcmVuZGVyaW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge01hdHJpeDR9XG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlcyBhdXRvbWF0aWMgdXBkYXRlcyBvZiB0aGUgbGlnaHQncyBzaGFkb3cuIElmIHlvdSBkbyBub3QgcmVxdWlyZSBkeW5hbWljXG5cdFx0ICogbGlnaHRpbmcgLyBzaGFkb3dzLCB5b3UgbWF5IHNldCB0aGlzIHRvIGBmYWxzZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgc2hhZG93IG1hcHMgd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IGByZW5kZXJgIGNhbGwuXG5cdFx0ICogSWYgeW91IGhhdmUgc2V0IHtAbGluayBMaWdodFNoYWRvdyNhdXRvVXBkYXRlfSB0byBgZmFsc2VgLCB5b3Ugd2lsbCBuZWVkIHRvXG5cdFx0ICogc2V0IHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIGFuZCB0aGVuIG1ha2UgYSByZW5kZXIgY2FsbCB0byB1cGRhdGUgdGhlIGxpZ2h0J3Mgc2hhZG93LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLl9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDE7XG5cblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbXG5cblx0XHRcdG5ldyBWZWN0b3I0KCAwLCAwLCAxLCAxIClcblxuXHRcdF07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGdldCB0aGUgbnVtYmVyIG9mIHZpZXdwb3J0cyB0aGF0IG5lZWRcblx0ICogdG8gYmUgcmVuZGVyZWQgZm9yIHRoaXMgc2hhZG93LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2aWV3cG9ydCBjb3VudC5cblx0ICovXG5cdGdldFZpZXdwb3J0Q291bnQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRDb3VudDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHNoYWRvdyBjYW1lcmFzIGZydXN0dW0uIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgcmVuZGVyZXIgdG8gY3VsbCBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtGcnVzdHVtfSBUaGUgc2hhZG93IGNhbWVyYSBmcnVzdHVtLlxuXHQgKi9cblx0Z2V0RnJ1c3R1bSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9mcnVzdHVtO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBtYXRyaWNlcyBmb3IgdGhlIGNhbWVyYSBhbmQgc2hhZG93LCB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpZ2h0fSBsaWdodCAtIFRoZSBsaWdodCBmb3Igd2hpY2ggdGhlIHNoYWRvdyBpcyBiZWluZyByZW5kZXJlZC5cblx0ICovXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcblxuXHRcdGNvbnN0IHNoYWRvd0NhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXG5cdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcblxuXHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcblx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0dGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdHNoYWRvd01hdHJpeC5zZXQoXG5cdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXG5cdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXG5cdFx0XHQwLjAsIDAuMCwgMC41LCAwLjUsXG5cdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcblx0XHQpO1xuXG5cdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZpZXdwb3J0IGRlZmluaXRpb24gZm9yIHRoZSBnaXZlbiB2aWV3cG9ydCBpbmRleC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0SW5kZXggLSBUaGUgdmlld3BvcnQgaW5kZXguXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjR9IFRoZSB2aWV3cG9ydC5cblx0ICovXG5cdGdldFZpZXdwb3J0KCB2aWV3cG9ydEluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXdwb3J0c1sgdmlld3BvcnRJbmRleCBdO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZnJhbWUgZXh0ZW5kcy5cblx0ICpcblx0ICogQHJldHVybiB7VmVjdG9yMn0gVGhlIGZyYW1lIGV4dGVuZHMuXG5cdCAqL1xuXHRnZXRGcmFtZUV4dGVudHMoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVFeHRlbnRzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdGlmICggdGhpcy5tYXAgKSB7XG5cblx0XHRcdHRoaXMubWFwLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXBQYXNzICkge1xuXG5cdFx0XHR0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGxpZ2h0IHNoYWRvdyBpbnN0YW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpZ2h0U2hhZG93fSBzb3VyY2UgLSBUaGUgbGlnaHQgc2hhZG93IHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge0xpZ2h0U2hhZG93fSBBIHJlZmVyZW5jZSB0byB0aGlzIGxpZ2h0IHNoYWRvdyBpbnN0YW5jZS5cblx0ICovXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XG5cdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHNvdXJjZS5uZWVkc1VwZGF0ZTtcblx0XHR0aGlzLm5vcm1hbEJpYXMgPSBzb3VyY2Uubm9ybWFsQmlhcztcblx0XHR0aGlzLmJsdXJTYW1wbGVzID0gc291cmNlLmJsdXJTYW1wbGVzO1xuXG5cdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgbGlnaHQgc2hhZG93IGluc3RhbmNlIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0xpZ2h0U2hhZG93fSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIGxpZ2h0IHNoYWRvdyBpbnRvIEpTT04uXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6ZWQgbGlnaHQgc2hhZG93LlxuXHQgKiBAc2VlIHtAbGluayBPYmplY3RMb2FkZXIjcGFyc2V9XG5cdCAqL1xuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBvYmplY3QgPSB7fTtcblxuXHRcdGlmICggdGhpcy5pbnRlbnNpdHkgIT09IDEgKSBvYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cdFx0aWYgKCB0aGlzLmJpYXMgIT09IDAgKSBvYmplY3QuYmlhcyA9IHRoaXMuYmlhcztcblx0XHRpZiAoIHRoaXMubm9ybWFsQmlhcyAhPT0gMCApIG9iamVjdC5ub3JtYWxCaWFzID0gdGhpcy5ub3JtYWxCaWFzO1xuXHRcdGlmICggdGhpcy5yYWRpdXMgIT09IDEgKSBvYmplY3QucmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cdFx0aWYgKCB0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIgKSBvYmplY3QubWFwU2l6ZSA9IHRoaXMubWFwU2l6ZS50b0FycmF5KCk7XG5cblx0XHRvYmplY3QuY2FtZXJhID0gdGhpcy5jYW1lcmEudG9KU09OKCBmYWxzZSApLm9iamVjdDtcblx0XHRkZWxldGUgb2JqZWN0LmNhbWVyYS5tYXRyaXg7XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaWdodFNoYWRvdyB9O1xuIiwiaW1wb3J0IHsgTGlnaHRTaGFkb3cgfSBmcm9tICcuL0xpZ2h0U2hhZG93LmpzJztcbmltcG9ydCB7IFJBRDJERUcgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHNoYWRvdyBjb25maWd1cmF0aW9uIG9mIGRpcmVjdGlvbmFsIGxpZ2h0cy5cbiAqXG4gKiBAYXVnbWVudHMgTGlnaHRTaGFkb3dcbiAqL1xuY2xhc3MgU3BvdExpZ2h0U2hhZG93IGV4dGVuZHMgTGlnaHRTaGFkb3cge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNwb3QgbGlnaHQgc2hhZG93LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1Nwb3RMaWdodFNoYWRvdyA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGZvY3VzIHRoZSBzaGFkb3cgY2FtZXJhLiBUaGUgY2FtZXJhJ3MgZmllbGQgb2YgdmlldyBpcyBzZXQgYXMgYVxuXHRcdCAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHNwb3RsaWdodCdzIGZpZWxkLW9mLXZpZXcuIFJhbmdlIGlzIGBbMCwgMV1gLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5mb2N1cyA9IDE7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcblxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXG5cdFx0Y29uc3QgZm92ID0gUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZSAqIHRoaXMuZm9jdXM7XG5cdFx0Y29uc3QgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG5cdFx0aWYgKCBmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhciApIHtcblxuXHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdH1cblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpY2VzKCBsaWdodCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BvdExpZ2h0U2hhZG93IH07XG4iLCJpbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xuaW1wb3J0IHsgU3BvdExpZ2h0U2hhZG93IH0gZnJvbSAnLi9TcG90TGlnaHRTaGFkb3cuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcblxuLyoqXG4gKiBUaGlzIGxpZ2h0IGdldHMgZW1pdHRlZCBmcm9tIGEgc2luZ2xlIHBvaW50IGluIG9uZSBkaXJlY3Rpb24sIGFsb25nIGEgY29uZVxuICogdGhhdCBpbmNyZWFzZXMgaW4gc2l6ZSB0aGUgZnVydGhlciBmcm9tIHRoZSBsaWdodCBpdCBnZXRzLlxuICpcbiAqIFRoaXMgbGlnaHQgY2FuIGNhc3Qgc2hhZG93cyAtIHNlZSB0aGUge0BsaW5rIFNwb3RMaWdodFNoYWRvd30gZm9yIGRldGFpbHMuXG4gKlxuICogYGBganNcbiAqIC8vIHdoaXRlIHNwb3RsaWdodCBzaGluaW5nIGZyb20gdGhlIHNpZGUsIG1vZHVsYXRlZCBieSBhIHRleHR1cmVcbiAqIGNvbnN0IHNwb3RMaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIDB4ZmZmZmZmICk7XG4gKiBzcG90TGlnaHQucG9zaXRpb24uc2V0KCAxMDAsIDEwMDAsIDEwMCApO1xuICogc3BvdExpZ2h0Lm1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCggdXJsICk7XG4gKlxuICogc3BvdExpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlO1xuICogc3BvdExpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAqIHNwb3RMaWdodC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSAxMDI0O1xuICogc3BvdExpZ2h0LnNoYWRvdy5jYW1lcmEubmVhciA9IDUwMDtcbiAqIHNwb3RMaWdodC5zaGFkb3cuY2FtZXJhLmZhciA9IDQwMDA7XG4gKiBzcG90TGlnaHQuc2hhZG93LmNhbWVyYS5mb3YgPSAzMDtzXG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTGlnaHRcbiAqL1xuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNwb3QgbGlnaHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KG51bWJlcnxDb2xvcnxzdHJpbmcpfSBbY29sb3I9MHhmZmZmZmZdIC0gVGhlIGxpZ2h0J3MgY29sb3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZW5zaXR5PTFdIC0gVGhlIGxpZ2h0J3Mgc3RyZW5ndGgvaW50ZW5zaXR5IG1lYXN1cmVkIGluIGNhbmRlbGEgKGNkKS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaXN0YW5jZT0wXSAtIE1heGltdW0gcmFuZ2Ugb2YgdGhlIGxpZ2h0LiBgMGAgbWVhbnMgbm8gbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGU9TWF0aC5QSS8zXSAtIE1heGltdW0gYW5nbGUgb2YgbGlnaHQgZGlzcGVyc2lvbiBmcm9tIGl0cyBkaXJlY3Rpb24gd2hvc2UgdXBwZXIgYm91bmQgaXMgYE1hdGguUEkvMmAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcGVudW1icmE9MF0gLSBQZXJjZW50IG9mIHRoZSBzcG90bGlnaHQgY29uZSB0aGF0IGlzIGF0dGVudWF0ZWQgZHVlIHRvIHBlbnVtYnJhLiBWYWx1ZSByYW5nZSBpcyBgWzAsMV1gLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RlY2F5PTJdIC0gVGhlIGFtb3VudCB0aGUgbGlnaHQgZGltcyBhbG9uZyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGxpZ2h0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlID0gMCwgYW5nbGUgPSBNYXRoLlBJIC8gMywgcGVudW1icmEgPSAwLCBkZWNheSA9IDIgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1Nwb3RMaWdodCA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuREVGQVVMVF9VUCApO1xuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc3BvdCBsaWdodCBwb2ludHMgZnJvbSBpdHMgcG9zaXRpb24gdG8gdGhlXG5cdFx0ICogdGFyZ2V0J3MgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBGb3IgdGhlIHRhcmdldCdzIHBvc2l0aW9uIHRvIGJlIGNoYW5nZWQgdG8gYW55dGhpbmcgb3RoZXJcblx0XHQgKiB0aGFuIHRoZSBkZWZhdWx0LCBpdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBzY2VuZS5cblx0XHQgKlxuXHRcdCAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gc2V0IHRoZSB0YXJnZXQgdG8gYmUgYW5vdGhlciAzRCBvYmplY3Rcblx0XHQgKiBpbiB0aGUgc2NlbmUuIFRoZSBsaWdodCB3aWxsIG5vdyB0cmFjayB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3QzRH1cblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogTWF4aW11bSByYW5nZSBvZiB0aGUgbGlnaHQuIGAwYCBtZWFucyBubyBsaW1pdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuXHRcdC8qKlxuXHRcdCAqIE1heGltdW0gYW5nbGUgb2YgbGlnaHQgZGlzcGVyc2lvbiBmcm9tIGl0cyBkaXJlY3Rpb24gd2hvc2UgdXBwZXIgYm91bmQgaXMgYE1hdGguUEkvMmAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IE1hdGguUEkvM1xuXHRcdCAqL1xuXHRcdHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFBlcmNlbnQgb2YgdGhlIHNwb3RsaWdodCBjb25lIHRoYXQgaXMgYXR0ZW51YXRlZCBkdWUgdG8gcGVudW1icmEuXG5cdFx0ICogVmFsdWUgcmFuZ2UgaXMgYFswLDFdYC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucGVudW1icmEgPSBwZW51bWJyYTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgdGhlIGxpZ2h0IGRpbXMgYWxvbmcgdGhlIGRpc3RhbmNlIG9mIHRoZSBsaWdodC4gSW4gY29udGV4dCBvZlxuXHRcdCAqIHBoeXNpY2FsbHktY29ycmVjdCByZW5kZXJpbmcgdGhlIGRlZmF1bHQgdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAyXG5cdFx0ICovXG5cdFx0dGhpcy5kZWNheSA9IGRlY2F5O1xuXG5cdFx0LyoqXG5cdFx0ICogQSB0ZXh0dXJlIHVzZWQgdG8gbW9kdWxhdGUgdGhlIGNvbG9yIG9mIHRoZSBsaWdodC4gVGhlIHNwb3QgbGlnaHRcblx0XHQgKiBjb2xvciBpcyBtaXhlZCB3aXRoIHRoZSBSR0IgdmFsdWUgb2YgdGhpcyB0ZXh0dXJlLCB3aXRoIGEgcmF0aW9cblx0XHQgKiBjb3JyZXNwb25kaW5nIHRvIGl0cyBhbHBoYSB2YWx1ZS4gVGhlIGNvb2tpZS1saWtlIG1hc2tpbmcgZWZmZWN0IGlzXG5cdFx0ICogcmVwcm9kdWNlZCB1c2luZyBwaXhlbCB2YWx1ZXMgKDAsIDAsIDAsIDEtY29va2llX3ZhbHVlKS5cblx0XHQgKlxuXHRcdCAqICpXYXJuaW5nKjogVGhpcyBwcm9wZXJ0eSBpcyBkaXNhYmxlZCBpZiB7QGxpbmsgT2JqZWN0M0QjY2FzdFNoYWRvd30gaXMgc2V0IHRvIGBmYWxzZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1RleHR1cmV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgdGhlIGxpZ2h0J3Mgc2hhZG93IGNvbmZpZ3VyYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7U3BvdExpZ2h0U2hhZG93fVxuXHRcdCAqL1xuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpZ2h0J3MgcG93ZXIuIFBvd2VyIGlzIHRoZSBsdW1pbm91cyBwb3dlciBvZiB0aGUgbGlnaHQgbWVhc3VyZWQgaW4gbHVtZW5zIChsbSkuXG5cdCAqICBDaGFuZ2luZyB0aGUgcG93ZXIgd2lsbCBhbHNvIGNoYW5nZSB0aGUgbGlnaHQncyBpbnRlbnNpdHkuXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gY2FuZGVsYSlcblx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XG5cblx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuXHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdFx0dGhpcy5wZW51bWJyYSA9IHNvdXJjZS5wZW51bWJyYTtcblx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTcG90TGlnaHQgfTtcbiIsImltcG9ydCB7IExpZ2h0U2hhZG93IH0gZnJvbSAnLi9MaWdodFNoYWRvdy5qcyc7XG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uL21hdGgvVmVjdG9yNC5qcyc7XG5cbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9sb29rVGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHNoYWRvdyBjb25maWd1cmF0aW9uIG9mIHBvaW50IGxpZ2h0cy5cbiAqXG4gKiBAYXVnbWVudHMgTGlnaHRTaGFkb3dcbiAqL1xuY2xhc3MgUG9pbnRMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwb2ludCBsaWdodCBzaGFkb3cuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG5cblx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMiggNCwgMiApO1xuXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XG5cblx0XHR0aGlzLl92aWV3cG9ydHMgPSBbXG5cdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcblx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgeHpYWlxuXHRcdFx0Ly8gICB5IFlcblx0XHRcdC8vXG5cdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG5cblx0XHRcdC8vIHBvc2l0aXZlIFhcblx0XHRcdG5ldyBWZWN0b3I0KCAyLCAxLCAxLCAxICksXG5cdFx0XHQvLyBuZWdhdGl2ZSBYXG5cdFx0XHRuZXcgVmVjdG9yNCggMCwgMSwgMSwgMSApLFxuXHRcdFx0Ly8gcG9zaXRpdmUgWlxuXHRcdFx0bmV3IFZlY3RvcjQoIDMsIDEsIDEsIDEgKSxcblx0XHRcdC8vIG5lZ2F0aXZlIFpcblx0XHRcdG5ldyBWZWN0b3I0KCAxLCAxLCAxLCAxICksXG5cdFx0XHQvLyBwb3NpdGl2ZSBZXG5cdFx0XHRuZXcgVmVjdG9yNCggMywgMCwgMSwgMSApLFxuXHRcdFx0Ly8gbmVnYXRpdmUgWVxuXHRcdFx0bmV3IFZlY3RvcjQoIDEsIDAsIDEsIDEgKVxuXHRcdF07XG5cblx0XHR0aGlzLl9jdWJlRGlyZWN0aW9ucyA9IFtcblx0XHRcdG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcblx0XHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXG5cdFx0XTtcblxuXHRcdHRoaXMuX2N1YmVVcHMgPSBbXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuXHRcdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKVxuXHRcdF07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIG1hdHJpY2VzIGZvciB0aGUgY2FtZXJhIGFuZCBzaGFkb3csIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcmVuZGVyZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlnaHR9IGxpZ2h0IC0gVGhlIGxpZ2h0IGZvciB3aGljaCB0aGUgc2hhZG93IGlzIGJlaW5nIHJlbmRlcmVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdwb3J0SW5kZXg9MF0gLSBUaGUgdmlld3BvcnQgaW5kZXguXG5cdCAqL1xuXHR1cGRhdGVNYXRyaWNlcyggbGlnaHQsIHZpZXdwb3J0SW5kZXggPSAwICkge1xuXG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0Y29uc3Qgc2hhZG93TWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG5cdFx0aWYgKCBmYXIgIT09IGNhbWVyYS5mYXIgKSB7XG5cblx0XHRcdGNhbWVyYS5mYXIgPSBmYXI7XG5cdFx0XHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0fVxuXG5cdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0Y2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcblxuXHRcdF9sb29rVGFyZ2V0LmNvcHkoIGNhbWVyYS5wb3NpdGlvbiApO1xuXHRcdF9sb29rVGFyZ2V0LmFkZCggdGhpcy5fY3ViZURpcmVjdGlvbnNbIHZpZXdwb3J0SW5kZXggXSApO1xuXHRcdGNhbWVyYS51cC5jb3B5KCB0aGlzLl9jdWJlVXBzWyB2aWV3cG9ydEluZGV4IF0gKTtcblx0XHRjYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXHRcdGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0c2hhZG93TWF0cml4Lm1ha2VUcmFuc2xhdGlvbiggLSBfbGlnaHRQb3NpdGlvbldvcmxkLngsIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC55LCAtIF9saWdodFBvc2l0aW9uV29ybGQueiApO1xuXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBQb2ludExpZ2h0U2hhZG93IH07XG4iLCJpbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xuaW1wb3J0IHsgUG9pbnRMaWdodFNoYWRvdyB9IGZyb20gJy4vUG9pbnRMaWdodFNoYWRvdy5qcyc7XG5cbi8qKlxuICogQSBsaWdodCB0aGF0IGdldHMgZW1pdHRlZCBmcm9tIGEgc2luZ2xlIHBvaW50IGluIGFsbCBkaXJlY3Rpb25zLiBBIGNvbW1vblxuICogdXNlIGNhc2UgZm9yIHRoaXMgaXMgdG8gcmVwbGljYXRlIHRoZSBsaWdodCBlbWl0dGVkIGZyb20gYSBiYXJlXG4gKiBsaWdodGJ1bGIuXG4gKlxuICogVGhpcyBsaWdodCBjYW4gY2FzdCBzaGFkb3dzIC0gc2VlIHRoZSB7QGxpbmsgUG9pbnRMaWdodFNoYWRvd30gZm9yIGRldGFpbHMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIDB4ZmYwMDAwLCAxLCAxMDAgKTtcbiAqIGxpZ2h0LnBvc2l0aW9uLnNldCggNTAsIDUwLCA1MCApO1xuICogc2NlbmUuYWRkKCBsaWdodCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcG9pbnQgbGlnaHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KG51bWJlcnxDb2xvcnxzdHJpbmcpfSBbY29sb3I9MHhmZmZmZmZdIC0gVGhlIGxpZ2h0J3MgY29sb3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZW5zaXR5PTFdIC0gVGhlIGxpZ2h0J3Mgc3RyZW5ndGgvaW50ZW5zaXR5IG1lYXN1cmVkIGluIGNhbmRlbGEgKGNkKS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaXN0YW5jZT0wXSAtIE1heGltdW0gcmFuZ2Ugb2YgdGhlIGxpZ2h0LiBgMGAgbWVhbnMgbm8gbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGVjYXk9Ml0gLSBUaGUgYW1vdW50IHRoZSBsaWdodCBkaW1zIGFsb25nIHRoZSBkaXN0YW5jZSBvZiB0aGUgbGlnaHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgPSAwLCBkZWNheSA9IDIgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1BvaW50TGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBkaXN0YW5jZSBpcyB6ZXJvLCBsaWdodCB3aWxsIGF0dGVudWF0ZSBhY2NvcmRpbmcgdG8gaW52ZXJzZS1zcXVhcmVcblx0XHQgKiBsYXcgdG8gaW5maW5pdGUgZGlzdGFuY2UuIFdoZW4gZGlzdGFuY2UgaXMgbm9uLXplcm8sIGxpZ2h0IHdpbGwgYXR0ZW51YXRlXG5cdFx0ICogYWNjb3JkaW5nIHRvIGludmVyc2Utc3F1YXJlIGxhdyB1bnRpbCBuZWFyIHRoZSBkaXN0YW5jZSBjdXRvZmYsIHdoZXJlIGl0XG5cdFx0ICogd2lsbCB0aGVuIGF0dGVudWF0ZSBxdWlja2x5IGFuZCBzbW9vdGhseSB0byAwLiBJbmhlcmVudGx5LCBjdXRvZmZzIGFyZSBub3Rcblx0XHQgKiBwaHlzaWNhbGx5IGNvcnJlY3QuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYW1vdW50IHRoZSBsaWdodCBkaW1zIGFsb25nIHRoZSBkaXN0YW5jZSBvZiB0aGUgbGlnaHQuIEluIGNvbnRleHQgb2Zcblx0XHQgKiBwaHlzaWNhbGx5LWNvcnJlY3QgcmVuZGVyaW5nIHRoZSBkZWZhdWx0IHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMlxuXHRcdCAqL1xuXHRcdHRoaXMuZGVjYXkgPSBkZWNheTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgdGhlIGxpZ2h0J3Mgc2hhZG93IGNvbmZpZ3VyYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7UG9pbnRMaWdodFNoYWRvd31cblx0XHQgKi9cblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBQb2ludExpZ2h0U2hhZG93KCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbGlnaHQncyBwb3dlci4gUG93ZXIgaXMgdGhlIGx1bWlub3VzIHBvd2VyIG9mIHRoZSBsaWdodCBtZWFzdXJlZCBpbiBsdW1lbnMgKGxtKS5cblx0ICogQ2hhbmdpbmcgdGhlIHBvd2VyIHdpbGwgYWxzbyBjaGFuZ2UgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5LlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IHBvd2VyKCkge1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpXG5cdFx0Ly8gZm9yIGFuIGlzb3Ryb3BpYyBsaWdodCBzb3VyY2UsIGx1bWlub3VzIHBvd2VyIChsbSkgPSA0IM+AIGx1bWlub3VzIGludGVuc2l0eSAoY2QpXG5cdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogNCAqIE1hdGguUEk7XG5cblx0fVxuXG5cdHNldCBwb3dlciggcG93ZXIgKSB7XG5cblx0XHQvLyBzZXQgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5IChpbiBjYW5kZWxhKSBmcm9tIHRoZSBkZXNpcmVkIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvICggNCAqIE1hdGguUEkgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG5cdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUG9pbnRMaWdodCB9O1xuIiwiaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi9DYW1lcmEuanMnO1xuXG4vKipcbiAqIENhbWVyYSB0aGF0IHVzZXMgW29ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcnRob2dyYXBoaWNfcHJvamVjdGlvbn0uXG4gKlxuICogSW4gdGhpcyBwcm9qZWN0aW9uIG1vZGUsIGFuIG9iamVjdCdzIHNpemUgaW4gdGhlIHJlbmRlcmVkIGltYWdlIHN0YXlzXG4gKiBjb25zdGFudCByZWdhcmRsZXNzIG9mIGl0cyBkaXN0YW5jZSBmcm9tIHRoZSBjYW1lcmEuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICogZm9yIHJlbmRlcmluZyAyRCBzY2VuZXMgYW5kIFVJIGVsZW1lbnRzLCBhbW9uZ3N0IG90aGVyIHRoaW5ncy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggd2lkdGggLyAtIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gLSAyLCAxLCAxMDAwICk7XG4gKiBzY2VuZS5hZGQoIGNhbWVyYSApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIENhbWVyYVxuICovXG5jbGFzcyBPcnRob2dyYXBoaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG9ydGhvZ3JhcGhpYyBjYW1lcmEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdD0tMV0gLSBUaGUgbGVmdCBwbGFuZSBvZiB0aGUgY2FtZXJhJ3MgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyaWdodD0xXSAtIFRoZSByaWdodCBwbGFuZSBvZiB0aGUgY2FtZXJhJ3MgZnJ1c3R1bS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0b3A9MV0gLSBUaGUgdG9wIHBsYW5lIG9mIHRoZSBjYW1lcmEncyBmcnVzdHVtLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2JvdHRvbT0tMV0gLSBUaGUgYm90dG9tIHBsYW5lIG9mIHRoZSBjYW1lcmEncyBmcnVzdHVtLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW25lYXI9MC4xXSAtIFRoZSBjYW1lcmEncyBuZWFyIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zhcj0yMDAwXSAtIFRoZSBjYW1lcmEncyBmYXIgcGxhbmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbGVmdCA9IC0gMSwgcmlnaHQgPSAxLCB0b3AgPSAxLCBib3R0b20gPSAtIDEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB6b29tIGZhY3RvciBvZiB0aGUgY2FtZXJhLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy56b29tID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlcHJlc2VudHMgdGhlIGZydXN0dW0gd2luZG93IHNwZWNpZmljYXRpb24uIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBlZGl0ZWRcblx0XHQgKiBkaXJlY3RseSBidXQgdmlhIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNzZXRWaWV3T2Zmc2V0fSBhbmQge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2NsZWFyVmlld09mZnNldH0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy52aWV3ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBjYW1lcmEncyBmcnVzdHVtLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdHRoaXMubGVmdCA9IGxlZnQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmlnaHQgcGxhbmUgb2YgdGhlIGNhbWVyYSdzIGZydXN0dW0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnJpZ2h0ID0gcmlnaHQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG9wIHBsYW5lIG9mIHRoZSBjYW1lcmEncyBmcnVzdHVtLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy50b3AgPSB0b3A7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYm90dG9tIHBsYW5lIG9mIHRoZSBjYW1lcmEncyBmcnVzdHVtLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdHRoaXMuYm90dG9tID0gYm90dG9tO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbWVyYSdzIG5lYXIgcGxhbmUuIFRoZSB2YWxpZCByYW5nZSBpcyBncmVhdGVyIHRoYW4gYDBgXG5cdFx0ICogYW5kIGxlc3MgdGhhbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB7QGxpbmsgT3J0aG9ncmFwaGljQ2FtZXJhI2Zhcn0uXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQsIHVubGlrZSBmb3IgdGhlIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYX0sIGAwYCBpcyBhXG5cdFx0ICogdmFsaWQgdmFsdWUgZm9yIGFuIG9ydGhvZ3JhcGhpYyBjYW1lcmEncyBuZWFyIHBsYW5lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwLjFcblx0XHQgKi9cblx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbWVyYSdzIGZhciBwbGFuZS4gTXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlXG5cdFx0ICogY3VycmVudCB2YWx1ZSBvZiB7QGxpbmsgT3J0aG9ncmFwaGljQ2FtZXJhI25lYXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAyMDAwXG5cdFx0ICovXG5cdFx0dGhpcy5mYXIgPSBmYXI7XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcblx0XHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblxuXHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG5cdCAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmdWxsV2lkdGggLSBUaGUgZnVsbCB3aWR0aCBvZiBtdWx0aXZpZXcgc2V0dXAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmdWxsSGVpZ2h0IC0gVGhlIGZ1bGwgaGVpZ2h0IG9mIG11bHRpdmlldyBzZXR1cC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgb2YgdGhlIHN1YmNhbWVyYS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgb2Zmc2V0IG9mIHRoZSBzdWJjYW1lcmEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiBzdWJjYW1lcmEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHN1YmNhbWVyYS5cblx0ICogQHNlZSB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjc2V0Vmlld09mZnNldH1cblx0ICovXG5cdHNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0ZnVsbEhlaWdodDogMSxcblx0XHRcdFx0b2Zmc2V0WDogMCxcblx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuXHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XG5cdFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuXHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHZpZXcgb2Zmc2V0IGZyb20gdGhlIHByb2plY3Rpb24gbWF0cml4LlxuXHQgKi9cblx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNhbWVyYSdzIHByb2plY3Rpb24gbWF0cml4LiBNdXN0IGJlIGNhbGxlZCBhZnRlciBhbnkgY2hhbmdlIG9mXG5cdCAqIGNhbWVyYSBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblxuXHRcdGNvbnN0IGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcblx0XHRjb25zdCBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdFx0Y29uc3QgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XG5cdFx0Y29uc3QgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XG5cblx0XHRsZXQgbGVmdCA9IGN4IC0gZHg7XG5cdFx0bGV0IHJpZ2h0ID0gY3ggKyBkeDtcblx0XHRsZXQgdG9wID0gY3kgKyBkeTtcblx0XHRsZXQgYm90dG9tID0gY3kgLSBkeTtcblxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRjb25zdCBzY2FsZVcgPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvIHRoaXMudmlldy5mdWxsV2lkdGggLyB0aGlzLnpvb207XG5cdFx0XHRjb25zdCBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xuXG5cdFx0XHRsZWZ0ICs9IHNjYWxlVyAqIHRoaXMudmlldy5vZmZzZXRYO1xuXHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogdGhpcy52aWV3LndpZHRoO1xuXHRcdFx0dG9wIC09IHNjYWxlSCAqIHRoaXMudmlldy5vZmZzZXRZO1xuXHRcdFx0Ym90dG9tID0gdG9wIC0gc2NhbGVIICogdGhpcy52aWV3LmhlaWdodDtcblxuXHRcdH1cblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIsIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcblxuXHR9XG5cblx0dG9KU09OKCBtZXRhICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblx0XHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcblx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcblx0XHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9O1xuIiwiaW1wb3J0IHsgTGlnaHRTaGFkb3cgfSBmcm9tICcuL0xpZ2h0U2hhZG93LmpzJztcbmltcG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzaGFkb3cgY29uZmlndXJhdGlvbiBvZiBkaXJlY3Rpb25hbCBsaWdodHMuXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0U2hhZG93XG4gKi9cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGlyZWN0aW9uYWwgbGlnaHQgc2hhZG93LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB9O1xuIiwiaW1wb3J0IHsgTGlnaHQgfSBmcm9tICcuL0xpZ2h0LmpzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgfSBmcm9tICcuL0RpcmVjdGlvbmFsTGlnaHRTaGFkb3cuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcblxuLyoqXG4gKiBBIGxpZ2h0IHRoYXQgZ2V0cyBlbWl0dGVkIGluIGEgc3BlY2lmaWMgZGlyZWN0aW9uLiBUaGlzIGxpZ2h0IHdpbGwgYmVoYXZlXG4gKiBhcyB0aG91Z2ggaXQgaXMgaW5maW5pdGVseSBmYXIgYXdheSBhbmQgdGhlIHJheXMgcHJvZHVjZWQgZnJvbSBpdCBhcmUgYWxsXG4gKiBwYXJhbGxlbC4gVGhlIGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0byBzaW11bGF0ZSBkYXlsaWdodDsgdGhlIHN1biBpc1xuICogZmFyIGVub3VnaCBhd2F5IHRoYXQgaXRzIHBvc2l0aW9uIGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIGluZmluaXRlLCBhbmRcbiAqIGFsbCBsaWdodCByYXlzIGNvbWluZyBmcm9tIGl0IGFyZSBwYXJhbGxlbC5cbiAqXG4gKiBBIGNvbW1vbiBwb2ludCBvZiBjb25mdXNpb24gZm9yIGRpcmVjdGlvbmFsIGxpZ2h0cyBpcyB0aGF0IHNldHRpbmcgdGhlXG4gKiByb3RhdGlvbiBoYXMgbm8gZWZmZWN0LiBUaGlzIGlzIGJlY2F1c2UgdGhyZWUuanMncyBEaXJlY3Rpb25hbExpZ2h0IGlzIHRoZVxuICogZXF1aXZhbGVudCB0byB3aGF0IGlzIG9mdGVuIGNhbGxlZCBhICdUYXJnZXQgRGlyZWN0IExpZ2h0JyBpbiBvdGhlclxuICogYXBwbGljYXRpb25zLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBpdHMgZGlyZWN0aW9uIGlzIGNhbGN1bGF0ZWQgYXMgcG9pbnRpbmcgZnJvbSB0aGUgbGlnaHQnc1xuICoge0BsaW5rIE9iamVjdDNEI3Bvc2l0aW9ufSB0byB0aGUge0BsaW5rIERpcmVjdGlvbmFsTGlnaHQjdGFyZ2V0fSBwb3NpdGlvblxuICogKGFzIG9wcG9zZWQgdG8gYSAnRnJlZSBEaXJlY3QgTGlnaHQnIHRoYXQganVzdCBoYXMgYSByb3RhdGlvblxuICogY29tcG9uZW50KS5cbiAqXG4gKiBUaGlzIGxpZ2h0IGNhbiBjYXN0IHNoYWRvd3MgLSBzZWUgdGhlIHtAbGluayBEaXJlY3Rpb25hbExpZ2h0U2hhZG93fSBmb3IgZGV0YWlscy5cbiAqXG4gKiBgYGBqc1xuICogLy8gV2hpdGUgZGlyZWN0aW9uYWwgbGlnaHQgYXQgaGFsZiBpbnRlbnNpdHkgc2hpbmluZyBmcm9tIHRoZSB0b3AuXG4gKiBjb25zdCBkaXJlY3Rpb25hbExpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIDB4ZmZmZmZmLCAwLjUgKTtcbiAqIHNjZW5lLmFkZCggZGlyZWN0aW9uYWxMaWdodCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGlyZWN0aW9uYWwgbGlnaHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KG51bWJlcnxDb2xvcnxzdHJpbmcpfSBbY29sb3I9MHhmZmZmZmZdIC0gVGhlIGxpZ2h0J3MgY29sb3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZW5zaXR5PTFdIC0gVGhlIGxpZ2h0J3Mgc3RyZW5ndGgvaW50ZW5zaXR5LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0RpcmVjdGlvbmFsTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5ERUZBVUxUX1VQICk7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkaXJlY3Rpb25hbCBsaWdodCBwb2ludHMgZnJvbSBpdHMgcG9zaXRpb24gdG8gdGhlXG5cdFx0ICogdGFyZ2V0J3MgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBGb3IgdGhlIHRhcmdldCdzIHBvc2l0aW9uIHRvIGJlIGNoYW5nZWQgdG8gYW55dGhpbmcgb3RoZXJcblx0XHQgKiB0aGFuIHRoZSBkZWZhdWx0LCBpdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBzY2VuZS5cblx0XHQgKlxuXHRcdCAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gc2V0IHRoZSB0YXJnZXQgdG8gYmUgYW5vdGhlciAzRCBvYmplY3Rcblx0XHQgKiBpbiB0aGUgc2NlbmUuIFRoZSBsaWdodCB3aWxsIG5vdyB0cmFjayB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3QzRH1cblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBob2xkcyB0aGUgbGlnaHQncyBzaGFkb3cgY29uZmlndXJhdGlvbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtEaXJlY3Rpb25hbExpZ2h0U2hhZG93fVxuXHRcdCAqL1xuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH07XG4iLCJpbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xuXG4vKipcbiAqIFRoaXMgbGlnaHQgZ2xvYmFsbHkgaWxsdW1pbmF0ZXMgYWxsIG9iamVjdHMgaW4gdGhlIHNjZW5lIGVxdWFsbHkuXG4gKlxuICogSXQgY2Fubm90IGJlIHVzZWQgdG8gY2FzdCBzaGFkb3dzIGFzIGl0IGRvZXMgbm90IGhhdmUgYSBkaXJlY3Rpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggMHg0MDQwNDAgKTsgLy8gc29mdCB3aGl0ZSBsaWdodFxuICogc2NlbmUuYWRkKCBsaWdodCApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhbWJpZW50IGxpZ2h0LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8Q29sb3J8c3RyaW5nKX0gW2NvbG9yPTB4ZmZmZmZmXSAtIFRoZSBsaWdodCdzIGNvbG9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2ludGVuc2l0eT0xXSAtIFRoZSBsaWdodCdzIHN0cmVuZ3RoL2ludGVuc2l0eS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNBbWJpZW50TGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFtYmllbnRMaWdodCB9O1xuIiwiaW1wb3J0IHsgTGlnaHQgfSBmcm9tICcuL0xpZ2h0LmpzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVtaXRzIGxpZ2h0IHVuaWZvcm1seSBhY3Jvc3MgdGhlIGZhY2UgYSByZWN0YW5ndWxhciBwbGFuZS5cbiAqIFRoaXMgbGlnaHQgdHlwZSBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBsaWdodCBzb3VyY2VzIHN1Y2ggYXMgYnJpZ2h0XG4gKiB3aW5kb3dzIG9yIHN0cmlwIGxpZ2h0aW5nLlxuICpcbiAqIEltcG9ydGFudCBOb3RlczpcbiAqXG4gKiAtIFRoZXJlIGlzIG5vIHNoYWRvdyBzdXBwb3J0LlxuICogLSBPbmx5IFBCUiBtYXRlcmlhbHMgYXJlIHN1cHBvcnRlZC5cbiAqIC0gWW91IGhhdmUgdG8gaW5jbHVkZSBgUmVjdEFyZWFMaWdodFVuaWZvcm1zTGliYCAoYFdlYkdMUmVuZGVyZXJgKSBvciBgUmVjdEFyZWFMaWdodFRleHR1cmVzTGliYCAoYFdlYkdQVVJlbmRlcmVyYClcbiAqIGludG8geW91ciBhcHAgYW5kIGluaXQgdGhlIHVuaWZvcm1zL3RleHR1cmVzLlxuICpcbiAqIGBgYGpzXG4gKiBSZWN0QXJlYUxpZ2h0VW5pZm9ybXNMaWIuaW5pdCgpOyAvLyBvbmx5IHJlbGV2YW50IGZvciBXZWJHTFJlbmRlcmVyXG4gKiBUSFJFRS5SZWN0QXJlYUxpZ2h0Tm9kZS5zZXRMVEMoIFJlY3RBcmVhTGlnaHRUZXh0dXJlc0xpYi5pbml0KCkgKTsgLy8gIG9ubHkgcmVsZXZhbnQgZm9yIFdlYkdQVVJlbmRlcmVyXG4gKlxuICogY29uc3QgaW50ZW5zaXR5ID0gMTsgY29uc3Qgd2lkdGggPSAxMDsgY29uc3QgaGVpZ2h0ID0gMTA7XG4gKiBjb25zdCByZWN0TGlnaHQgPSBuZXcgVEhSRUUuUmVjdEFyZWFMaWdodCggMHhmZmZmZmYsIGludGVuc2l0eSwgd2lkdGgsIGhlaWdodCApO1xuICogcmVjdExpZ2h0LnBvc2l0aW9uLnNldCggNSwgNSwgMCApO1xuICogcmVjdExpZ2h0Lmxvb2tBdCggMCwgMCwgMCApO1xuICogc2NlbmUuYWRkKCByZWN0TGlnaHQgKVxuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIFJlY3RBcmVhTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYXJlYSBsaWdodC5cblx0ICpcblx0ICogQHBhcmFtIHsobnVtYmVyfENvbG9yfHN0cmluZyl9IFtjb2xvcj0weGZmZmZmZl0gLSBUaGUgbGlnaHQncyBjb2xvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlbnNpdHk9MV0gLSBUaGUgbGlnaHQncyBzdHJlbmd0aC9pbnRlbnNpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MTBdIC0gVGhlIHdpZHRoIG9mIHRoZSBsaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTBdIC0gVGhlIGhlaWdodCBvZiB0aGUgbGlnaHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gMTAgKSB7XG5cblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1JlY3RBcmVhTGlnaHQgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JlY3RBcmVhTGlnaHQnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHdpZHRoIG9mIHRoZSBsaWdodC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMTBcblx0XHQgKi9cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaGVpZ2h0IG9mIHRoZSBsaWdodC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMTBcblx0XHQgKi9cblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaWdodCdzIHBvd2VyLiBQb3dlciBpcyB0aGUgbHVtaW5vdXMgcG93ZXIgb2YgdGhlIGxpZ2h0IG1lYXN1cmVkIGluIGx1bWVucyAobG0pLlxuXHQgKiBDaGFuZ2luZyB0aGUgcG93ZXIgd2lsbCBhbHNvIGNoYW5nZSB0aGUgbGlnaHQncyBpbnRlbnNpdHkuXG5cdCAqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgcG93ZXIoKSB7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gbml0cylcblx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBNYXRoLlBJO1xuXG5cdH1cblxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xuXG5cdFx0Ly8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gbml0cykgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUmVjdEFyZWFMaWdodCB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRoaXJkLW9yZGVyIHNwaGVyaWNhbCBoYXJtb25pY3MgKFNIKS4gTGlnaHQgcHJvYmVzIHVzZSB0aGlzIGNsYXNzXG4gKiB0byBlbmNvZGUgbGlnaHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogLSBQcmltYXJ5IHJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L3BhcGVycy9lbnZtYXAvZW52bWFwLnBkZn1cbiAqIC0gU2Vjb25kYXJ5IHJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vd3d3LnBwc2xvYW4ub3JnL3B1YmxpY2F0aW9ucy9TdHVwaWRTSDM2LnBkZn1cbiAqL1xuY2xhc3MgU3BoZXJpY2FsSGFybW9uaWNzMyB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3BoZXJpY2FsIGhhcm1vbmljcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NwaGVyaWNhbEhhcm1vbmljczMgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgaG9sZGluZyB0aGUgKDkpIFNIIGNvZWZmaWNpZW50cy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxWZWN0b3IzPn1cblx0XHQgKi9cblx0XHR0aGlzLmNvZWZmaWNpZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gU0ggY29lZmZpY2llbnRzIHRvIHRoaXMgaW5zdGFuY2UgYnkgY29weWluZ1xuXHQgKiB0aGUgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PFZlY3RvcjM+fSBjb2VmZmljaWVudHMgLSBUaGUgU0ggY29lZmZpY2llbnRzLlxuXHQgKiBAcmV0dXJuIHtTcGhlcmljYWxIYXJtb25pY3MzfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyaWNhbCBoYXJtb25pY3MuXG5cdCAqL1xuXHRzZXQoIGNvZWZmaWNpZW50cyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uY29weSggY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbGwgU0ggY29lZmZpY2llbnRzIHRvIGAwYC5cblx0ICpcblx0ICogQHJldHVybiB7U3BoZXJpY2FsSGFybW9uaWNzM30gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmljYWwgaGFybW9uaWNzLlxuXHQgKi9cblx0emVybygpIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uc2V0KCAwLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJhZGlhbmNlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGdpdmVuIG5vcm1hbC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBub3JtYWwgLSBUaGUgbm9ybWFsIHZlY3RvciAoYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aClcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIHJhZGlhbmNlLlxuXHQgKi9cblx0Z2V0QXQoIG5vcm1hbCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cblx0XHRjb25zdCBjb2VmZiA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Ly8gYmFuZCAwXG5cdFx0dGFyZ2V0LmNvcHkoIGNvZWZmWyAwIF0gKS5tdWx0aXBseVNjYWxhciggMC4yODIwOTUgKTtcblxuXHRcdC8vIGJhbmQgMVxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAxIF0sIDAuNDg4NjAzICogeSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAyIF0sIDAuNDg4NjAzICogeiApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAzIF0sIDAuNDg4NjAzICogeCApO1xuXG5cdFx0Ly8gYmFuZCAyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDQgXSwgMS4wOTI1NDggKiAoIHggKiB5ICkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNSBdLCAxLjA5MjU0OCAqICggeSAqIHogKSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA2IF0sIDAuMzE1MzkyICogKCAzLjAgKiB6ICogeiAtIDEuMCApICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDcgXSwgMS4wOTI1NDggKiAoIHggKiB6ICkgKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgOCBdLCAwLjU0NjI3NCAqICggeCAqIHggLSB5ICogeSApICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaXJyYWRpYW5jZSAocmFkaWFuY2UgY29udm9sdmVkIHdpdGggY29zaW5lIGxvYmUpIGluIHRoZVxuXHQgKiBkaXJlY3Rpb24gb2YgdGhlIGdpdmVuIG5vcm1hbC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBub3JtYWwgLSBUaGUgbm9ybWFsIHZlY3RvciAoYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aClcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIGlycmFkaWFuY2UuXG5cdCAqL1xuXHRnZXRJcnJhZGlhbmNlQXQoIG5vcm1hbCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XG5cblx0XHRjb25zdCBjb2VmZiA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0Ly8gYmFuZCAwXG5cdFx0dGFyZ2V0LmNvcHkoIGNvZWZmWyAwIF0gKS5tdWx0aXBseVNjYWxhciggMC44ODYyMjcgKTsgLy8gz4AgKiAwLjI4MjA5NVxuXG5cdFx0Ly8gYmFuZCAxXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDEgXSwgMi4wICogMC41MTE2NjQgKiB5ICk7IC8vICggMiAqIM+AIC8gMyApICogMC40ODg2MDNcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMiBdLCAyLjAgKiAwLjUxMTY2NCAqIHogKTtcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMyBdLCAyLjAgKiAwLjUxMTY2NCAqIHggKTtcblxuXHRcdC8vIGJhbmQgMlxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA0IF0sIDIuMCAqIDAuNDI5MDQzICogeCAqIHkgKTsgLy8gKCDPgCAvIDQgKSAqIDEuMDkyNTQ4XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDUgXSwgMi4wICogMC40MjkwNDMgKiB5ICogeiApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA2IF0sIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCApOyAvLyAoIM+AIC8gNCApICogMC4zMTUzOTIgKiAzXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDcgXSwgMi4wICogMC40MjkwNDMgKiB4ICogeiApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA4IF0sIDAuNDI5MDQzICogKCB4ICogeCAtIHkgKiB5ICkgKTsgLy8gKCDPgCAvIDQgKSAqIDAuNTQ2Mjc0XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gU0ggdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtTcGhlcmljYWxIYXJtb25pY3MzfSBzaCAtIFRoZSBTSCB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1NwaGVyaWNhbEhhcm1vbmljczN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3BoZXJpY2FsIGhhcm1vbmljcy5cblx0ICovXG5cdGFkZCggc2ggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLmFkZCggc2guY29lZmZpY2llbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHBlcmZvcm1pbmcge0BsaW5rIFNwaGVyaWNhbEhhcm1vbmljczMjYWRkfSBhbmRcblx0ICoge0BsaW5rIFNwaGVyaWNhbEhhcm1vbmljczMjc2NhbGV9IGF0IG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJpY2FsSGFybW9uaWNzM30gc2ggLSBUaGUgU0ggdG8gYWRkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBzY2FsZSBmYWN0b3IuXG5cdCAqIEByZXR1cm4ge1NwaGVyaWNhbEhhcm1vbmljczN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3BoZXJpY2FsIGhhcm1vbmljcy5cblx0ICovXG5cdGFkZFNjYWxlZFNIKCBzaCwgcyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uYWRkU2NhbGVkVmVjdG9yKCBzaC5jb2VmZmljaWVudHNbIGkgXSwgcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTY2FsZXMgdGhpcyBTSCBieSB0aGUgZ2l2ZW4gc2NhbGUgZmFjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcyAtIFRoZSBzY2FsZSBmYWN0b3IuXG5cdCAqIEByZXR1cm4ge1NwaGVyaWNhbEhhcm1vbmljczN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3BoZXJpY2FsIGhhcm1vbmljcy5cblx0ICovXG5cdHNjYWxlKCBzICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5tdWx0aXBseVNjYWxhciggcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5lYXIgaW50ZXJwb2xhdGVzIGJldHdlZW4gdGhlIGdpdmVuIFNIIGFuZCB0aGlzIGluc3RhbmNlIGJ5IHRoZSBnaXZlblxuXHQgKiBhbHBoYSBmYWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJpY2FsSGFybW9uaWNzM30gc2ggLSBUaGUgU0ggdG8gaW50ZXJwb2xhdGUgd2l0aC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gVGhlIGFscGhhIGZhY3Rvci5cblx0ICogQHJldHVybiB7U3BoZXJpY2FsSGFybW9uaWNzM30gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmljYWwgaGFybW9uaWNzLlxuXHQgKi9cblx0bGVycCggc2gsIGFscGhhICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5sZXJwKCBzaC5jb2VmZmljaWVudHNbIGkgXSwgYWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBzcGhlcmljYWwgaGFybW9uaWNzIGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtTcGhlcmljYWxIYXJtb25pY3MzfSBzaCAtIFRoZSBzcGhlcmljYWwgaGFybW9uaWNzIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgc3BoZXJpY2FsIGhhcm1vbmljcyBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqL1xuXHRlcXVhbHMoIHNoICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0aWYgKCAhIHRoaXMuY29lZmZpY2llbnRzWyBpIF0uZXF1YWxzKCBzaC5jb2VmZmljaWVudHNbIGkgXSApICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc3BoZXJpY2FsIGhhcm1vbmljcyB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1NwaGVyaWNhbEhhcm1vbmljczN9IHNoIC0gVGhlIHNwaGVyaWNhbCBoYXJtb25pY3MgdG8gY29weS5cblx0ICogQHJldHVybiB7U3BoZXJpY2FsSGFybW9uaWNzM30gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmljYWwgaGFybW9uaWNzLlxuXHQgKi9cblx0Y29weSggc2ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHNoLmNvZWZmaWNpZW50cyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBzcGhlcmljYWwgaGFybW9uaWNzIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NwaGVyaWNhbEhhcm1vbmljczN9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgU0ggY29lZmZpY2llbnRzIG9mIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBTSCBjb2VmZmljaWVudHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gVGhlIGFycmF5IG9mZnNldCB3aGVyZSB0byBzdGFydCBjb3B5aW5nLlxuXHQgKiBAcmV0dXJuIHtTcGhlcmljYWxIYXJtb25pY3MzfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Y29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRjb2VmZmljaWVudHNbIGkgXS5mcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgKyAoIGkgKiAzICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBTSCBjb2VmZmljaWVudHMsIG9yIGNvcGllcyB0aGVtIGludG8gdGhlIHByb3ZpZGVkXG5cdCAqIGFycmF5LiBUaGUgY29lZmZpY2llbnRzIGFyZSByZXByZXNlbnRlZCBhcyBudW1iZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFthcnJheT1bXV0gLSBUaGUgdGFyZ2V0IGFycmF5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIFRoZSBhcnJheSBvZmZzZXQgd2hlcmUgdG8gc3RhcnQgY29weWluZy5cblx0ICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgd2l0aCBmbGF0IFNIIGNvZWZmaWNpZW50cy5cblx0ICovXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdGNvZWZmaWNpZW50c1sgaSBdLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKyAoIGkgKiAzICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBTSCBiYXNpcyBmb3IgdGhlIGdpdmVuIG5vcm1hbCB2ZWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gbm9ybWFsIC0gVGhlIG5vcm1hbC5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaEJhc2lzIC0gVGhlIHRhcmdldCBhcnJheSBob2xkaW5nIHRoZSBTSCBiYXNpcy5cblx0ICovXG5cdHN0YXRpYyBnZXRCYXNpc0F0KCBub3JtYWwsIHNoQmFzaXMgKSB7XG5cblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXG5cdFx0Y29uc3QgeCA9IG5vcm1hbC54LCB5ID0gbm9ybWFsLnksIHogPSBub3JtYWwuejtcblxuXHRcdC8vIGJhbmQgMFxuXHRcdHNoQmFzaXNbIDAgXSA9IDAuMjgyMDk1O1xuXG5cdFx0Ly8gYmFuZCAxXG5cdFx0c2hCYXNpc1sgMSBdID0gMC40ODg2MDMgKiB5O1xuXHRcdHNoQmFzaXNbIDIgXSA9IDAuNDg4NjAzICogejtcblx0XHRzaEJhc2lzWyAzIF0gPSAwLjQ4ODYwMyAqIHg7XG5cblx0XHQvLyBiYW5kIDJcblx0XHRzaEJhc2lzWyA0IF0gPSAxLjA5MjU0OCAqIHggKiB5O1xuXHRcdHNoQmFzaXNbIDUgXSA9IDEuMDkyNTQ4ICogeSAqIHo7XG5cdFx0c2hCYXNpc1sgNiBdID0gMC4zMTUzOTIgKiAoIDMgKiB6ICogeiAtIDEgKTtcblx0XHRzaEJhc2lzWyA3IF0gPSAxLjA5MjU0OCAqIHggKiB6O1xuXHRcdHNoQmFzaXNbIDggXSA9IDAuNTQ2Mjc0ICogKCB4ICogeCAtIHkgKiB5ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyaWNhbEhhcm1vbmljczMgfTtcbiIsImltcG9ydCB7IFNwaGVyaWNhbEhhcm1vbmljczMgfSBmcm9tICcuLi9tYXRoL1NwaGVyaWNhbEhhcm1vbmljczMuanMnO1xuaW1wb3J0IHsgTGlnaHQgfSBmcm9tICcuL0xpZ2h0LmpzJztcblxuLyoqXG4gKiBMaWdodCBwcm9iZXMgYXJlIGFuIGFsdGVybmF0aXZlIHdheSBvZiBhZGRpbmcgbGlnaHQgdG8gYSAzRCBzY2VuZS4gVW5saWtlXG4gKiBjbGFzc2ljYWwgbGlnaHQgc291cmNlcyAoZS5nLiBkaXJlY3Rpb25hbCwgcG9pbnQgb3Igc3BvdCBsaWdodHMpLCBsaWdodFxuICogcHJvYmVzIGRvIG5vdCBlbWl0IGxpZ2h0LiBJbnN0ZWFkIHRoZXkgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgbGlnaHRcbiAqIHBhc3NpbmcgdGhyb3VnaCAzRCBzcGFjZS4gRHVyaW5nIHJlbmRlcmluZywgdGhlIGxpZ2h0IHRoYXQgaGl0cyBhIDNEXG4gKiBvYmplY3QgaXMgYXBwcm94aW1hdGVkIGJ5IHVzaW5nIHRoZSBkYXRhIGZyb20gdGhlIGxpZ2h0IHByb2JlLlxuICpcbiAqIExpZ2h0IHByb2JlcyBhcmUgdXN1YWxseSBjcmVhdGVkIGZyb20gKHJhZGlhbmNlKSBlbnZpcm9ubWVudCBtYXBzLiBUaGVcbiAqIGNsYXNzIHtAbGluayBMaWdodFByb2JlR2VuZXJhdG9yfSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgbGlnaHQgcHJvYmVzIGZyb21cbiAqIGN1YmUgdGV4dHVyZXMgb3IgcmVuZGVyIHRhcmdldHMuIEhvd2V2ZXIsIGxpZ2h0IGVzdGltYXRpb24gZGF0YSBjb3VsZCBhbHNvXG4gKiBiZSBwcm92aWRlZCBpbiBvdGhlciBmb3JtcyBlLmcuIGJ5IFdlYlhSLiBUaGlzIGVuYWJsZXMgdGhlIHJlbmRlcmluZyBvZlxuICogYXVnbWVudGVkIHJlYWxpdHkgY29udGVudCB0aGF0IHJlYWN0cyB0byByZWFsIHdvcmxkIGxpZ2h0aW5nLlxuICpcbiAqIFRoZSBjdXJyZW50IHByb2JlIGltcGxlbWVudGF0aW9uIGluIHRocmVlLmpzIHN1cHBvcnRzIHNvLWNhbGxlZCBkaWZmdXNlXG4gKiBsaWdodCBwcm9iZXMuIFRoaXMgdHlwZSBvZiBsaWdodCBwcm9iZSBpcyBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBhblxuICogaXJyYWRpYW5jZSBlbnZpcm9ubWVudCBtYXAuXG4gKlxuICogQGF1Z21lbnRzIExpZ2h0XG4gKi9cbmNsYXNzIExpZ2h0UHJvYmUgZXh0ZW5kcyBMaWdodCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbGlnaHQgcHJvYmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJpY2FsSGFybW9uaWNzM30gc2ggLSBUaGUgc3BoZXJpY2FsIGhhcm1vbmljcyB3aGljaCByZXByZXNlbnRzIGVuY29kZWQgbGlnaHRpbmcgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZW5zaXR5PTFdIC0gVGhlIGxpZ2h0J3Mgc3RyZW5ndGgvaW50ZW5zaXR5LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHNoID0gbmV3IFNwaGVyaWNhbEhhcm1vbmljczMoKSwgaW50ZW5zaXR5ID0gMSApIHtcblxuXHRcdHN1cGVyKCB1bmRlZmluZWQsIGludGVuc2l0eSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0xpZ2h0UHJvYmUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaWdodCBwcm9iZSB1c2VzIHNwaGVyaWNhbCBoYXJtb25pY3MgdG8gZW5jb2RlIGxpZ2h0aW5nIGluZm9ybWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1NwaGVyaWNhbEhhcm1vbmljczN9XG5cdFx0ICovXG5cdFx0dGhpcy5zaCA9IHNoO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuc2guY29weSggc291cmNlLnNoICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlc2VyaWFsaXplcyB0aGUgbGlnaHQgcHJvdmUgZnJvbSB0aGUgZ2l2ZW4gSlNPTi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiBob2xkaW5nIHRoZSBzZXJpYWxpemVkIGxpZ2h0IHByb2JlLlxuXHQgKiBAcmV0dXJuIHtMaWdodFByb2JlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGxpZ2h0IHByb2JlLlxuXHQgKi9cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHR0aGlzLmludGVuc2l0eSA9IGpzb24uaW50ZW5zaXR5OyAvLyBUT0RPOiBNb3ZlIHRoaXMgYml0IHRvIExpZ2h0LmZyb21KU09OKCk7XG5cdFx0dGhpcy5zaC5mcm9tQXJyYXkoIGpzb24uc2ggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC5zaCA9IHRoaXMuc2gudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IExpZ2h0UHJvYmUgfTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uL21hdGgvVmVjdG9yNC5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5pbXBvcnQge1xuXHRTaGFkb3dNYXRlcmlhbCxcblx0U3ByaXRlTWF0ZXJpYWwsXG5cdFJhd1NoYWRlck1hdGVyaWFsLFxuXHRTaGFkZXJNYXRlcmlhbCxcblx0UG9pbnRzTWF0ZXJpYWwsXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbCxcblx0TWVzaFBob25nTWF0ZXJpYWwsXG5cdE1lc2hUb29uTWF0ZXJpYWwsXG5cdE1lc2hOb3JtYWxNYXRlcmlhbCxcblx0TWVzaExhbWJlcnRNYXRlcmlhbCxcblx0TWVzaERlcHRoTWF0ZXJpYWwsXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLFxuXHRNZXNoQmFzaWNNYXRlcmlhbCxcblx0TWVzaE1hdGNhcE1hdGVyaWFsLFxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwsXG5cdExpbmVCYXNpY01hdGVyaWFsLFxuXHRNYXRlcmlhbCxcbn0gZnJvbSAnLi4vbWF0ZXJpYWxzL01hdGVyaWFscy5qcyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGxvYWRpbmcgZ2VvbWV0cmllcy4gVGhlIGZpbGVzIGFyZSBpbnRlcm5hbGx5XG4gKiBsb2FkZWQgdmlhIHtAbGluayBGaWxlTG9hZGVyfS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XG4gKiBjb25zdCBtYXRlcmlhbCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoICdtYXRlcmlhbC5qc29uJyApO1xuICogYGBgXG4gKiBUaGlzIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IG5vZGUgbWF0ZXJpYWxzLiBVc2Uge0BsaW5rIE5vZGVNYXRlcmlhbExvYWRlcn0gaW5zdGVhZC5cbiAqXG4gKiBAYXVnbWVudHMgTG9hZGVyXG4gKi9cbmNsYXNzIE1hdGVyaWFsTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtYXRlcmlhbCBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHQvKipcblx0XHQgKiBBIGRpY3Rpb25hcnkgaG9sZGluZyB0ZXh0dXJlcyB1c2VkIGJ5IHRoZSBtYXRlcmlhbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLFRleHR1cmU+fVxuXHRcdCAqL1xuXHRcdHRoaXMudGV4dHVyZXMgPSB7fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBsb2FkaW5nIGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgcGFzcyB0aGUgbG9hZGVkIG1hdGVyaWFsIHRvIHRoZSBgb25Mb2FkKClgIGNhbGxiYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHBhdGgvVVJMIG9mIHRoZSBmaWxlIHRvIGJlIGxvYWRlZC4gVGhpcyBjYW4gYWxzbyBiZSBhIGRhdGEgVVJJLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKE1hdGVyaWFsKX0gb25Mb2FkIC0gRXhlY3V0ZWQgd2hlbiB0aGUgbG9hZGluZyBwcm9jZXNzIGhhcyBiZWVuIGZpbmlzaGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gb25Qcm9ncmVzcyAtIEV4ZWN1dGVkIHdoaWxlIHRoZSBsb2FkaW5nIGlzIGluIHByb2dyZXNzLlxuXHQgKiBAcGFyYW0ge29uRXJyb3JDYWxsYmFja30gb25FcnJvciAtIEV4ZWN1dGVkIHdoZW4gZXJyb3JzIG9jY3VyLlxuXHQgKi9cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBnaXZlbiBKU09OIG9iamVjdCBhbmQgcmV0dXJucyBhIG1hdGVyaWFsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBzZXJpYWxpemVkIG1hdGVyaWFsLlxuXHQgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIHBhcnNlZCBtYXRlcmlhbC5cblx0ICovXG5cdHBhcnNlKCBqc29uICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggbmFtZSApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIGpzb24udHlwZSApO1xuXG5cdFx0aWYgKCBqc29uLnV1aWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xuXHRcdGlmICgganNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xuXHRcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xuXHRcdGlmICgganNvbi5zaGVlbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW4gPSBqc29uLnNoZWVuO1xuXHRcdGlmICgganNvbi5zaGVlbkNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlbkNvbG9yID0gbmV3IENvbG9yKCkuc2V0SGV4KCBqc29uLnNoZWVuQ29sb3IgKTtcblx0XHRpZiAoIGpzb24uc2hlZW5Sb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0ganNvbi5zaGVlblJvdWdobmVzcztcblx0XHRpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHkgPSBqc29uLnNwZWN1bGFySW50ZW5zaXR5O1xuXHRcdGlmICgganNvbi5zcGVjdWxhckNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvci5zZXRIZXgoIGpzb24uc3BlY3VsYXJDb2xvciApO1xuXHRcdGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xuXHRcdGlmICgganNvbi5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdCA9IGpzb24uY2xlYXJjb2F0O1xuXHRcdGlmICgganNvbi5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IGpzb24uY2xlYXJjb2F0Um91Z2huZXNzO1xuXHRcdGlmICgganNvbi5kaXNwZXJzaW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwZXJzaW9uID0ganNvbi5kaXNwZXJzaW9uO1xuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSBqc29uLmlyaWRlc2NlbmNlO1xuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZUlPUiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IgPSBqc29uLmlyaWRlc2NlbmNlSU9SO1xuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0ganNvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlO1xuXHRcdGlmICgganNvbi50cmFuc21pc3Npb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA9IGpzb24udHJhbnNtaXNzaW9uO1xuXHRcdGlmICgganNvbi50aGlja25lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRoaWNrbmVzcyA9IGpzb24udGhpY2tuZXNzO1xuXHRcdGlmICgganNvbi5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlID0ganNvbi5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdGlmICgganNvbi5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvci5zZXRIZXgoIGpzb24uYXR0ZW51YXRpb25Db2xvciApO1xuXHRcdGlmICgganNvbi5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5ID0ganNvbi5hbmlzb3Ryb3B5O1xuXHRcdGlmICgganNvbi5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGpzb24uYW5pc290cm9weVJvdGF0aW9uO1xuXHRcdGlmICgganNvbi5mb2cgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvZyA9IGpzb24uZm9nO1xuXHRcdGlmICgganNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLmZsYXRTaGFkaW5nO1xuXHRcdGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuXHRcdGlmICgganNvbi5jb21iaW5lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb21iaW5lID0ganNvbi5jb21iaW5lO1xuXHRcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuXHRcdGlmICgganNvbi5zaGFkb3dTaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkb3dTaWRlID0ganNvbi5zaGFkb3dTaWRlO1xuXHRcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xuXHRcdGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xuXHRcdGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuXHRcdGlmICgganNvbi5hbHBoYUhhc2ggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhSGFzaCA9IGpzb24uYWxwaGFIYXNoO1xuXHRcdGlmICgganNvbi5kZXB0aEZ1bmMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoRnVuYyA9IGpzb24uZGVwdGhGdW5jO1xuXHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xuXHRcdGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xuXHRcdGlmICgganNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xuXHRcdGlmICgganNvbi5ibGVuZFNyYyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRTcmMgPSBqc29uLmJsZW5kU3JjO1xuXHRcdGlmICgganNvbi5ibGVuZERzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmREc3QgPSBqc29uLmJsZW5kRHN0O1xuXHRcdGlmICgganNvbi5ibGVuZEVxdWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uID0ganNvbi5ibGVuZEVxdWF0aW9uO1xuXHRcdGlmICgganNvbi5ibGVuZFNyY0FscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZFNyY0FscGhhID0ganNvbi5ibGVuZFNyY0FscGhhO1xuXHRcdGlmICgganNvbi5ibGVuZERzdEFscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZERzdEFscGhhID0ganNvbi5ibGVuZERzdEFscGhhO1xuXHRcdGlmICgganNvbi5ibGVuZEVxdWF0aW9uQWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSA9IGpzb24uYmxlbmRFcXVhdGlvbkFscGhhO1xuXHRcdGlmICgganNvbi5ibGVuZENvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuYmxlbmRDb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRDb2xvci5zZXRIZXgoIGpzb24uYmxlbmRDb2xvciApO1xuXHRcdGlmICgganNvbi5ibGVuZEFscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZEFscGhhID0ganNvbi5ibGVuZEFscGhhO1xuXHRcdGlmICgganNvbi5zdGVuY2lsV3JpdGVNYXNrICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrID0ganNvbi5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdGlmICgganNvbi5zdGVuY2lsRnVuYyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmMgPSBqc29uLnN0ZW5jaWxGdW5jO1xuXHRcdGlmICgganNvbi5zdGVuY2lsUmVmICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsUmVmID0ganNvbi5zdGVuY2lsUmVmO1xuXHRcdGlmICgganNvbi5zdGVuY2lsRnVuY01hc2sgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayA9IGpzb24uc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdGlmICgganNvbi5zdGVuY2lsRmFpbCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbEZhaWwgPSBqc29uLnN0ZW5jaWxGYWlsO1xuXHRcdGlmICgganNvbi5zdGVuY2lsWkZhaWwgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCA9IGpzb24uc3RlbmNpbFpGYWlsO1xuXHRcdGlmICgganNvbi5zdGVuY2lsWlBhc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyA9IGpzb24uc3RlbmNpbFpQYXNzO1xuXHRcdGlmICgganNvbi5zdGVuY2lsV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSA9IGpzb24uc3RlbmNpbFdyaXRlO1xuXG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVjYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHRpZiAoIGpzb24ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdGF0aW9uID0ganNvbi5yb3RhdGlvbjtcblxuXHRcdGlmICgganNvbi5saW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpbmV3aWR0aCA9IGpzb24ubGluZXdpZHRoO1xuXHRcdGlmICgganNvbi5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGFzaFNpemUgPSBqc29uLmRhc2hTaXplO1xuXHRcdGlmICgganNvbi5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xuXHRcdGlmICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2NhbGUgPSBqc29uLnNjYWxlO1xuXG5cdFx0aWYgKCBqc29uLnBvbHlnb25PZmZzZXQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSBqc29uLnBvbHlnb25PZmZzZXQ7XG5cdFx0aWYgKCBqc29uLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBqc29uLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0aWYgKCBqc29uLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0ganNvbi5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHRpZiAoIGpzb24uZGl0aGVyaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXRoZXJpbmcgPSBqc29uLmRpdGhlcmluZztcblxuXHRcdGlmICgganNvbi5hbHBoYVRvQ292ZXJhZ2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9IGpzb24uYWxwaGFUb0NvdmVyYWdlO1xuXHRcdGlmICgganNvbi5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSA9IGpzb24ucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdGlmICgganNvbi5mb3JjZVNpbmdsZVBhc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9IGpzb24uZm9yY2VTaW5nbGVQYXNzO1xuXG5cdFx0aWYgKCBqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZpc2libGUgPSBqc29uLnZpc2libGU7XG5cblx0XHRpZiAoIGpzb24udG9uZU1hcHBlZCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudG9uZU1hcHBlZCA9IGpzb24udG9uZU1hcHBlZDtcblxuXHRcdGlmICgganNvbi51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXG5cdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBqc29uLnZlcnRleENvbG9ycyA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gKCBqc29uLnZlcnRleENvbG9ycyA+IDAgKSA/IHRydWUgOiBmYWxzZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gU2hhZGVyIE1hdGVyaWFsXG5cblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgbmFtZSBpbiBqc29uLnVuaWZvcm1zICkge1xuXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm0gPSBqc29uLnVuaWZvcm1zWyBuYW1lIF07XG5cblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXSA9IHt9O1xuXG5cdFx0XHRcdHN3aXRjaCAoIHVuaWZvcm0udHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IGdldFRleHR1cmUoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IENvbG9yKCkuc2V0SGV4KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3YyJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Myc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndjQnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ20zJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBuZXcgTWF0cml4MygpLmZyb21BcnJheSggdW5pZm9ybS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtNCc6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHVuaWZvcm0udmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlZmluZXMgPSBqc29uLmRlZmluZXM7XG5cdFx0aWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XG5cdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG5cdFx0aWYgKCBqc29uLmdsc2xWZXJzaW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5nbHNsVmVyc2lvbiA9IGpzb24uZ2xzbFZlcnNpb247XG5cblx0XHRpZiAoIGpzb24uZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4ganNvbi5leHRlbnNpb25zICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLmV4dGVuc2lvbnNbIGtleSBdID0ganNvbi5leHRlbnNpb25zWyBrZXkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmxpZ2h0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRzID0ganNvbi5saWdodHM7XG5cdFx0aWYgKCBqc29uLmNsaXBwaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGlwcGluZyA9IGpzb24uY2xpcHBpbmc7XG5cblx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcblxuXHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuXHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0Ly8gbWFwc1xuXG5cdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcblx0XHRpZiAoIGpzb24ubWF0Y2FwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXRjYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1hdGNhcCApO1xuXG5cdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcblxuXHRcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XG5cdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cblx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xuXHRcdGlmICgganNvbi5ub3JtYWxNYXBUeXBlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0ganNvbi5ub3JtYWxNYXBUeXBlO1xuXHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsZXQgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5vcm1hbFNjYWxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuXG5cdFx0XHRcdG5vcm1hbFNjYWxlID0gWyBub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XG5cdFx0aWYgKCBqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcblxuXHRcdGlmICgganNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XG5cdFx0aWYgKCBqc29uLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IGpzb24uZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhckludGVuc2l0eU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFySW50ZW5zaXR5TWFwICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyQ29sb3JNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyQ29sb3JNYXAgKTtcblxuXHRcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XG5cdFx0aWYgKCBqc29uLmVudk1hcFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbnZNYXBSb3RhdGlvbi5mcm9tQXJyYXkoIGpzb24uZW52TWFwUm90YXRpb24gKTtcblx0XHRpZiAoIGpzb24uZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHkgPSBqc29uLmVudk1hcEludGVuc2l0eTtcblxuXHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXHRcdGlmICgganNvbi5yZWZyYWN0aW9uUmF0aW8gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IGpzb24ucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcblx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XG5cdFx0aWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XG5cblx0XHRpZiAoIGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdyYWRpZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5ncmFkaWVudE1hcCApO1xuXG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5jbGVhcmNvYXRNYXAgKTtcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmNsZWFyY29hdFJvdWdobmVzc01hcCApO1xuXHRcdGlmICgganNvbi5jbGVhcmNvYXROb3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwICk7XG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlICk7XG5cblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2VNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5pcmlkZXNjZW5jZU1hcCApO1xuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICk7XG5cblx0XHRpZiAoIGpzb24udHJhbnNtaXNzaW9uTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc21pc3Npb25NYXAgPSBnZXRUZXh0dXJlKCBqc29uLnRyYW5zbWlzc2lvbk1hcCApO1xuXHRcdGlmICgganNvbi50aGlja25lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRoaWNrbmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24udGhpY2tuZXNzTWFwICk7XG5cblx0XHRpZiAoIGpzb24uYW5pc290cm9weU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW5pc290cm9weU1hcCA9IGdldFRleHR1cmUoIGpzb24uYW5pc290cm9weU1hcCApO1xuXG5cdFx0aWYgKCBqc29uLnNoZWVuQ29sb3JNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNoZWVuQ29sb3JNYXAgKTtcblx0XHRpZiAoIGpzb24uc2hlZW5Sb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zaGVlblJvdWdobmVzc01hcCApO1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxuXHQvKipcblx0ICogVGV4dHVyZXMgYXJlIG5vdCBlbWJlZGRlZCBpbiB0aGUgbWF0ZXJpYWwgSlNPTiBzbyB0aGV5IGhhdmVcblx0ICogdG8gYmUgaW5qZWN0ZWQgYmVmb3JlIHRoZSBsb2FkaW5nIHByb2Nlc3Mgc3RhcnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBBIGRpY3Rpb25hcnkgaG9sZGluZyB0ZXh0dXJlcyBmb3IgbWF0ZXJpYWwgcHJvcGVydGllcy5cblx0ICogQHJldHVybiB7TWF0ZXJpYWxMb2FkZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0ZXJpYWwgbG9hZGVyLlxuXHQgKi9cblx0c2V0VGV4dHVyZXMoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG1hdGVyaWFsIGZvciB0aGUgZ2l2ZW4gdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgbWF0ZXJpYWwgdHlwZS5cblx0ICogQHJldHVybiB7TWF0ZXJpYWx9IFRoZSBuZXcgbWF0ZXJpYWwuXG5cdCAqL1xuXHRjcmVhdGVNYXRlcmlhbEZyb21UeXBlKCB0eXBlICkge1xuXG5cdFx0cmV0dXJuIE1hdGVyaWFsTG9hZGVyLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBtYXRlcmlhbCBmb3IgdGhlIGdpdmVuIHR5cGUuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgbWF0ZXJpYWwgdHlwZS5cblx0ICogQHJldHVybiB7TWF0ZXJpYWx9IFRoZSBuZXcgbWF0ZXJpYWwuXG5cdCAqL1xuXHRzdGF0aWMgY3JlYXRlTWF0ZXJpYWxGcm9tVHlwZSggdHlwZSApIHtcblxuXHRcdGNvbnN0IG1hdGVyaWFsTGliID0ge1xuXHRcdFx0U2hhZG93TWF0ZXJpYWwsXG5cdFx0XHRTcHJpdGVNYXRlcmlhbCxcblx0XHRcdFJhd1NoYWRlck1hdGVyaWFsLFxuXHRcdFx0U2hhZGVyTWF0ZXJpYWwsXG5cdFx0XHRQb2ludHNNYXRlcmlhbCxcblx0XHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRcdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwsXG5cdFx0XHRNZXNoUGhvbmdNYXRlcmlhbCxcblx0XHRcdE1lc2hUb29uTWF0ZXJpYWwsXG5cdFx0XHRNZXNoTm9ybWFsTWF0ZXJpYWwsXG5cdFx0XHRNZXNoTGFtYmVydE1hdGVyaWFsLFxuXHRcdFx0TWVzaERlcHRoTWF0ZXJpYWwsXG5cdFx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbCxcblx0XHRcdE1lc2hCYXNpY01hdGVyaWFsLFxuXHRcdFx0TWVzaE1hdGNhcE1hdGVyaWFsLFxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsLFxuXHRcdFx0TGluZUJhc2ljTWF0ZXJpYWwsXG5cdFx0XHRNYXRlcmlhbFxuXHRcdH07XG5cblx0XHRyZXR1cm4gbmV3IG1hdGVyaWFsTGliWyB0eXBlIF0oKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTWF0ZXJpYWxMb2FkZXIgfTtcbiIsIi8qKlxuICogQSBjbGFzcyB3aXRoIGxvYWRlciB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgTG9hZGVyVXRpbHMge1xuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgYmFzZSBVUkwgZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC1UaGUgVVJMIHRvIGV4dHJhY3QgdGhlIGJhc2UgVVJMIGZyb20uXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGV4dHJhY3RlZCBiYXNlIFVSTC5cblx0ICovXG5cdHN0YXRpYyBleHRyYWN0VXJsQmFzZSggdXJsICkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSB1cmwubGFzdEluZGV4T2YoICcvJyApO1xuXG5cdFx0aWYgKCBpbmRleCA9PT0gLSAxICkgcmV0dXJuICcuLyc7XG5cblx0XHRyZXR1cm4gdXJsLnNsaWNlKCAwLCBpbmRleCArIDEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc29sdmVzIHJlbGF0aXZlIFVSTHMgYWdhaW5zdCB0aGUgZ2l2ZW4gcGF0aC4gQWJzb2x1dGUgcGF0aHMsIGRhdGEgdXJscyxcblx0ICogYW5kIGJsb2IgVVJMcyB3aWxsIGJlIHJldHVybmVkIGFzIGlzLiBJbnZhbGlkIFVSTHMgd2lsbCByZXR1cm4gYW4gZW1wdHlcblx0ICogc3RyaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC1UaGUgVVJMIHRvIHJlc29sdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIGJhc2UgcGF0aCBmb3IgcmVsYXRpdmUgVVJMcyB0byBiZSByZXNvbHZlZCBhZ2FpbnN0LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZXNvbHZlZCBVUkwuXG5cdCAqL1xuXHRzdGF0aWMgcmVzb2x2ZVVSTCggdXJsLCBwYXRoICkge1xuXG5cdFx0Ly8gSW52YWxpZCBVUkxcblx0XHRpZiAoIHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0XHQvLyBIb3N0IFJlbGF0aXZlIFVSTFxuXHRcdGlmICggL15odHRwcz86XFwvXFwvL2kudGVzdCggcGF0aCApICYmIC9eXFwvLy50ZXN0KCB1cmwgKSApIHtcblxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSggLyheaHR0cHM/OlxcL1xcL1teXFwvXSspLiovaSwgJyQxJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGUgVVJMIGh0dHA6Ly8saHR0cHM6Ly8sLy9cblx0XHRpZiAoIC9eKGh0dHBzPzopP1xcL1xcLy9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIERhdGEgVVJJXG5cdFx0aWYgKCAvXmRhdGE6LiosLiokL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gQmxvYiBVUkxcblx0XHRpZiAoIC9eYmxvYjouKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBSZWxhdGl2ZSBVUkxcblx0XHRyZXR1cm4gcGF0aCArIHVybDtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTG9hZGVyVXRpbHMgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi9CdWZmZXJHZW9tZXRyeS5qcyc7XG5cbi8qKlxuICogQW4gaW5zdGFuY2VkIHZlcnNpb24gb2YgYSBnZW9tZXRyeS5cbiAqL1xuY2xhc3MgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2VkIGJ1ZmZlciBnZW9tZXRyeS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGluc3RhbmNlIGNvdW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBJbmZpbml0eVxuXHRcdCAqL1xuXHRcdHRoaXMuaW5zdGFuY2VDb3VudCA9IEluZmluaXR5O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuaW5zdGFuY2VDb3VudCA9IHNvdXJjZS5pbnN0YW5jZUNvdW50O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEuaW5zdGFuY2VDb3VudCA9IHRoaXMuaW5zdGFuY2VDb3VudDtcblxuXHRcdGRhdGEuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xuaW1wb3J0IHsgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlciB9IGZyb20gJy4uL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xuaW1wb3J0IHsgZ2V0VHlwZWRBcnJheSB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgbG9hZGluZyBnZW9tZXRyaWVzLiBUaGUgZmlsZXMgYXJlIGludGVybmFsbHlcbiAqIGxvYWRlZCB2aWEge0BsaW5rIEZpbGVMb2FkZXJ9LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcbiAqIGNvbnN0IGdlb21ldHJ5ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyggJ21vZGVscy9qc29uL3ByZXNzdXJlLmpzb24nICk7XG4gKlxuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4RjVGNUY1IH0gKTtcbiAqIGNvbnN0IG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggb2JqZWN0ICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTG9hZGVyXG4gKi9cbmNsYXNzIEJ1ZmZlckdlb21ldHJ5TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBnZW9tZXRyeSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbG9hZGluZyBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIHBhc3MgdGhlIGxvYWRlZCBnZW9tZXRyeSB0byB0aGUgYG9uTG9hZCgpYCBjYWxsYmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBwYXRoL1VSTCBvZiB0aGUgZmlsZSB0byBiZSBsb2FkZWQuIFRoaXMgY2FuIGFsc28gYmUgYSBkYXRhIFVSSS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihCdWZmZXJHZW9tZXRyeSl9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gdGhlIGxvYWRpbmcgcHJvY2VzcyBoYXMgYmVlbiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtvblByb2dyZXNzQ2FsbGJhY2t9IG9uUHJvZ3Jlc3MgLSBFeGVjdXRlZCB3aGlsZSB0aGUgbG9hZGluZyBpcyBpbiBwcm9ncmVzcy5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICovXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTiBvYmplY3QgYW5kIHJldHVybnMgYSBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgc2VyaWFsaXplZCBnZW9tZXRyeS5cblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9IFRoZSBwYXJzZWQgZ2VvbWV0cnkuXG5cdCAqL1xuXHRwYXJzZSgganNvbiApIHtcblxuXHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyTWFwID0ge307XG5cdFx0Y29uc3QgYXJyYXlCdWZmZXJNYXAgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdldEludGVybGVhdmVkQnVmZmVyKCBqc29uLCB1dWlkICkge1xuXG5cdFx0XHRpZiAoIGludGVybGVhdmVkQnVmZmVyTWFwWyB1dWlkIF0gIT09IHVuZGVmaW5lZCApIHJldHVybiBpbnRlcmxlYXZlZEJ1ZmZlck1hcFsgdXVpZCBdO1xuXG5cdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlcnMgPSBqc29uLmludGVybGVhdmVkQnVmZmVycztcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gaW50ZXJsZWF2ZWRCdWZmZXJzWyB1dWlkIF07XG5cblx0XHRcdGNvbnN0IGJ1ZmZlciA9IGdldEFycmF5QnVmZmVyKCBqc29uLCBpbnRlcmxlYXZlZEJ1ZmZlci5idWZmZXIgKTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBnZXRUeXBlZEFycmF5KCBpbnRlcmxlYXZlZEJ1ZmZlci50eXBlLCBidWZmZXIgKTtcblx0XHRcdGNvbnN0IGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgaW50ZXJsZWF2ZWRCdWZmZXIuc3RyaWRlICk7XG5cdFx0XHRpYi51dWlkID0gaW50ZXJsZWF2ZWRCdWZmZXIudXVpZDtcblxuXHRcdFx0aW50ZXJsZWF2ZWRCdWZmZXJNYXBbIHV1aWQgXSA9IGliO1xuXG5cdFx0XHRyZXR1cm4gaWI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcigganNvbiwgdXVpZCApIHtcblxuXHRcdFx0aWYgKCBhcnJheUJ1ZmZlck1hcFsgdXVpZCBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYXJyYXlCdWZmZXJNYXBbIHV1aWQgXTtcblxuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXJzID0ganNvbi5hcnJheUJ1ZmZlcnM7XG5cdFx0XHRjb25zdCBhcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyc1sgdXVpZCBdO1xuXG5cdFx0XHRjb25zdCBhYiA9IG5ldyBVaW50MzJBcnJheSggYXJyYXlCdWZmZXIgKS5idWZmZXI7XG5cblx0XHRcdGFycmF5QnVmZmVyTWFwWyB1dWlkIF0gPSBhYjtcblxuXHRcdFx0cmV0dXJuIGFiO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBqc29uLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPyBuZXcgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XG5cblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KCBpbmRleC50eXBlLCBpbmRleC5hcnJheSApO1xuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0bGV0IGJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGdldEludGVybGVhdmVkQnVmZmVyKCBqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhICk7XG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggYXR0cmlidXRlLnR5cGUsIGF0dHJpYnV0ZS5hcnJheSApO1xuXHRcdFx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGVDb25zdHIgPSBhdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgOiBCdWZmZXJBdHRyaWJ1dGU7XG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBidWZmZXJBdHRyaWJ1dGVDb25zdHIoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQgKSBidWZmZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGUudXNhZ2UgIT09IHVuZGVmaW5lZCApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRVc2FnZSggYXR0cmlidXRlLnVzYWdlICk7XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGpzb24uZGF0YS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRpZiAoIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheSA9IG1vcnBoQXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVsgaSBdO1xuXHRcdFx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGdldEludGVybGVhdmVkQnVmZmVyKCBqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhICk7XG5cdFx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggYXR0cmlidXRlLnR5cGUsIGF0dHJpYnV0ZS5hcnJheSApO1xuXHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUubmFtZSAhPT0gdW5kZWZpbmVkICkgYnVmZmVyQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCBidWZmZXJBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzWyBrZXkgXSA9IGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGpzb24uZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcblxuXHRcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5uYW1lICkgZ2VvbWV0cnkubmFtZSA9IGpzb24ubmFtZTtcblx0XHRpZiAoIGpzb24udXNlckRhdGEgKSBnZW9tZXRyeS51c2VyRGF0YSA9IGpzb24udXNlckRhdGE7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5TG9hZGVyIH07XG4iLCJpbXBvcnQge1xuXHRVVk1hcHBpbmcsXG5cdEN1YmVSZWZsZWN0aW9uTWFwcGluZyxcblx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxuXHRFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcblx0RXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuXG5cdFJlcGVhdFdyYXBwaW5nLFxuXHRDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuXG5cdE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHROZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJGaWx0ZXIsXG5cdExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJy4uL29iamVjdHMvR3JvdXAuanMnO1xuaW1wb3J0IHsgSW5zdGFuY2VkTWVzaCB9IGZyb20gJy4uL29iamVjdHMvSW5zdGFuY2VkTWVzaC5qcyc7XG5pbXBvcnQgeyBCYXRjaGVkTWVzaCB9IGZyb20gJy4uL29iamVjdHMvQmF0Y2hlZE1lc2guanMnO1xuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi4vb2JqZWN0cy9TcHJpdGUuanMnO1xuaW1wb3J0IHsgUG9pbnRzIH0gZnJvbSAnLi4vb2JqZWN0cy9Qb2ludHMuanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4uL29iamVjdHMvTGluZS5qcyc7XG5pbXBvcnQgeyBMaW5lTG9vcCB9IGZyb20gJy4uL29iamVjdHMvTGluZUxvb3AuanMnO1xuaW1wb3J0IHsgTGluZVNlZ21lbnRzIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lU2VnbWVudHMuanMnO1xuaW1wb3J0IHsgTE9EIH0gZnJvbSAnLi4vb2JqZWN0cy9MT0QuanMnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XG5pbXBvcnQgeyBTa2lubmVkTWVzaCB9IGZyb20gJy4uL29iamVjdHMvU2tpbm5lZE1lc2guanMnO1xuaW1wb3J0IHsgQm9uZSB9IGZyb20gJy4uL29iamVjdHMvQm9uZS5qcyc7XG5pbXBvcnQgeyBTa2VsZXRvbiB9IGZyb20gJy4uL29iamVjdHMvU2tlbGV0b24uanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5pbXBvcnQgeyBGb2cgfSBmcm9tICcuLi9zY2VuZXMvRm9nLmpzJztcbmltcG9ydCB7IEZvZ0V4cDIgfSBmcm9tICcuLi9zY2VuZXMvRm9nRXhwMi5qcyc7XG5pbXBvcnQgeyBIZW1pc3BoZXJlTGlnaHQgfSBmcm9tICcuLi9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzJztcbmltcG9ydCB7IFNwb3RMaWdodCB9IGZyb20gJy4uL2xpZ2h0cy9TcG90TGlnaHQuanMnO1xuaW1wb3J0IHsgUG9pbnRMaWdodCB9IGZyb20gJy4uL2xpZ2h0cy9Qb2ludExpZ2h0LmpzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHQgfSBmcm9tICcuLi9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qcyc7XG5pbXBvcnQgeyBBbWJpZW50TGlnaHQgfSBmcm9tICcuLi9saWdodHMvQW1iaWVudExpZ2h0LmpzJztcbmltcG9ydCB7IFJlY3RBcmVhTGlnaHQgfSBmcm9tICcuLi9saWdodHMvUmVjdEFyZWFMaWdodC5qcyc7XG5pbXBvcnQgeyBMaWdodFByb2JlIH0gZnJvbSAnLi4vbGlnaHRzL0xpZ2h0UHJvYmUuanMnO1xuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMnO1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuLi9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzJztcbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnLi4vc2NlbmVzL1NjZW5lLmpzJztcbmltcG9ydCB7IEN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vdGV4dHVyZXMvU291cmNlLmpzJztcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xuaW1wb3J0IHsgSW1hZ2VMb2FkZXIgfSBmcm9tICcuL0ltYWdlTG9hZGVyLmpzJztcbmltcG9ydCB7IExvYWRpbmdNYW5hZ2VyIH0gZnJvbSAnLi9Mb2FkaW5nTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBBbmltYXRpb25DbGlwIH0gZnJvbSAnLi4vYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanMnO1xuaW1wb3J0IHsgTWF0ZXJpYWxMb2FkZXIgfSBmcm9tICcuL01hdGVyaWFsTG9hZGVyLmpzJztcbmltcG9ydCB7IExvYWRlclV0aWxzIH0gZnJvbSAnLi9Mb2FkZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeUxvYWRlciB9IGZyb20gJy4vQnVmZmVyR2VvbWV0cnlMb2FkZXIuanMnO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XG5pbXBvcnQgKiBhcyBHZW9tZXRyaWVzIGZyb20gJy4uL2dlb21ldHJpZXMvR2VvbWV0cmllcy5qcyc7XG5pbXBvcnQgeyBnZXRUeXBlZEFycmF5IH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQm94MyB9IGZyb20gJy4uL21hdGgvQm94My5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5cbi8qKlxuICogQSBsb2FkZXIgZm9yIGxvYWRpbmcgYSBKU09OIHJlc291cmNlIGluIHRoZSBbSlNPTiBPYmplY3QvU2NlbmUgZm9ybWF0XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3dpa2kvSlNPTi1PYmplY3QtU2NlbmUtZm9ybWF0LTR9LlxuICogVGhlIGZpbGVzIGFyZSBpbnRlcm5hbGx5IGxvYWRlZCB2aWEge0BsaW5rIEZpbGVMb2FkZXJ9LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuT2JqZWN0TG9hZGVyKCk7XG4gKiBjb25zdCBvYmogPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCAnbW9kZWxzL2pzb24vZXhhbXBsZS5qc29uJyApO1xuICogc2NlbmUuYWRkKCBvYmogKTtcbiAqXG4gKiAvLyBBbHRlcm5hdGl2ZWx5LCB0byBwYXJzZSBhIHByZXZpb3VzbHkgbG9hZGVkIEpTT04gc3RydWN0dXJlXG4gKiBjb25zdCBvYmplY3QgPSBhd2FpdCBsb2FkZXIucGFyc2VBc3luYyggYV9qc29uX29iamVjdCApO1xuICogc2NlbmUuYWRkKCBvYmplY3QgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMb2FkZXJcbiAqL1xuY2xhc3MgT2JqZWN0TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBvYmplY3QgbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xvYWRpbmdNYW5hZ2VyfSBbbWFuYWdlcl0gLSBUaGUgbG9hZGluZyBtYW5hZ2VyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGxvYWRpbmcgZnJvbSB0aGUgZ2l2ZW4gVVJMIGFuZCBwYXNzIHRoZSBsb2FkZWQgM0Qgb2JqZWN0IHRvIHRoZSBgb25Mb2FkKClgIGNhbGxiYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHBhdGgvVVJMIG9mIHRoZSBmaWxlIHRvIGJlIGxvYWRlZC4gVGhpcyBjYW4gYWxzbyBiZSBhIGRhdGEgVVJJLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdDNEKX0gb25Mb2FkIC0gRXhlY3V0ZWQgd2hlbiB0aGUgbG9hZGluZyBwcm9jZXNzIGhhcyBiZWVuIGZpbmlzaGVkLlxuXHQgKiBAcGFyYW0ge29uUHJvZ3Jlc3NDYWxsYmFja30gb25Qcm9ncmVzcyAtIEV4ZWN1dGVkIHdoaWxlIHRoZSBsb2FkaW5nIGlzIGluIHByb2dyZXNzLlxuXHQgKiBAcGFyYW0ge29uRXJyb3JDYWxsYmFja30gb25FcnJvciAtIEV4ZWN1dGVkIHdoZW4gZXJyb3JzIG9jY3VyLlxuXHQgKi9cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdGxldCBqc29uID0gbnVsbDtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdGlmICggbWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApICk7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLnBhcnNlKCBqc29uLCBvbkxvYWQgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jIHZlcnNpb24gb2Yge0BsaW5rIE9iamVjdExvYWRlciNsb2FkfS5cblx0ICpcblx0ICogQGFzeW5jXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGEgZGF0YSBVUkkuXG5cdCAqIEBwYXJhbSB7b25Qcm9ncmVzc0NhbGxiYWNrfSBvblByb2dyZXNzIC0gRXhlY3V0ZWQgd2hpbGUgdGhlIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3MuXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2FkZWQgM0Qgb2JqZWN0LlxuXHQgKi9cblx0YXN5bmMgbG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKTtcblxuXHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cblx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF3YWl0IHNjb3BlLnBhcnNlQXN5bmMoIGpzb24gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gSlNPTi4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIE9iamVjdExvYWRlciNsb2FkfVxuXHQgKiBidXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSB0byBwYXJzZSBhIHByZXZpb3VzbHkgbG9hZGVkIEpTT04gc3RydWN0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBzZXJpYWxpemVkIDNEIG9iamVjdC5cblx0ICogQHBhcmFtIHtvbkxvYWR9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gYWxsIHJlc291cmNlcyAoZS5nLiB0ZXh0dXJlcykgaGF2ZSBiZWVuIGZ1bGx5IGxvYWRlZC5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IFRoZSBwYXJzZWQgM0Qgb2JqZWN0LlxuXHQgKi9cblx0cGFyc2UoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcygganNvbi5zaGFwZXMgKTtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XG5cblx0XHRjb25zdCBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucygganNvbi5za2VsZXRvbnMsIG9iamVjdCApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xuXHRcdHRoaXMuYmluZExpZ2h0VGFyZ2V0cyggb2JqZWN0ICk7XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGV0IGhhc0ltYWdlcyA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB1dWlkIGluIGltYWdlcyApIHtcblxuXHRcdFx0XHRpZiAoIGltYWdlc1sgdXVpZCBdLmRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0aGFzSW1hZ2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNJbWFnZXMgPT09IGZhbHNlICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBc3luYyB2ZXJzaW9uIG9mIHtAbGluayBPYmplY3RMb2FkZXIjcGFyc2V9LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBzZXJpYWxpemVkIDNEIG9iamVjdC5cblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHBhcnNlZCAzRCBvYmplY3QuXG5cdCAqL1xuXHRhc3luYyBwYXJzZUFzeW5jKCBqc29uICkge1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKCBqc29uLmFuaW1hdGlvbnMgKTtcblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGVzKCBqc29uLnNoYXBlcyApO1xuXHRcdGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzLCBzaGFwZXMgKTtcblxuXHRcdGNvbnN0IGltYWdlcyA9IGF3YWl0IHRoaXMucGFyc2VJbWFnZXNBc3luYygganNvbi5pbWFnZXMgKTtcblxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucygganNvbi5za2VsZXRvbnMsIG9iamVjdCApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xuXHRcdHRoaXMuYmluZExpZ2h0VGFyZ2V0cyggb2JqZWN0ICk7XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH1cblxuXHQvLyBpbnRlcm5hbHNcblxuXHRwYXJzZVNoYXBlcygganNvbiApIHtcblxuXHRcdGNvbnN0IHNoYXBlcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IG5ldyBTaGFwZSgpLmZyb21KU09OKCBqc29uWyBpIF0gKTtcblxuXHRcdFx0XHRzaGFwZXNbIHNoYXBlLnV1aWQgXSA9IHNoYXBlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxuXHRwYXJzZVNrZWxldG9ucygganNvbiwgb2JqZWN0ICkge1xuXG5cdFx0Y29uc3Qgc2tlbGV0b25zID0ge307XG5cdFx0Y29uc3QgYm9uZXMgPSB7fTtcblxuXHRcdC8vIGdlbmVyYXRlIGJvbmUgbG9va3VwIHRhYmxlXG5cblx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGlmICggY2hpbGQuaXNCb25lICkgYm9uZXNbIGNoaWxkLnV1aWQgXSA9IGNoaWxkO1xuXG5cdFx0fSApO1xuXG5cdFx0Ly8gY3JlYXRlIHNrZWxldG9uc1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbigpLmZyb21KU09OKCBqc29uWyBpIF0sIGJvbmVzICk7XG5cblx0XHRcdFx0c2tlbGV0b25zWyBza2VsZXRvbi51dWlkIF0gPSBza2VsZXRvbjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNrZWxldG9ucztcblxuXHR9XG5cblx0cGFyc2VHZW9tZXRyaWVzKCBqc29uLCBzaGFwZXMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBnZW9tZXRyeTtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0Y2FzZSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGlmICggZGF0YS50eXBlIGluIEdlb21ldHJpZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXS5mcm9tSlNPTiggZGF0YSwgc2hhcGVzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBgVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJHsgZGF0YS50eXBlIH1cImAgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcblxuXHR9XG5cblx0cGFyc2VNYXRlcmlhbHMoIGpzb24sIHRleHR1cmVzICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB7fTsgLy8gTXVsdGlNYXRlcmlhbFxuXHRcdGNvbnN0IG1hdGVyaWFscyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuXHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNhY2hlWyBkYXRhLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y2FjaGVbIGRhdGEudXVpZCBdID0gbG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBjYWNoZVsgZGF0YS51dWlkIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0fVxuXG5cdHBhcnNlQW5pbWF0aW9ucygganNvbiApIHtcblxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0YW5pbWF0aW9uc1sgY2xpcC51dWlkIF0gPSBjbGlwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuXHR9XG5cblx0cGFyc2VJbWFnZXMoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25zdCBpbWFnZXMgPSB7fTtcblxuXHRcdGxldCBsb2FkZXI7XG5cblx0XHRmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRyZXR1cm4gbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZSggaW1hZ2UgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGltYWdlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZTtcblxuXHRcdFx0XHRjb25zdCBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCB1cmwgKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblxuXHRcdFx0XHRyZXR1cm4gbG9hZEltYWdlKCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRhdGE6IGdldFR5cGVkQXJyYXkoIGltYWdlLnR5cGUsIGltYWdlLmRhdGEgKSxcblx0XHRcdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xuXG5cdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0ganNvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IGpzb25bIGkgXTtcblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2UudXJsO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cblx0XHRcdFx0XHQvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcblxuXHRcdFx0XHRcdGNvbnN0IGltYWdlQXJyYXkgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB1cmwubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRVcmwgPSB1cmxbIGogXTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKCBjdXJyZW50VXJsICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGVzZXJpYWxpemVkSW1hZ2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIGRlc2VyaWFsaXplZEltYWdlICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaCggbmV3IERhdGFUZXh0dXJlKCBkZXNlcmlhbGl6ZWRJbWFnZS5kYXRhLCBkZXNlcmlhbGl6ZWRJbWFnZS53aWR0aCwgZGVzZXJpYWxpemVkSW1hZ2UuaGVpZ2h0ICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbmV3IFNvdXJjZSggaW1hZ2VBcnJheSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBsb2FkIHNpbmdsZSBpbWFnZVxuXG5cdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKCBpbWFnZS51cmwgKTtcblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGRlc2VyaWFsaXplZEltYWdlICk7XG5cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZXM7XG5cblx0fVxuXG5cdGFzeW5jIHBhcnNlSW1hZ2VzQXN5bmMoIGpzb24gKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgaW1hZ2VzID0ge307XG5cblx0XHRsZXQgbG9hZGVyO1xuXG5cdFx0YXN5bmMgZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZSggaW1hZ2UgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGltYWdlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZTtcblxuXHRcdFx0XHRjb25zdCBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCB1cmwgKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblxuXHRcdFx0XHRyZXR1cm4gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyggcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggaW1hZ2UuZGF0YSApIHtcblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBnZXRUeXBlZEFycmF5KCBpbWFnZS50eXBlLCBpbWFnZS5kYXRhICksXG5cdFx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBqc29uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0ganNvblsgaSBdO1xuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZS51cmw7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxuXG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2VBcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFVybCA9IHVybFsgaiBdO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGF3YWl0IGRlc2VyaWFsaXplSW1hZ2UoIGN1cnJlbnRVcmwgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaCggZGVzZXJpYWxpemVkSW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcyBmb3IgY3ViZSB0ZXh0dXJlc1xuXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VBcnJheS5wdXNoKCBuZXcgRGF0YVRleHR1cmUoIGRlc2VyaWFsaXplZEltYWdlLmRhdGEsIGRlc2VyaWFsaXplZEltYWdlLndpZHRoLCBkZXNlcmlhbGl6ZWRJbWFnZS5oZWlnaHQgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBpbWFnZUFycmF5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGxvYWQgc2luZ2xlIGltYWdlXG5cblx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGF3YWl0IGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlLnVybCApO1xuXHRcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbmV3IFNvdXJjZSggZGVzZXJpYWxpemVkSW1hZ2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZXM7XG5cblx0fVxuXG5cdHBhcnNlVGV4dHVyZXMoIGpzb24sIGltYWdlcyApIHtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlLCB0eXBlICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcblxuXHRcdFx0cmV0dXJuIHR5cGVbIHZhbHVlIF07XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xuXG5cdFx0XHRcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcImltYWdlXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc291cmNlID0gaW1hZ2VzWyBkYXRhLmltYWdlIF07XG5cdFx0XHRcdGNvbnN0IGltYWdlID0gc291cmNlLmRhdGE7XG5cblx0XHRcdFx0bGV0IHRleHR1cmU7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbWFnZSApICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBpbWFnZS5sZW5ndGggPT09IDYgKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBpbWFnZSAmJiBpbWFnZS5kYXRhICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaW1hZ2UgKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gdGV4dHVyZXMgY2FuIGhhdmUgdW5kZWZpbmVkIGltYWdlIGRhdGFcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5zb3VyY2UgPSBzb3VyY2U7XG5cblx0XHRcdFx0dGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZywgVEVYVFVSRV9NQVBQSU5HICk7XG5cdFx0XHRcdGlmICggZGF0YS5jaGFubmVsICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNoYW5uZWwgPSBkYXRhLmNoYW5uZWw7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBkYXRhLm9mZnNldCApO1xuXHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIGRhdGEucmVwZWF0ICk7XG5cdFx0XHRcdGlmICggZGF0YS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY2VudGVyLmZyb21BcnJheSggZGF0YS5jZW50ZXIgKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcblxuXHRcdFx0XHRpZiAoIGRhdGEud3JhcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMCBdLCBURVhUVVJFX1dSQVBQSU5HICk7XG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdLCBURVhUVVJFX1dSQVBQSU5HICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5mb3JtYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XG5cdFx0XHRcdGlmICggZGF0YS5pbnRlcm5hbEZvcm1hdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9IGRhdGEuaW50ZXJuYWxGb3JtYXQ7XG5cdFx0XHRcdGlmICggZGF0YS50eXBlICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0XHRcdGlmICggZGF0YS5jb2xvclNwYWNlICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBkYXRhLmNvbG9yU3BhY2U7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcblx0XHRcdFx0aWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcblx0XHRcdFx0aWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZmxpcFkgPSBkYXRhLmZsaXBZO1xuXG5cdFx0XHRcdGlmICggZGF0YS5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZGF0YS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHRcdGlmICggZGF0YS5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSBkYXRhLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0XHRcdGlmICggZGF0YS51bnBhY2tBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ID0gZGF0YS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0XHRcdGlmICggZGF0YS5jb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uID0gZGF0YS5jb21wYXJlRnVuY3Rpb247XG5cblx0XHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuXHRcdFx0XHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZXM7XG5cblx0fVxuXG5cdHBhcnNlT2JqZWN0KCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICkge1xuXG5cdFx0bGV0IG9iamVjdDtcblxuXHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcblxuXHRcdFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHV1aWQgPSBuYW1lWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgdXVpZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWxzWyB1dWlkIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCB1dWlkICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmVzWyB1dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgdXVpZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlc1sgdXVpZCBdO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGdlb21ldHJ5LCBtYXRlcmlhbDtcblxuXHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnU2NlbmUnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xuXG5cdFx0XHRcdGlmICggZGF0YS5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE51bWJlci5pc0ludGVnZXIoIGRhdGEuYmFja2dyb3VuZCApICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IG5ldyBDb2xvciggZGF0YS5iYWNrZ3JvdW5kICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IGdldFRleHR1cmUoIGRhdGEuYmFja2dyb3VuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRhdGEuZW52aXJvbm1lbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IGdldFRleHR1cmUoIGRhdGEuZW52aXJvbm1lbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLmZvZyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nJyApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2coIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5uZWFyLCBkYXRhLmZvZy5mYXIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJyApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2dFeHAyKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZvZy5uYW1lICE9PSAnJyApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmZvZy5uYW1lID0gZGF0YS5mb2cubmFtZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmRCbHVycmluZXNzICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBkYXRhLmJhY2tncm91bmRCbHVycmluZXNzO1xuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJhY2tncm91bmRJbnRlbnNpdHkgPSBkYXRhLmJhY2tncm91bmRJbnRlbnNpdHk7XG5cdFx0XHRcdGlmICggZGF0YS5iYWNrZ3JvdW5kUm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5iYWNrZ3JvdW5kUm90YXRpb24uZnJvbUFycmF5KCBkYXRhLmJhY2tncm91bmRSb3RhdGlvbiApO1xuXG5cdFx0XHRcdGlmICggZGF0YS5lbnZpcm9ubWVudEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmVudmlyb25tZW50SW50ZW5zaXR5ID0gZGF0YS5lbnZpcm9ubWVudEludGVuc2l0eTtcblx0XHRcdFx0aWYgKCBkYXRhLmVudmlyb25tZW50Um90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5lbnZpcm9ubWVudFJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5lbnZpcm9ubWVudFJvdGF0aW9uICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdGlmICggZGF0YS5mb2N1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZvY3VzID0gZGF0YS5mb2N1cztcblx0XHRcdFx0aWYgKCBkYXRhLnpvb20gIT09IHVuZGVmaW5lZCApIG9iamVjdC56b29tID0gZGF0YS56b29tO1xuXHRcdFx0XHRpZiAoIGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbUdhdWdlID0gZGF0YS5maWxtR2F1Z2U7XG5cdFx0XHRcdGlmICggZGF0YS5maWxtT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbU9mZnNldCA9IGRhdGEuZmlsbU9mZnNldDtcblx0XHRcdFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLnpvb20gIT09IHVuZGVmaW5lZCApIG9iamVjdC56b29tID0gZGF0YS56b29tO1xuXHRcdFx0XHRpZiAoIGRhdGEudmlldyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgZGF0YS52aWV3ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IEFtYmllbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cdFx0XHRcdG9iamVjdC50YXJnZXQgPSBkYXRhLnRhcmdldCB8fCAnJztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBSZWN0QXJlYUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5wZW51bWJyYSwgZGF0YS5kZWNheSApO1xuXHRcdFx0XHRvYmplY3QudGFyZ2V0ID0gZGF0YS50YXJnZXQgfHwgJyc7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnTGlnaHRQcm9iZSc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTiggZGF0YSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdTa2lubmVkTWVzaCc6XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xuXHRcdFx0IFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmJpbmRNb2RlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYmluZE1vZGUgPSBkYXRhLmJpbmRNb2RlO1xuXHRcdFx0XHRpZiAoIGRhdGEuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJpbmRNYXRyaXguZnJvbUFycmF5KCBkYXRhLmJpbmRNYXRyaXggKTtcblx0XHRcdFx0aWYgKCBkYXRhLnNrZWxldG9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdNZXNoJzpcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0luc3RhbmNlZE1lc2gnOlxuXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGRhdGEuY291bnQ7XG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlTWF0cml4ID0gZGF0YS5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvciA9IGRhdGEuaW5zdGFuY2VDb2xvcjtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgSW5zdGFuY2VkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCApO1xuXHRcdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBpbnN0YW5jZU1hdHJpeC5hcnJheSApLCAxNiApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlQ29sb3IgIT09IHVuZGVmaW5lZCApIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggaW5zdGFuY2VDb2xvci5hcnJheSApLCBpbnN0YW5jZUNvbG9yLml0ZW1TaXplICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0JhdGNoZWRNZXNoJzpcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgQmF0Y2hlZE1lc2goIGRhdGEubWF4SW5zdGFuY2VDb3VudCwgZGF0YS5tYXhWZXJ0ZXhDb3VudCwgZGF0YS5tYXhJbmRleENvdW50LCBtYXRlcmlhbCApO1xuXHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdFx0b2JqZWN0LnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSBkYXRhLnBlck9iamVjdEZydXN0dW1DdWxsZWQ7XG5cdFx0XHRcdG9iamVjdC5zb3J0T2JqZWN0cyA9IGRhdGEuc29ydE9iamVjdHM7XG5cblx0XHRcdFx0b2JqZWN0Ll9kcmF3UmFuZ2VzID0gZGF0YS5kcmF3UmFuZ2VzO1xuXHRcdFx0XHRvYmplY3QuX3Jlc2VydmVkUmFuZ2VzID0gZGF0YS5yZXNlcnZlZFJhbmdlcztcblxuXHRcdFx0XHRvYmplY3QuX2dlb21ldHJ5SW5mbyA9IGRhdGEuZ2VvbWV0cnlJbmZvLm1hcCggaW5mbyA9PiB7XG5cblx0XHRcdFx0XHRsZXQgYm94ID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgc3BoZXJlID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoIGluZm8uYm91bmRpbmdCb3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ym94ID0gbmV3IEJveDMoKTtcblx0XHRcdFx0XHRcdGJveC5taW4uZnJvbUFycmF5KCBpbmZvLmJvdW5kaW5nQm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0Ym94Lm1heC5mcm9tQXJyYXkoIGluZm8uYm91bmRpbmdCb3gubWF4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGluZm8uYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0c3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXHRcdFx0XHRcdFx0c3BoZXJlLnJhZGl1cyA9IGluZm8uYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXHRcdFx0XHRcdFx0c3BoZXJlLmNlbnRlci5mcm9tQXJyYXkoIGluZm8uYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0Li4uaW5mbyxcblx0XHRcdFx0XHRcdGJvdW5kaW5nQm94OiBib3gsXG5cdFx0XHRcdFx0XHRib3VuZGluZ1NwaGVyZTogc3BoZXJlXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG9iamVjdC5faW5zdGFuY2VJbmZvID0gZGF0YS5pbnN0YW5jZUluZm87XG5cblx0XHRcdFx0b2JqZWN0Ll9hdmFpbGFibGVJbnN0YW5jZUlkcyA9IGRhdGEuX2F2YWlsYWJsZUluc3RhbmNlSWRzO1xuXHRcdFx0XHRvYmplY3QuX2F2YWlsYWJsZUdlb21ldHJ5SWRzID0gZGF0YS5fYXZhaWxhYmxlR2VvbWV0cnlJZHM7XG5cblx0XHRcdFx0b2JqZWN0Ll9uZXh0SW5kZXhTdGFydCA9IGRhdGEubmV4dEluZGV4U3RhcnQ7XG5cdFx0XHRcdG9iamVjdC5fbmV4dFZlcnRleFN0YXJ0ID0gZGF0YS5uZXh0VmVydGV4U3RhcnQ7XG5cdFx0XHRcdG9iamVjdC5fZ2VvbWV0cnlDb3VudCA9IGRhdGEuZ2VvbWV0cnlDb3VudDtcblxuXHRcdFx0XHRvYmplY3QuX21heEluc3RhbmNlQ291bnQgPSBkYXRhLm1heEluc3RhbmNlQ291bnQ7XG5cdFx0XHRcdG9iamVjdC5fbWF4VmVydGV4Q291bnQgPSBkYXRhLm1heFZlcnRleENvdW50O1xuXHRcdFx0XHRvYmplY3QuX21heEluZGV4Q291bnQgPSBkYXRhLm1heEluZGV4Q291bnQ7XG5cblx0XHRcdFx0b2JqZWN0Ll9nZW9tZXRyeUluaXRpYWxpemVkID0gZGF0YS5nZW9tZXRyeUluaXRpYWxpemVkO1xuXG5cdFx0XHRcdG9iamVjdC5fbWF0cmljZXNUZXh0dXJlID0gZ2V0VGV4dHVyZSggZGF0YS5tYXRyaWNlc1RleHR1cmUudXVpZCApO1xuXG5cdFx0XHRcdG9iamVjdC5faW5kaXJlY3RUZXh0dXJlID0gZ2V0VGV4dHVyZSggZGF0YS5pbmRpcmVjdFRleHR1cmUudXVpZCApO1xuXG5cdFx0XHRcdGlmICggZGF0YS5jb2xvcnNUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuX2NvbG9yc1RleHR1cmUgPSBnZXRUZXh0dXJlKCBkYXRhLmNvbG9yc1RleHR1cmUudXVpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRhdGEuYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblx0XHRcdFx0XHRvYmplY3QuYm91bmRpbmdTcGhlcmUuY2VudGVyLmZyb21BcnJheSggZGF0YS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblx0XHRcdFx0XHRvYmplY3QuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gZGF0YS5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGF0YS5ib3VuZGluZ0JveCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblx0XHRcdFx0XHRvYmplY3QuYm91bmRpbmdCb3gubWluLmZyb21BcnJheSggZGF0YS5ib3VuZGluZ0JveC5taW4gKTtcblx0XHRcdFx0XHRvYmplY3QuYm91bmRpbmdCb3gubWF4LmZyb21BcnJheSggZGF0YS5ib3VuZGluZ0JveC5tYXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0xPRCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExPRCgpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMaW5lJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMaW5lTG9vcCc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVMb29wKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0xpbmVTZWdtZW50cyc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdQb2ludENsb3VkJzpcblx0XHRcdGNhc2UgJ1BvaW50cyc6XG5cblx0XHRcdFx0b2JqZWN0ID0gbmV3IFBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdTcHJpdGUnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnR3JvdXAnOlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdCb25lJzpcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0fVxuXG5cdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG9iamVjdC5tYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuXG5cdFx0XHRpZiAoIGRhdGEubWF0cml4QXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBkYXRhLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0XHRpZiAoIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlICkgb2JqZWN0Lm1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG5cdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcblx0XHRcdGlmICggZGF0YS5xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIGRhdGEucXVhdGVybmlvbiApO1xuXHRcdFx0aWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEudXAgIT09IHVuZGVmaW5lZCApIG9iamVjdC51cC5mcm9tQXJyYXkoIGRhdGEudXAgKTtcblxuXHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcblx0XHRpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRpZiAoIGRhdGEuc2hhZG93ICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93LmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5pbnRlbnNpdHkgPSBkYXRhLnNoYWRvdy5pbnRlbnNpdHk7XG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93LmJpYXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuYmlhcyA9IGRhdGEuc2hhZG93LmJpYXM7XG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93Lm5vcm1hbEJpYXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cubm9ybWFsQmlhcyA9IGRhdGEuc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93LnJhZGl1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5yYWRpdXMgPSBkYXRhLnNoYWRvdy5yYWRpdXM7XG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93Lm1hcFNpemUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cubWFwU2l6ZS5mcm9tQXJyYXkoIGRhdGEuc2hhZG93Lm1hcFNpemUgKTtcblx0XHRcdGlmICggZGF0YS5zaGFkb3cuY2FtZXJhICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmNhbWVyYSA9IHRoaXMucGFyc2VPYmplY3QoIGRhdGEuc2hhZG93LmNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHRcdGlmICggZGF0YS5mcnVzdHVtQ3VsbGVkICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGRhdGEuZnJ1c3R1bUN1bGxlZDtcblx0XHRpZiAoIGRhdGEucmVuZGVyT3JkZXIgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZW5kZXJPcmRlciA9IGRhdGEucmVuZGVyT3JkZXI7XG5cdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXHRcdGlmICggZGF0YS5sYXllcnMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5sYXllcnMubWFzayA9IGRhdGEubGF5ZXJzO1xuXG5cdFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3RBbmltYXRpb25zID0gZGF0YS5hbmltYXRpb25zO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RBbmltYXRpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB1dWlkID0gb2JqZWN0QW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbnNbIHV1aWQgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRhdGEudHlwZSA9PT0gJ0xPRCcgKSB7XG5cblx0XHRcdGlmICggZGF0YS5hdXRvVXBkYXRlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuYXV0b1VwZGF0ZSA9IGRhdGEuYXV0b1VwZGF0ZTtcblxuXHRcdFx0Y29uc3QgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XG5cblx0XHRcdGZvciAoIGxldCBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGwgXTtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSwgbGV2ZWwuaHlzdGVyZXNpcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cblx0YmluZFNrZWxldG9ucyggb2JqZWN0LCBza2VsZXRvbnMgKSB7XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzKCBza2VsZXRvbnMgKS5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGlmICggY2hpbGQuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSAmJiBjaGlsZC5za2VsZXRvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gc2tlbGV0b25zWyBjaGlsZC5za2VsZXRvbiBdO1xuXG5cdFx0XHRcdGlmICggc2tlbGV0b24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gc2tlbGV0b24gZm91bmQgd2l0aCBVVUlEOicsIGNoaWxkLnNrZWxldG9uICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNoaWxkLmJpbmQoIHNrZWxldG9uLCBjaGlsZC5iaW5kTWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGJpbmRMaWdodFRhcmdldHMoIG9iamVjdCApIHtcblxuXHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBjaGlsZC5pc0RpcmVjdGlvbmFsTGlnaHQgfHwgY2hpbGQuaXNTcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZCA9IGNoaWxkLnRhcmdldDtcblxuXHRcdFx0XHRjb25zdCB0YXJnZXQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCB1dWlkICk7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNoaWxkLnRhcmdldCA9IHRhcmdldDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y2hpbGQudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IFRFWFRVUkVfTUFQUElORyA9IHtcblx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXG5cdEN1YmVSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxuXHRDdWJlUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcblx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuXHRFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZ1xufTtcblxuY29uc3QgVEVYVFVSRV9XUkFQUElORyA9IHtcblx0UmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxuXHRDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG59O1xuXG5jb25zdCBURVhUVVJFX0ZJTFRFUiA9IHtcblx0TmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHROZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyOiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcblx0TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcjogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcblx0TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5cbmV4cG9ydCB7IE9iamVjdExvYWRlciB9O1xuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcblxuLyoqXG4gKiBBIGxvYWRlciBmb3IgbG9hZGluZyBpbWFnZXMgYXMgYW4gW0ltYWdlQml0bWFwXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW1hZ2VCaXRtYXB9LlxuICogQW4gYEltYWdlQml0bWFwYCBwcm92aWRlcyBhbiBhc3luY2hyb25vdXMgYW5kIHJlc291cmNlIGVmZmljaWVudCBwYXRod2F5IHRvIHByZXBhcmVcbiAqIHRleHR1cmVzIGZvciByZW5kZXJpbmcuXG4gKlxuICogTm90ZSB0aGF0IHtAbGluayBUZXh0dXJlI2ZsaXBZfSBhbmQge0BsaW5rIFRleHR1cmUjcHJlbXVsdGlwbHlBbHBoYX0gYXJlIGlnbm9yZWQgd2l0aCBpbWFnZSBiaXRtYXBzLlxuICogVGhleSBuZWVkcyB0aGVzZSBjb25maWd1cmF0aW9uIG9uIGJpdG1hcCBjcmVhdGlvbiB1bmxpa2UgcmVndWxhciBpbWFnZXMgbmVlZCB0aGVtIG9uIHVwbG9hZGluZyB0byBHUFUuXG4gKlxuICogWW91IG5lZWQgdG8gc2V0IHRoZSBlcXVpdmFsZW50IG9wdGlvbnMgdmlhIHtAbGluayBJbWFnZUJpdG1hcExvYWRlciNzZXRPcHRpb25zfSBpbnN0ZWFkLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0IHVubGlrZSB7QGxpbmsgRmlsZUxvYWRlcn0sIHRoaXMgbG9hZGVyIGRvZXMgbm90IGF2b2lkIG11bHRpcGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMgdG8gdGhlIHNhbWUgVVJMLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXIoKTtcbiAqIGxvYWRlci5zZXRPcHRpb25zKCB7IGltYWdlT3JpZW50YXRpb246ICdmbGlwWScgfSApOyAvLyBzZXQgb3B0aW9ucyBpZiBuZWVkZWRcbiAqIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyggJ2ltYWdlLnBuZycgKTtcbiAqXG4gKiBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlQml0bWFwICk7XG4gKiB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMb2FkZXJcbiAqL1xuY2xhc3MgSW1hZ2VCaXRtYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGltYWdlIGJpdG1hcCBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TG9hZGluZ01hbmFnZXJ9IFttYW5hZ2VyXSAtIFRoZSBsb2FkaW5nIG1hbmFnZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPSB0cnVlO1xuXG5cdFx0aWYgKCB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogY3JlYXRlSW1hZ2VCaXRtYXAoKSBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGZldGNoKCkgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBsb2FkZXIgb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQge3ByZW11bHRpcGx5QWxwaGE6J25vbmUnfVxuXHRcdCAqL1xuXHRcdHRoaXMub3B0aW9ucyA9IHsgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnIH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBsb2FkZXIgb3B0aW9ucy4gVGhlIHN0cnVjdHVyZSBvZiB0aGUgb2JqZWN0IG11c3QgbWF0Y2ggdGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIgb2Zcblx0ICogW2NyZWF0ZUltYWdlQml0bWFwXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2NyZWF0ZUltYWdlQml0bWFwfS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbG9hZGVyIG9wdGlvbnMgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtJbWFnZUJpdG1hcExvYWRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbWFnZSBiaXRtYXAgbG9hZGVyLlxuXHQgKi9cblx0c2V0T3B0aW9ucyggb3B0aW9ucyApIHtcblxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBsb2FkaW5nIGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgcGFzcyB0aGUgbG9hZGVkIGltYWdlIGJpdG1hcCB0byB0aGUgYG9uTG9hZCgpYCBjYWxsYmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBwYXRoL1VSTCBvZiB0aGUgZmlsZSB0byBiZSBsb2FkZWQuIFRoaXMgY2FuIGFsc28gYmUgYSBkYXRhIFVSSS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihJbWFnZUJpdG1hcCl9IG9uTG9hZCAtIEV4ZWN1dGVkIHdoZW4gdGhlIGxvYWRpbmcgcHJvY2VzcyBoYXMgYmVlbiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtvblByb2dyZXNzQ2FsbGJhY2t9IG9uUHJvZ3Jlc3MgLSBVbnN1cHBvcnRlZCBpbiB0aGlzIGxvYWRlci5cblx0ICogQHBhcmFtIHtvbkVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBFeGVjdXRlZCB3aGVuIGVycm9ycyBvY2N1ci5cblx0ICogQHJldHVybiB7SW1hZ2VCaXRtYXB8dW5kZWZpbmVkfSBUaGUgaW1hZ2UgYml0bWFwLlxuXHQgKi9cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXG5cdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0Ly8gSWYgY2FjaGVkIGlzIGEgcHJvbWlzZSwgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZVxuXHRcdFx0aWYgKCBjYWNoZWQudGhlbiApIHtcblxuXHRcdFx0XHRjYWNoZWQudGhlbiggaW1hZ2VCaXRtYXAgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdH0gKS5jYXRjaCggZSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgY2FjaGVkIGlzIG5vdCBhIHByb21pc2UgKGkuZS4sIGl0J3MgYWxyZWFkeSBhbiBpbWFnZUJpdG1hcClcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgMCApO1xuXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmV0Y2hPcHRpb25zID0ge307XG5cdFx0ZmV0Y2hPcHRpb25zLmNyZWRlbnRpYWxzID0gKCB0aGlzLmNyb3NzT3JpZ2luID09PSAnYW5vbnltb3VzJyApID8gJ3NhbWUtb3JpZ2luJyA6ICdpbmNsdWRlJztcblx0XHRmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcjtcblxuXHRcdGNvbnN0IHByb21pc2UgPSBmZXRjaCggdXJsLCBmZXRjaE9wdGlvbnMgKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0cmV0dXJuIHJlcy5ibG9iKCk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBibG9iICkge1xuXG5cdFx0XHRyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoIGJsb2IsIE9iamVjdC5hc3NpZ24oIHNjb3BlLm9wdGlvbnMsIHsgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJyB9ICkgKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGltYWdlQml0bWFwICkge1xuXG5cdFx0XHRDYWNoZS5hZGQoIHVybCwgaW1hZ2VCaXRtYXAgKTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdHJldHVybiBpbWFnZUJpdG1hcDtcblxuXHRcdH0gKS5jYXRjaCggZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XG5cblx0XHRcdENhY2hlLnJlbW92ZSggdXJsICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9ICk7XG5cblx0XHRDYWNoZS5hZGQoIHVybCwgcHJvbWlzZSApO1xuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgSW1hZ2VCaXRtYXBMb2FkZXIgfTtcbiIsImxldCBfY29udGV4dDtcblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBnbG9iYWwgYXVkaW8gY29udGV4dCBpbiB0aGUgZW5naW5lLlxuICpcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQXVkaW9Db250ZXh0IHtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZ2xvYmFsIG5hdGl2ZSBhdWRpbyBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBdWRpb0NvbnRleHR9IFRoZSBuYXRpdmUgYXVkaW8gY29udGV4dC5cblx0ICovXG5cdHN0YXRpYyBnZXRDb250ZXh0KCkge1xuXG5cdFx0aWYgKCBfY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2NvbnRleHQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgdG8gc2V0IHRoZSBnbG9iYWwgbmF0aXZlIGF1ZGlvIGNvbnRleHQgZnJvbSBvdXRzaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gdmFsdWUgLSBUaGUgbmF0aXZlIGNvbnRleHQgdG8gc2V0LlxuXHQgKi9cblx0c3RhdGljIHNldENvbnRleHQoIHZhbHVlICkge1xuXG5cdFx0X2NvbnRleHQgPSB2YWx1ZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQXVkaW9Db250ZXh0IH07XG4iLCJpbXBvcnQgeyBBdWRpb0NvbnRleHQgfSBmcm9tICcuLi9hdWRpby9BdWRpb0NvbnRleHQuanMnO1xuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGxvYWRpbmcgYXVkaW8gYnVmZmVycy4gQXVkaW9zIGFyZSBpbnRlcm5hbGx5XG4gKiBsb2FkZWQgdmlhIHtAbGluayBGaWxlTG9hZGVyfS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYXVkaW9MaXN0ZW5lciA9IG5ldyBUSFJFRS5BdWRpb0xpc3RlbmVyKCk7XG4gKiBjb25zdCBhbWJpZW50U291bmQgPSBuZXcgVEhSRUUuQXVkaW8oIGF1ZGlvTGlzdGVuZXIgKTtcbiAqXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuQXVkaW9Mb2FkZXIoKTtcbiAqIGNvbnN0IGF1ZGlvQnVmZmVyID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyggJ2F1ZGlvL2FtYmllbnRfb2NlYW4ub2dnJyApO1xuICpcbiAqIGFtYmllbnRTb3VuZC5zZXRCdWZmZXIoIGF1ZGlvQnVmZmVyICk7XG4gKiBhbWJpZW50U291bmQucGxheSgpO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExvYWRlclxuICovXG5jbGFzcyBBdWRpb0xvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYXVkaW8gbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xvYWRpbmdNYW5hZ2VyfSBbbWFuYWdlcl0gLSBUaGUgbG9hZGluZyBtYW5hZ2VyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGxvYWRpbmcgZnJvbSB0aGUgZ2l2ZW4gVVJMIGFuZCBwYXNzZXMgdGhlIGxvYWRlZCBhdWRpbyBidWZmZXJcblx0ICogdG8gdGhlIGBvbkxvYWQoKWAgY2FsbGJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgcGF0aC9VUkwgb2YgdGhlIGZpbGUgdG8gYmUgbG9hZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGEgZGF0YSBVUkkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oQXVkaW9CdWZmZXIpfSBvbkxvYWQgLSBFeGVjdXRlZCB3aGVuIHRoZSBsb2FkaW5nIHByb2Nlc3MgaGFzIGJlZW4gZmluaXNoZWQuXG5cdCAqIEBwYXJhbSB7b25Qcm9ncmVzc0NhbGxiYWNrfSBvblByb2dyZXNzIC0gRXhlY3V0ZWQgd2hpbGUgdGhlIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3MuXG5cdCAqIEBwYXJhbSB7b25FcnJvckNhbGxiYWNrfSBvbkVycm9yIC0gRXhlY3V0ZWQgd2hlbiBlcnJvcnMgb2NjdXIuXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGJ1ZmZlci4gVGhlIGBkZWNvZGVBdWRpb0RhdGFgIG1ldGhvZFxuXHRcdFx0XHQvLyBkZXRhY2hlcyB0aGUgYnVmZmVyIHdoZW4gY29tcGxldGUsIHByZXZlbnRpbmcgcmV1c2UuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNvcHkgPSBidWZmZXIuc2xpY2UoIDAgKTtcblxuXHRcdFx0XHRjb25zdCBjb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblx0XHRcdFx0Y29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIGJ1ZmZlckNvcHksIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XG5cblx0XHRcdFx0fSApLmNhdGNoKCBoYW5kbGVFcnJvciApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRoYW5kbGVFcnJvciggZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVFcnJvciggZSApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEF1ZGlvTG9hZGVyIH07XG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IERFRzJSQUQgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4vUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xuXG5jb25zdCBfZXllUmlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfZXllTGVmdCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9wcm9qZWN0aW9uTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG4vKipcbiAqIEEgc3BlY2lhbCB0eXBlIG9mIGNhbWVyYSB0aGF0IHVzZXMgdHdvIHBlcnNwZWN0aXZlIGNhbWVyYXMgd2l0aFxuICogc3RlcmVvc2NvcGljIHByb2plY3Rpb24uIENhbiBiZSB1c2VkIGZvciByZW5kZXJpbmcgc3RlcmVvIGVmZmVjdHNcbiAqIGxpa2UgWzNEIEFuYWdseXBoXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbmFnbHlwaF8zRH0gb3JcbiAqIFtQYXJhbGxheCBCYXJyaWVyXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9wYXJhbGxheF9iYXJyaWVyfS5cbiAqL1xuY2xhc3MgU3RlcmVvQ2FtZXJhIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzdGVyZW8gY2FtZXJhLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBwcm9wZXJ0eSBpcyB1c2VkIGZvciBkZXRlY3RpbmcgdGhlIG9iamVjdCB0eXBlXG5cdFx0ICogaW4gY29udGV4dCBvZiBzZXJpYWxpemF0aW9uL2Rlc2VyaWFsaXphdGlvbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gJ1N0ZXJlb0NhbWVyYSc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXNwZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5hc3BlY3QgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV5ZSBzZXBhcmF0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRpc3RhbmNlXG5cdFx0ICogYmV0d2VlbiB0aGUgbGVmdCBhbmQgcmlnaHQgY2FtZXJhLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwLjA2NFxuXHRcdCAqL1xuXHRcdHRoaXMuZXllU2VwID0gMC4wNjQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY2FtZXJhIHJlcHJlc2VudGluZyB0aGUgbGVmdCBleWUuIFRoaXMgaXMgYWRkZWQgdG8gbGF5ZXIgYDFgIHNvIG9iamVjdHMgdG8gYmVcblx0XHQgKiByZW5kZXJlZCBieSB0aGUgbGVmdCBjYW1lcmEgbXVzdCBhbHNvIGJlIGFkZGVkIHRvIHRoaXMgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7UGVyc3BlY3RpdmVDYW1lcmF9XG5cdFx0ICovXG5cdFx0dGhpcy5jYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0dGhpcy5jYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcblx0XHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbWVyYSByZXByZXNlbnRpbmcgdGhlIHJpZ2h0IGV5ZS4gVGhpcyBpcyBhZGRlZCB0byBsYXllciBgMmAgc28gb2JqZWN0cyB0byBiZVxuXHRcdCAqIHJlbmRlcmVkIGJ5IHRoZSByaWdodCBjYW1lcmEgbXVzdCBhbHNvIGJlIGFkZGVkIHRvIHRoaXMgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7UGVyc3BlY3RpdmVDYW1lcmF9XG5cdFx0ICovXG5cdFx0dGhpcy5jYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcblx0XHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY2FjaGUgPSB7XG5cdFx0XHRmb2N1czogbnVsbCxcblx0XHRcdGZvdjogbnVsbCxcblx0XHRcdGFzcGVjdDogbnVsbCxcblx0XHRcdG5lYXI6IG51bGwsXG5cdFx0XHRmYXI6IG51bGwsXG5cdFx0XHR6b29tOiBudWxsLFxuXHRcdFx0ZXllU2VwOiBudWxsXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHN0ZXJlbyBjYW1lcmEgYmFzZWQgb24gdGhlIGdpdmVuIHBlcnNwZWN0aXZlIGNhbWVyYS5cblx0ICpcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhIC0gVGhlIHBlcnNwZWN0aXZlIGNhbWVyYS5cblx0ICovXG5cdHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZTtcblxuXHRcdGNvbnN0IG5lZWRzVXBkYXRlID0gY2FjaGUuZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBjYWNoZS5mb3YgIT09IGNhbWVyYS5mb3YgfHxcblx0XHRcdGNhY2hlLmFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IGNhY2hlLm5lYXIgIT09IGNhbWVyYS5uZWFyIHx8XG5cdFx0XHRjYWNoZS5mYXIgIT09IGNhbWVyYS5mYXIgfHwgY2FjaGUuem9vbSAhPT0gY2FtZXJhLnpvb20gfHwgY2FjaGUuZXllU2VwICE9PSB0aGlzLmV5ZVNlcDtcblxuXHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGNhY2hlLmZvY3VzID0gY2FtZXJhLmZvY3VzO1xuXHRcdFx0Y2FjaGUuZm92ID0gY2FtZXJhLmZvdjtcblx0XHRcdGNhY2hlLmFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcblx0XHRcdGNhY2hlLm5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHRcdGNhY2hlLmZhciA9IGNhbWVyYS5mYXI7XG5cdFx0XHRjYWNoZS56b29tID0gY2FtZXJhLnpvb207XG5cdFx0XHRjYWNoZS5leWVTZXAgPSB0aGlzLmV5ZVNlcDtcblxuXHRcdFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxuXHRcdFx0Ly8gaHR0cDovL3BhdWxib3Vya2UubmV0L3N0ZXJlb2dyYXBoaWNzL3N0ZXJlb3JlbmRlci9cblxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdGNvbnN0IGV5ZVNlcEhhbGYgPSBjYWNoZS5leWVTZXAgLyAyO1xuXHRcdFx0Y29uc3QgZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwSGFsZiAqIGNhY2hlLm5lYXIgLyBjYWNoZS5mb2N1cztcblx0XHRcdGNvbnN0IHltYXggPSAoIGNhY2hlLm5lYXIgKiBNYXRoLnRhbiggREVHMlJBRCAqIGNhY2hlLmZvdiAqIDAuNSApICkgLyBjYWNoZS56b29tO1xuXHRcdFx0bGV0IHhtaW4sIHhtYXg7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XG5cblx0XHRcdF9leWVMZWZ0LmVsZW1lbnRzWyAxMiBdID0gLSBleWVTZXBIYWxmO1xuXHRcdFx0X2V5ZVJpZ2h0LmVsZW1lbnRzWyAxMiBdID0gZXllU2VwSGFsZjtcblxuXHRcdFx0Ly8gZm9yIGxlZnQgZXllXG5cblx0XHRcdHhtaW4gPSAtIHltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHR4bWF4ID0geW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBjYWNoZS5uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weSggX3Byb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0Ly8gZm9yIHJpZ2h0IGV5ZVxuXG5cdFx0XHR4bWluID0gLSB5bWF4ICogY2FjaGUuYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogY2FjaGUubmVhciAvICggeG1heCAtIHhtaW4gKTtcblx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XG5cblx0XHRcdHRoaXMuY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIF9wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIF9leWVMZWZ0ICk7XG5cdFx0dGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBfZXllUmlnaHQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3RlcmVvQ2FtZXJhIH07XG4iLCJpbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4vUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xuXG4vKipcbiAqIFRoaXMgdHlwZSBvZiBjYW1lcmEgY2FuIGJlIHVzZWQgaW4gb3JkZXIgdG8gZWZmaWNpZW50bHkgcmVuZGVyIGEgc2NlbmUgd2l0aCBhXG4gKiBwcmVkZWZpbmVkIHNldCBvZiBjYW1lcmFzLiBUaGlzIGlzIGFuIGltcG9ydGFudCBwZXJmb3JtYW5jZSBhc3BlY3QgZm9yXG4gKiByZW5kZXJpbmcgVlIgc2NlbmVzLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIGBBcnJheUNhbWVyYWAgYWx3YXlzIGhhcyBhbiBhcnJheSBvZiBzdWIgY2FtZXJhcy4gSXQncyBtYW5kYXRvcnlcbiAqIHRvIGRlZmluZSBmb3IgZWFjaCBzdWIgY2FtZXJhIHRoZSBgdmlld3BvcnRgIHByb3BlcnR5IHdoaWNoIGRldGVybWluZXMgdGhlXG4gKiBwYXJ0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzIHJlbmRlcmVkIHdpdGggdGhpcyBjYW1lcmEuXG4gKlxuICogQGF1Z21lbnRzIFBlcnNwZWN0aXZlQ2FtZXJhXG4gKi9cbmNsYXNzIEFycmF5Q2FtZXJhIGV4dGVuZHMgUGVyc3BlY3RpdmVDYW1lcmEge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFycmF5IGNhbWVyYS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxQZXJzcGVjdGl2ZUNhbWVyYT59IFthcnJheT1bXV0gLSBBbiBhcnJheSBvZiBwZXJzcGVjdGl2ZSBzdWIgY2FtZXJhcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhcnJheSA9IFtdICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNBcnJheUNhbWVyYSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoaXMgY2FtZXJhIGlzIHVzZWQgd2l0aCBtdWx0aXZpZXcgcmVuZGVyaW5nIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5pc011bHRpVmlld0NhbWVyYSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgcGVyc3BlY3RpdmUgc3ViIGNhbWVyYXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8UGVyc3BlY3RpdmVDYW1lcmE+fVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FtZXJhcyA9IGFycmF5O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBBcnJheUNhbWVyYSB9O1xuIiwiLyoqXG4gKiBDbGFzcyBmb3Iga2VlcGluZyB0cmFjayBvZiB0aW1lLlxuICovXG5jbGFzcyBDbG9jayB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY2xvY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9TdGFydD10cnVlXSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBzdGFydCB0aGUgY2xvY2sgd2hlblxuXHQgKiBgZ2V0RGVsdGEoKWAgaXMgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhdXRvU3RhcnQgPSB0cnVlICkge1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIGNsb2NrIHN0YXJ0cyBhdXRvbWF0aWNhbGx5IHdoZW4gYGdldERlbHRhKClgIGlzIGNhbGxlZFxuXHRcdCAqIGZvciB0aGUgZmlyc3QgdGltZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmF1dG9TdGFydCA9IGF1dG9TdGFydDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBjbG9jaydzIGBzdGFydCgpYCBtZXRob2Qgd2FzIGxhc3QgY2FsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIGNsb2NrJ3MgYHN0YXJ0KClgLCBgZ2V0RWxhcHNlZFRpbWUoKWAgb3Jcblx0XHQgKiBgZ2V0RGVsdGEoKWAgbWV0aG9kcyB3ZXJlIGxhc3QgY2FsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vbGRUaW1lID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEtlZXBzIHRyYWNrIG9mIHRoZSB0b3RhbCB0aW1lIHRoYXQgdGhlIGNsb2NrIGhhcyBiZWVuIHJ1bm5pbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIGNsb2NrIGlzIHJ1bm5pbmcgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIHRoZSBjbG9jay4gV2hlbiBgYXV0b1N0YXJ0YCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcblx0ICogY2FsbGVkIGJ5IHRoZSBjbGFzcy5cblx0ICovXG5cdHN0YXJ0KCkge1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSBub3coKTtcblxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgY2xvY2suXG5cdCAqL1xuXHRzdG9wKCkge1xuXG5cdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbGFwc2VkIHRpbWUgaW4gc2Vjb25kcy5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZWxhcHNlZCB0aW1lLlxuXHQgKi9cblx0Z2V0RWxhcHNlZFRpbWUoKSB7XG5cblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRlbHRhIHRpbWUuXG5cdCAqL1xuXHRnZXREZWx0YSgpIHtcblxuXHRcdGxldCBkaWZmID0gMDtcblxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdGNvbnN0IG5ld1RpbWUgPSBub3coKTtcblxuXHRcdFx0ZGlmZiA9ICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApIC8gMTAwMDtcblx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkaWZmO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBub3coKSB7XG5cblx0cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuXG59XG5cbmV4cG9ydCB7IENsb2NrIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9tYXRoL1F1YXRlcm5pb24uanMnO1xuaW1wb3J0IHsgQ2xvY2sgfSBmcm9tICcuLi9jb3JlL0Nsb2NrLmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5pbXBvcnQgeyBBdWRpb0NvbnRleHQgfSBmcm9tICcuL0F1ZGlvQ29udGV4dC5qcyc7XG5cbmNvbnN0IF9wb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX3NjYWxlID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX29yaWVudGF0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIFRoZSBjbGFzcyByZXByZXNlbnRzIGEgdmlydHVhbCBsaXN0ZW5lciBvZiB0aGUgYWxsIHBvc2l0aW9uYWwgYW5kIG5vbi1wb3NpdGlvbmFsIGF1ZGlvIGVmZmVjdHNcbiAqIGluIHRoZSBzY2VuZS4gQSB0aHJlZS5qcyBhcHBsaWNhdGlvbiB1c3VhbGx5IGNyZWF0ZXMgYSBzaW5nbGUgbGlzdGVuZXIuIEl0IGlzIGEgbWFuZGF0b3J5XG4gKiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgZm9yIGF1ZGlvcyBlbnRpdGllcyBsaWtlIHtAbGluayBBdWRpb30gYW5kIHtAbGluayBQb3NpdGlvbmFsQXVkaW99LlxuICpcbiAqIEluIG1vc3QgY2FzZXMsIHRoZSBsaXN0ZW5lciBvYmplY3QgaXMgYSBjaGlsZCBvZiB0aGUgY2FtZXJhLiBTbyB0aGUgM0QgdHJhbnNmb3JtYXRpb24gb2YgdGhlXG4gKiBjYW1lcmEgcmVwcmVzZW50cyB0aGUgM0QgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICpcbiAqIEBhdWdtZW50cyBPYmplY3QzRFxuICovXG5jbGFzcyBBdWRpb0xpc3RlbmVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGF1ZGlvIGxpc3RlbmVyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBhdWRpbyBjb250ZXh0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGdhaW4gbm9kZSB1c2VkIGZvciB2b2x1bWUgY29udHJvbC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtHYWluTm9kZX1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9wdGlvbmFsIGZpbHRlci5cblx0XHQgKlxuXHRcdCAqIERlZmluZWQgdmlhIHtAbGluayBBdWRpb0xpc3RlbmVyI3NldEZpbHRlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0F1ZGlvTm9kZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGltZSBkZWx0YSB2YWx1ZXMgcmVxdWlyZWQgZm9yIGBsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgpYCB1c2FnZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZURlbHRhID0gMDtcblxuXHRcdC8vIHByaXZhdGVcblxuXHRcdHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lcidzIGlucHV0IG5vZGUuXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgb3RoZXIgYXVkaW8gbm9kZXMgdG8gY29ubmVjdCB0byB0aGlzIGxpc3RlbmVyLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtHYWluTm9kZX0gVGhlIGlucHV0IG5vZGUuXG5cdCAqL1xuXHRnZXRJbnB1dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdhaW47XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjdXJyZW50IGZpbHRlciBmcm9tIHRoaXMgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0F1ZGlvTGlzdGVuZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbGlzdGVuZXIuXG5cdCAqL1xuXHRyZW1vdmVGaWx0ZXIoKSB7XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNldCBmaWx0ZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4gez9BdWRpb05vZGV9IFRoZSBmaWx0ZXIuXG5cdCAqL1xuXHRnZXRGaWx0ZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXI7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBmaWx0ZXIgdG8gdGhpcyBsaXN0ZW5lci5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb05vZGV9IHZhbHVlIC0gVGhlIGZpbHRlciB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1ZGlvTGlzdGVuZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbGlzdGVuZXIuXG5cdCAqL1xuXHRzZXRGaWx0ZXIoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG5cdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG5cdFx0dGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFwcGxpY2F0aW9ucyBtYXN0ZXIgdm9sdW1lLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXN0ZXIgdm9sdW1lLlxuXHQgKi9cblx0Z2V0TWFzdGVyVm9sdW1lKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgYXBwbGljYXRpb25zIG1hc3RlciB2b2x1bWUuIFRoaXMgdm9sdW1lIHNldHRpbmcgYWZmZWN0c1xuXHQgKiBhbGwgYXVkaW8gbm9kZXMgaW4gdGhlIHNjZW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbWFzdGVyIHZvbHVtZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1ZGlvTGlzdGVuZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbGlzdGVuZXIuXG5cdCAqL1xuXHRzZXRNYXN0ZXJWb2x1bWUoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKCB2YWx1ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRjb25zdCBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcblx0XHRjb25zdCB1cCA9IHRoaXMudXA7XG5cblx0XHR0aGlzLnRpbWVEZWx0YSA9IHRoaXMuX2Nsb2NrLmdldERlbHRhKCk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlICk7XG5cblx0XHRfb3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uICk7XG5cblx0XHRpZiAoIGxpc3RlbmVyLnBvc2l0aW9uWCApIHtcblxuXHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgKHNlZSAjMTQzOTMpXG5cblx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLnRpbWVEZWx0YTtcblxuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueCwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueSwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueiwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbi54LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci5mb3J3YXJkWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLnksIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24ueiwgZW5kVGltZSApO1xuXHRcdFx0bGlzdGVuZXIudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCB1cC54LCBlbmRUaW1lICk7XG5cdFx0XHRsaXN0ZW5lci51cFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIHVwLnksIGVuZFRpbWUgKTtcblx0XHRcdGxpc3RlbmVyLnVwWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggdXAueiwgZW5kVGltZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oIF9wb3NpdGlvbi54LCBfcG9zaXRpb24ueSwgX3Bvc2l0aW9uLnogKTtcblx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBfb3JpZW50YXRpb24ueCwgX29yaWVudGF0aW9uLnksIF9vcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEF1ZGlvTGlzdGVuZXIgfTtcbiIsImltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG5vbi1wb3NpdGlvbmFsICggZ2xvYmFsICkgYXVkaW8gb2JqZWN0LlxuICpcbiAqIFRoaXMgYW5kIHJlbGF0ZWQgYXVkaW8gbW9kdWxlcyBtYWtlIHVzZSBvZiB0aGUgW1dlYiBBdWRpbyBBUElde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby0xLjEvfS5cbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGFuIEF1ZGlvTGlzdGVuZXIgYW5kIGFkZCBpdCB0byB0aGUgY2FtZXJhXG4gKiBjb25zdCBsaXN0ZW5lciA9IG5ldyBUSFJFRS5BdWRpb0xpc3RlbmVyKCk7XG4gKiBjYW1lcmEuYWRkKCBsaXN0ZW5lciApO1xuICpcbiAqIC8vIGNyZWF0ZSBhIGdsb2JhbCBhdWRpbyBzb3VyY2VcbiAqIGNvbnN0IHNvdW5kID0gbmV3IFRIUkVFLkF1ZGlvKCBsaXN0ZW5lciApO1xuICpcbiAqIC8vIGxvYWQgYSBzb3VuZCBhbmQgc2V0IGl0IGFzIHRoZSBBdWRpbyBvYmplY3QncyBidWZmZXJcbiAqIGNvbnN0IGF1ZGlvTG9hZGVyID0gbmV3IFRIUkVFLkF1ZGlvTG9hZGVyKCk7XG4gKiBhdWRpb0xvYWRlci5sb2FkKCAnc291bmRzL2FtYmllbnQub2dnJywgZnVuY3Rpb24oIGJ1ZmZlciApIHtcbiAqIFx0c291bmQuc2V0QnVmZmVyKCBidWZmZXIgKTtcbiAqIFx0c291bmQuc2V0TG9vcCggdHJ1ZSApO1xuICogXHRzb3VuZC5zZXRWb2x1bWUoIDAuNSApO1xuICogXHRzb3VuZC5wbGF5KCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBPYmplY3QzRFxuICovXG5jbGFzcyBBdWRpbyBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhdWRpby5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb0xpc3RlbmVyfSBsaXN0ZW5lciAtIFRoZSBnbG9iYWwgYXVkaW8gbGlzdGVuZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbGlzdGVuZXIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBnbG9iYWwgYXVkaW8gbGlzdGVuZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXVkaW9MaXN0ZW5lcn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXVkaW8gY29udGV4dC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBnYWluIG5vZGUgdXNlZCBmb3Igdm9sdW1lIGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBzdGFydCBwbGF5YmFjayBhdXRvbWF0aWNhbGx5IG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gYW4gYXVkaW8gYnVmZmVyLlxuXHRcdCAqXG5cdFx0ICogRGVmaW5lZCB2aWEge0BsaW5rIEF1ZGlvI3NldEJ1ZmZlcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0F1ZGlvQnVmZmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmJ1ZmZlciA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBNb2RpZnkgcGl0Y2gsIG1lYXN1cmVkIGluIGNlbnRzLiArLy0gMTAwIGlzIGEgc2VtaXRvbmUuXG5cdFx0ICogKy8tIDEyMDAgaXMgYW4gb2N0YXZlLlxuXHRcdCAqXG5cdFx0ICogRGVmaW5lZCB2aWEge0BsaW5rIEF1ZGlvI3NldERldHVuZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmRldHVuZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBhdWRpbyBzaG91bGQgbG9vcCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBEZWZpbmVkIHZpYSB7QGxpbmsgQXVkaW8jc2V0TG9vcH0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB3aGVyZSBpbiB0aGUgYXVkaW8gYnVmZmVyIHRoZSByZXBsYXkgc2hvdWxkXG5cdFx0ICogc3RhcnQsIGluIHNlY29uZHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmxvb3BTdGFydCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIHdoZXJlIGluIHRoZSBhdWRpbyBidWZmZXIgdGhlIHJlcGxheSBzaG91bGRcblx0XHQgKiBzdG9wLCBpbiBzZWNvbmRzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wRW5kID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9mZnNldCB0byB0aGUgdGltZSB3aXRoaW4gdGhlIGF1ZGlvIGJ1ZmZlciB0aGUgcGxheWJhY2tcblx0XHQgKiBzaG91bGQgYmVnaW4sIGluIHNlY29uZHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgZHVyYXRpb24gb2YgdGhlIGF1ZGlvLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3VuZGVmaW5lZHxudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwbGF5YmFjayBzcGVlZC5cblx0XHQgKlxuXHRcdCAqIERlZmluZWQgdmlhIHtAbGluayBBdWRpbyNzZXRQbGF5YmFja1JhdGV9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGF1ZGlvIGlzIHBsYXlpbmcgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogVGhpcyBmbGFnIHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgd2hlbiB1c2luZyB7QGxpbmsgQXVkaW8jcGxheX0sXG5cdFx0ICoge0BsaW5rIEF1ZGlvI3BhdXNlfSwge0BsaW5rIEF1ZGlvI3N0b3B9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGF1ZGlvIHBsYXliYWNrIGNhbiBiZSBjb250cm9sbGVkXG5cdFx0ICogd2l0aCBtZXRob2QgbGlrZSB7QGxpbmsgQXVkaW8jcGxheX0gb3Ige0BsaW5rIEF1ZGlvI3BhdXNlfS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmxhZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHdoZW4gYXVkaW8gc291cmNlcyBhcmVcblx0XHQgKiBkZWZpbmVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGF1ZGlvIHNvdXJjZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBwcm9wZXJ0eSBpcyBhdXRvbWF0aWNhbGx5IGJ5IG9uZSBvZiB0aGUgYHNldCooKWAgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/QXVkaW9Ob2RlfVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIHRoZSBzb3VyY2UgdHlwZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBwcm9wZXJ0eSBpcyBhdXRvbWF0aWNhbGx5IGJ5IG9uZSBvZiB0aGUgYHNldCooKWAgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoJ2VtcHR5J3wnYXVkaW9Ob2RlJ3wnbWVkaWFOb2RlJ3wnbWVkaWFTdHJlYW1Ob2RlJ3wnYnVmZmVyJyl9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgJ2VtcHR5J1xuXHRcdCAqL1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdlbXB0eSc7XG5cblx0XHR0aGlzLl9zdGFydGVkQXQgPSAwO1xuXHRcdHRoaXMuX3Byb2dyZXNzID0gMDtcblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIENhbiBiZSB1c2VkIHRvIGFwcGx5IGEgdmFyaWV0eSBvZiBsb3ctb3JkZXIgZmlsdGVycyB0byBjcmVhdGVcblx0XHQgKiBtb3JlIGNvbXBsZXggc291bmQgZWZmZWN0cyBlLmcuIHZpYSBgQmlxdWFkRmlsdGVyTm9kZWAuXG5cdFx0ICpcblx0XHQgKiBUaGUgcHJvcGVydHkgaXMgYXV0b21hdGljYWxseSBzZXQgYnkge0BsaW5rIEF1ZGlvI3NldEZpbHRlcnN9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FycmF5PEF1ZGlvTm9kZT59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5maWx0ZXJzID0gW107XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvdXRwdXQgYXVkaW8gbm9kZS5cblx0ICpcblx0ICogQHJldHVybiB7R2Fpbk5vZGV9IFRoZSBvdXRwdXQgbm9kZS5cblx0ICovXG5cdGdldE91dHB1dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdhaW47XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBhdWRpbyBub2RlIGFzIHRoZSBzb3VyY2Ugb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICoge0BsaW5rIEF1ZGlvI3NvdXJjZVR5cGV9IGlzIHNldCB0byBgYXVkaW9Ob2RlYCBhbmQge0BsaW5rIEF1ZGlvI2hhc1BsYXliYWNrQ29udHJvbH0gdG8gYGZhbHNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb05vZGV9IGF1ZGlvTm9kZSAtIFRoZSBhdWRpbyBub2RlIGxpa2UgYW4gaW5zdGFuY2Ugb2YgYE9zY2lsbGF0b3JOb2RlYC5cblx0ICogQHJldHVybiB7QXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXROb2RlU291cmNlKCBhdWRpb05vZGUgKSB7XG5cblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdhdWRpb05vZGUnO1xuXHRcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuXHRcdHRoaXMuY29ubmVjdCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBtZWRpYSBlbGVtZW50IGFzIHRoZSBzb3VyY2Ugb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICoge0BsaW5rIEF1ZGlvI3NvdXJjZVR5cGV9IGlzIHNldCB0byBgbWVkaWFOb2RlYCBhbmQge0BsaW5rIEF1ZGlvI2hhc1BsYXliYWNrQ29udHJvbH0gdG8gYGZhbHNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnQgLSBUaGUgbWVkaWEgZWxlbWVudC5cblx0ICogQHJldHVybiB7QXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRNZWRpYUVsZW1lbnRTb3VyY2UoIG1lZGlhRWxlbWVudCApIHtcblxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhTm9kZSc7XG5cdFx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKCBtZWRpYUVsZW1lbnQgKTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gbWVkaWEgc3RyZWFtIGFzIHRoZSBzb3VyY2Ugb2YgdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICoge0BsaW5rIEF1ZGlvI3NvdXJjZVR5cGV9IGlzIHNldCB0byBgbWVkaWFTdHJlYW1Ob2RlYCBhbmQge0BsaW5rIEF1ZGlvI2hhc1BsYXliYWNrQ29udHJvbH0gdG8gYGZhbHNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gbWVkaWFTdHJlYW0gLSBUaGUgbWVkaWEgc3RyZWFtLlxuXHQgKiBAcmV0dXJuIHtBdWRpb30gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldE1lZGlhU3RyZWFtU291cmNlKCBtZWRpYVN0cmVhbSApIHtcblxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhU3RyZWFtTm9kZSc7XG5cdFx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoIG1lZGlhU3RyZWFtICk7XG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGdpdmVuIGF1ZGlvIGJ1ZmZlciBhcyB0aGUgc291cmNlIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIHtAbGluayBBdWRpbyNzb3VyY2VUeXBlfSBpcyBzZXQgdG8gYGJ1ZmZlcmAgYW5kIHtAbGluayBBdWRpbyNoYXNQbGF5YmFja0NvbnRyb2x9IHRvIGB0cnVlYC5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYXVkaW9CdWZmZXIgLSBUaGUgYXVkaW8gYnVmZmVyLlxuXHQgKiBAcmV0dXJuIHtBdWRpb30gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldEJ1ZmZlciggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdidWZmZXInO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgcGxheWJhY2sgb2YgdGhlIGF1ZGlvLlxuXHQgKlxuXHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGggY29tcGF0aWJsZSBhdWRpbyBzb3VyY2VzIHRoYXQgYWxsb3cgcGxheWJhY2sgY29udHJvbC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSAtIFRoZSBkZWxheSwgaW4gc2Vjb25kcywgYXQgd2hpY2ggdGhlIGF1ZGlvIHNob3VsZCBzdGFydCBwbGF5aW5nLlxuXHQgKiBAcmV0dXJuIHtBdWRpb3x1bmRlZmluZWR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRwbGF5KCBkZWxheSA9IDAgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyBkZWxheTtcblxuXHRcdGNvbnN0IHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0c291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XG5cdFx0c291cmNlLmxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0O1xuXHRcdHNvdXJjZS5sb29wRW5kID0gdGhpcy5sb29wRW5kO1xuXHRcdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcblx0XHRzb3VyY2Uuc3RhcnQoIHRoaXMuX3N0YXJ0ZWRBdCwgdGhpcy5fcHJvZ3Jlc3MgKyB0aGlzLm9mZnNldCwgdGhpcy5kdXJhdGlvbiApO1xuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cblx0XHR0aGlzLnNldERldHVuZSggdGhpcy5kZXR1bmUgKTtcblx0XHR0aGlzLnNldFBsYXliYWNrUmF0ZSggdGhpcy5wbGF5YmFja1JhdGUgKTtcblxuXHRcdHJldHVybiB0aGlzLmNvbm5lY3QoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGUgcGxheWJhY2sgb2YgdGhlIGF1ZGlvLlxuXHQgKlxuXHQgKiBDYW4gb25seSBiZSB1c2VkIHdpdGggY29tcGF0aWJsZSBhdWRpbyBzb3VyY2VzIHRoYXQgYWxsb3cgcGxheWJhY2sgY29udHJvbC5cblx0ICpcblx0ICogQHJldHVybiB7QXVkaW98dW5kZWZpbmVkfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0cGF1c2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gdXBkYXRlIGN1cnJlbnQgcHJvZ3Jlc3NcblxuXHRcdFx0dGhpcy5fcHJvZ3Jlc3MgKz0gTWF0aC5tYXgoIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0ZWRBdCwgMCApICogdGhpcy5wbGF5YmFja1JhdGU7XG5cblx0XHRcdGlmICggdGhpcy5sb29wID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIGVuc3VyZSBfcHJvZ3Jlc3MgZG9lcyBub3QgZXhjZWVkIGR1cmF0aW9uIHdpdGggbG9vcGVkIGF1ZGlvc1xuXG5cdFx0XHRcdHRoaXMuX3Byb2dyZXNzID0gdGhpcy5fcHJvZ3Jlc3MgJSAoIHRoaXMuZHVyYXRpb24gfHwgdGhpcy5idWZmZXIuZHVyYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdFx0XHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gbnVsbDtcblxuXHRcdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgdGhlIHBsYXliYWNrIG9mIHRoZSBhdWRpby5cblx0ICpcblx0ICogQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIGNvbXBhdGlibGUgYXVkaW8gc291cmNlcyB0aGF0IGFsbG93IHBsYXliYWNrIGNvbnRyb2wuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gLSBUaGUgZGVsYXksIGluIHNlY29uZHMsIGF0IHdoaWNoIHRoZSBhdWRpbyBzaG91bGQgc3RvcCBwbGF5aW5nLlxuXHQgKiBAcmV0dXJuIHtBdWRpb3x1bmRlZmluZWR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzdG9wKCBkZWxheSA9IDAgKSB7XG5cblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLnNvdXJjZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCggdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgZGVsYXkgKTtcblx0XHRcdHRoaXMuc291cmNlLm9uZW5kZWQgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29ubmVjdHMgdG8gdGhlIGF1ZGlvIHNvdXJjZS4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgb25cblx0ICogaW5pdGlhbGlzYXRpb24gYW5kIHdoZW4gc2V0dGluZyAvIHJlbW92aW5nIGZpbHRlcnMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0F1ZGlvfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y29ubmVjdCgpIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNjb25uZWN0cyB0byB0aGUgYXVkaW8gc291cmNlLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBvblxuXHQgKiBpbml0aWFsaXNhdGlvbiBhbmQgd2hlbiBzZXR0aW5nIC8gcmVtb3ZpbmcgZmlsdGVycy5cblx0ICpcblx0ICogQHJldHVybiB7QXVkaW98dW5kZWZpbmVkfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0ZGlzY29ubmVjdCgpIHtcblxuXHRcdGlmICggdGhpcy5fY29ubmVjdGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5maWx0ZXJzWyB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNldCBmaWx0ZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheTxBdWRpb05vZGU+fSBUaGUgbGlzdCBvZiBmaWx0ZXJzLlxuXHQgKi9cblx0Z2V0RmlsdGVycygpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGFuIGFycmF5IG9mIGZpbHRlcnMgYW5kIGNvbm5lY3RzIHRoZW0gd2l0aCB0aGUgYXVkaW8gc291cmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PEF1ZGlvTm9kZT59IFt2YWx1ZV0gLSBBIGxpc3Qgb2YgZmlsdGVycy5cblx0ICogQHJldHVybiB7QXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRGaWx0ZXJzKCB2YWx1ZSApIHtcblxuXHRcdGlmICggISB2YWx1ZSApIHZhbHVlID0gW107XG5cblx0XHRpZiAoIHRoaXMuX2Nvbm5lY3RlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0XHR0aGlzLmZpbHRlcnMgPSB2YWx1ZS5zbGljZSgpO1xuXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmZpbHRlcnMgPSB2YWx1ZS5zbGljZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBkZXR1bmluZyBvZiBvc2NpbGxhdGlvbiBpbiBjZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGRldHVuaW5nIG9mIG9zY2lsbGF0aW9uIGluIGNlbnRzLlxuXHQgKiBAcmV0dXJuIHtBdWRpb30gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldERldHVuZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmRldHVuZSA9IHZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSAmJiB0aGlzLnNvdXJjZS5kZXR1bmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSggdGhpcy5kZXR1bmUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkZXR1bmluZyBvZiBvc2NpbGxhdGlvbiBpbiBjZW50cy5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGV0dW5pbmcgb2Ygb3NjaWxsYXRpb24gaW4gY2VudHMuXG5cdCAqL1xuXHRnZXREZXR1bmUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kZXR1bmU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCBmaWx0ZXIgaW4gdGhlIGxpc3Qgb2YgZmlsdGVycy5cblx0ICpcblx0ICogQHJldHVybiB7QXVkaW9Ob2RlfHVuZGVmaW5lZH0gVGhlIGZpcnN0IGZpbHRlciBpbiB0aGUgbGlzdCBvZiBmaWx0ZXJzLlxuXHQgKi9cblx0Z2V0RmlsdGVyKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWyAwIF07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgc2luZ2xlIGZpbHRlciBub2RlIHRvIHRoZSBhdWRpby5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb05vZGV9IFtmaWx0ZXJdIC0gVGhlIGZpbHRlciB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1ZGlvfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0RmlsdGVyKCBmaWx0ZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBsYXliYWNrIHJhdGUuXG5cdCAqXG5cdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBjb21wYXRpYmxlIGF1ZGlvIHNvdXJjZXMgdGhhdCBhbGxvdyBwbGF5YmFjayBjb250cm9sLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXSAtIFRoZSBwbGF5YmFjayByYXRlIHRvIHNldC5cblx0ICogQHJldHVybiB7QXVkaW98dW5kZWZpbmVkfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0UGxheWJhY2tSYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFRhcmdldEF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGxheWJhY2sgcmF0ZS5cblx0ICovXG5cdGdldFBsYXliYWNrUmF0ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gcGxheWJhY2sgZmluaXNoZWQuXG5cdCAqL1xuXHRvbkVuZGVkKCkge1xuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb29wIGZsYWcuXG5cdCAqXG5cdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBjb21wYXRpYmxlIGF1ZGlvIHNvdXJjZXMgdGhhdCBhbGxvdyBwbGF5YmFjayBjb250cm9sLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBhdWRpbyBzaG91bGQgbG9vcCBvciBub3QuXG5cdCAqL1xuXHRnZXRMb29wKCkge1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmxvb3A7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsb29wIGZsYWcuXG5cdCAqXG5cdCAqIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBjb21wYXRpYmxlIGF1ZGlvIHNvdXJjZXMgdGhhdCBhbGxvdyBwbGF5YmFjayBjb250cm9sLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgYXVkaW8gc2hvdWxkIGxvb3Agb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtBdWRpb3x1bmRlZmluZWR9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRMb29wKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLmxvb3AgPSB2YWx1ZTtcblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxvb3Agc3RhcnQgdmFsdWUgd2hpY2ggZGVmaW5lcyB3aGVyZSBpbiB0aGUgYXVkaW8gYnVmZmVyIHRoZSByZXBsYXkgc2hvdWxkXG5cdCAqIHN0YXJ0LCBpbiBzZWNvbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbG9vcCBzdGFydCB2YWx1ZS5cblx0ICogQHJldHVybiB7QXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRMb29wU3RhcnQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5sb29wU3RhcnQgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbG9vcCBlbmQgdmFsdWUgd2hpY2ggZGVmaW5lcyB3aGVyZSBpbiB0aGUgYXVkaW8gYnVmZmVyIHRoZSByZXBsYXkgc2hvdWxkXG5cdCAqIHN0b3AsIGluIHNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBsb29wIGVuZCB2YWx1ZS5cblx0ICogQHJldHVybiB7QXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRMb29wRW5kKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubG9vcEVuZCA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2b2x1bWUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZvbHVtZS5cblx0ICovXG5cdGdldFZvbHVtZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZvbHVtZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZvbHVtZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1ZGlvfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0Vm9sdW1lKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZ2Fpbi5nYWluLnNldFRhcmdldEF0VGltZSggdmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdGlmICggc291cmNlLnNvdXJjZVR5cGUgIT09ICdidWZmZXInICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gc291cmNlIHR5cGUgY2Fubm90IGJlIGNvcGllZC4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hdXRvcGxheSA9IHNvdXJjZS5hdXRvcGxheTtcblxuXHRcdHRoaXMuYnVmZmVyID0gc291cmNlLmJ1ZmZlcjtcblx0XHR0aGlzLmRldHVuZSA9IHNvdXJjZS5kZXR1bmU7XG5cdFx0dGhpcy5sb29wID0gc291cmNlLmxvb3A7XG5cdFx0dGhpcy5sb29wU3RhcnQgPSBzb3VyY2UubG9vcFN0YXJ0O1xuXHRcdHRoaXMubG9vcEVuZCA9IHNvdXJjZS5sb29wRW5kO1xuXHRcdHRoaXMub2Zmc2V0ID0gc291cmNlLm9mZnNldDtcblx0XHR0aGlzLmR1cmF0aW9uID0gc291cmNlLmR1cmF0aW9uO1xuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gc291cmNlLnBsYXliYWNrUmF0ZTtcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHNvdXJjZS5oYXNQbGF5YmFja0NvbnRyb2w7XG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gc291cmNlLnNvdXJjZVR5cGU7XG5cblx0XHR0aGlzLmZpbHRlcnMgPSBzb3VyY2UuZmlsdGVycy5zbGljZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCByZWN1cnNpdmUgKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubGlzdGVuZXIgKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQXVkaW8gfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBBdWRpbyB9IGZyb20gJy4vQXVkaW8uanMnO1xuXG5jb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9zY2FsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcG9zaXRpb25hbCBhdWRpbyBvYmplY3QuXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhbiBBdWRpb0xpc3RlbmVyIGFuZCBhZGQgaXQgdG8gdGhlIGNhbWVyYVxuICogY29uc3QgbGlzdGVuZXIgPSBuZXcgVEhSRUUuQXVkaW9MaXN0ZW5lcigpO1xuICogY2FtZXJhLmFkZCggbGlzdGVuZXIgKTtcbiAqXG4gKiAvLyBjcmVhdGUgdGhlIFBvc2l0aW9uYWxBdWRpbyBvYmplY3QgKHBhc3NpbmcgaW4gdGhlIGxpc3RlbmVyKVxuICogY29uc3Qgc291bmQgPSBuZXcgVEhSRUUuUG9zaXRpb25hbEF1ZGlvKCBsaXN0ZW5lciApO1xuICpcbiAqIC8vIGxvYWQgYSBzb3VuZCBhbmQgc2V0IGl0IGFzIHRoZSBQb3NpdGlvbmFsQXVkaW8gb2JqZWN0J3MgYnVmZmVyXG4gKiBjb25zdCBhdWRpb0xvYWRlciA9IG5ldyBUSFJFRS5BdWRpb0xvYWRlcigpO1xuICogYXVkaW9Mb2FkZXIubG9hZCggJ3NvdW5kcy9zb25nLm9nZycsIGZ1bmN0aW9uKCBidWZmZXIgKSB7XG4gKiBcdHNvdW5kLnNldEJ1ZmZlciggYnVmZmVyICk7XG4gKiBcdHNvdW5kLnNldFJlZkRpc3RhbmNlKCAyMCApO1xuICogXHRzb3VuZC5wbGF5KCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb2JqZWN0IGZvciB0aGUgc291bmQgdG8gcGxheSBmcm9tXG4gKiBjb25zdCBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIDIwLCAzMiwgMTYgKTtcbiAqIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCB7IGNvbG9yOiAweGZmMjIwMCB9ICk7XG4gKiBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goIHNwaGVyZSwgbWF0ZXJpYWwgKTtcbiAqIHNjZW5lLmFkZCggbWVzaCApO1xuICpcbiAqIC8vIGZpbmFsbHkgYWRkIHRoZSBzb3VuZCB0byB0aGUgbWVzaFxuICogbWVzaC5hZGQoIHNvdW5kICk7XG4gKlxuICogQGF1Z21lbnRzIEF1ZGlvXG4gKi9cbmNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIHBvc2l0aW9uYWwgYXVkaW8uXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXVkaW9MaXN0ZW5lcn0gbGlzdGVuZXIgLSBUaGUgZ2xvYmFsIGF1ZGlvIGxpc3RlbmVyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGxpc3RlbmVyICkge1xuXG5cdFx0c3VwZXIoIGxpc3RlbmVyICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGFubmVyIG5vZGUgcmVwcmVzZW50cyB0aGUgbG9jYXRpb24sIGRpcmVjdGlvbiwgYW5kIGJlaGF2aW9yIG9mIGFuIGF1ZGlvXG5cdFx0ICogc291cmNlIGluIDNEIHNwYWNlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1Bhbm5lck5vZGV9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0dGhpcy5wYW5uZXIucGFubmluZ01vZGVsID0gJ0hSVEYnO1xuXHRcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG5cdH1cblxuXHRjb25uZWN0KCkge1xuXG5cdFx0c3VwZXIuY29ubmVjdCgpO1xuXG5cdFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblxuXHRcdHN1cGVyLmRpc2Nvbm5lY3QoKTtcblxuXHRcdHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE91dHB1dCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVmZXJlbmNlIGRpc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWZlcmVuY2UgZGlzdGFuY2UuXG5cdCAqL1xuXHRnZXRSZWZEaXN0YW5jZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHJlZmVyZW5jZSBkaXN0YW5jZSBmb3IgcmVkdWNpbmcgdm9sdW1lIGFzIHRoZSBhdWRpbyBzb3VyY2UgbW92ZXNcblx0ICogZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lciDigJMgaS5lLiB0aGUgZGlzdGFuY2UgYXQgd2hpY2ggdGhlIHZvbHVtZSByZWR1Y3Rpb25cblx0ICogc3RhcnRzIHRha2luZyBlZmZlY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSByZWZlcmVuY2UgZGlzdGFuY2UgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtQb3NpdGlvbmFsQXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRSZWZEaXN0YW5jZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvbGxvZmYgZmFjdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb2xsb2ZmIGZhY3Rvci5cblx0ICovXG5cdGdldFJvbGxvZmZGYWN0b3IoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlZmluZXMgaG93IHF1aWNrbHkgdGhlIHZvbHVtZSBpcyByZWR1Y2VkIGFzIHRoZSBzb3VyY2UgbW92ZXMgYXdheSBmcm9tIHRoZSBsaXN0ZW5lci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHJvbGxvZmYgZmFjdG9yLlxuXHQgKiBAcmV0dXJuIHtQb3NpdGlvbmFsQXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRSb2xsb2ZmRmFjdG9yKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBkaXN0YW5jZSBtb2RlbC5cblx0ICpcblx0ICogQHJldHVybiB7KCdsaW5lYXInfCdpbnZlcnNlJ3wnZXhwb25lbnRpYWwnKX0gVGhlIGRpc3RhbmNlIG1vZGVsLlxuXHQgKi9cblx0Z2V0RGlzdGFuY2VNb2RlbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lcyB3aGljaCBhbGdvcml0aG0gdG8gdXNlIHRvIHJlZHVjZSB0aGUgdm9sdW1lIG9mIHRoZSBhdWRpbyBzb3VyY2Vcblx0ICogYXMgaXQgbW92ZXMgYXdheSBmcm9tIHRoZSBsaXN0ZW5lci5cblx0ICpcblx0ICogUmVhZCBbdGhlIHNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby0xLjEvI2VudW1kZWYtZGlzdGFuY2Vtb2RlbHR5cGV9XG5cdCAqIGZvciBtb3JlIGRldGFpbHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KCdsaW5lYXInfCdpbnZlcnNlJ3wnZXhwb25lbnRpYWwnKX0gdmFsdWUgLSBUaGUgZGlzdGFuY2UgbW9kZWwgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtQb3NpdGlvbmFsQXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXREaXN0YW5jZU1vZGVsKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWwgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBtYXggZGlzdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heCBkaXN0YW5jZS5cblx0ICovXG5cdGdldE1heERpc3RhbmNlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBhdWRpbyBzb3VyY2UgYW5kIHRoZSBsaXN0ZW5lcixcblx0ICogYWZ0ZXIgd2hpY2ggdGhlIHZvbHVtZSBpcyBub3QgcmVkdWNlZCBhbnkgZnVydGhlci5cblx0ICpcblx0ICogVGhpcyB2YWx1ZSBpcyB1c2VkIG9ubHkgYnkgdGhlIGBsaW5lYXJgIGRpc3RhbmNlIG1vZGVsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbWF4IGRpc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtQb3NpdGlvbmFsQXVkaW99IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRNYXhEaXN0YW5jZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkaXJlY3Rpb25hbCBjb25lIGluIHdoaWNoIHRoZSBhdWRpbyBjYW4gYmUgbGlzdGVuZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb25lSW5uZXJBbmdsZSAtIEFuIGFuZ2xlLCBpbiBkZWdyZWVzLCBvZiBhIGNvbmUgaW5zaWRlIG9mIHdoaWNoIHRoZXJlIHdpbGwgYmUgbm8gdm9sdW1lIHJlZHVjdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvbmVPdXRlckFuZ2xlIC0gQW4gYW5nbGUsIGluIGRlZ3JlZXMsIG9mIGEgY29uZSBvdXRzaWRlIG9mIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBiZSByZWR1Y2VkIGJ5IGEgY29uc3RhbnQgdmFsdWUsIGRlZmluZWQgYnkgdGhlIGBjb25lT3V0ZXJHYWluYCBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb25lT3V0ZXJHYWluIC0gVGhlIGFtb3VudCBvZiB2b2x1bWUgcmVkdWN0aW9uIG91dHNpZGUgdGhlIGNvbmUgZGVmaW5lZCBieSB0aGUgYGNvbmVPdXRlckFuZ2xlYC4gV2hlbiBzZXQgdG8gYDBgLCBubyBzb3VuZCBjYW4gYmUgaGVhcmQuXG5cdCAqIEByZXR1cm4ge1Bvc2l0aW9uYWxBdWRpb30gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldERpcmVjdGlvbmFsQ29uZSggY29uZUlubmVyQW5nbGUsIGNvbmVPdXRlckFuZ2xlLCBjb25lT3V0ZXJHYWluICkge1xuXG5cdFx0dGhpcy5wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBjb25lSW5uZXJBbmdsZTtcblx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xuXHRcdHRoaXMucGFubmVyLmNvbmVPdXRlckdhaW4gPSBjb25lT3V0ZXJHYWluO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gdHJ1ZSAmJiB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlICk7XG5cblx0XHRfb3JpZW50YXRpb24uc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiApO1xuXG5cdFx0Y29uc3QgcGFubmVyID0gdGhpcy5wYW5uZXI7XG5cblx0XHRpZiAoIHBhbm5lci5wb3NpdGlvblggKSB7XG5cblx0XHRcdC8vIGNvZGUgcGF0aCBmb3IgQ2hyb21lIGFuZCBGaXJlZm94IChzZWUgIzE0MzkzKVxuXG5cdFx0XHRjb25zdCBlbmRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5saXN0ZW5lci50aW1lRGVsdGE7XG5cblx0XHRcdHBhbm5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbi54LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueSwgZW5kVGltZSApO1xuXHRcdFx0cGFubmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLnosIGVuZFRpbWUgKTtcblx0XHRcdHBhbm5lci5vcmllbnRhdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbi54LCBlbmRUaW1lICk7XG5cdFx0XHRwYW5uZXIub3JpZW50YXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24ueSwgZW5kVGltZSApO1xuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLnosIGVuZFRpbWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBhbm5lci5zZXRQb3NpdGlvbiggX3Bvc2l0aW9uLngsIF9wb3NpdGlvbi55LCBfcG9zaXRpb24ueiApO1xuXHRcdFx0cGFubmVyLnNldE9yaWVudGF0aW9uKCBfb3JpZW50YXRpb24ueCwgX29yaWVudGF0aW9uLnksIF9vcmllbnRhdGlvbi56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFBvc2l0aW9uYWxBdWRpbyB9O1xuIiwiLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSB1c2VkIHRvIGFuYWx5c2UgYXVkaW8gZGF0YS5cbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGFuIEF1ZGlvTGlzdGVuZXIgYW5kIGFkZCBpdCB0byB0aGUgY2FtZXJhXG4gKiBjb25zdCBsaXN0ZW5lciA9IG5ldyBUSFJFRS5BdWRpb0xpc3RlbmVyKCk7XG4gKiBjYW1lcmEuYWRkKCBsaXN0ZW5lciApO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBBdWRpbyBzb3VyY2VcbiAqIGNvbnN0IHNvdW5kID0gbmV3IFRIUkVFLkF1ZGlvKCBsaXN0ZW5lciApO1xuICpcbiAqIC8vIGxvYWQgYSBzb3VuZCBhbmQgc2V0IGl0IGFzIHRoZSBBdWRpbyBvYmplY3QncyBidWZmZXJcbiAqIGNvbnN0IGF1ZGlvTG9hZGVyID0gbmV3IFRIUkVFLkF1ZGlvTG9hZGVyKCk7XG4gKiBhdWRpb0xvYWRlci5sb2FkKCAnc291bmRzL2FtYmllbnQub2dnJywgZnVuY3Rpb24oIGJ1ZmZlciApIHtcbiAqIFx0c291bmQuc2V0QnVmZmVyKCBidWZmZXIgKTtcbiAqIFx0c291bmQuc2V0TG9vcCh0cnVlKTtcbiAqIFx0c291bmQuc2V0Vm9sdW1lKDAuNSk7XG4gKiBcdHNvdW5kLnBsYXkoKTtcbiAqIH0pO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBBdWRpb0FuYWx5c2VyLCBwYXNzaW5nIGluIHRoZSBzb3VuZCBhbmQgZGVzaXJlZCBmZnRTaXplXG4gKiBjb25zdCBhbmFseXNlciA9IG5ldyBUSFJFRS5BdWRpb0FuYWx5c2VyKCBzb3VuZCwgMzIgKTtcbiAqXG4gKiAvLyBnZXQgdGhlIGF2ZXJhZ2UgZnJlcXVlbmN5IG9mIHRoZSBzb3VuZFxuICogY29uc3QgZGF0YSA9IGFuYWx5c2VyLmdldEF2ZXJhZ2VGcmVxdWVuY3koKTtcbiAqIGBgYFxuICovXG5jbGFzcyBBdWRpb0FuYWx5c2VyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhdWRpbyBhbmFseXplci5cblx0ICpcblx0ICogQHBhcmFtIHtBdWRpb30gYXVkaW8gLSBUaGUgYXVkaW8gdG8gYW5hbHl6ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtmZnRTaXplPTIwNDhdIC0gVGhlIHdpbmRvdyBzaXplIGluIHNhbXBsZXMgdGhhdCBpcyB1c2VkIHdoZW4gcGVyZm9ybWluZyBhIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gKEZGVCkgdG8gZ2V0IGZyZXF1ZW5jeSBkb21haW4gZGF0YS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBhdWRpbywgZmZ0U2l6ZSA9IDIwNDggKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZ2xvYmFsIGF1ZGlvIGxpc3RlbmVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0FuYWx5c2VyTm9kZX1cblx0XHQgKi9cblx0XHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHRcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemU7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgYW5hbHl6ZWQgZGF0YS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtVaW50OEFycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XG5cblx0XHRhdWRpby5nZXRPdXRwdXQoKS5jb25uZWN0KCB0aGlzLmFuYWx5c2VyICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggZnJlcXVlbmN5IGRhdGEgb2YgdGhlIGF1ZGlvLlxuXHQgKlxuXHQgKiBFYWNoIGl0ZW0gaW4gdGhlIGFycmF5IHJlcHJlc2VudHMgdGhlIGRlY2liZWwgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZnJlcXVlbmN5LlxuXHQgKiBUaGUgZnJlcXVlbmNpZXMgYXJlIHNwcmVhZCBsaW5lYXJseSBmcm9tIDAgdG8gMS8yIG9mIHRoZSBzYW1wbGUgcmF0ZS5cblx0ICogRm9yIGV4YW1wbGUsIGZvciA0ODAwMCBzYW1wbGUgcmF0ZSwgdGhlIGxhc3QgaXRlbSBvZiB0aGUgYXJyYXkgd2lsbCByZXByZXNlbnRcblx0ICogdGhlIGRlY2liZWwgdmFsdWUgZm9yIDI0MDAwIEh6LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtVaW50OEFycmF5fSBUaGUgZnJlcXVlbmN5IGRhdGEuXG5cdCAqL1xuXHRnZXRGcmVxdWVuY3lEYXRhKCkge1xuXG5cdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSggdGhpcy5kYXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSBvZiB0aGUgZnJlcXVlbmNpZXMgcmV0dXJuZWQgYnkge0BsaW5rIEF1ZGlvQW5hbHlzZXIjZ2V0RnJlcXVlbmN5RGF0YX0uXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGF2ZXJhZ2UgZnJlcXVlbmN5LlxuXHQgKi9cblx0Z2V0QXZlcmFnZUZyZXF1ZW5jeSgpIHtcblxuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhbHVlICs9IGRhdGFbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBBdWRpb0FuYWx5c2VyIH07XG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcblxuLyoqXG4gKiBCdWZmZXJlZCBzY2VuZSBncmFwaCBwcm9wZXJ0eSB0aGF0IGFsbG93cyB3ZWlnaHRlZCBhY2N1bXVsYXRpb247IHVzZWQgaW50ZXJuYWxseS5cbiAqL1xuY2xhc3MgUHJvcGVydHlNaXhlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcHJvcGVydHkgbWl4ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UHJvcGVydHlCaW5kaW5nfSBiaW5kaW5nIC0gVGhlIHByb3BlcnR5IGJpbmRpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIFRoZSBrZXlmcmFtZSB0cmFjayB0eXBlIG5hbWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVNpemUgLSBUaGUga2V5ZnJhbWUgdHJhY2sgdmFsdWUgc2l6ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBiaW5kaW5nLCB0eXBlTmFtZSwgdmFsdWVTaXplICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHByb3BlcnR5IGJpbmRpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7UHJvcGVydHlCaW5kaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUga2V5ZnJhbWUgdHJhY2sgdmFsdWUgc2l6ZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XG5cblx0XHRsZXQgbWl4RnVuY3Rpb24sXG5cdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlLFxuXHRcdFx0c2V0SWRlbnRpdHk7XG5cblx0XHQvLyBidWZmZXIgbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgfCBhZGRBY2N1IHwgKG9wdGlvbmFsIHdvcmspIF1cblx0XHQvL1xuXHRcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcblx0XHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuXHRcdC8vXG5cdFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3Jcblx0XHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3Rcblx0XHQvLyBjaGFuZ2VzXG5cdFx0Ly9cblx0XHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblx0XHQvL1xuXHRcdC8vICdhZGQnIGlzIHVzZWQgZm9yIGFkZGl0aXZlIGN1bXVsYXRpdmUgcmVzdWx0c1xuXHRcdC8vXG5cdFx0Ly8gJ3dvcmsnIGlzIG9wdGlvbmFsIGFuZCBpcyBvbmx5IHByZXNlbnQgZm9yIHF1YXRlcm5pb24gdHlwZXMuIEl0IGlzIHVzZWRcblx0XHQvLyB0byBzdG9yZSBpbnRlcm1lZGlhdGUgcXVhdGVybmlvbiBtdWx0aXBsaWNhdGlvbiByZXN1bHRzXG5cblx0XHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcblxuXHRcdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XG5cdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uO1xuXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSggdmFsdWVTaXplICogNiApO1xuXHRcdFx0XHR0aGlzLl93b3JrSW5kZXggPSA1O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NlbGVjdDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIHJlZ3VsYXIgbWl4IGZ1bmN0aW9uIGFuZCBmb3IgYWRkaXRpdmUgb24gdGhlc2UgdHlwZXMsXG5cdFx0XHRcdC8vIGFkZGl0aXZlIGlzIG5vdCByZWxldmFudCBmb3Igbm9uLW51bWVyaWMgdHlwZXNcblx0XHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSA9IHRoaXMuX3NlbGVjdDtcblxuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcjtcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSggdmFsdWVTaXplICogNSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljO1xuXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSggdmFsdWVTaXplICogNSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uID0gbWl4RnVuY3Rpb247XG5cdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUgPSBtaXhGdW5jdGlvbkFkZGl0aXZlO1xuXHRcdHRoaXMuX3NldElkZW50aXR5ID0gc2V0SWRlbnRpdHk7XG5cdFx0dGhpcy5fb3JpZ0luZGV4ID0gMztcblx0XHR0aGlzLl9hZGRJbmRleCA9IDQ7XG5cblx0XHQvKipcblx0XHQgKiBUT0RPXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVE9ET1xuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVE9ET1xuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy51c2VDb3VudCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUT0RPXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFjY3VtdWxhdGVzIGRhdGEgaW4gdGhlIGBpbmNvbWluZ2AgcmVnaW9uIGludG8gYGFjY3U8aT5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWNjdUluZGV4IC0gVGhlIGFjY3VtdWxhdGlvbiBpbmRleC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQuXG5cdCAqL1xuXHRhY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcblxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXG5cdFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGU7XG5cblx0XHRsZXQgY3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblxuXHRcdGlmICggY3VycmVudFdlaWdodCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBpIF0gPSBidWZmZXJbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcblx0XHRcdGNvbnN0IG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFjY3VtdWxhdGVzIGRhdGEgaW4gdGhlIGBpbmNvbWluZ2AgcmVnaW9uIGludG8gYGFkZGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0LlxuXHQgKi9cblx0YWNjdW11bGF0ZUFkZGl0aXZlKCB3ZWlnaHQgKSB7XG5cblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gc3RyaWRlICogdGhpcy5fYWRkSW5kZXg7XG5cblx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID09PSAwICkge1xuXG5cdFx0XHQvLyBhZGQgPSBpZGVudGl0eVxuXG5cdFx0XHR0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRkIDo9IGFkZCArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSggYnVmZmVyLCBvZmZzZXQsIDAsIHdlaWdodCwgc3RyaWRlICk7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgKz0gd2VpZ2h0O1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgc3RhdGUgb2YgYGFjY3U8aT5gIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYWNjdUluZGV4IC0gVGhlIGFjY3VtdWxhdGlvbiBpbmRleC5cblx0ICovXG5cdGFwcGx5KCBhY2N1SW5kZXggKSB7XG5cblx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQsXG5cdFx0XHR3ZWlnaHRBZGRpdGl2ZSA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlLFxuXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cblx0XHRpZiAoIHdlaWdodCA8IDEgKSB7XG5cblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcblxuXHRcdFx0Y29uc3Qgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblxuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKFxuXHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHdlaWdodEFkZGl0aXZlID4gMCApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBhZGRpdGl2ZSBhY2N1TlxuXG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSggYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArKyBpICkge1xuXG5cdFx0XHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcblxuXHRcdFx0XHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0XHRiaW5kaW5nLnNldFZhbHVlKCBidWZmZXIsIG9mZnNldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZW1lbWJlcnMgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzLlxuXHQgKi9cblx0c2F2ZU9yaWdpbmFsU3RhdGUoKSB7XG5cblx0XHRjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG5cdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXHRcdGZvciAoIGxldCBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRvIGlkZW50aXR5IGZvciBhZGRpdGl2ZVxuXHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhIHtAbGluayBQcm9wZXJ0eU1peGVyI3NhdmVPcmlnaW5hbFN0YXRlfSB0byB0aGUgYmluZGluZy5cblx0ICovXG5cdHJlc3RvcmVPcmlnaW5hbFN0YXRlKCkge1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcblx0XHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XG5cblx0fVxuXG5cdC8vIGludGVybmFsc1xuXG5cdF9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYygpIHtcblxuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYnVmZmVyWyBpIF0gPSAwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb24oKSB7XG5cblx0XHR0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYygpO1xuXHRcdHRoaXMuYnVmZmVyWyB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplICsgMyBdID0gMTtcblxuXHR9XG5cblx0X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcblxuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9vcmlnSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5idWZmZXJbIHRhcmdldEluZGV4ICsgaSBdID0gdGhpcy5idWZmZXJbIHN0YXJ0SW5kZXggKyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gbWl4IGZ1bmN0aW9uc1xuXG5cdF9zZWxlY3QoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGlmICggdCA+PSAwLjUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRcdGJ1ZmZlclsgZHN0T2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X3NsZXJwKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0ICkge1xuXG5cdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcblxuXHR9XG5cblx0X3NsZXJwQWRkaXRpdmUoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGNvbnN0IHdvcmtPZmZzZXQgPSB0aGlzLl93b3JrSW5kZXggKiBzdHJpZGU7XG5cblx0XHQvLyBTdG9yZSByZXN1bHQgaW4gaW50ZXJtZWRpYXRlIGJ1ZmZlciBvZmZzZXRcblx0XHRRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBidWZmZXIsIHdvcmtPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCApO1xuXG5cdFx0Ly8gU2xlcnAgdG8gdGhlIGludGVybWVkaWF0ZSByZXN1bHRcblx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHdvcmtPZmZzZXQsIHQgKTtcblxuXHR9XG5cblx0X2xlcnAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGNvbnN0IHMgPSAxIC0gdDtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9sZXJwQWRkaXRpdmUoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBQcm9wZXJ0eU1peGVyIH07XG4iLCIvLyBDaGFyYWN0ZXJzIFtdLjovIGFyZSByZXNlcnZlZCBmb3IgdHJhY2sgYmluZGluZyBzeW50YXguXG5jb25zdCBfUkVTRVJWRURfQ0hBUlNfUkUgPSAnXFxcXFtcXFxcXVxcXFwuOlxcXFwvJztcbmNvbnN0IF9yZXNlcnZlZFJlID0gbmV3IFJlZ0V4cCggJ1snICsgX1JFU0VSVkVEX0NIQVJTX1JFICsgJ10nLCAnZycgKTtcblxuLy8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcbi8vIG9ubHkgbGF0aW4gY2hhcmFjdGVycywgYW5kIHRoZSB1bmljb2RlIFxccHtMfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gU29cbi8vIGluc3RlYWQsIHdlIGV4Y2x1ZGUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgbWF0Y2ggZXZlcnl0aGluZyBlbHNlLlxuY29uc3QgX3dvcmRDaGFyID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJztcbmNvbnN0IF93b3JkQ2hhck9yRG90ID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRS5yZXBsYWNlKCAnXFxcXC4nLCAnJyApICsgJ10nO1xuXG4vLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxuLy8gYmUgbWF0Y2hlZCB0byBwYXJzZSB0aGUgcmVzdCBvZiB0aGUgdHJhY2sgbmFtZS5cbmNvbnN0IF9kaXJlY3RvcnlSZSA9IC8qQF9fUFVSRV9fKi8gLygoPzpXQytbXFwvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcblxuLy8gVGFyZ2V0IG5vZGUuIE1heSBjb250YWluIHdvcmQgY2hhcmFjdGVycyAoYS16QS1aMC05XykgYW5kICcuJyBvciAnLScuXG5jb25zdCBfbm9kZVJlID0gLypAX19QVVJFX18qLyAvKFdDT0QrKT8vLnNvdXJjZS5yZXBsYWNlKCAnV0NPRCcsIF93b3JkQ2hhck9yRG90ICk7XG5cbi8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcbi8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cbmNvbnN0IF9vYmplY3RSZSA9IC8qQF9fUFVSRV9fKi8gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcblxuLy8gUHJvcGVydHkgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWQgY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5XG4vLyBjb250YWluIGFueSBub24tYnJhY2tldCBjaGFyYWN0ZXJzLlxuY29uc3QgX3Byb3BlcnR5UmUgPSAvKkBfX1BVUkVfXyovIC9cXC4oV0MrKSg/OlxcWyguKylcXF0pPy8uc291cmNlLnJlcGxhY2UoICdXQycsIF93b3JkQ2hhciApO1xuXG5jb25zdCBfdHJhY2tSZSA9IG5ldyBSZWdFeHAoICcnXG5cdCsgJ14nXG5cdCsgX2RpcmVjdG9yeVJlXG5cdCsgX25vZGVSZVxuXHQrIF9vYmplY3RSZVxuXHQrIF9wcm9wZXJ0eVJlXG5cdCsgJyQnXG4pO1xuXG5jb25zdCBfc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbICdtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnLCAnbWFwJyBdO1xuXG5jbGFzcyBDb21wb3NpdGUge1xuXG5cdGNvbnN0cnVjdG9yKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xuXG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHRcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XG5cdFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0fVxuXG5cdGdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcblxuXHRcdGNvbnN0IGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XG5cblx0XHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3Rcblx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIGJpbmRpbmcuZ2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcblxuXHR9XG5cblx0c2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uc2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YmluZCgpIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVuYmluZCgpIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gTm90ZTogVGhpcyBjbGFzcyB1c2VzIGEgU3RhdGUgcGF0dGVybiBvbiBhIHBlci1tZXRob2QgYmFzaXM6XG4vLyAnYmluZCcgc2V0cyAndGhpcy5nZXRWYWx1ZScgLyAnc2V0VmFsdWUnIGFuZCBzaGFkb3dzIHRoZVxuLy8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcbi8vIHRoZSBib3VuZCBzdGF0ZS4gV2hlbiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB0aGUgbWV0aG9kc1xuLy8gYmVjb21lIG5vLW9wcy5cblxuXG4vKipcbiAqIFRoaXMgaG9sZHMgYSByZWZlcmVuY2UgdG8gYSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaDsgdXNlZCBpbnRlcm5hbGx5LlxuICovXG5jbGFzcyBQcm9wZXJ0eUJpbmRpbmcge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3BlcnR5IGJpbmRpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByb290Tm9kZSAtIFRoZSByb290IG5vZGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGguXG5cdCAqIEBwYXJhbSB7P09iamVjdH0gW3BhcnNlZFBhdGhdIC0gVGhlIHBhcnNlZCBwYXRoLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJvb3ROb2RlLCBwYXRoLCBwYXJzZWRQYXRoICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCBwYXRoIHRvIHRoZSBhbmltYXRlZCBwcm9wZXJ0eS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXRoLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCBvd25zIHRoZSBhbmltYXRlZCBwcm9wZXJ0eS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvb3Qgbm9kZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3QzRHxTa2VsZXRvbn1cblx0XHQgKi9cblx0XHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG5cblx0XHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblxuXHR9XG5cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgcHJvcGVydHkgYmluZGluZyBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByb290IC0gVGhlIHJvb3Qgbm9kZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aC5cblx0ICogQHBhcmFtIHs/T2JqZWN0fSBbcGFyc2VkUGF0aF0gLSBUaGUgcGFyc2VkIHBhdGguXG5cdCAqIEByZXR1cm4ge1Byb3BlcnR5QmluZGluZ3xDb21wb3NpdGV9IFRoZSBjcmVhdGVkIHByb3BlcnR5IGJpbmRpbmcgb3IgY29tcG9zaXRlLlxuXHQgKi9cblx0c3RhdGljIGNyZWF0ZSggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuXHRcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHQgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTm9kZSBuYW1lIHRvIGJlIHNhbml0aXplZC5cblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgc2FuaXRpemVkIG5vZGUgbmFtZS5cblx0ICovXG5cdHN0YXRpYyBzYW5pdGl6ZU5vZGVOYW1lKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIG5hbWUucmVwbGFjZSggL1xccy9nLCAnXycgKS5yZXBsYWNlKCBfcmVzZXJ2ZWRSZSwgJycgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gdHJhY2sgbmFtZSAoYW4gb2JqZWN0IHBhdGggdG8gYW4gYW5pbWF0ZWQgcHJvcGVydHkpIGFuZFxuXHQgKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXRoLiBNYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvbGxvd2luZyBmb3Jtczpcblx0ICpcblx0ICogLSBub2RlTmFtZS5wcm9wZXJ0eVxuXHQgKiAtIG5vZGVOYW1lLnByb3BlcnR5W2FjY2Vzc29yXVxuXHQgKiAtIG5vZGVOYW1lLm1hdGVyaWFsLnByb3BlcnR5W2FjY2Vzc29yXVxuXHQgKiAtIHV1aWQucHJvcGVydHlbYWNjZXNzb3JdXG5cdCAqIC0gdXVpZC5vYmplY3ROYW1lW29iamVjdEluZGV4XS5wcm9wZXJ0eU5hbWVbcHJvcGVydHlJbmRleF1cblx0ICogLSBwYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5XG5cdCAqIC0gcGFyZW50TmFtZS9wYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5W2luZGV4XVxuXHQgKiAtIC5ib25lW0FybWF0dXJlLkRFRl9jb2ddLnBvc2l0aW9uXG5cdCAqIC0gc2NlbmU6aGVsaXVtX2JhbGxvb25fbW9kZWw6aGVsaXVtX2JhbGxvb25fbW9kZWwucG9zaXRpb25cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tOYW1lIC0gVGhlIHRyYWNrIG5hbWUgdG8gcGFyc2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCB0cmFjayBuYW1lIGFzIGFuIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBwYXJzZVRyYWNrTmFtZSggdHJhY2tOYW1lICkge1xuXG5cdFx0Y29uc3QgbWF0Y2hlcyA9IF90cmFja1JlLmV4ZWMoIHRyYWNrTmFtZSApO1xuXG5cdFx0aWYgKCBtYXRjaGVzID09PSBudWxsICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdQcm9wZXJ0eUJpbmRpbmc6IENhbm5vdCBwYXJzZSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3VsdHMgPSB7XG5cdFx0XHQvLyBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWyAxIF0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxuXHRcdFx0bm9kZU5hbWU6IG1hdGNoZXNbIDIgXSxcblx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbIDMgXSxcblx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXG5cdFx0XHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbIDUgXSwgLy8gcmVxdWlyZWRcblx0XHRcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbIDYgXVxuXHRcdH07XG5cblx0XHRjb25zdCBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKTtcblxuXHRcdGlmICggbGFzdERvdCAhPT0gdW5kZWZpbmVkICYmIGxhc3REb3QgIT09IC0gMSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKCBsYXN0RG90ICsgMSApO1xuXG5cdFx0XHQvLyBPYmplY3QgbmFtZXMgbXVzdCBiZSBjaGVja2VkIGFnYWluc3QgYW4gYWxsb3dsaXN0LiBPdGhlcndpc2UsIHRoZXJlXG5cdFx0XHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcblx0XHRcdC8vICdiYXInIGNvdWxkIGJlIHRoZSBvYmplY3ROYW1lLCBvciBwYXJ0IG9mIGEgbm9kZU5hbWUgKHdoaWNoIGNhblxuXHRcdFx0Ly8gaW5jbHVkZSAnLicgY2hhcmFjdGVycykuXG5cdFx0XHRpZiAoIF9zdXBwb3J0ZWRPYmplY3ROYW1lcy5pbmRleE9mKCBvYmplY3ROYW1lICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIDAsIGxhc3REb3QgKTtcblx0XHRcdFx0cmVzdWx0cy5vYmplY3ROYW1lID0gb2JqZWN0TmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCByZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHRzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoZXMgZm9yIGEgbm9kZSBpbiB0aGUgaGllcmFyY2h5IG9mIHRoZSBnaXZlbiByb290IG9iamVjdCBieSB0aGUgZ2l2ZW5cblx0ICogbm9kZSBuYW1lLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByb290IC0gVGhlIHJvb3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG5vZGUuXG5cdCAqIEByZXR1cm4gez9PYmplY3R9IFRoZSBmb3VuZCBub2RlLiBSZXR1cm5zIGBudWxsYCBpZiBubyBvYmplY3Qgd2FzIGZvdW5kLlxuXHQgKi9cblx0c3RhdGljIGZpbmROb2RlKCByb290LCBub2RlTmFtZSApIHtcblxuXHRcdGlmICggbm9kZU5hbWUgPT09IHVuZGVmaW5lZCB8fCBub2RlTmFtZSA9PT0gJycgfHwgbm9kZU5hbWUgPT09ICcuJyB8fCBub2RlTmFtZSA9PT0gLSAxIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcblxuXHRcdFx0cmV0dXJuIHJvb3Q7XG5cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblx0XHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSByb290LnNrZWxldG9uLmdldEJvbmVCeU5hbWUoIG5vZGVOYW1lICk7XG5cblx0XHRcdGlmICggYm9uZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG5cdFx0aWYgKCByb290LmNoaWxkcmVuICkge1xuXG5cdFx0XHRjb25zdCBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uICggY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGNoaWxkTm9kZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcblxuXHRcdFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcImJpbmRcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XG5cdF9nZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cdF9zZXRWYWx1ZV91bmF2YWlsYWJsZSgpIHt9XG5cblx0Ly8gR2V0dGVyc1xuXG5cdF9nZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0YnVmZmVyWyBvZmZzZXQgXSA9IHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3Qgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuXHR9XG5cblx0Ly8gRGlyZWN0XG5cblx0X3NldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0X3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gRW50aXJlQXJyYXlcblxuXHRfc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRjb25zdCBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHR9XG5cblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gQXJyYXlFbGVtZW50XG5cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuXHR9XG5cblx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gSGFzVG9Gcm9tQXJyYXlcblxuXHRfc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRfZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcblxuXHRcdHRoaXMuYmluZCgpO1xuXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcblxuXHR9XG5cblx0X3NldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIHRoZSBwcm9wZXJ0eSB0cmFja2VkIGJ5IHRoaXMgYmluZGluZy5cblx0ICovXG5cdGJpbmQoKSB7XG5cblx0XHRsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xuXHRcdGNvbnN0IHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGg7XG5cblx0XHRjb25zdCBvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lO1xuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xuXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0dGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCB0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICk7XG5cblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcblxuXHRcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IE5vIHRhcmdldCBub2RlIGZvdW5kIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHRsZXQgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG5cdFx0XHRzd2l0Y2ggKCBvYmplY3ROYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdib25lcyc6XG5cblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcCc6XG5cblx0XHRcdFx0XHRpZiAoICdtYXAnIGluIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hcDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWFwIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hcC4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUgdW5kZWZpbmVkLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXNvbHZlIHByb3BlcnR5XG5cdFx0Y29uc3Qgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdGlmICggbm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArXG5cdFx0XHRcdCcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cdFx0bGV0IHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcblxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0aWYgKCB0YXJnZXRPYmplY3QuaXNNYXRlcmlhbCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5pc09iamVjdDNEID09PSB0cnVlICkge1xuXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cblx0XHR9XG5cblx0XHQvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXG5cdFx0bGV0IGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XG5cblx0XHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXG5cblx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJyApIHtcblxuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuJywgdGhpcyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLicsIHRoaXMgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgcHJvcGVydHlJbmRleCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gdGFyZ2V0T2JqZWN0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgcHJvcGVydHlJbmRleCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cdFx0XHR0aGlzLnByb3BlcnR5SW5kZXggPSBwcm9wZXJ0eUluZGV4O1xuXG5cdFx0fSBlbHNlIGlmICggbm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblxuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cblx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBub2RlUHJvcGVydHkgKSApIHtcblxuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkVudGlyZUFycmF5O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlWyBiaW5kaW5nVHlwZSBdO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nWyBiaW5kaW5nVHlwZSBdWyB2ZXJzaW9uaW5nIF07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmRzIHRoZSBwcm9wZXJ0eS5cblx0ICovXG5cdHVuYmluZCgpIHtcblxuXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cblx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG5cdFx0Ly8gbm90ZTogYXZvaWRpbmcgdG8gbXV0YXRlIHRoZSBzaGFwZSBvZiAndGhpcycgdmlhICdkZWxldGUnXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cblx0fVxuXG59XG5cblByb3BlcnR5QmluZGluZy5Db21wb3NpdGUgPSBDb21wb3NpdGU7XG5cblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuQmluZGluZ1R5cGUgPSB7XG5cdERpcmVjdDogMCxcblx0RW50aXJlQXJyYXk6IDEsXG5cdEFycmF5RWxlbWVudDogMixcblx0SGFzRnJvbVRvQXJyYXk6IDNcbn07XG5cblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuVmVyc2lvbmluZyA9IHtcblx0Tm9uZTogMCxcblx0TmVlZHNVcGRhdGU6IDEsXG5cdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcbn07XG5cblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuR2V0dGVyQnlCaW5kaW5nVHlwZSA9IFtcblxuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9kaXJlY3QsXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5LFxuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheUVsZW1lbnQsXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX3RvQXJyYXksXG5cbl07XG5cblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmcgPSBbXG5cblx0W1xuXHRcdC8vIERpcmVjdFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdCxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsXG5cblx0XSwgW1xuXG5cdFx0Ly8gRW50aXJlQXJyYXlcblxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlLFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsXG5cblx0XSwgW1xuXG5cdFx0Ly8gQXJyYXlFbGVtZW50XG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50LFxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcblxuXHRdLCBbXG5cblx0XHQvLyBIYXNUb0Zyb21BcnJheVxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheSxcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUsXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsXG5cblx0XVxuXG5dO1xuXG5cbmV4cG9ydCB7IFByb3BlcnR5QmluZGluZyB9O1xuIiwiaW1wb3J0IHsgUHJvcGVydHlCaW5kaW5nIH0gZnJvbSAnLi9Qcm9wZXJ0eUJpbmRpbmcuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVVVUlEIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG4vKipcbiAqIEEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IHJlY2VpdmVzIGEgc2hhcmVkIGFuaW1hdGlvbiBzdGF0ZS5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAtIEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXG4gKiBjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxuICogLSBJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuICogLSBZb3UgY2FuIGFsc28gYWRkIGFuZCByZW1vdmUgb2JqZWN0cyBsYXRlciB3aGVuIHRoZSBtaXhlciBpcyBydW5uaW5nLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxuICogc28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZSBvbiB0aGUgZ3JvdXAuXG4gKlxuICogTGltaXRhdGlvbjpcbiAqXG4gKiAtIFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGUgYWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxuICogLSBBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhIHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuICovXG5jbGFzcyBBbmltYXRpb25PYmplY3RHcm91cCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYW5pbWF0aW9uIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdDNEfSBhcmd1bWVudHMgLSBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIDNEIG9iamVjdHMgdGhhdCBzaGFyZSB0aGUgc2FtZSBhbmltYXRpb24gc3RhdGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNBbmltYXRpb25PYmplY3RHcm91cCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgVVVJRCBvZiB0aGUgM0Qgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuXHRcdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xuXHRcdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IDA7IC8vIHRocmVzaG9sZFxuXHRcdC8vIG5vdGU6IHJlYWQgYnkgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZVxuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IHt9O1xuXHRcdHRoaXMuX2luZGljZXNCeVVVSUQgPSBpbmRpY2VzOyAvLyBmb3IgYm9va2tlZXBpbmdcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGluZGljZXNbIGFyZ3VtZW50c1sgaSBdLnV1aWQgXSA9IGk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9wYXRocyA9IFtdOyAvLyBpbnNpZGU6IHN0cmluZ1xuXHRcdHRoaXMuX3BhcnNlZFBhdGhzID0gW107IC8vIGluc2lkZTogeyB3ZSBkb24ndCBjYXJlLCBoZXJlIH1cblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxuXHRcdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyAvLyBpbnNpZGU6IGluZGljZXMgaW4gdGhlc2UgYXJyYXlzXG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHR0aGlzLnN0YXRzID0ge1xuXG5cdFx0XHRvYmplY3RzOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fb2JqZWN0cy5sZW5ndGg7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHtcblxuXHRcdFx0XHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBvYmplY3RzIHRvIHRoaXMgYW5pbWF0aW9uIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdDNEfSBhcmd1bWVudHMgLSBUaGUgM0Qgb2JqZWN0cyB0byBhZGQuXG5cdCAqL1xuXHRhZGQoKSB7XG5cblx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0cGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0bGV0IGtub3duT2JqZWN0ID0gdW5kZWZpbmVkLFxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcblx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0bGV0IGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cblx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cyArKztcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdGJpbmRpbmdzWyBqIF0ucHVzaCggbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0a25vd25PYmplY3QgPSBvYmplY3RzWyBpbmRleCBdO1xuXG5cdFx0XHRcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cblx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0XHRcdFx0bGV0IGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xuXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xuXHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcblx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcblxuXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0c1sgaW5kZXggXSAhPT0ga25vd25PYmplY3QgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwOiBEaWZmZXJlbnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIFVVSUQgJyArXG5cdFx0XHRcdFx0J2RldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLicgKTtcblxuXHRcdFx0fSAvLyBlbHNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlXG5cblx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGFyYml0cmFyeSBudW1iZXIgb2Ygb2JqZWN0cyB0byB0aGlzIGFuaW1hdGlvbiBncm91cFxuXHQgKlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdDNEfSBhcmd1bWVudHMgLSBUaGUgM0Qgb2JqZWN0cyB0byByZW1vdmUuXG5cdCAqL1xuXHRyZW1vdmUoKSB7XG5cblx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblxuXHRcdGxldCBuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCBpbnRvIHRoZSBDQUNIRUQgcmVnaW9uXG5cblx0XHRcdFx0Y29uc3QgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXG5cdFx0XHRcdFx0Zmlyc3RBY3RpdmVPYmplY3QgPSBvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXTtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xuXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGxhc3RDYWNoZWRJbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0sXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gZmlyc3RBY3RpdmU7XG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWFsbG9jYXRlcyBhbGwgbWVtb3J5IHJlc291cmNlcyBmb3IgdGhlIHBhc3NlZCAzRCBvYmplY3RzIG9mIHRoaXMgYW5pbWF0aW9uIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdDNEfSBhcmd1bWVudHMgLSBUaGUgM0Qgb2JqZWN0cyB0byB1bmNhY2hlLlxuXHQgKi9cblx0dW5jYWNoZSgpIHtcblxuXHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxuXG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2Vcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXG5cdFx0XHRcdFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcblxuXHRcdFx0XHRcdGNvbnN0IGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHR9XG5cblx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG5cdHN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aDtcblx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHJldHVybiBiaW5kaW5nc1sgaW5kZXggXTtcblxuXHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheSggbk9iamVjdHMgKTtcblxuXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cblx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3QgPSBvYmplY3RzWyBpIF07XG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcblxuXHR9XG5cblx0dW5zdWJzY3JpYmVfKCBwYXRoICkge1xuXG5cdFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxuXHRcdC8vIHVwZGF0ZSB0aGUgYXJyYXkgcHJldmlvdXNseSBvYnRhaW5lZCB3aXRoICdzdWJzY3JpYmVfJ1xuXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcblx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuXHRcdFx0aW5kaWNlc0J5UGF0aFsgbGFzdEJpbmRpbmdzUGF0aCBdID0gaW5kZXg7XG5cblx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblxuXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdHBhdGhzLnBvcCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBBbmltYXRpb25PYmplY3RHcm91cCB9O1xuIiwiaW1wb3J0IHsgV3JhcEFyb3VuZEVuZGluZywgWmVyb0N1cnZhdHVyZUVuZGluZywgWmVyb1Nsb3BlRW5kaW5nLCBMb29wUGluZ1BvbmcsIExvb3BPbmNlLCBMb29wUmVwZWF0LCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUsIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBgQW5pbWF0aW9uQWN0aW9uYCBzY2hlZHVsZXMgdGhlIHBsYXliYWNrIG9mIGFuIGFuaW1hdGlvbiB3aGljaCBpc1xuICogc3RvcmVkIGluIHtAbGluayBBbmltYXRpb25DbGlwfS5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uQWN0aW9uIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbk1peGVyfSBtaXhlciAtIFRoZSBtaXhlciB0aGF0IGlzIGNvbnRyb2xsZWQgYnkgdGhpcyBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQ2xpcH0gY2xpcCAtIFRoZSBhbmltYXRpb24gY2xpcCB0aGF0IGhvbGRzIHRoZSBhY3R1YWwga2V5ZnJhbWVzLlxuXHQgKiBAcGFyYW0gez9PYmplY3QzRH0gW2xvY2FsUm9vdD1udWxsXSAtIFRoZSByb290IG9iamVjdCBvbiB3aGljaCB0aGlzIGFjdGlvbiBpcyBwZXJmb3JtZWQuXG5cdCAqIEBwYXJhbSB7KE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZXxBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSl9IFtibGVuZE1vZGVdIC0gVGhlIGJsZW5kIG1vZGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWl4ZXIsIGNsaXAsIGxvY2FsUm9vdCA9IG51bGwsIGJsZW5kTW9kZSA9IGNsaXAuYmxlbmRNb2RlICkge1xuXG5cdFx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcblx0XHR0aGlzLl9jbGlwID0gY2xpcDtcblx0XHR0aGlzLl9sb2NhbFJvb3QgPSBsb2NhbFJvb3Q7XG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGhvdyB0aGUgYW5pbWF0aW9uIGlzIGJsZW5kZWQvY29tYmluZWQgd2hlbiB0d28gb3IgbW9yZSBhbmltYXRpb25zXG5cdFx0ICogYXJlIHNpbXVsdGFuZW91c2x5IHBsYXllZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHsoTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlfEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlKX1cblx0XHQgKi9cblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IGNsaXAudHJhY2tzLFxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdGNvbnN0IGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcblx0XHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHRcdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50czsgLy8gYm91bmQgYnkgdGhlIG1peGVyXG5cblx0XHQvLyBpbnNpZGU6IFByb3BlcnR5TWl4ZXIgKG1hbmFnZWQgYnkgdGhlIG1peGVyKVxuXHRcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHRcdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0dGhpcy5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7IC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcblxuXHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9vcCBtb2RlLCBzZXQgdmlhIHtAbGluayBBbmltYXRpb25BY3Rpb24jc2V0TG9vcH0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KExvb3BSZXBlYXR8TG9vcE9uY2V8TG9vcFBpbmdQb25nKX1cblx0XHQgKiBAZGVmYXVsdCBMb29wUmVwZWF0XG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gTG9vcFJlcGVhdDtcblx0XHR0aGlzLl9sb29wQ291bnQgPSAtIDE7XG5cblx0XHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxuXHRcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9jYWwgdGltZSBvZiB0aGlzIGFjdGlvbiAoaW4gc2Vjb25kcywgc3RhcnRpbmcgd2l0aCBgMGApLlxuXHRcdCAqXG5cdFx0ICogVGhlIHZhbHVlIGdldHMgY2xhbXBlZCBvciB3cmFwcGVkIHRvIGBbMCxjbGlwLmR1cmF0aW9uXWAgKGFjY29yZGluZyB0byB0aGVcblx0XHQgKiBsb29wIHN0YXRlKS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgSW5maW5pdHlcblx0XHQgKi9cblx0XHR0aGlzLnRpbWUgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSB7QGxpbmsgQW5pbWF0aW9uQWN0aW9uI3RpbWV9LiBBIHZhbHVlIG9mIGAwYCBjYXVzZXMgdGhlXG5cdFx0ICogYW5pbWF0aW9uIHRvIHBhdXNlLiBOZWdhdGl2ZSB2YWx1ZXMgY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBwbGF5IGJhY2t3YXJkcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZVNjYWxlID0gMTtcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZ3JlZSBvZiBpbmZsdWVuY2Ugb2YgdGhpcyBhY3Rpb24gKGluIHRoZSBpbnRlcnZhbCBgWzAsIDFdYCkuIFZhbHVlc1xuXHRcdCAqIGJldHdlZW4gYDBgIChubyBpbXBhY3QpIGFuZCBgMWAgKGZ1bGwgaW1wYWN0KSBjYW4gYmUgdXNlZCB0byBibGVuZCBiZXR3ZWVuXG5cdFx0ICogc2V2ZXJhbCBhY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy53ZWlnaHQgPSAxO1xuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHJlcGV0aXRpb25zIG9mIHRoZSBwZXJmb3JtZWQgY2xpcCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhpcyBhY3Rpb24uXG5cdFx0ICogQ2FuIGJlIHNldCB2aWEge0BsaW5rIEFuaW1hdGlvbkFjdGlvbiNzZXRMb29wfS5cblx0XHQgKlxuXHRcdCAqIFNldHRpbmcgdGhpcyBudW1iZXIgaGFzIG5vIGVmZmVjdCBpZiB7QGxpbmsgQW5pbWF0aW9uQWN0aW9uI2xvb3B9IGlzIHNldCB0b1xuXHRcdCAqIGBUSFJFRTpMb29wT25jZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IEluZmluaXR5XG5cdFx0ICovXG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5O1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHBsYXliYWNrIG9mIHRoZSBhY3Rpb24gaXMgcGF1c2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGBmYWxzZWAsIHRoZSBhY3Rpb24gaXMgZGlzYWJsZWQgc28gaXQgaGFzIG5vIGltcGFjdC5cblx0XHQgKlxuXHRcdCAqIFdoZW4gdGhlIGFjdGlvbiBpcyByZS1lbmFibGVkLCB0aGUgYW5pbWF0aW9uIGNvbnRpbnVlcyBmcm9tIGl0cyBjdXJyZW50XG5cdFx0ICogdGltZSAoc2V0dGluZyBgZW5hYmxlZGAgdG8gYGZhbHNlYCBkb2Vzbid0IHJlc2V0IHRoZSBhY3Rpb24pLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBJZiBzZXQgdG8gdHJ1ZSB0aGUgYW5pbWF0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBwYXVzZWQgb24gaXRzIGxhc3QgZnJhbWUuXG5cdFx0ICpcblx0XHQgKiBJZiBzZXQgdG8gZmFsc2UsIHtAbGluayBBbmltYXRpb25BY3Rpb24jZW5hYmxlZH0gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHN3aXRjaGVkXG5cdFx0ICogdG8gYGZhbHNlYCB3aGVuIHRoZSBsYXN0IGxvb3Agb2YgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgdGhpcyBhY3Rpb24gaGFzXG5cdFx0ICogbm8gZnVydGhlciBpbXBhY3QuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBUaGlzIG1lbWJlciBoYXMgbm8gaW1wYWN0IGlmIHRoZSBhY3Rpb24gaXMgaW50ZXJydXB0ZWQgKGl0XG5cdFx0ICogaGFzIG9ubHkgYW4gZWZmZWN0IGlmIGl0cyBsYXN0IGxvb3AgaGFzIHJlYWxseSBmaW5pc2hlZCkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZXMgc21vb3RoIGludGVycG9sYXRpb24gd2l0aG91dCBzZXBhcmF0ZSBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlcyBzbW9vdGggaW50ZXJwb2xhdGlvbiB3aXRob3V0IHNlcGFyYXRlIGNsaXBzIGZvciBzdGFydCwgbG9vcCBhbmQgZW5kLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuemVyb1Nsb3BlQXRFbmQgPSB0cnVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIHRoZSBwbGF5YmFjayBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHBsYXkoKSB7XG5cblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgdGhlIHBsYXliYWNrIG9mIHRoZSBhbmltYXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkFjdGlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKi9cblx0c3RvcCgpIHtcblxuXHRcdHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBwbGF5YmFjayBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHJlc2V0KCkge1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy50aW1lID0gMDsgLy8gcmVzdGFydCBjbGlwXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxOy8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBpcyBydW5uaW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBhbmltYXRpb24gaXMgcnVubmluZyBvciBub3QuXG5cdCAqL1xuXHRpc1J1bm5pbmcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIHdoZW4ge0BsaW5rIEFuaW1hdGlvbkFjdGlvbiNwbGF5fSBoYXMgYmVlbiBjYWxsZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBzY2hlZHVsZWQgb3Igbm90LlxuXHQgKi9cblx0aXNTY2hlZHVsZWQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSB0aW1lIHdoZW4gdGhlIGFuaW1hdGlvbiBzaG91bGQgc3RhcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIC0gVGhlIHN0YXJ0IHRpbWUgaW4gc2Vjb25kcy5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQWN0aW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIGFuaW1hdGlvbiBhY3Rpb24uXG5cdCAqL1xuXHRzdGFydEF0KCB0aW1lICkge1xuXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29uZmlndXJlcyB0aGUgbG9vcCBzZXR0aW5ncyBmb3IgdGhpcyBhY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7KExvb3BSZXBlYXR8TG9vcE9uY2V8TG9vcFBpbmdQb25nKX0gbW9kZSAtIFRoZSBsb29wIG1vZGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByZXBldGl0aW9ucyAtIFRoZSBudW1iZXIgb2YgcmVwZXRpdGlvbnMuXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkFjdGlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKi9cblx0c2V0TG9vcCggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XG5cblx0XHR0aGlzLmxvb3AgPSBtb2RlO1xuXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZWZmZWN0aXZlIHdlaWdodCBvZiB0aGlzIGFjdGlvbi5cblx0ICpcblx0ICogQW4gYWN0aW9uIGhhcyBubyBlZmZlY3QgYW5kIHRodXMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvIHdoZW4gdGhlXG5cdCAqIGFjdGlvbiBpcyBkaXNhYmxlZC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHNldEVmZmVjdGl2ZVdlaWdodCggd2VpZ2h0ICkge1xuXG5cdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG5cblx0XHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXG5cdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gdGhpcy5lbmFibGVkID8gd2VpZ2h0IDogMDtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgdGhpcyBhY3Rpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGVmZmVjdGl2ZSB3ZWlnaHQuXG5cdCAqL1xuXHRnZXRFZmZlY3RpdmVXZWlnaHQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0O1xuXG5cdH1cblxuXHQvKipcblx0ICogRmFkZXMgdGhlIGFuaW1hdGlvbiBpbiBieSBpbmNyZWFzaW5nIGl0cyB3ZWlnaHQgZ3JhZHVhbGx5IGZyb20gYDBgIHRvIGAxYCxcblx0ICogd2l0aGluIHRoZSBwYXNzZWQgdGltZSBpbnRlcnZhbC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBmYWRlLlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdGZhZGVJbiggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAwLCAxICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGYWRlcyB0aGUgYW5pbWF0aW9uIG91dCBieSBkZWNyZWFzaW5nIGl0cyB3ZWlnaHQgZ3JhZHVhbGx5IGZyb20gYDFgIHRvIGAwYCxcblx0ICogd2l0aGluIHRoZSBwYXNzZWQgdGltZSBpbnRlcnZhbC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBmYWRlLlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdGZhZGVPdXQoIGR1cmF0aW9uICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2F1c2VzIHRoaXMgYWN0aW9uIHRvIGZhZGUgaW4gYW5kIHRoZSBnaXZlbiBhY3Rpb24gdG8gZmFkZSBvdXQsXG5cdCAqIHdpdGhpbiB0aGUgcGFzc2VkIHRpbWUgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQWN0aW9ufSBmYWRlT3V0QWN0aW9uIC0gVGhlIGFuaW1hdGlvbiBhY3Rpb24gdG8gZmFkZSBvdXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgZmFkZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbd2FycD1mYWxzZV0gLSBXaGV0aGVyIHdhcnBpbmcgc2hvdWxkIGJlIHVzZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdGNyb3NzRmFkZUZyb20oIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwID0gZmFsc2UgKSB7XG5cblx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoIGR1cmF0aW9uICk7XG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XG5cblx0XHRpZiAoIHdhcnAgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcblxuXHRcdFx0XHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXG5cdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcblxuXHRcdFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XG5cdFx0XHR0aGlzLndhcnAoIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2F1c2VzIHRoaXMgYWN0aW9uIHRvIGZhZGUgb3V0IGFuZCB0aGUgZ2l2ZW4gYWN0aW9uIHRvIGZhZGUgaW4sXG5cdCAqIHdpdGhpbiB0aGUgcGFzc2VkIHRpbWUgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQWN0aW9ufSBmYWRlSW5BY3Rpb24gLSBUaGUgYW5pbWF0aW9uIGFjdGlvbiB0byBmYWRlIGluLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gb2YgdGhlIGZhZGUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dhcnA9ZmFsc2VdIC0gV2hldGhlciB3YXJwaW5nIHNob3VsZCBiZSB1c2VkIG9yIG5vdC5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQWN0aW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIGFuaW1hdGlvbiBhY3Rpb24uXG5cdCAqL1xuXHRjcm9zc0ZhZGVUbyggZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCA9IGZhbHNlICkge1xuXG5cdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgYW55IGZhZGluZyB3aGljaCBpcyBhcHBsaWVkIHRvIHRoaXMgYWN0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHN0b3BGYWRpbmcoKSB7XG5cblx0XHRjb25zdCB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB3ZWlnaHRJbnRlcnBvbGFudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB0aGlzIGFjdGlvbi5cblx0ICpcblx0ICogQW4gYWN0aW9uIGhhcyBubyBlZmZlY3QgYW5kIHRodXMgYW4gZWZmZWN0aXZlIHRpbWUgc2NhbGUgb2YgemVybyB3aGVuIHRoZVxuXHQgKiBhY3Rpb24gaXMgcGF1c2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlIC0gVGhlIHRpbWUgc2NhbGUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHNldEVmZmVjdGl2ZVRpbWVTY2FsZSggdGltZVNjYWxlICkge1xuXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHRoaXMgYWN0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlZmZlY3RpdmUgdGltZSBzY2FsZS5cblx0ICovXG5cdGdldEVmZmVjdGl2ZVRpbWVTY2FsZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkdXJhdGlvbiBmb3IgYSBzaW5nbGUgbG9vcCBvZiB0aGlzIGFjdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIHRvIHNldC5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQWN0aW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIGFuaW1hdGlvbiBhY3Rpb24uXG5cdCAqL1xuXHRzZXREdXJhdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTeW5jaHJvbml6ZXMgdGhpcyBhY3Rpb24gd2l0aCB0aGUgcGFzc2VkIG90aGVyIGFjdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtBbmltYXRpb25BY3Rpb259IGFjdGlvbiAtIFRoZSBhY3Rpb24gdG8gc3luYyB3aXRoLlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdHN5bmNXaXRoKCBhY3Rpb24gKSB7XG5cblx0XHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcblx0XHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XG5cblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVjZWxlcmF0ZXMgdGhpcyBhbmltYXRpb24ncyBzcGVlZCB0byBgMGAgd2l0aGluIHRoZSBwYXNzZWQgdGltZSBpbnRlcnZhbC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uLlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25BY3Rpb259IEEgcmVmZXJlbmNlIHRvIHRoaXMgYW5pbWF0aW9uIGFjdGlvbi5cblx0ICovXG5cdGhhbHQoIGR1cmF0aW9uICkge1xuXG5cdFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLCAwLCBkdXJhdGlvbiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgcGxheWJhY2sgc3BlZWQsIHdpdGhpbiB0aGUgcGFzc2VkIHRpbWUgaW50ZXJ2YWwsIGJ5IG1vZGlmeWluZ1xuXHQgKiB7QGxpbmsgQW5pbWF0aW9uQWN0aW9uI3RpbWVTY2FsZX0gZ3JhZHVhbGx5IGZyb20gYHN0YXJ0VGltZVNjYWxlYCB0b1xuXHQgKiBgZW5kVGltZVNjYWxlYC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZVNjYWxlIC0gVGhlIHN0YXJ0IHRpbWUgc2NhbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlbmRUaW1lU2NhbGUgLSBUaGUgZW5kIHRpbWUgc2NhbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbi5cblx0ICogQHJldHVybiB7QW5pbWF0aW9uQWN0aW9ufSBBIHJlZmVyZW5jZSB0byB0aGlzIGFuaW1hdGlvbiBhY3Rpb24uXG5cdCAqL1xuXHR3YXJwKCBzdGFydFRpbWVTY2FsZSwgZW5kVGltZVNjYWxlLCBkdXJhdGlvbiApIHtcblxuXHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsXG5cdFx0XHRub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRsZXQgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuXHRcdHRpbWVzWyAwIF0gPSBub3c7XG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xuXG5cdFx0dmFsdWVzWyAwIF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHR2YWx1ZXNbIDEgXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgYW55IHNjaGVkdWxlZCB3YXJwaW5nIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhpcyBhY3Rpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbkFjdGlvbn0gQSByZWZlcmVuY2UgdG8gdGhpcyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKi9cblx0c3RvcFdhcnBpbmcoKSB7XG5cblx0XHRjb25zdCB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG5cdFx0aWYgKCB0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB0aW1lU2NhbGVJbnRlcnBvbGFudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbmltYXRpb24gbWl4ZXIgb2YgdGhpcyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25NaXhlcn0gVGhlIGFuaW1hdGlvbiBtaXhlci5cblx0ICovXG5cdGdldE1peGVyKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX21peGVyO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5pbWF0aW9uIGNsaXAgb2YgdGhpcyBhbmltYXRpb24gYWN0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25DbGlwfSBUaGUgYW5pbWF0aW9uIGNsaXAuXG5cdCAqL1xuXHRnZXRDbGlwKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NsaXA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByb290IG9iamVjdCBvZiB0aGlzIGFuaW1hdGlvbiBhY3Rpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdDNEfSBUaGUgcm9vdCBvYmplY3QuXG5cdCAqL1xuXHRnZXRSb290KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcblxuXHR9XG5cblx0Ly8gSW50ZXJuYVxuXG5cdF91cGRhdGUoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICkge1xuXG5cdFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxuXG5cdFx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHtcblxuXHRcdFx0Ly8gY2FsbCAuX3VwZGF0ZVdlaWdodCgpIHRvIHVwZGF0ZSAuX2VmZmVjdGl2ZVdlaWdodFxuXG5cdFx0XHR0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblxuXHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxuXG5cdFx0XHRjb25zdCB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcblx0XHRcdGlmICggdGltZVJ1bm5pbmcgPCAwIHx8IHRpbWVEaXJlY3Rpb24gPT09IDAgKSB7XG5cblx0XHRcdFx0ZGVsdGFUaW1lID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcblxuXHRcdGRlbHRhVGltZSAqPSB0aGlzLl91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKTtcblx0XHRjb25zdCBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApO1xuXG5cdFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cblx0XHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcblxuXHRcdGNvbnN0IHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xuXG5cdFx0aWYgKCB3ZWlnaHQgPiAwICkge1xuXG5cdFx0XHRjb25zdCBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XG5cdFx0XHRjb25zdCBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMuYmxlbmRNb2RlICkge1xuXG5cdFx0XHRcdGNhc2UgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU6XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcblx0XHRcdFx0XHRcdHByb3BlcnR5TWl4ZXJzWyBqIF0uYWNjdW11bGF0ZUFkZGl0aXZlKCB3ZWlnaHQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlOlxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X3VwZGF0ZVdlaWdodCggdGltZSApIHtcblxuXHRcdGxldCB3ZWlnaHQgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgKSB7XG5cblx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xuXG5cdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xuXG5cdFx0XHRcdFx0dGhpcy5zdG9wRmFkaW5nKCk7XG5cblx0XHRcdFx0XHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZhZGVkIG91dCwgZGlzYWJsZVxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0cmV0dXJuIHdlaWdodDtcblxuXHR9XG5cblx0X3VwZGF0ZVRpbWVTY2FsZSggdGltZSApIHtcblxuXHRcdGxldCB0aW1lU2NhbGUgPSAwO1xuXG5cdFx0aWYgKCAhIHRoaXMucGF1c2VkICkge1xuXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xuXG5cdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xuXG5cdFx0XHRcdFx0dGhpcy5zdG9wV2FycGluZygpO1xuXG5cdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIG1vdGlvbiBoYXMgaGFsdGVkLCBwYXVzZVxuXHRcdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gd2FycCBkb25lIC0gYXBwbHkgZmluYWwgdGltZSBzY2FsZVxuXHRcdFx0XHRcdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0cmV0dXJuIHRpbWVTY2FsZTtcblxuXHR9XG5cblx0X3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApIHtcblxuXHRcdGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbjtcblx0XHRjb25zdCBsb29wID0gdGhpcy5sb29wO1xuXG5cdFx0bGV0IHRpbWUgPSB0aGlzLnRpbWUgKyBkZWx0YVRpbWU7XG5cdFx0bGV0IGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudDtcblxuXHRcdGNvbnN0IHBpbmdQb25nID0gKCBsb29wID09PSBMb29wUGluZ1BvbmcgKTtcblxuXHRcdGlmICggZGVsdGFUaW1lID09PSAwICkge1xuXG5cdFx0XHRpZiAoIGxvb3BDb3VudCA9PT0gLSAxICkgcmV0dXJuIHRpbWU7XG5cblx0XHRcdHJldHVybiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsb29wID09PSBMb29wT25jZSApIHtcblxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblxuXHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSAwO1xuXHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGhhbmRsZV9zdG9wOiB7XG5cblx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uICkge1xuXG5cdFx0XHRcdFx0dGltZSA9IGR1cmF0aW9uO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0dGltZSA9IDA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0XHRicmVhayBoYW5kbGVfc3RvcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuXHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA8IDAgPyAtIDEgOiAxXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHsgLy8gcmVwZXRpdGl2ZSBSZXBlYXQgb3IgUGluZ1BvbmdcblxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblxuXHRcdFx0XHRpZiAoIGRlbHRhVGltZSA+PSAwICkge1xuXG5cdFx0XHRcdFx0bG9vcENvdW50ID0gMDtcblxuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcblx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxuXHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxuXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xuXG5cdFx0XHRcdC8vIHdyYXAgYXJvdW5kXG5cblx0XHRcdFx0Y29uc3QgbG9vcERlbHRhID0gTWF0aC5mbG9vciggdGltZSAvIGR1cmF0aW9uICk7IC8vIHNpZ25lZFxuXHRcdFx0XHR0aW1lIC09IGR1cmF0aW9uICogbG9vcERlbHRhO1xuXG5cdFx0XHRcdGxvb3BDb3VudCArPSBNYXRoLmFicyggbG9vcERlbHRhICk7XG5cblx0XHRcdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XG5cblx0XHRcdFx0aWYgKCBwZW5kaW5nIDw9IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBoYXZlIHRvIHN0b3AgKHN3aXRjaCBzdGF0ZSwgY2xhbXAgdGltZSwgZmlyZSBldmVudClcblxuXHRcdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuXHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPiAwID8gMSA6IC0gMVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8ga2VlcCBydW5uaW5nXG5cblx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXG5cblx0XHRcdFx0XHRcdGNvbnN0IGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggYXRTdGFydCwgISBhdFN0YXJ0LCBwaW5nUG9uZyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gbG9vcENvdW50O1xuXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6IGxvb3BEZWx0YVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkge1xuXG5cdFx0XHRcdC8vIGludmVydCB0aW1lIGZvciB0aGUgXCJwb25nIHJvdW5kXCJcblxuXHRcdFx0XHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGltZTtcblxuXHR9XG5cblx0X3NldEVuZGluZ3MoIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcblxuXHRcdGNvbnN0IHNldHRpbmdzID0gdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHRcdGlmICggcGluZ1BvbmcgKSB7XG5cblx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gWmVyb1Nsb3BlRW5kaW5nO1xuXHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gWmVyb1Nsb3BlRW5kaW5nO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuXG5cdFx0XHRpZiAoIGF0U3RhcnQgKSB7XG5cblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gV3JhcEFyb3VuZEVuZGluZztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0RW5kICkge1xuXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IHRoaXMuemVyb1Nsb3BlQXRFbmQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCBcdCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgd2VpZ2h0Tm93LCB3ZWlnaHRUaGVuICkge1xuXG5cdFx0Y29uc3QgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZTtcblx0XHRsZXQgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuXHRcdHRpbWVzWyAwIF0gPSBub3c7XG5cdFx0dmFsdWVzWyAwIF0gPSB3ZWlnaHROb3c7XG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xuXHRcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEFuaW1hdGlvbkFjdGlvbiB9O1xuIiwiaW1wb3J0IHsgQW5pbWF0aW9uQWN0aW9uIH0gZnJvbSAnLi9BbmltYXRpb25BY3Rpb24uanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vY29yZS9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgTGluZWFySW50ZXJwb2xhbnQgfSBmcm9tICcuLi9tYXRoL2ludGVycG9sYW50cy9MaW5lYXJJbnRlcnBvbGFudC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUJpbmRpbmcgfSBmcm9tICcuL1Byb3BlcnR5QmluZGluZy5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eU1peGVyIH0gZnJvbSAnLi9Qcm9wZXJ0eU1peGVyLmpzJztcbmltcG9ydCB7IEFuaW1hdGlvbkNsaXAgfSBmcm9tICcuL0FuaW1hdGlvbkNsaXAuanMnO1xuaW1wb3J0IHsgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCAxICk7XG5cbi8qKlxuICogYEFuaW1hdGlvbk1peGVyYCBpcyBhIHBsYXllciBmb3IgYW5pbWF0aW9ucyBvbiBhIHBhcnRpY3VsYXIgb2JqZWN0IGluXG4gKiB0aGUgc2NlbmUuIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBpbiB0aGUgc2NlbmUgYXJlIGFuaW1hdGVkIGluZGVwZW5kZW50bHksXG4gKiBvbmUgYEFuaW1hdGlvbk1peGVyYCBtYXkgYmUgdXNlZCBmb3IgZWFjaCBvYmplY3QuXG4gKi9cbmNsYXNzIEFuaW1hdGlvbk1peGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhbmltYXRpb24gbWl4ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IHJvb3QgLSBUaGUgb2JqZWN0IHdob3NlIGFuaW1hdGlvbnMgc2hhbGwgYmUgcGxheWVkIGJ5IHRoaXMgbWl4ZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggcm9vdCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9yb290ID0gcm9vdDtcblx0XHR0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpO1xuXHRcdHRoaXMuX2FjY3VJbmRleCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZ2xvYmFsIG1peGVyIHRpbWUgKGluIHNlY29uZHM7IHN0YXJ0aW5nIHdpdGggYDBgIG9uIHRoZSBtaXhlcidzIGNyZWF0aW9uKS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMudGltZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgZ2xvYmFsIHRpbWUuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBTZXR0aW5nIHRoaXMgbWVtYmVyIHRvIGAwYCBhbmQgbGF0ZXIgYmFjayB0byBgMWAgaXMgYVxuXHRcdCAqIHBvc3NpYmlsaXR5IHRvIHBhdXNlL3VucGF1c2UgYWxsIGFjdGlvbnMgdGhhdCBhcmUgY29udHJvbGxlZCBieSB0aGlzXG5cdFx0ICogbWl4ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblxuXHR9XG5cblx0X2JpbmRBY3Rpb24oIGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uICkge1xuXG5cdFx0Y29uc3Qgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcblx0XHRcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZTtcblxuXHRcdGxldCBiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nc0J5TmFtZTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgdHJhY2sgPSB0cmFja3NbIGkgXSxcblx0XHRcdFx0dHJhY2tOYW1lID0gdHJhY2submFtZTtcblxuXHRcdFx0bGV0IGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVsgdHJhY2tOYW1lIF07XG5cblx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xuXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcGF0aCA9IHByb3RvdHlwZUFjdGlvbiAmJiBwcm90b3R5cGVBY3Rpb24uXG5cdFx0XHRcdFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XG5cblx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFxuXHRcdFx0XHRcdFByb3BlcnR5QmluZGluZy5jcmVhdGUoIHJvb3QsIHRyYWNrTmFtZSwgcGF0aCApLFxuXHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XG5cblx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9hY3RpdmF0ZUFjdGlvbiggYWN0aW9uICkge1xuXG5cdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0aWYgKCBhY3Rpb24uX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXG5cdFx0XHRcdC8vIGFwcGVhcnMgdG8gYmUgc3RpbGwgdXNpbmcgaXQgLT4gcmViaW5kXG5cblx0XHRcdFx0Y29uc3Qgcm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkLFxuXHRcdFx0XHRcdGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0XHRcdHRoaXMuX2JpbmRBY3Rpb24oIGFjdGlvbixcblx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXSApO1xuXG5cdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHQvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nLnVzZUNvdW50ICsrID09PSAwICkge1xuXG5cdFx0XHRcdFx0dGhpcy5fbGVuZEJpbmRpbmcoIGJpbmRpbmcgKTtcblx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICkge1xuXG5cdFx0aWYgKCB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XG5cblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCAtLSBiaW5kaW5nLnVzZUNvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VyXG5cblx0X2luaXRNZW1vcnlNYW5hZ2VyKCkge1xuXG5cdFx0dGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cblx0XHR0aGlzLl9hY3Rpb25zQnlDbGlwID0ge307XG5cdFx0Ly8gaW5zaWRlOlxuXHRcdC8vIHtcblx0XHQvLyBcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+IC0gdXNlZCBhcyBwcm90b3R5cGVzXG5cdFx0Ly8gXHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvbiAtIGxvb2t1cFxuXHRcdC8vIH1cblxuXG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gJ25BY3RpdmVCaW5kaW5ncycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cblx0XHR0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTsgLy8gaW5zaWRlOiBNYXA8IG5hbWUsIFByb3BlcnR5TWl4ZXIgPlxuXG5cblx0XHR0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzID0gW107IC8vIHNhbWUgZ2FtZSBhcyBhYm92ZVxuXHRcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdHRoaXMuc3RhdHMgPSB7XG5cblx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVBY3Rpb25zO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRiaW5kaW5nczoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5ncztcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xuXHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXG5cblx0X2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblx0XHRyZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPCB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuXHR9XG5cblx0X2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRsZXQgYWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHtcblxuXHRcdFx0XHRrbm93bkFjdGlvbnM6IFsgYWN0aW9uIF0sXG5cdFx0XHRcdGFjdGlvbkJ5Um9vdDoge31cblxuXHRcdFx0fTtcblxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcblxuXHRcdFx0YWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSA9IGFjdGlvbnNGb3JDbGlwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qga25vd25BY3Rpb25zID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xuXG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xuXHRcdFx0a25vd25BY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XG5cdFx0YWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcblxuXHRcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSA9IGFjdGlvbjtcblxuXHR9XG5cblx0X3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblxuXHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdGFjdGlvbnMucG9wKCk7XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xuXG5cblx0XHRjb25zdCBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0sXG5cdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxuXG5cdFx0XHRsYXN0S25vd25BY3Rpb24gPVxuXHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcblxuXHRcdFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcblxuXHRcdGxhc3RLbm93bkFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGJ5Q2xpcENhY2hlSW5kZXg7XG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xuXHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XG5cblx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xuXG5cblx0XHRjb25zdCBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3QsXG5cdFx0XHRyb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XG5cblx0XHRkZWxldGUgYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHR9XG5cblx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcblxuXHR9XG5cblx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9sZW5kQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHwgIGluYWN0aXZlIGFjdGlvbnMgIF1cblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxuXHRcdC8vICAgICAgICAgICAgICAgICAgPC1zd2FwLT5cblx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVBY3Rpb25zICsrLFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0YWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XG5cblx0XHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcblxuXHR9XG5cblx0X3Rha2VCYWNrQWN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHw8IGluYWN0aXZlIGFjdGlvbnMgIF1cblx0XHQvLyAgICAgICAgYSAgICAgICAgc1xuXHRcdC8vICAgICAgICAgPC1zd2FwLT5cblx0XHQvLyAgICAgICAgcyAgICAgICAgYVxuXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVBY3Rpb25zLFxuXG5cdFx0XHRsYXN0QWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0YWN0aW9uc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XG5cblx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUFjdGlvbjtcblxuXHR9XG5cblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIFByb3BlcnR5TWl4ZXIgb2JqZWN0c1xuXG5cdF9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRsZXQgYmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ0J5TmFtZTtcblxuXHRcdH1cblxuXHRcdGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdID0gYmluZGluZztcblxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XG5cdFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xuXG5cdH1cblxuXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICkge1xuXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxuXHRcdFx0cm9vdFV1aWQgPSBwcm9wQmluZGluZy5yb290Tm9kZS51dWlkLFxuXHRcdFx0dHJhY2tOYW1lID0gcHJvcEJpbmRpbmcucGF0aCxcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxuXG5cdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGJpbmRpbmdzLmxlbmd0aCAtIDEgXSxcblx0XHRcdGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xuXG5cdFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0YmluZGluZ3NbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XG5cdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRkZWxldGUgYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XG5cblx0XHRpZiAoIE9iamVjdC5rZXlzKCBiaW5kaW5nQnlOYW1lICkubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRkZWxldGUgYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdF9sZW5kQmluZGluZyggYmluZGluZyApIHtcblxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XG5cblx0fVxuXG5cdF90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKSB7XG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLFxuXG5cdFx0XHRsYXN0QWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcblxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0YmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYmluZGluZztcblxuXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVCaW5kaW5nO1xuXG5cdH1cblxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cblx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSB7XG5cblx0XHRjb25zdCBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgKys7XG5cblx0XHRsZXQgaW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbnRlcnBvbGFudCA9IG5ldyBMaW5lYXJJbnRlcnBvbGFudChcblx0XHRcdFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXG5cdFx0XHRcdDEsIF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyICk7XG5cblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcblxuXHR9XG5cblx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCBpbnRlcnBvbGFudCApIHtcblxuXHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxuXG5cdFx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0aW50ZXJwb2xhbnRzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVJbnRlcnBvbGFudDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEFuaW1hdGlvbkFjdGlvbn0gZm9yIHRoZSBwYXNzZWQgY2xpcC5cblx0ICpcblx0ICogSWYgYW4gYWN0aW9uIGZpdHRpbmcgdGhlIGNsaXAgYW5kIHJvb3QgcGFyYW1ldGVycyBkb2Vzbid0IHlldCBleGlzdCwgaXRcblx0ICogd2lsbCBiZSBjcmVhdGVkIGJ5IHRoaXMgbWV0aG9kLiBDYWxsaW5nIHRoaXMgbWV0aG9kIHNldmVyYWwgdGltZXMgd2l0aCB0aGVcblx0ICogc2FtZSBjbGlwIGFuZCByb290IHBhcmFtZXRlcnMgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgYWN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbkNsaXB8c3RyaW5nfSBjbGlwIC0gQW4gYW5pbWF0aW9uIGNsaXAgb3IgYWx0ZXJuYXRpdmVseSB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNsaXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IFtvcHRpb25hbFJvb3RdIC0gQW4gYWx0ZXJuYXRpdmUgcm9vdCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7KE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZXxBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSl9IFtibGVuZE1vZGVdIC0gVGhlIGJsZW5kIG1vZGUuXG5cdCAqIEByZXR1cm4gez9BbmltYXRpb25BY3Rpb259IFRoZSBhbmltYXRpb24gYWN0aW9uLlxuXHQgKi9cblx0Y2xpcEFjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290LCBibGVuZE1vZGUgKSB7XG5cblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZDtcblxuXHRcdGxldCBjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID8gQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwO1xuXG5cdFx0Y29uc3QgY2xpcFV1aWQgPSBjbGlwT2JqZWN0ICE9PSBudWxsID8gY2xpcE9iamVjdC51dWlkIDogY2xpcDtcblxuXHRcdGNvbnN0IGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblx0XHRsZXQgcHJvdG90eXBlQWN0aW9uID0gbnVsbDtcblxuXHRcdGlmICggYmxlbmRNb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggY2xpcE9iamVjdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRibGVuZE1vZGUgPSBjbGlwT2JqZWN0LmJsZW5kTW9kZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgZXhpc3RpbmdBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICggZXhpc3RpbmdBY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBleGlzdGluZ0FjdGlvbi5ibGVuZE1vZGUgPT09IGJsZW5kTW9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcblx0XHRcdC8vIHRoZSBiaW5kaW5ncyBhZ2FpbiBidXQgY2FuIGp1c3QgY29weVxuXHRcdFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF07XG5cblx0XHRcdC8vIGFsc28sIHRha2UgdGhlIGNsaXAgZnJvbSB0aGUgcHJvdG90eXBlIGFjdGlvblxuXHRcdFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsIClcblx0XHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcblxuXHRcdH1cblxuXHRcdC8vIGNsaXAgbXVzdCBiZSBrbm93biB3aGVuIHNwZWNpZmllZCB2aWEgc3RyaW5nXG5cdFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyBhbGxvY2F0ZSBhbGwgcmVzb3VyY2VzIHJlcXVpcmVkIHRvIHJ1biBpdFxuXHRcdGNvbnN0IG5ld0FjdGlvbiA9IG5ldyBBbmltYXRpb25BY3Rpb24oIHRoaXMsIGNsaXBPYmplY3QsIG9wdGlvbmFsUm9vdCwgYmxlbmRNb2RlICk7XG5cblx0XHR0aGlzLl9iaW5kQWN0aW9uKCBuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApO1xuXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcblx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcblxuXHRcdHJldHVybiBuZXdBY3Rpb247XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGV4aXN0aW5nIGFuaW1hdGlvbiBhY3Rpb24gZm9yIHRoZSBwYXNzZWQgY2xpcC5cblx0ICpcblx0ICogQHBhcmFtIHtBbmltYXRpb25DbGlwfHN0cmluZ30gY2xpcCAtIEFuIGFuaW1hdGlvbiBjbGlwIG9yIGFsdGVybmF0aXZlbHkgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjbGlwLlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBbb3B0aW9uYWxSb290XSAtIEFuIGFsdGVybmF0aXZlIHJvb3Qgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHs/QW5pbWF0aW9uQWN0aW9ufSBUaGUgYW5pbWF0aW9uIGFjdGlvbi4gUmV0dXJucyBgbnVsbGAgaWYgbm8gYWN0aW9uIHdhcyBmb3VuZC5cblx0ICovXG5cdGV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuXHRcdFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcblxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zIG9uIHRoaXMgbWl4ZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbk1peGVyfSBBIHJlZmVyZW5jZSB0byB0aGkgYW5pbWF0aW9uIG1peGVyLlxuXHQgKi9cblx0c3RvcEFsbEFjdGlvbigpIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuXHRcdGZvciAoIGxldCBpID0gbkFjdGlvbnMgLSAxOyBpID49IDA7IC0tIGkgKSB7XG5cblx0XHRcdGFjdGlvbnNbIGkgXS5zdG9wKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBnbG9iYWwgbWl4ZXIgdGltZSBhbmQgdXBkYXRlcyB0aGUgYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBUaGlzIGlzIHVzdWFsbHkgZG9uZSBpbiB0aGUgcmVuZGVyIGxvb3AgYnkgcGFzc2luZyB0aGUgZGVsdGFcblx0ICogdGltZSBmcm9tIHtAbGluayBDbG9ja30gb3Ige0BsaW5rIFRpbWVyfS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRoZSBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0FuaW1hdGlvbk1peGVyfSBBIHJlZmVyZW5jZSB0byB0aGkgYW5pbWF0aW9uIG1peGVyLlxuXHQgKi9cblx0dXBkYXRlKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XG5cblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxuXHRcdFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbiggZGVsdGFUaW1lICksXG5cblx0XHRcdGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxO1xuXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cblx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnbG9iYWwgbWl4ZXIgdG8gYSBzcGVjaWZpYyB0aW1lIGFuZCB1cGRhdGVzIHRoZSBhbmltYXRpb24gYWNjb3JkaW5nbHkuXG5cdCAqXG5cdCAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8ganVtcCB0byBhbiBleGFjdCB0aW1lIGluIGFuIGFuaW1hdGlvbi4gVGhlXG5cdCAqIGlucHV0IHBhcmFtZXRlciB3aWxsIGJlIHNjYWxlZCBieSB7QGxpbmsgQW5pbWF0aW9uTWl4ZXIjdGltZVNjYWxlfVxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRoZSB0aW1lIHRvIHNldCBpbiBzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBbmltYXRpb25NaXhlcn0gQSByZWZlcmVuY2UgdG8gdGhpIGFuaW1hdGlvbiBtaXhlci5cblx0ICovXG5cdHNldFRpbWUoIHRpbWUgKSB7XG5cblx0XHR0aGlzLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0O1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLl9hY3Rpb25zWyBpIF0udGltZSA9IDA7IC8vIFplcm8gb3V0IHRpbWUgYXR0cmlidXRlIGZvciBhbGwgYXNzb2NpYXRlZCBBbmltYXRpb25BY3Rpb24gb2JqZWN0cy5cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSggdGltZSApOyAvLyBVcGRhdGUgdXNlZCB0byBzZXQgZXhhY3QgdGltZS4gUmV0dXJucyBcInRoaXNcIiBBbmltYXRpb25NaXhlciBvYmplY3QuXG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoaXMgbWl4ZXIncyByb290IG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0M0R9IFRoZSBtaXhlcidzIHJvb3Qgb2JqZWN0LlxuXHQgKi9cblx0Z2V0Um9vdCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9yb290O1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVhbGxvY2F0ZXMgYWxsIG1lbW9yeSByZXNvdXJjZXMgZm9yIGEgY2xpcC4gQmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kIG1ha2Vcblx0ICogc3VyZSB0byBjYWxsIHtAbGluayBBbmltYXRpb25BY3Rpb24jc3RvcH0gZm9yIGFsbCByZWxhdGVkIGFjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQ2xpcH0gY2xpcCAtIFRoZSBjbGlwIHRvIHVuY2FjaGUuXG5cdCAqL1xuXHR1bmNhY2hlQ2xpcCggY2xpcCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0Y2xpcFV1aWQgPSBjbGlwLnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuXHRcdFx0Ly8ganVzdCB0aHJvdyBhd2F5XG5cblx0XHRcdGNvbnN0IGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcblxuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0XHRjb25zdCBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogRGVhbGxvY2F0ZXMgYWxsIG1lbW9yeSByZXNvdXJjZXMgZm9yIGEgcm9vdCBvYmplY3QuIEJlZm9yZSB1c2luZyB0aGlzXG5cdCAqIG1ldGhvZCBtYWtlIHN1cmUgdG8gY2FsbCB7QGxpbmsgQW5pbWF0aW9uQWN0aW9uI3N0b3B9IGZvciBhbGwgcmVsYXRlZFxuXHQgKiBhY3Rpb25zIG9yIGFsdGVybmF0aXZlbHkge0BsaW5rIEFuaW1hdGlvbk1peGVyI3N0b3BBbGxBY3Rpb259IHdoZW4gdGhlXG5cdCAqIG1peGVyIG9wZXJhdGVzIG9uIGEgc2luZ2xlIHJvb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IHJvb3QgLSBUaGUgcm9vdCBvYmplY3QgdG8gdW5jYWNoZS5cblx0ICovXG5cdHVuY2FjaGVSb290KCByb290ICkge1xuXG5cdFx0Y29uc3Qgcm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcblxuXHRcdGZvciAoIGNvbnN0IGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXAgKSB7XG5cblx0XHRcdGNvbnN0IGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0uYWN0aW9uQnlSb290LFxuXHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICggYWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgdHJhY2tOYW1lIGluIGJpbmRpbmdCeU5hbWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWFsbG9jYXRlcyBhbGwgbWVtb3J5IHJlc291cmNlcyBmb3IgYW4gYWN0aW9uLiBUaGUgYWN0aW9uIGlzIGlkZW50aWZpZWQgYnkgdGhlXG5cdCAqIGdpdmVuIGNsaXAgYW5kIGFuIG9wdGlvbmFsIHJvb3Qgb2JqZWN0LiBCZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QgbWFrZVxuXHQgKiBzdXJlIHRvIGNhbGwge0BsaW5rIEFuaW1hdGlvbkFjdGlvbiNzdG9wfSB0byBkZWFjdGl2YXRlIHRoZSBhY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uQ2xpcHxzdHJpbmd9IGNsaXAgLSBBbiBhbmltYXRpb24gY2xpcCBvciBhbHRlcm5hdGl2ZWx5IHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gY2xpcC5cblx0ICogQHBhcmFtIHtPYmplY3QzRH0gW29wdGlvbmFsUm9vdF0gLSBBbiBhbHRlcm5hdGl2ZSByb290IG9iamVjdC5cblx0ICovXG5cdHVuY2FjaGVBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuXHRcdGNvbnN0IGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xuXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBBbmltYXRpb25NaXhlciB9O1xuIiwiaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9SZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgRGF0YTNEVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0RhdGEzRFRleHR1cmUuanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSAzRCByZW5kZXIgdGFyZ2V0LlxuICpcbiAqIEBhdWdtZW50cyBSZW5kZXJUYXJnZXRcbiAqL1xuY2xhc3MgUmVuZGVyVGFyZ2V0M0QgZXh0ZW5kcyBSZW5kZXJUYXJnZXQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IDNEIHJlbmRlciB0YXJnZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7UmVuZGVyVGFyZ2V0fk9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXQzRCA9IHRydWU7XG5cblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHQvKipcblx0XHQgKiBPdmVyd3JpdHRlbiB3aXRoIGEgZGlmZmVyZW50IHRleHR1cmUgdHlwZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtEYXRhM0RUZXh0dXJlfVxuXHRcdCAqL1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBEYXRhM0RUZXh0dXJlKCBudWxsLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFJlbmRlclRhcmdldDNEIH07XG4iLCJpbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuL1JlbmRlclRhcmdldC5qcyc7XG5pbXBvcnQgeyBEYXRhQXJyYXlUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YUFycmF5VGV4dHVyZS5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhcnJheSByZW5kZXIgdGFyZ2V0LlxuICpcbiAqIEBhdWdtZW50cyBSZW5kZXJUYXJnZXRcbiAqL1xuY2xhc3MgUmVuZGVyVGFyZ2V0QXJyYXkgZXh0ZW5kcyBSZW5kZXJUYXJnZXQge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IDNEIHJlbmRlciB0YXJnZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTFdIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRhcmdldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7UmVuZGVyVGFyZ2V0fk9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXRBcnJheSA9IHRydWU7XG5cblx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHQvKipcblx0XHQgKiBPdmVyd3JpdHRlbiB3aXRoIGEgZGlmZmVyZW50IHRleHR1cmUgdHlwZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtEYXRhQXJyYXlUZXh0dXJlfVxuXHRcdCAqL1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBEYXRhQXJyYXlUZXh0dXJlKCBudWxsLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFJlbmRlclRhcmdldEFycmF5IH07XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSB1bmlmb3JtIHdoaWNoIGlzIGEgZ2xvYmFsIHNoYWRlciB2YXJpYWJsZS4gVGhleSBhcmUgcGFzc2VkIHRvIHNoYWRlciBwcm9ncmFtcy5cbiAqXG4gKiBXaGVuIGRlY2xhcmluZyBhIHVuaWZvcm0gb2YgYSB7QGxpbmsgU2hhZGVyTWF0ZXJpYWx9LCBpdCBpcyBkZWNsYXJlZCBieSB2YWx1ZSBvciBieSBvYmplY3QuXG4gKiBgYGBqc1xuICogdW5pZm9ybXM6IHtcbiAqIFx0dGltZTogeyB2YWx1ZTogMS4wIH0sXG4gKiBcdHJlc29sdXRpb246IG5ldyBVbmlmb3JtKCBuZXcgVmVjdG9yMigpIClcbiAqIH07XG4gKiBgYGBcbiAqIFNpbmNlIHRoaXMgY2xhc3MgY2FuIG9ubHkgYmUgdXNlZCBpbiBjb250ZXh0IG9mIHtAbGluayBTaGFkZXJNYXRlcmlhbH0sIGl0IGlzIG9ubHkgc3VwcG9ydGVkXG4gKiBpbiB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG4gKi9cbmNsYXNzIFVuaWZvcm0ge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHVuaWZvcm0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB1bmlmb3JtIHZhbHVlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHZhbHVlICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaWZvcm0gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7YW55fVxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdW5pZm9ybSB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKiBJZiB0aGUgdmFsdWUgaGFzIGEgYGNsb25lKClgIG1ldGhvZCwgdGhlIHZhbHVlIGlzIGNsb25lZCBhcyB3ZWxsLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtVbmlmb3JtfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgVW5pZm9ybSggdGhpcy52YWx1ZS5jbG9uZSA9PT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuY2xvbmUoKSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBVbmlmb3JtIH07XG4iLCJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBtYW5hZ2luZyBtdWx0aXBsZSB1bmlmb3JtcyBpbiBhIHNpbmdsZSBncm91cC4gVGhlIHJlbmRlcmVyIHdpbGwgcHJvY2Vzc1xuICogc3VjaCBhIGRlZmluaXRpb24gYXMgYSBzaW5nbGUgVUJPLlxuICpcbiAqIFNpbmNlIHRoaXMgY2xhc3MgY2FuIG9ubHkgYmUgdXNlZCBpbiBjb250ZXh0IG9mIHtAbGluayBTaGFkZXJNYXRlcmlhbH0sIGl0IGlzIG9ubHkgc3VwcG9ydGVkXG4gKiBpbiB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG4gKlxuICogQGF1Z21lbnRzIEV2ZW50RGlzcGF0Y2hlclxuICovXG5jbGFzcyBVbmlmb3Jtc0dyb3VwIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyB1bmlmb3JtcyBncm91cC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNVbmlmb3Jtc0dyb3VwID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgM0Qgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQG5hbWUgVW5pZm9ybXNHcm91cCNpZFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQgKysgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm1zIGdyb3VwLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBidWZmZXIgdXNhZ2UuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7KFN0YXRpY0RyYXdVc2FnZXxEeW5hbWljRHJhd1VzYWdlfFN0cmVhbURyYXdVc2FnZXxTdGF0aWNSZWFkVXNhZ2V8RHluYW1pY1JlYWRVc2FnZXxTdHJlYW1SZWFkVXNhZ2V8U3RhdGljQ29weVVzYWdlfER5bmFtaWNDb3B5VXNhZ2V8U3RyZWFtQ29weVVzYWdlKX1cblx0XHQgKiBAZGVmYXVsdCBTdGF0aWNEcmF3VXNhZ2Vcblx0XHQgKi9cblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgaG9sZGluZyB0aGUgdW5pZm9ybXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8VW5pZm9ybT59XG5cdFx0ICovXG5cdFx0dGhpcy51bmlmb3JtcyA9IFtdO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gdW5pZm9ybSB0byB0aGlzIHVuaWZvcm1zIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1VuaWZvcm19IHVuaWZvcm0gLSBUaGUgdW5pZm9ybSB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1VuaWZvcm1zR3JvdXB9IEEgcmVmZXJlbmNlIHRvIHRoaXMgdW5pZm9ybXMgZ3JvdXAuXG5cdCAqL1xuXHRhZGQoIHVuaWZvcm0gKSB7XG5cblx0XHR0aGlzLnVuaWZvcm1zLnB1c2goIHVuaWZvcm0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdW5pZm9ybSBmcm9tIHRoaXMgdW5pZm9ybXMgZ3JvdXAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VW5pZm9ybX0gdW5pZm9ybSAtIFRoZSB1bmlmb3JtIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7VW5pZm9ybXNHcm91cH0gQSByZWZlcmVuY2UgdG8gdGhpcyB1bmlmb3JtcyBncm91cC5cblx0ICovXG5cdHJlbW92ZSggdW5pZm9ybSApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy51bmlmb3Jtcy5pbmRleE9mKCB1bmlmb3JtICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB0aGlzLnVuaWZvcm1zLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbmFtZSBvZiB0aGlzIHVuaWZvcm1zIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIHRvIHNldC5cblx0ICogQHJldHVybiB7VW5pZm9ybXNHcm91cH0gQSByZWZlcmVuY2UgdG8gdGhpcyB1bmlmb3JtcyBncm91cC5cblx0ICovXG5cdHNldE5hbWUoIG5hbWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1c2FnZSBvZiB0aGlzIHVuaWZvcm1zIGdyb3VwLlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdGF0aWNEcmF3VXNhZ2V8RHluYW1pY0RyYXdVc2FnZXxTdHJlYW1EcmF3VXNhZ2V8U3RhdGljUmVhZFVzYWdlfER5bmFtaWNSZWFkVXNhZ2V8U3RyZWFtUmVhZFVzYWdlfFN0YXRpY0NvcHlVc2FnZXxEeW5hbWljQ29weVVzYWdlfFN0cmVhbUNvcHlVc2FnZSl9IHZhbHVlIC0gVGhlIHVzYWdlIHRvIHNldC5cblx0ICogQHJldHVybiB7VW5pZm9ybXNHcm91cH0gQSByZWZlcmVuY2UgdG8gdGhpcyB1bmlmb3JtcyBncm91cC5cblx0ICovXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudXNhZ2UgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKlxuXHQgKiBAZmlyZXMgVGV4dHVyZSNkaXNwb3NlXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdW5pZm9ybXMgZ3JvdXAgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtVbmlmb3Jtc0dyb3VwfSBzb3VyY2UgLSBUaGUgdW5pZm9ybXMgZ3JvdXAgdG8gY29weS5cblx0ICogQHJldHVybiB7VW5pZm9ybXNHcm91cH0gQSByZWZlcmVuY2UgdG8gdGhpcyB1bmlmb3JtcyBncm91cC5cblx0ICovXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMudXNhZ2UgPSBzb3VyY2UudXNhZ2U7XG5cblx0XHRjb25zdCB1bmlmb3Jtc1NvdXJjZSA9IHNvdXJjZS51bmlmb3JtcztcblxuXHRcdHRoaXMudW5pZm9ybXMubGVuZ3RoID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHVuaWZvcm1zU291cmNlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0gQXJyYXkuaXNBcnJheSggdW5pZm9ybXNTb3VyY2VbIGkgXSApID8gdW5pZm9ybXNTb3VyY2VbIGkgXSA6IFsgdW5pZm9ybXNTb3VyY2VbIGkgXSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCB1bmlmb3Jtcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0dGhpcy51bmlmb3Jtcy5wdXNoKCB1bmlmb3Jtc1sgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHVuaWZvcm1zIGdyb3VwIHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1VuaWZvcm1zR3JvdXB9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBVbmlmb3Jtc0dyb3VwIH07XG4iLCJpbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlciB9IGZyb20gJy4vSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlZCB2ZXJzaW9uIG9mIGFuIGludGVybGVhdmVkIGJ1ZmZlci5cbiAqXG4gKiBAYXVnbWVudHMgSW50ZXJsZWF2ZWRCdWZmZXJcbiAqL1xuY2xhc3MgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgZXh0ZW5kcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2VkIGludGVybGVhdmVkIGJ1ZmZlci5cblx0ICpcblx0ICogQHBhcmFtIHtUeXBlZEFycmF5fSBhcnJheSAtIEEgdHlwZWQgYXJyYXkgd2l0aCBhIHNoYXJlZCBidWZmZXIgc3RvcmluZyBhdHRyaWJ1dGUgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFRoZSBudW1iZXIgb2YgdHlwZWQtYXJyYXkgZWxlbWVudHMgcGVyIHZlcnRleC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttZXNoUGVyQXR0cmlidXRlPTFdIC0gRGVmaW5lcyBob3cgb2Z0ZW4gYSB2YWx1ZSBvZiB0aGlzIGludGVybGVhdmVkIGJ1ZmZlciBzaG91bGQgYmUgcmVwZWF0ZWQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSA9IDEgKSB7XG5cblx0XHRzdXBlciggYXJyYXksIHN0cmlkZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgaG93IG9mdGVuIGEgdmFsdWUgb2YgdGhpcyBidWZmZXIgYXR0cmlidXRlIHNob3VsZCBiZSByZXBlYXRlZCxcblx0XHQgKiBzZWUge0BsaW5rIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSNtZXNoUGVyQXR0cmlidXRlfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoIGRhdGEgKSB7XG5cblx0XHRjb25zdCBpYiA9IHN1cGVyLmNsb25lKCBkYXRhICk7XG5cblx0XHRpYi5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIGliO1xuXG5cdH1cblxuXHR0b0pTT04oIGRhdGEgKSB7XG5cblx0XHRjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCBkYXRhICk7XG5cblx0XHRqc29uLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXHRcdGpzb24ubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiBqc29uO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciB9O1xuIiwiLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB2ZXJzaW9uIG9mIGEgYnVmZmVyIGF0dHJpYnV0ZSB3aXRoIG1vcmUgY29udHJvbCBvdmVyIHRoZSBWQk8uXG4gKlxuICogVGhlIHJlbmRlcmVyIGRvZXMgbm90IGNvbnN0cnVjdCBhIFZCTyBmb3IgdGhpcyBraW5kIG9mIGF0dHJpYnV0ZS4gSW5zdGVhZCwgaXQgdXNlc1xuICogd2hhdGV2ZXIgVkJPIGlzIHBhc3NlZCBpbiBjb25zdHJ1Y3RvciBhbmQgY2FuIGxhdGVyIGJlIGFsdGVyZWQgdmlhIHRoZSBgYnVmZmVyYCBwcm9wZXJ0eS5cbiAqXG4gKiBUaGUgbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgY2xhc3MgaXMgd2hlbiBzb21lIGtpbmQgb2YgR1BHUFUgY2FsY3VsYXRpb24gaW50ZXJmZXJlc1xuICogb3IgZXZlbiBwcm9kdWNlcyB0aGUgVkJPcyBpbiBxdWVzdGlvbi5cbiAqXG4gKiBOb3RpY2UgdGhhdCB0aGlzIGNsYXNzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB7QGxpbmsgV2ViR0xSZW5kZXJlcn0uXG4gKi9cbmNsYXNzIEdMQnVmZmVyQXR0cmlidXRlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBHTCBidWZmZXIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBidWZmZXIgLSBUaGUgbmF0aXZlIFdlYkdMIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgLSBUaGUgbmF0aXZlIGRhdGEgdHlwZSAoZS5nLiBgZ2wuRkxPQVRgKS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1TaXplIC0gVGhlIGl0ZW0gc2l6ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGVsZW1lbnRTaXplIC0gVGhlIGNvcnJlc3BvbmRpbmcgc2l6ZSAoaW4gYnl0ZXMpIGZvciB0aGUgZ2l2ZW4gYHR5cGVgIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIGV4cGVjdGVkIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiBWQk8uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggYnVmZmVyLCB0eXBlLCBpdGVtU2l6ZSwgZWxlbWVudFNpemUsIGNvdW50ICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc0dMQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgYXR0cmlidXRlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYXRpdmUgV2ViR0wgYnVmZmVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1dlYkdMQnVmZmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBkYXRhIHR5cGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaXRlbSBzaXplLCBzZWUge0BsaW5rIEJ1ZmZlckF0dHJpYnV0ZSNpdGVtU2l6ZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb3JyZXNwb25kaW5nIHNpemUgKGluIGJ5dGVzKSBmb3IgdGhlIGdpdmVuIGB0eXBlYCBwYXJhbWV0ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuZWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBleHBlY3RlZCBudW1iZXIgb2YgdmVydGljZXMgaW4gVkJPLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cblx0XHQvKipcblx0XHQgKiBBIHZlcnNpb24gbnVtYmVyLCBpbmNyZW1lbnRlZCBldmVyeSB0aW1lIHRoZSBgbmVlZHNVcGRhdGVgIGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIHRoYXQgdGhpcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgYW5kIHNob3VsZCBiZSByZS1zZW50IHRvXG5cdCAqIHRoZSBHUFUuIFNldCB0aGlzIHRvIGB0cnVlYCB3aGVuIHlvdSBtb2RpZnkgdGhlIHZhbHVlIG9mIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuXHQgKi9cblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBnaXZlbiBuYXRpdmUgV2ViR0wgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHNldC5cblx0ICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfSBBIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0c2V0QnVmZmVyKCBidWZmZXIgKSB7XG5cblx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZ2l2ZW4gbmF0aXZlIGRhdGEgdHlwZSBhbmQgZWxlbWVudCBzaXplLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHlwZSAtIFRoZSBuYXRpdmUgZGF0YSB0eXBlIChlLmcuIGBnbC5GTE9BVGApLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZWxlbWVudFNpemUgLSBUaGUgY29ycmVzcG9uZGluZyBzaXplIChpbiBieXRlcykgZm9yIHRoZSBnaXZlbiBgdHlwZWAgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRUeXBlKCB0eXBlLCBlbGVtZW50U2l6ZSApIHtcblxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpdGVtIHNpemUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtU2l6ZSAtIFRoZSBpdGVtIHNpemUuXG5cdCAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldEl0ZW1TaXplKCBpdGVtU2l6ZSApIHtcblxuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY291bnQgKHRoZSBleHBlY3RlZCBudW1iZXIgb2YgdmVydGljZXMgaW4gVkJPKS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIGNvdW50LlxuXHQgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRzZXRDb3VudCggY291bnQgKSB7XG5cblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgR0xCdWZmZXJBdHRyaWJ1dGUgfTtcbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgUmF5IH0gZnJvbSAnLi4vbWF0aC9SYXkuanMnO1xuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xuXG5jb25zdCBfbWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gYXNzaXN0IHdpdGggcmF5Y2FzdGluZy4gUmF5Y2FzdGluZyBpcyB1c2VkIGZvclxuICogbW91c2UgcGlja2luZyAod29ya2luZyBvdXQgd2hhdCBvYmplY3RzIGluIHRoZSAzZCBzcGFjZSB0aGUgbW91c2UgaXMgb3ZlcilcbiAqIGFtb25nc3Qgb3RoZXIgdGhpbmdzLlxuICovXG5jbGFzcyBSYXljYXN0ZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHJheWNhc3Rlci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHZlY3RvciB3aGVyZSB0aGUgcmF5IGNhc3RzIGZyb20uXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gZGlyZWN0aW9uIC0gVGhlIChub3JtYWxpemVkKSBkaXJlY3Rpb24gdmVjdG9yIHRoYXQgZ2l2ZXMgZGlyZWN0aW9uIHRvIHRoZSByYXkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbmVhcj0wXSAtIEFsbCByZXN1bHRzIHJldHVybmVkIGFyZSBmdXJ0aGVyIGF3YXkgdGhhbiBuZWFyLiBOZWFyIGNhbid0IGJlIG5lZ2F0aXZlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zhcj1JbmZpbml0eV0gLSBBbGwgcmVzdWx0cyByZXR1cm5lZCBhcmUgY2xvc2VyIHRoYW4gZmFyLiBGYXIgY2FuJ3QgYmUgbG93ZXIgdGhhbiBuZWFyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyID0gMCwgZmFyID0gSW5maW5pdHkgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmF5IHVzZWQgZm9yIHJheWNhc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7UmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMucmF5ID0gbmV3IFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCByZXN1bHRzIHJldHVybmVkIGFyZSBmdXJ0aGVyIGF3YXkgdGhhbiBuZWFyLiBOZWFyIGNhbid0IGJlIG5lZ2F0aXZlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCByZXN1bHRzIHJldHVybmVkIGFyZSBmdXJ0aGVyIGF3YXkgdGhhbiBuZWFyLiBOZWFyIGNhbid0IGJlIG5lZ2F0aXZlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBJbmZpbml0eVxuXHRcdCAqL1xuXHRcdHRoaXMuZmFyID0gZmFyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbWVyYSB0byB1c2Ugd2hlbiByYXljYXN0aW5nIGFnYWluc3Qgdmlldy1kZXBlbmRlbnQgb2JqZWN0cyBzdWNoIGFzXG5cdFx0ICogYmlsbGJvYXJkZWQgb2JqZWN0cyBsaWtlIHNwcml0ZXMuIFRoaXMgZmllbGQgY2FuIGJlIHNldCBtYW51YWxseSBvclxuXHRcdCAqIGlzIHNldCB3aGVuIGNhbGxpbmcgYHNldEZyb21DYW1lcmEoKWAuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P0NhbWVyYX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jYW1lcmEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHRvIHNlbGVjdGl2ZWx5IGlnbm9yZSAzRCBvYmplY3RzIHdoZW4gcGVyZm9ybWluZyBpbnRlcnNlY3Rpb24gdGVzdHMuXG5cdFx0ICogVGhlIGZvbGxvd2luZyBjb2RlIGV4YW1wbGUgZW5zdXJlcyB0aGF0IG9ubHkgM0Qgb2JqZWN0cyBvbiBsYXllciBgMWAgd2lsbCBiZVxuXHRcdCAqIGhvbm9yZWQgYnkgcmF5Y2FzdGVyLlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogcmF5Y2FzdGVyLmxheWVycy5zZXQoIDEgKTtcblx0XHQgKiBvYmplY3QubGF5ZXJzLmVuYWJsZSggMSApO1xuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0xheWVyc31cblx0XHQgKi9cblx0XHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcblxuXG5cdFx0LyoqXG5cdFx0ICogQSBwYXJhbWV0ZXIgb2JqZWN0IHRoYXQgY29uZmlndXJlcyB0aGUgcmF5Y2FzdGluZy4gSXQgaGFzIHRoZSBzdHJ1Y3R1cmU6XG5cdFx0ICpcblx0XHQgKiBgYGBcblx0XHQgKiB7XG5cdFx0ICogXHRNZXNoOiB7fSxcblx0XHQgKiBcdExpbmU6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0ICogXHRMT0Q6IHt9LFxuXHRcdCAqIFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxuXHRcdCAqIFx0U3ByaXRlOiB7fVxuXHRcdCAqIH1cblx0XHQgKiBgYGBcblx0XHQgKiBXaGVyZSBgdGhyZXNob2xkYCBpcyB0aGUgcHJlY2lzaW9uIG9mIHRoZSByYXljYXN0ZXIgd2hlbiBpbnRlcnNlY3Rpbmcgb2JqZWN0cywgaW4gd29ybGQgdW5pdHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0TWVzaDoge30sXG5cdFx0XHRMaW5lOiB7IHRocmVzaG9sZDogMSB9LFxuXHRcdFx0TE9EOiB7fSxcblx0XHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcblx0XHRcdFNwcml0ZToge31cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgcmF5IHdpdGggYSBuZXcgb3JpZ2luIGFuZCBkaXJlY3Rpb24gYnkgY29weWluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGFyZ3VtZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHZlY3RvciB3aGVyZSB0aGUgcmF5IGNhc3RzIGZyb20uXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gZGlyZWN0aW9uIC0gVGhlIChub3JtYWxpemVkKSBkaXJlY3Rpb24gdmVjdG9yIHRoYXQgZ2l2ZXMgZGlyZWN0aW9uIHRvIHRoZSByYXkuXG5cdCAqL1xuXHRzZXQoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZXMgdGhlIGdpdmVuIGNvb3JkaW5hdGVzIGFuZCBjYW1lcmEgdG8gY29tcHV0ZSBhIG5ldyBvcmlnaW4gYW5kIGRpcmVjdGlvbiBmb3IgdGhlIGludGVybmFsIHJheS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBjb29yZHMgLSAyRCBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UsIGluIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzIChOREMpLlxuXHQgKiBYIGFuZCBZIGNvbXBvbmVudHMgc2hvdWxkIGJlIGJldHdlZW4gYC0xYCBhbmQgYDFgLlxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSBmcm9tIHdoaWNoIHRoZSByYXkgc2hvdWxkIG9yaWdpbmF0ZS5cblx0ICovXG5cdHNldEZyb21DYW1lcmEoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdFx0fSBlbHNlIGlmICggY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlOiAnICsgY2FtZXJhLnR5cGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZXMgdGhlIGdpdmVuIFdlYlhSIGNvbnRyb2xsZXIgdG8gY29tcHV0ZSBhIG5ldyBvcmlnaW4gYW5kIGRpcmVjdGlvbiBmb3IgdGhlIGludGVybmFsIHJheS5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJYUkNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBjb3B5IHRoZSBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIGZyb20uXG5cdCAqIEByZXR1cm4ge1JheWNhc3Rlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyByYXljYXN0ZXIuXG5cdCAqL1xuXHRzZXRGcm9tWFJDb250cm9sbGVyKCBjb250cm9sbGVyICkge1xuXG5cdFx0X21hdHJpeC5pZGVudGl0eSgpLmV4dHJhY3RSb3RhdGlvbiggY29udHJvbGxlci5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY29udHJvbGxlci5tYXRyaXhXb3JsZCApO1xuXHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5TWF0cml4NCggX21hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGEgcmF5Y2FzdGVyIGludGVyc2VjdGlvbiB0ZXN0LlxuXHQgKiBAdHlwZWRlZiB7T2JqZWN0fSBSYXljYXN0ZXJ+SW50ZXJzZWN0aW9uXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSByYXkncyBvcmlnaW4gdG8gdGhlIGludGVyc2VjdGlvbiBwb2ludC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlVG9SYXkgLSAgU29tZSAzRCBvYmplY3RzIGUuZy4ge0BsaW5rIFBvaW50c30gcHJvdmlkZSB0aGUgZGlzdGFuY2Ugb2YgdGhlXG5cdCAqIGludGVyc2VjdGlvbiB0byB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgcmF5LiBGb3Igb3RoZXIgb2JqZWN0cyBpdCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuXHQgKiBAcHJvcGVydHkge1ZlY3RvcjN9IHBvaW50IC0gVGhlIGludGVyc2VjdGlvbiBwb2ludCwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG5cdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBmYWNlIC0gVGhlIGZhY2UgdGhhdCBoYXMgYmVlbiBpbnRlcnNlY3RlZC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGZhY2VJbmRleCAtIFRoZSBmYWNlIGluZGV4LlxuXHQgKiBAcHJvcGVydHkge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0IHRoYXQgaGFzIGJlZW4gaW50ZXJzZWN0ZWQuXG5cdCAqIEBwcm9wZXJ0eSB7VmVjdG9yMn0gdXYgLSBVLFYgY29vcmRpbmF0ZXMgYXQgcG9pbnQgb2YgaW50ZXJzZWN0aW9uLlxuXHQgKiBAcHJvcGVydHkge1ZlY3RvcjJ9IHV2MSAtIFNlY29uZCBzZXQgb2YgVSxWIGNvb3JkaW5hdGVzIGF0IHBvaW50IG9mIGludGVyc2VjdGlvbi5cblx0ICogQHByb3BlcnR5IHtWZWN0b3IzfSB1djEgLSBJbnRlcnBvbGF0ZWQgbm9ybWFsIHZlY3RvciBhdCBwb2ludCBvZiBpbnRlcnNlY3Rpb24uXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnN0YW5jZUlkIC0gVGhlIGluZGV4IG51bWJlciBvZiB0aGUgaW5zdGFuY2Ugd2hlcmUgdGhlIHJheVxuXHQgKiBpbnRlcnNlY3RzIHRoZSB7QGxpbmsgSW5zdGFuY2VkTWVzaH0uXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgYWxsIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBvYmplY3Qgd2l0aCBvciB3aXRob3V0IHRoZVxuXHQgKiBkZXNjZW5kYW50cy4gSW50ZXJzZWN0aW9ucyBhcmUgcmV0dXJuZWQgc29ydGVkIGJ5IGRpc3RhbmNlLCBjbG9zZXN0IGZpcnN0LlxuXHQgKlxuXHQgKiBgUmF5Y2FzdGVyYCBkZWxlZ2F0ZXMgdG8gdGhlIGByYXljYXN0KClgIG1ldGhvZCBvZiB0aGUgcGFzc2VkIDNEIG9iamVjdCwgd2hlblxuXHQgKiBldmFsdWF0aW5nIHdoZXRoZXIgdGhlIHJheSBpbnRlcnNlY3RzIHRoZSBvYmplY3Qgb3Igbm90LiBUaGlzIGFsbG93cyBtZXNoZXMgdG8gcmVzcG9uZFxuXHQgKiBkaWZmZXJlbnRseSB0byByYXkgY2FzdGluZyB0aGFuIGxpbmVzIG9yIHBvaW50cy5cblx0ICpcblx0ICogTm90ZSB0aGF0IGZvciBtZXNoZXMsIGZhY2VzIG11c3QgYmUgcG9pbnRlZCB0b3dhcmRzIHRoZSBvcmlnaW4gb2YgdGhlIHJheSBpbiBvcmRlclxuXHQgKiB0byBiZSBkZXRlY3RlZDsgaW50ZXJzZWN0aW9ucyBvZiB0aGUgcmF5IHBhc3NpbmcgdGhyb3VnaCB0aGUgYmFjayBvZiBhIGZhY2Ugd2lsbCBub3Rcblx0ICogYmUgZGV0ZWN0ZWQuIFRvIHJheWNhc3QgYWdhaW5zdCBib3RoIGZhY2VzIG9mIGFuIG9iamVjdCwgeW91J2xsIHdhbnQgdG8gc2V0ICB7QGxpbmsgTWF0ZXJpYWwjc2lkZX1cblx0ICogdG8gYFRIUkVFLkRvdWJsZVNpZGVgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgM0Qgb2JqZWN0IHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgcmF5LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9dHJ1ZV0gLSBJZiBzZXQgdG8gYHRydWVgLCBpdCBhbHNvIGNoZWNrcyBhbGwgZGVzY2VuZGFudHMuXG5cdCAqIE90aGVyd2lzZSBpdCBvbmx5IGNoZWNrcyBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5PFJheWNhc3Rlcn5JbnRlcnNlY3Rpb24+fSBbaW50ZXJzZWN0cz1bXV0gVGhlIHRhcmdldCBhcnJheSB0aGF0IGhvbGRzIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZC5cblx0ICogQHJldHVybiB7QXJyYXk8UmF5Y2FzdGVyfkludGVyc2VjdGlvbj59IEFuIGFycmF5IGhvbGRpbmcgdGhlIGludGVyc2VjdGlvbiBwb2ludHMuXG5cdCAqL1xuXHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgcmVjdXJzaXZlID0gdHJ1ZSwgaW50ZXJzZWN0cyA9IFtdICkge1xuXG5cdFx0aW50ZXJzZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBhbGwgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIG9iamVjdHMgd2l0aCBvciB3aXRob3V0XG5cdCAqIHRoZSBkZXNjZW5kYW50cy4gSW50ZXJzZWN0aW9ucyBhcmUgcmV0dXJuZWQgc29ydGVkIGJ5IGRpc3RhbmNlLCBjbG9zZXN0IGZpcnN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PE9iamVjdDNEPn0gb2JqZWN0cyAtIFRoZSAzRCBvYmplY3RzIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgcmF5LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9dHJ1ZV0gLSBJZiBzZXQgdG8gYHRydWVgLCBpdCBhbHNvIGNoZWNrcyBhbGwgZGVzY2VuZGFudHMuXG5cdCAqIE90aGVyd2lzZSBpdCBvbmx5IGNoZWNrcyBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5PFJheWNhc3Rlcn5JbnRlcnNlY3Rpb24+fSBbaW50ZXJzZWN0cz1bXV0gVGhlIHRhcmdldCBhcnJheSB0aGF0IGhvbGRzIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZC5cblx0ICogQHJldHVybiB7QXJyYXk8UmF5Y2FzdGVyfkludGVyc2VjdGlvbj59IEFuIGFycmF5IGhvbGRpbmcgdGhlIGludGVyc2VjdGlvbiBwb2ludHMuXG5cdCAqL1xuXHRpbnRlcnNlY3RPYmplY3RzKCBvYmplY3RzLCByZWN1cnNpdmUgPSB0cnVlLCBpbnRlcnNlY3RzID0gW10gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGludGVyc2VjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRsZXQgcHJvcGFnYXRlID0gdHJ1ZTtcblxuXHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggcmF5Y2FzdGVyLmxheWVycyApICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0aWYgKCByZXN1bHQgPT09IGZhbHNlICkgcHJvcGFnYXRlID0gZmFsc2U7XG5cblx0fVxuXG5cdGlmICggcHJvcGFnYXRlID09PSB0cnVlICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aW50ZXJzZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUmF5Y2FzdGVyIH07XG4iLCJpbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBwb2ludHMgaW4gM0Qgc3BhY2UgYXNcbiAqIFtTcGhlcmljYWwgY29vcmRpbmF0ZXNde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbX0uXG4gKi9cbmNsYXNzIFNwaGVyaWNhbCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3BoZXJpY2FsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xXSAtIFRoZSByYWRpdXMsIG9yIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgKHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UpIGZyb20gdGhlIHBvaW50IHRvIHRoZSBvcmlnaW4uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbcGhpPTBdIC0gVGhlIHBvbGFyIGFuZ2xlIGluIHJhZGlhbnMgZnJvbSB0aGUgeSAodXApIGF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGhldGE9MF0gLSBUaGUgZXF1YXRvci9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucyBhcm91bmQgdGhlIHkgKHVwKSBheGlzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHBoaSA9IDAsIHRoZXRhID0gMCApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYWRpdXMsIG9yIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgKHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UpIGZyb20gdGhlIHBvaW50IHRvIHRoZSBvcmlnaW4uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwb2xhciBhbmdsZSBpbiByYWRpYW5zIGZyb20gdGhlIHkgKHVwKSBheGlzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5waGkgPSBwaGk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXF1YXRvci9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucyBhcm91bmQgdGhlIHkgKHVwKSBheGlzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc3BoZXJpY2FsIGNvbXBvbmVudHMgYnkgY29weWluZyB0aGUgZ2l2ZW4gdmFsdWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBoaSAtIFRoZSBwb2xhciBhbmdsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVGhlIGF6aW11dGhhbCBhbmdsZS5cblx0ICogQHJldHVybiB7U3BoZXJpY2FsfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyaWNhbC5cblx0ICovXG5cdHNldCggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBwaGk7XG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc3BoZXJpY2FsIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3BoZXJpY2FsfSBvdGhlciAtIFRoZSBzcGhlcmljYWwgdG8gY29weS5cblx0ICogQHJldHVybiB7U3BoZXJpY2FsfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyaWNhbC5cblx0ICovXG5cdGNvcHkoIG90aGVyICkge1xuXG5cdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0dGhpcy5waGkgPSBvdGhlci5waGk7XG5cdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN0cmljdHMgdGhlIHBvbGFyIGFuZ2xlIFtwYWdlOi5waGkgcGhpXSB0byBiZSBiZXR3ZWVuIGAwLjAwMDAwMWAgYW5kIHBpIC1cblx0ICogYDAuMDAwMDAxYC5cblx0ICpcblx0ICogQHJldHVybiB7U3BoZXJpY2FsfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyaWNhbC5cblx0ICovXG5cdG1ha2VTYWZlKCkge1xuXG5cdFx0Y29uc3QgRVBTID0gMC4wMDAwMDE7XG5cdFx0dGhpcy5waGkgPSBjbGFtcCggdGhpcy5waGksIEVQUywgTWF0aC5QSSAtIEVQUyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzcGhlcmljYWwgY29tcG9uZW50cyBmcm9tIHRoZSBnaXZlbiB2ZWN0b3Igd2hpY2ggaXMgYXNzdW1lZCB0byBob2xkXG5cdCAqIENhcnRlc2lhbiBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB2IC0gVGhlIHZlY3RvciB0byBzZXQuXG5cdCAqIEByZXR1cm4ge1NwaGVyaWNhbH0gQSByZWZlcmVuY2UgdG8gdGhpcyBzcGhlcmljYWwuXG5cdCAqL1xuXHRzZXRGcm9tVmVjdG9yMyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHYueCwgdi55LCB2LnogKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwaGVyaWNhbCBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIENhcnRlc2lhbiBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeCB2YWx1ZS5cblx0ICogQHJldHVybiB7U3BoZXJpY2FsfSBBIHJlZmVyZW5jZSB0byB0aGlzIHNwaGVyaWNhbC5cblx0ICovXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XG5cblx0XHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnRoZXRhID0gMDtcblx0XHRcdHRoaXMucGhpID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB4LCB6ICk7XG5cdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyggY2xhbXAoIHkgLyB0aGlzLnJhZGl1cywgLSAxLCAxICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBzcGhlcmljYWwgd2l0aCBjb3BpZWQgdmFsdWVzIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7U3BoZXJpY2FsfSBBIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BoZXJpY2FsIH07XG4iLCIvKipcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IHBvaW50cyBpbiAzRCBzcGFjZSBhc1xuICogW0N5bGluZHJpY2FsIGNvb3JkaW5hdGVzXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbX0uXG4gKi9cbmNsYXNzIEN5bGluZHJpY2FsIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjeWxpbmRyaWNhbC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MV0gLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIGEgcG9pbnQgaW4gdGhlIHgteiBwbGFuZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YT0wXSAtIEEgY291bnRlcmNsb2Nrd2lzZSBhbmdsZSBpbiB0aGUgeC16IHBsYW5lIG1lYXN1cmVkIGluIHJhZGlhbnMgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgaGVpZ2h0IGFib3ZlIHRoZSB4LXogcGxhbmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdGhldGEgPSAwLCB5ID0gMCApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHQvKipcblx0XHQgKiBBIGNvdW50ZXJjbG9ja3dpc2UgYW5nbGUgaW4gdGhlIHgteiBwbGFuZSBtZWFzdXJlZCBpbiByYWRpYW5zIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBoZWlnaHQgYWJvdmUgdGhlIHgteiBwbGFuZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMueSA9IHk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjeWxpbmRyaWNhbCBjb21wb25lbnRzIGJ5IGNvcHlpbmcgdGhlIGdpdmVuIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSAtIFRoZSB0aGV0YSBhbmdsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgaGVpZ2h0IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtDeWxpbmRyaWNhbH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjeWxpbmRyaWNhbC5cblx0ICovXG5cdHNldCggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gY3lsaW5kcmljYWwgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtDeWxpbmRyaWNhbH0gb3RoZXIgLSBUaGUgY3lsaW5kcmljYWwgdG8gY29weS5cblx0ICogQHJldHVybiB7Q3lsaW5kcmljYWx9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY3lsaW5kcmljYWwuXG5cdCAqL1xuXHRjb3B5KCBvdGhlciApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xuXHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHR0aGlzLnkgPSBvdGhlci55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjeWxpbmRyaWNhbCBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIHZlY3RvciB3aGljaCBpcyBhc3N1bWVkIHRvIGhvbGRcblx0ICogQ2FydGVzaWFuIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHYgLSBUaGUgdmVjdG9yIHRvIHNldC5cblx0ICogQHJldHVybiB7Q3lsaW5kcmljYWx9IEEgcmVmZXJlbmNlIHRvIHRoaXMgY3lsaW5kcmljYWwuXG5cdCAqL1xuXHRzZXRGcm9tVmVjdG9yMyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHYueCwgdi55LCB2LnogKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN5bGluZHJpY2FsIGNvbXBvbmVudHMgZnJvbSB0aGUgZ2l2ZW4gQ2FydGVzaWFuIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB4IHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtDeWxpbmRyaWNhbH0gQSByZWZlcmVuY2UgdG8gdGhpcyBjeWxpbmRyaWNhbC5cblx0ICovXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggeCAqIHggKyB6ICogeiApO1xuXHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB4LCB6ICk7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBjeWxpbmRyaWNhbCB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtDeWxpbmRyaWNhbH0gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEN5bGluZHJpY2FsIH07XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSAyeDIgbWF0cml4LlxuICpcbiAqIEEgTm90ZSBvbiBSb3ctTWFqb3IgYW5kIENvbHVtbi1NYWpvciBPcmRlcmluZzpcbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgYW5kIHtAbGluayBNYXRyaXgyI3NldH0gbWV0aG9kIHRha2UgYXJndW1lbnRzIGluXG4gKiBbcm93LW1ham9yXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctX2FuZF9jb2x1bW4tbWFqb3Jfb3JkZXIjQ29sdW1uLW1ham9yX29yZGVyfVxuICogb3JkZXIsIHdoaWxlIGludGVybmFsbHkgdGhleSBhcmUgc3RvcmVkIGluIHRoZSB7QGxpbmsgTWF0cml4MiNlbGVtZW50c30gYXJyYXkgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuICogVGhpcyBtZWFucyB0aGF0IGNhbGxpbmc6XG4gKiBgYGBqc1xuICogY29uc3QgbSA9IG5ldyBUSFJFRS5NYXRyaXgyKCk7XG4gKiBtLnNldCggMTEsIDEyLFxuICogICAgICAgIDIxLCAyMiApO1xuICogYGBgXG4gKiB3aWxsIHJlc3VsdCBpbiB0aGUgZWxlbWVudHMgYXJyYXkgY29udGFpbmluZzpcbiAqIGBgYGpzXG4gKiBtLmVsZW1lbnRzID0gWyAxMSwgMjEsXG4gKiAgICAgICAgICAgICAgICAxMiwgMjIgXTtcbiAqIGBgYFxuICogYW5kIGludGVybmFsbHkgYWxsIGNhbGN1bGF0aW9ucyBhcmUgcGVyZm9ybWVkIHVzaW5nIGNvbHVtbi1tYWpvciBvcmRlcmluZy5cbiAqIEhvd2V2ZXIsIGFzIHRoZSBhY3R1YWwgb3JkZXJpbmcgbWFrZXMgbm8gZGlmZmVyZW5jZSBtYXRoZW1hdGljYWxseSBhbmRcbiAqIG1vc3QgcGVvcGxlIGFyZSB1c2VkIHRvIHRoaW5raW5nIGFib3V0IG1hdHJpY2VzIGluIHJvdy1tYWpvciBvcmRlciwgdGhlXG4gKiB0aHJlZS5qcyBkb2N1bWVudGF0aW9uIHNob3dzIG1hdHJpY2VzIGluIHJvdy1tYWpvciBvcmRlci4gSnVzdCBiZWFyIGluXG4gKiBtaW5kIHRoYXQgaWYgeW91IGFyZSByZWFkaW5nIHRoZSBzb3VyY2UgY29kZSwgeW91J2xsIGhhdmUgdG8gdGFrZSB0aGVcbiAqIHRyYW5zcG9zZSBvZiBhbnkgbWF0cmljZXMgb3V0bGluZWQgaGVyZSB0byBtYWtlIHNlbnNlIG9mIHRoZSBjYWxjdWxhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyAyeDIgbWF0cml4LiBUaGUgYXJndW1lbnRzIGFyZSBzdXBwb3NlZCB0byBiZVxuXHQgKiBpbiByb3ctbWFqb3Igb3JkZXIuIElmIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBpbml0aWFsaXplcyB0aGUgbWF0cml4IGFzIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMTFdIC0gMS0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW24xMl0gLSAxLTIgbWF0cml4IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbjIxXSAtIDItMSBtYXRyaXggZWxlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtuMjJdIC0gMi0yIG1hdHJpeCBlbGVtZW50LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMjEsIG4yMiApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdE1hdHJpeDIucHJvdG90eXBlLmlzTWF0cml4MiA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBBIGNvbHVtbi1tYWpvciBsaXN0IG9mIG1hdHJpeCB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cblx0XHQgKi9cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXHRcdFx0MSwgMCxcblx0XHRcdDAsIDEsXG5cdFx0XTtcblxuXHRcdGlmICggbjExICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc2V0KCBuMTEsIG4xMiwgbjIxLCBuMjIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhpcyBtYXRyaXggdG8gdGhlIDJ4MiBpZGVudGl0eSBtYXRyaXguXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hdHJpeDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdDEsIDAsXG5cdFx0XHQwLCAxLFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgLSBUaGUgbWF0cml4IGVsZW1lbnRzIGluIGNvbHVtbi1tYWpvciBvcmRlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBJbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxuXHQgKi9cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBtYXRyaXguVGhlIGFyZ3VtZW50cyBhcmUgc3VwcG9zZWQgdG8gYmVcblx0ICogaW4gcm93LW1ham9yIG9yZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbjExIC0gMS0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbjEyIC0gMS0yIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbjIxIC0gMi0xIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbjIyIC0gMi0yIG1hdHJpeCBlbGVtZW50LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyfSBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cblx0ICovXG5cdHNldCggbjExLCBuMTIsIG4yMSwgbjIyICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDIgXSA9IG4xMjtcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgMyBdID0gbjIyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi9WZWN0b3IyLmpzJztcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIGluIDJEIHNwYWNlLlxuICovXG5jbGFzcyBCb3gyIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBib3VuZGluZyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW21pbj0oSW5maW5pdHksSW5maW5pdHkpXSAtIEEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGJveC5cblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbbWF4PSgtSW5maW5pdHksLUluZmluaXR5KV0gLSBBIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBib3guXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbWluID0gbmV3IFZlY3RvcjIoICsgSW5maW5pdHksICsgSW5maW5pdHkgKSwgbWF4ID0gbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNCb3gyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjJ9XG5cdFx0ICovXG5cdFx0dGhpcy5taW4gPSBtaW47XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGJveC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWZWN0b3IyfVxuXHRcdCAqL1xuXHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kYXJpZXMgb2YgdGhpcyBib3guXG5cdCAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1pbiAtIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1heCAtIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgYm94LlxuXHQgKiBAcmV0dXJuIHtCb3gyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdHNldCggbWluLCBtYXggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiB0aGlzIGJveCBzbyBpdCBlbmNsb3NlcyB0aGUgcG9zaXRpb24gZGF0YVxuXHQgKiBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yMj59IHBvaW50cyAtIEFuIGFycmF5IGhvbGRpbmcgMkQgcG9zaXRpb24gZGF0YSBhcyBpbnN0YW5jZXMgb2Yge0BsaW5rIFZlY3RvcjJ9LlxuXHQgKiBAcmV0dXJuIHtCb3gyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENlbnRlcnMgdGhpcyBib3ggb24gdGhlIGdpdmVuIGNlbnRlciB2ZWN0b3IgYW5kIHNldHMgdGhpcyBib3gncyB3aWR0aCwgaGVpZ2h0IGFuZFxuXHQgKiBkZXB0aCB0byB0aGUgZ2l2ZW4gc2l6ZSB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gY2VudGVyIC0gVGhlIGNlbnRlciBvZiB0aGUgYm94LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHNpemUgLSBUaGUgeCBhbmQgeSBkaW1lbnNpb25zIG9mIHRoZSBib3guXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0c2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuXHRcdGNvbnN0IGhhbGZTaXplID0gX3ZlY3Rvci5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgYm94IHdpdGggY29waWVkIHZhbHVlcyBmcm9tIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGJveCB0byB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDJ9IGJveCAtIFRoZSBib3ggdG8gY29weS5cblx0ICogQHJldHVybiB7Qm94Mn0gQSByZWZlcmVuY2UgdG8gdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRjb3B5KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyB0aGlzIGJveCBlbXB0eSB3aGljaCBtZWFucyBpbiBlbmNsb3NlcyBhIHplcm8gc3BhY2UgaW4gMkQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0bWFrZUVtcHR5KCkge1xuXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYm94IGluY2x1ZGVzIHplcm8gcG9pbnRzIHdpdGhpbiBpdHMgYm91bmRzLlxuXHQgKiBOb3RlIHRoYXQgYSBib3ggd2l0aCBlcXVhbCBsb3dlciBhbmQgdXBwZXIgYm91bmRzIHN0aWxsIGluY2x1ZGVzIG9uZVxuXHQgKiBwb2ludCwgdGhlIG9uZSBib3RoIGJvdW5kcyBzaGFyZS5cblx0ICpcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGJveCBpcyBlbXB0eSBvciBub3QuXG5cdCAqL1xuXHRpc0VtcHR5KCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoaXMgYm94LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgY2VudGVyIHBvaW50LlxuXHQgKi9cblx0Z2V0Q2VudGVyKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwICkgOiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGlzIGJveC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHNpemUuXG5cdCAqL1xuXHRnZXRTaXplKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwICkgOiB0YXJnZXQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBhbmRzIHRoZSBib3VuZGFyaWVzIG9mIHRoaXMgYm94IHRvIGluY2x1ZGUgdGhlIGdpdmVuIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvaW50IC0gVGhlIHBvaW50IHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGJ5IHRoZSBib3VuZGluZyBib3guXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0ZXhwYW5kQnlQb2ludCggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBhbmRzIHRoaXMgYm94IGVxdWlsYXRlcmFsbHkgYnkgdGhlIGdpdmVuIHZlY3Rvci4gVGhlIHdpZHRoIG9mIHRoaXNcblx0ICogYm94IHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgaW4gYm90aFxuXHQgKiBkaXJlY3Rpb25zLiBUaGUgaGVpZ2h0IG9mIHRoaXMgYm94IHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHkgY29tcG9uZW50IG9mXG5cdCAqIHRoZSB2ZWN0b3IgaW4gYm90aCBkaXJlY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZlY3RvciAtIFRoZSB2ZWN0b3IgdGhhdCBzaG91bGQgZXhwYW5kIHRoZSBib3VuZGluZyBib3guXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcyBlYWNoIGRpbWVuc2lvbiBvZiB0aGUgYm94IGJ5IHRoZSBnaXZlbiBzY2FsYXIuIElmIG5lZ2F0aXZlLCB0aGVcblx0ICogZGltZW5zaW9ucyBvZiB0aGUgYm94IHdpbGwgYmUgY29udHJhY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUgdGhhdCBzaG91bGQgZXhwYW5kIHRoZSBib3VuZGluZyBib3guXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0ZXhwYW5kQnlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgbGllcyB3aXRoaW4gb3Igb24gdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYm91bmRpbmcgYm94IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludCBvciBub3QuXG5cdCAqL1xuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiBwb2ludC54ID49IHRoaXMubWluLnggJiYgcG9pbnQueCA8PSB0aGlzLm1heC54ICYmXG5cdFx0XHRwb2ludC55ID49IHRoaXMubWluLnkgJiYgcG9pbnQueSA8PSB0aGlzLm1heC55O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBib3VuZGluZyBib3ggaW5jbHVkZXMgdGhlIGVudGlyZXR5IG9mIHRoZSBnaXZlbiBib3VuZGluZyBib3guXG5cdCAqIElmIHRoaXMgYm94IGFuZCB0aGUgZ2l2ZW4gb25lIGFyZSBpZGVudGljYWwsIHRoaXMgZnVuY3Rpb24gYWxzbyByZXR1cm5zIGB0cnVlYC5cblx0ICpcblx0ICogQHBhcmFtIHtCb3gyfSBib3ggLSBUaGUgYm91bmRpbmcgYm94IHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGJvdW5kaW5nIGJveCBjb250YWlucyB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94IG9yIG5vdC5cblx0ICovXG5cdGNvbnRhaW5zQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHBvaW50IGFzIGEgcHJvcG9ydGlvbiBvZiB0aGlzIGJveCdzIHdpZHRoIGFuZCBoZWlnaHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gcG9pbnQgLSBBIHBvaW50IGluIDJEIHNwYWNlLlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmVjdG9yIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbWV0aG9kJ3MgcmVzdWx0LlxuXHQgKiBAcmV0dXJuIHtWZWN0b3IyfSBBIHBvaW50IGFzIGEgcHJvcG9ydGlvbiBvZiB0aGlzIGJveCdzIHdpZHRoIGFuZCBoZWlnaHQuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXIoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxuXHRcdCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94IGludGVyc2VjdHMgd2l0aCB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICpcblx0ICogQHBhcmFtIHtCb3gyfSBib3ggLSBUaGUgYm91bmRpbmcgYm94IHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHdpdGggdGhpcyBib3VuZGluZyBib3guXG5cdCAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xuXG5cdFx0cmV0dXJuIGJveC5tYXgueCA+PSB0aGlzLm1pbi54ICYmIGJveC5taW4ueCA8PSB0aGlzLm1heC54ICYmXG5cdFx0XHRib3gubWF4LnkgPj0gdGhpcy5taW4ueSAmJiBib3gubWluLnkgPD0gdGhpcy5tYXgueTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENsYW1wcyB0aGUgZ2l2ZW4gcG9pbnQgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhpcyBib3guXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2xhbXAuXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBjbGFtcGVkIHBvaW50LlxuXHQgKi9cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgZnJvbSBhbnkgZWRnZSBvZiB0aGlzIGJveCB0byB0aGUgc3BlY2lmaWVkIHBvaW50LiBJZlxuXHQgKiB0aGUgZ2l2ZW4gcG9pbnQgbGllcyBpbnNpZGUgb2YgdGhpcyBib3gsIHRoZSBkaXN0YW5jZSB3aWxsIGJlIGAwYC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBwb2ludCAtIFRoZSBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0by5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuXHQgKi9cblx0ZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiB0aGlzLmNsYW1wUG9pbnQoIHBvaW50LCBfdmVjdG9yICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBib3VuZGluZyBib3ggYW5kIHRoZSBnaXZlbiBvbmUsIHNldHRpbmcgdGhlIHVwcGVyXG5cdCAqIGJvdW5kIG9mIHRoaXMgYm94IHRvIHRoZSBsZXNzZXIgb2YgdGhlIHR3byBib3hlcycgdXBwZXIgYm91bmRzIGFuZCB0aGVcblx0ICogbG93ZXIgYm91bmQgb2YgdGhpcyBib3ggdG8gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBib3hlcycgbG93ZXIgYm91bmRzLiBJZlxuXHQgKiB0aGVyZSdzIG5vIG92ZXJsYXAsIG1ha2VzIHRoaXMgYm94IGVtcHR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDJ9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdG8gaW50ZXJzZWN0IHdpdGguXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0aW50ZXJzZWN0KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgdW5pb24gb2YgdGhpcyBib3ggYW5kIGFub3RoZXIgYW5kIHRoZSBnaXZlbiBvbmUsIHNldHRpbmcgdGhlIHVwcGVyXG5cdCAqIGJvdW5kIG9mIHRoaXMgYm94IHRvIHRoZSBncmVhdGVyIG9mIHRoZSB0d28gYm94ZXMnIHVwcGVyIGJvdW5kcyBhbmQgdGhlXG5cdCAqIGxvd2VyIGJvdW5kIG9mIHRoaXMgYm94IHRvIHRoZSBsZXNzZXIgb2YgdGhlIHR3byBib3hlcycgbG93ZXIgYm91bmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0JveDJ9IGJveCAtIFRoZSBib3VuZGluZyBib3ggdGhhdCB3aWxsIGJlIHVuaW9uZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtCb3gyfSBBIHJlZmVyZW5jZSB0byB0aGlzIGJvdW5kaW5nIGJveC5cblx0ICovXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgZ2l2ZW4gb2Zmc2V0IHRvIGJvdGggdGhlIHVwcGVyIGFuZCBsb3dlciBib3VuZHMgb2YgdGhpcyBib3VuZGluZyBib3gsXG5cdCAqIGVmZmVjdGl2ZWx5IG1vdmluZyBpdCBpbiAyRCBzcGFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gdHJhbnNsYXRlIHRoZSBib3VuZGluZyBib3guXG5cdCAqIEByZXR1cm4ge0JveDJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgYm91bmRpbmcgYm94IGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtCb3gyfSBib3ggLSBUaGUgYm94IHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgYm91bmRpbmcgYm94IGlzIGVxdWFsIHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICovXG5cdGVxdWFscyggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBCb3gyIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jb25zdCBfc3RhcnRQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3N0YXJ0RW5kID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEFuIGFuYWx5dGljYWwgbGluZSBzZWdtZW50IGluIDNEIHNwYWNlIHJlcHJlc2VudGVkIGJ5IGEgc3RhcnQgYW5kIGVuZCBwb2ludC5cbiAqL1xuY2xhc3MgTGluZTMge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpbmUgc2VnbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbc3RhcnQ9KDAsMCwwKV0gLSBTdGFydCBvZiB0aGUgbGluZSBzZWdtZW50LlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtlbmQ9KDAsMCwwKV0gLSBFbmQgb2YgdGhlIGxpbmUgc2VnbWVudC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBzdGFydCA9IG5ldyBWZWN0b3IzKCksIGVuZCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHQvKipcblx0XHQgKiBTdGFydCBvZiB0aGUgbGluZSBzZWdtZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXG5cdFx0LyoqXG5cdFx0ICogRW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cblx0XHQgKi9cblx0XHR0aGlzLmVuZCA9IGVuZDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGJ5IGNvcHlpbmcgdGhlIGdpdmVuIHZlY3RvcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gc3RhcnQgLSBUaGUgc3RhcnQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gZW5kIC0gVGhlIGVuZCBwb2ludC5cblx0ICogQHJldHVybiB7TGluZTN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbGluZSBzZWdtZW50LlxuXHQgKi9cblx0c2V0KCBzdGFydCwgZW5kICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuXHRcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbGluZSBzZWdtZW50IHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGluZTN9IGxpbmUgLSBUaGUgbGluZSBzZWdtZW50IHRvIGNvcHkuXG5cdCAqIEByZXR1cm4ge0xpbmUzfSBBIHJlZmVyZW5jZSB0byB0aGlzIGxpbmUgc2VnbWVudC5cblx0ICovXG5cdGNvcHkoIGxpbmUgKSB7XG5cblx0XHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblx0XHR0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIGxpbmUgc2VnbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIGNlbnRlciBwb2ludC5cblx0ICovXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRlbHRhIHZlY3RvciBvZiB0aGUgbGluZSBzZWdtZW50J3Mgc3RhcnQgYW5kIGVuZCBwb2ludC5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZlY3RvciB0aGF0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIG1ldGhvZCdzIHJlc3VsdC5cblx0ICogQHJldHVybiB7VmVjdG9yM30gVGhlIGRlbHRhIHZlY3Rvci5cblx0ICovXG5cdGRlbHRhKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lJyBzdGFydCBhbmQgZW5kIHBvaW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIEV1Y2xpZGVhbiBkaXN0YW5jZS5cblx0ICovXG5cdGRpc3RhbmNlU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lJyBzdGFydCBhbmQgZW5kIHBvaW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBFdWNsaWRlYW4gZGlzdGFuY2UuXG5cdCAqL1xuXHRkaXN0YW5jZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIGF0IGEgY2VydGFpbiBwb3NpdGlvbiBhbG9uZyB0aGUgbGluZSBzZWdtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdCAtIEEgdmFsdWUgYmV0d2VlbiBgWzAsMV1gIHRvIHJlcHJlc2VudCBhIHBvc2l0aW9uIGFsb25nIHRoZSBsaW5lIHNlZ21lbnQuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBkZWx0YSB2ZWN0b3IuXG5cdCAqL1xuXHRhdCggdCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHRhcmdldCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcG9pbnQgcGFyYW1ldGVyIGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGFzIHByb2plY3RlZCBvbiB0aGUgbGluZSBzZWdtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IGZvciB3aGljaCB0byByZXR1cm4gYSBwb2ludCBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xhbXBUb0xpbmUgLSBXaGV0aGVyIHRvIGNsYW1wIHRoZSByZXN1bHQgdG8gdGhlIHJhbmdlIGBbMCwxXWAgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb2ludCBwYXJhbWV0ZXIuXG5cdCAqL1xuXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRfc3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XG5cdFx0X3N0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cblx0XHRjb25zdCBzdGFydEVuZDIgPSBfc3RhcnRFbmQuZG90KCBfc3RhcnRFbmQgKTtcblx0XHRjb25zdCBzdGFydEVuZF9zdGFydFAgPSBfc3RhcnRFbmQuZG90KCBfc3RhcnRQICk7XG5cblx0XHRsZXQgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuXHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdHQgPSBjbGFtcCggdCwgMCwgMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbG9zZXRzIHBvaW50IG9uIHRoZSBsaW5lIGZvciBhIGdpdmVuIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IHBvaW50IC0gVGhlIHBvaW50IHRvIGNvbXB1dGUgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgZm9yLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNsYW1wVG9MaW5lIC0gV2hldGhlciB0byBjbGFtcCB0aGUgcmVzdWx0IHRvIHRoZSByYW5nZSBgWzAsMV1gIG9yIG5vdC5cblx0ICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSAgVGhlIHRhcmdldCB2ZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBtZXRob2QncyByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lLlxuXHQgKi9cblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGNsYW1wVG9MaW5lLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcblxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCB0YXJnZXQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhpcyBsaW5lIHNlZ21lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0ICogQHJldHVybiB7TGluZTN9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbGluZSBzZWdtZW50LlxuXHQgKi9cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBsaW5lIHNlZ21lbnQgaXMgZXF1YWwgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmUzfSBsaW5lIC0gVGhlIGxpbmUgc2VnbWVudCB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGxpbmUgc2VnbWVudCBpcyBlcXVhbCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqL1xuXHRlcXVhbHMoIGxpbmUgKSB7XG5cblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGxpbmUgc2VnbWVudCB3aXRoIGNvcGllZCB2YWx1ZXMgZnJvbSB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtMaW5lM30gQSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IExpbmUzIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XG5pbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuLyoqXG4gKiBUaGlzIGRpc3BsYXlzIGEgY29uZSBzaGFwZWQgaGVscGVyIG9iamVjdCBmb3IgYSB7QGxpbmsgU3BvdExpZ2h0fS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3BvdExpZ2h0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggMHhmZmZmZmYgKTtcbiAqIHNwb3RMaWdodC5wb3NpdGlvbi5zZXQoIDEwLCAxMCwgMTAgKTtcbiAqIHNjZW5lLmFkZCggc3BvdExpZ2h0ICk7XG4gKlxuICogY29uc3Qgc3BvdExpZ2h0SGVscGVyID0gbmV3IFRIUkVFLlNwb3RMaWdodEhlbHBlciggc3BvdExpZ2h0ICk7XG4gKiBzY2VuZS5hZGQoIHNwb3RMaWdodEhlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIFNwb3RMaWdodEhlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzcG90IGxpZ2h0IGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtIZW1pc3BoZXJlTGlnaHR9IGxpZ2h0IC0gVGhlIGxpZ2h0IHRvIGJlIHZpc3VhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfENvbG9yfHN0cmluZ30gW2NvbG9yXSAtIFRoZSBoZWxwZXIncyBjb2xvci4gSWYgbm90IHNldCwgdGhlIGhlbHBlciB3aWxsIHRha2Vcblx0ICogdGhlIGNvbG9yIG9mIHRoZSBsaWdodC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgY29sb3IgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpZ2h0IGJlaW5nIHZpc3VhbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7U3BvdExpZ2h0fVxuXHRcdCAqL1xuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIHBhcmFtZXRlciBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAqIElmIG5vdCBzZXQsIHRoZSBoZWxwZXIgd2lsbCB0YWtlIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfENvbG9yfHN0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0SGVscGVyJztcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXG5cdFx0XHQwLCAwLCAwLCBcdDAsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLCBcdDEsIDAsIDEsXG5cdFx0XHQwLCAwLCAwLFx0LSAxLCAwLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAxLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQwLCAtIDEsIDFcblx0XHRdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcblx0XHRcdGNvbnN0IHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdHBvc2l0aW9ucy5wdXNoKFxuXHRcdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXG5cdFx0XHRcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhlbHBlciB0byBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiBvZiB0aGVcblx0ICogbGlnaHQgYmVpbmcgdmlzdWFsaXplZC5cblx0ICovXG5cdHVwZGF0ZSgpIHtcblxuXHRcdHRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cdFx0dGhpcy5saWdodC50YXJnZXQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHQvLyB1cGRhdGUgdGhlIGxvY2FsIG1hdHJpeCBiYXNlZCBvbiB0aGUgcGFyZW50IGFuZCBsaWdodCB0YXJnZXQgdHJhbnNmb3Jtc1xuXHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cblx0XHRcdHRoaXMucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlICk7XG5cblx0XHRcdHRoaXMubWF0cml4XG5cdFx0XHRcdC5jb3B5KCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCApXG5cdFx0XHRcdC5pbnZlcnQoKVxuXHRcdFx0XHQubXVsdGlwbHkoIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubWF0cml4LmNvcHkoIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0Y29uc3QgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcblx0XHRjb25zdCBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cblx0XHRfdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMuY29uZS5sb29rQXQoIF92ZWN0b3IgKTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFNwb3RMaWdodEhlbHBlciB9O1xuIiwiaW1wb3J0IHsgTGluZVNlZ21lbnRzIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lU2VnbWVudHMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuXG4vKipcbiAqIEEgaGVscGVyIG9iamVjdCB0byBhc3Npc3Qgd2l0aCB2aXN1YWxpemluZyBhIHtAbGluayBTa2VsZXRvbn0uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGhlbHBlciA9IG5ldyBUSFJFRS5Ta2VsZXRvbkhlbHBlciggc2tpbm5lZE1lc2ggKTtcbiAqIHNjZW5lLmFkZCggaGVscGVyICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgTGluZVNlZ21lbnRzXG4gKi9cbmNsYXNzIFNrZWxldG9uSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBoZW1pc3BoZXJlIGxpZ2h0IGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gIFVzdWFsbHkgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFNraW5uZWRNZXNofS4gSG93ZXZlciwgYW55IDNEIG9iamVjdFxuXHQgKiBjYW4gYmUgdXNlZCBpZiBpdCByZXByZXNlbnRzIGEgaGllcmFyY2h5IG9mIGJvbmVzIChzZWUge0BsaW5rIEJvbmV9KS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBib25lcyA9IGdldEJvbmVMaXN0KCBvYmplY3QgKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXG5cdFx0Y29uc3QgY29sb3IxID0gbmV3IENvbG9yKCAwLCAwLCAxICk7XG5cdFx0Y29uc3QgY29sb3IyID0gbmV3IENvbG9yKCAwLCAxLCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGJvbmUgPSBib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIgKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5pc1NrZWxldG9uSGVscGVyID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTa2VsZXRvbkhlbHBlcic7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IGJlaW5nIHZpc3VhbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0M0R9XG5cdFx0ICovXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xuXG5cdFx0LyoqXG5cdFx0ICogaGUgbGlzdCBvZiBib25lcyB0aGF0IHRoZSBoZWxwZXIgdmlzdWFsaXplcy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtBcnJheTxCb25lPn1cblx0XHQgKi9cblx0XHR0aGlzLmJvbmVzID0gYm9uZXM7XG5cblx0XHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRfbWF0cml4V29ybGRJbnYuY29weSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX21hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBfYm9uZU1hdHJpeCApO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGosIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdFx0XHRfYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBfbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBfYm9uZU1hdHJpeCApO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHRcdFx0aiArPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZyZWVzIHRoZSBHUFUtcmVsYXRlZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpc1xuXHQgKiBtZXRob2Qgd2hlbmV2ZXIgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgdXNlZCBpbiB5b3VyIGFwcC5cblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuXG5mdW5jdGlvbiBnZXRCb25lTGlzdCggb2JqZWN0ICkge1xuXG5cdGNvbnN0IGJvbmVMaXN0ID0gW107XG5cblx0aWYgKCBvYmplY3QuaXNCb25lID09PSB0cnVlICkge1xuXG5cdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoKCAuLi5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn1cblxuXG5leHBvcnQgeyBTa2VsZXRvbkhlbHBlciB9O1xuIiwiaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBTcGhlcmVHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIFRoaXMgZGlzcGxheXMgYSBoZWxwZXIgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgYSBzcGhlcmljYWwgbWVzaCBmb3JcbiAqIHZpc3VhbGl6aW5nIGFuIGluc3RhbmNlIG9mIHtAbGluayBQb2ludExpZ2h0fS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcG9pbnRMaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCAweGZmMDAwMCwgMSwgMTAwICk7XG4gKiBwb2ludExpZ2h0LnBvc2l0aW9uLnNldCggMTAsIDEwLCAxMCApO1xuICogc2NlbmUuYWRkKCBwb2ludExpZ2h0ICk7XG4gKlxuICogY29uc3Qgc3BoZXJlU2l6ZSA9IDE7XG4gKiBjb25zdCBwb2ludExpZ2h0SGVscGVyID0gbmV3IFRIUkVFLlBvaW50TGlnaHRIZWxwZXIoIHBvaW50TGlnaHQsIHNwaGVyZVNpemUgKTtcbiAqIHNjZW5lLmFkZCggcG9pbnRMaWdodEhlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE1lc2hcbiAqL1xuY2xhc3MgUG9pbnRMaWdodEhlbHBlciBleHRlbmRzIE1lc2gge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvaW50IGxpZ2h0IGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtQb2ludExpZ2h0fSBsaWdodCAtIFRoZSBsaWdodCB0byBiZSB2aXN1YWxpemVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3NwaGVyZVNpemU9MV0gLSBUaGUgc2l6ZSBvZiB0aGUgc3BoZXJlIGhlbHBlci5cblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSBbY29sb3JdIC0gVGhlIGhlbHBlcidzIGNvbG9yLiBJZiBub3Qgc2V0LCB0aGUgaGVscGVyIHdpbGwgdGFrZVxuXHQgKiB0aGUgY29sb3Igb2YgdGhlIGxpZ2h0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvciApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlnaHQgYmVpbmcgdmlzdWFsaXplZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtIZW1pc3BoZXJlTGlnaHR9XG5cdFx0ICovXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIHBhcmFtZXRlciBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAqIElmIG5vdCBzZXQsIHRoZSBoZWxwZXIgd2lsbCB0YWtlIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfENvbG9yfHN0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodEhlbHBlcic7XG5cblx0XHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cblx0XHQvKlxuXHQvLyBUT0RPOiBkZWxldGUgdGhpcyBjb21tZW50P1xuXHRjb25zdCBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcblx0Y29uc3QgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xuXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG5cdGNvbnN0IGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHR9XG5cblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHQqL1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgaGVscGVyIHRvIG1hdGNoIHRoZSBwb3NpdGlvbiBvZiB0aGVcblx0ICogbGlnaHQgYmVpbmcgdmlzdWFsaXplZC5cblx0ICovXG5cdHVwZGF0ZSgpIHtcblxuXHRcdHRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0Lypcblx0XHRjb25zdCBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRcdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdFx0fVxuXHRcdCovXG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgUG9pbnRMaWdodEhlbHBlciB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL01lc2guanMnO1xuaW1wb3J0IHsgTWVzaEJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgT2N0YWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi4vZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2NvbG9yMSA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XG5jb25zdCBfY29sb3IyID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdmlzdWFsIGFpZCBjb25zaXN0aW5nIG9mIGEgc3BoZXJpY2FsIG1lc2ggZm9yIGFcbiAqIGdpdmVuIHtAbGluayBIZW1pc3BoZXJlTGlnaHR9LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIDB4ZmZmZmJiLCAweDA4MDgyMCwgMSApO1xuICogY29uc3QgaGVscGVyID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlciggbGlnaHQsIDUgKTtcbiAqIHNjZW5lLmFkZCggaGVscGVyICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgSGVtaXNwaGVyZUxpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGhlbWlzcGhlcmUgbGlnaHQgaGVscGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hlbWlzcGhlcmVMaWdodH0gbGlnaHQgLSBUaGUgbGlnaHQgdG8gYmUgdmlzdWFsaXplZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIC0gVGhlIHNpemUgb2YgdGhlIG1lc2ggdXNlZCB0byB2aXN1YWxpemUgdGhlIGxpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcnxDb2xvcnxzdHJpbmd9IFtjb2xvcl0gLSBUaGUgaGVscGVyJ3MgY29sb3IuIElmIG5vdCBzZXQsIHRoZSBoZWxwZXIgd2lsbCB0YWtlXG5cdCAqIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaWdodCBiZWluZyB2aXN1YWxpemVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0hlbWlzcGhlcmVMaWdodH1cblx0XHQgKi9cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIHBhcmFtZXRlciBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAqIElmIG5vdCBzZXQsIHRoZSBoZWxwZXIgd2lsbCB0YWtlIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVtYmVyfENvbG9yfHN0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0SGVscGVyJztcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggc2l6ZSApO1xuXHRcdGdlb21ldHJ5LnJvdGF0ZVkoIE1hdGguUEkgKiAwLjUgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XG5cdFx0aWYgKCB0aGlzLmNvbG9yID09PSB1bmRlZmluZWQgKSB0aGlzLm1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdGNvbnN0IGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uLmNvdW50ICogMyApO1xuXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhlbHBlciB0byBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiBvZiB0aGVcblx0ICogbGlnaHQgYmVpbmcgdmlzdWFsaXplZC5cblx0ICovXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IG1lc2ggPSB0aGlzLmNoaWxkcmVuWyAwIF07XG5cblx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGNvbG9ycyA9IG1lc2guZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XG5cblx0XHRcdF9jb2xvcjEuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXHRcdFx0X2NvbG9yMi5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNvbG9ycy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY29sb3IgPSAoIGkgPCAoIGwgLyAyICkgKSA/IF9jb2xvcjEgOiBfY29sb3IyO1xuXG5cdFx0XHRcdGNvbG9ycy5zZXRYWVooIGksIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5saWdodC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdG1lc2gubG9va0F0KCBfdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0SGVscGVyIH07XG4iLCJpbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XG5cbi8qKlxuICogVGhlIGhlbHBlciBpcyBhbiBvYmplY3QgdG8gZGVmaW5lIGdyaWRzLiBHcmlkcyBhcmUgdHdvLWRpbWVuc2lvbmFsXG4gKiBhcnJheXMgb2YgbGluZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHNpemUgPSAxMDtcbiAqIGNvbnN0IGRpdmlzaW9ucyA9IDEwO1xuICpcbiAqIGNvbnN0IGdyaWRIZWxwZXIgPSBuZXcgVEhSRUUuR3JpZEhlbHBlciggc2l6ZSwgZGl2aXNpb25zICk7XG4gKiBzY2VuZS5hZGQoIGdyaWRIZWxwZXIgKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMaW5lU2VnbWVudHNcbiAqL1xuY2xhc3MgR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JpZCBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xMF0gLSBUaGUgc2l6ZSBvZiB0aGUgZ3JpZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaXZpc2lvbnM9MTBdIC0gVGhlIG51bWJlciBvZiBkaXZpc2lvbnMgYWNyb3NzIHRoZSBncmlkLlxuXHQgKiBAcGFyYW0ge251bWJlcnxDb2xvcnxzdHJpbmd9IFtjb2xvcjE9MHg0NDQ0NDRdIC0gVGhlIGNvbG9yIG9mIHRoZSBjZW50ZXIgbGluZS5cblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSBbY29sb3IyPTB4ODg4ODg4XSAtIFRoZSBjb2xvciBvZiB0aGUgbGluZXMgb2YgdGhlIGdyaWQuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEwLCBkaXZpc2lvbnMgPSAxMCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4ICkge1xuXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgKTtcblx0XHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiApO1xuXG5cdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0XHRjb25zdCBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcblx0XHRjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggLSBoYWxmU2l6ZSwgMCwgaywgaGFsZlNpemUsIDAsIGsgKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXHRcdFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0dyaWRIZWxwZXInO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEdyaWRIZWxwZXIgfTtcbiIsImltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBpcyBhbiBvYmplY3QgdG8gZGVmaW5lIHBvbGFyIGdyaWRzLiBHcmlkcyBhcmVcbiAqIHR3by1kaW1lbnNpb25hbCBhcnJheXMgb2YgbGluZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHJhZGl1cyA9IDEwO1xuICogY29uc3Qgc2VjdG9ycyA9IDE2O1xuICogY29uc3QgcmluZ3MgPSA4O1xuICogY29uc3QgZGl2aXNpb25zID0gNjQ7XG4gKlxuICogY29uc3QgaGVscGVyID0gbmV3IFRIUkVFLlBvbGFyR3JpZEhlbHBlciggcmFkaXVzLCBzZWN0b3JzLCByaW5ncywgZGl2aXNpb25zICk7XG4gKiBzY2VuZS5hZGQoIGhlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpbmVTZWdtZW50c1xuICovXG5jbGFzcyBQb2xhckdyaWRIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvbGFyIGdyaWQgaGVscGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xMF0gLSBUaGUgcmFkaXVzIG9mIHRoZSBwb2xhciBncmlkLiBUaGlzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3NlY3RvcnM9MTZdIC0gVGhlIG51bWJlciBvZiBzZWN0b3JzIHRoZSBncmlkIHdpbGwgYmUgZGl2aWRlZCBpbnRvLiBUaGlzIGNhbiBiZSBhbnkgcG9zaXRpdmUgaW50ZWdlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtyaW5ncz0xNl0gLSBUaGUgbnVtYmVyIG9mIHJpbmdzLiBUaGlzIGNhbiBiZSBhbnkgcG9zaXRpdmUgaW50ZWdlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkaXZpc2lvbnM9NjRdIC0gVGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzIHVzZWQgZm9yIGVhY2ggY2lyY2xlLiBUaGlzIGNhbiBiZSBhbnkgcG9zaXRpdmUgaW50ZWdlci5cblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSBbY29sb3IxPTB4NDQ0NDQ0XSAtIFRoZSBmaXJzdCBjb2xvciB1c2VkIGZvciBncmlkIGVsZW1lbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcnxDb2xvcnxzdHJpbmd9IFtjb2xvcjI9MHg4ODg4ODhdIC0gIFRoZSBzZWNvbmQgY29sb3IgdXNlZCBmb3IgZ3JpZCBlbGVtZW50cy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxMCwgc2VjdG9ycyA9IDE2LCByaW5ncyA9IDgsIGRpdmlzaW9ucyA9IDY0LCBjb2xvcjEgPSAweDQ0NDQ0NCwgY29sb3IyID0gMHg4ODg4ODggKSB7XG5cblx0XHRjb2xvcjEgPSBuZXcgQ29sb3IoIGNvbG9yMSApO1xuXHRcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICk7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBzZWN0b3JzXG5cblx0XHRpZiAoIHNlY3RvcnMgPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzZWN0b3JzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHYgPSAoIGkgLyBzZWN0b3JzICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdFx0Y29uc3QgeCA9IE1hdGguc2luKCB2ICkgKiByYWRpdXM7XG5cdFx0XHRcdGNvbnN0IHogPSBNYXRoLmNvcyggdiApICogcmFkaXVzO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSB0aGUgcmluZ3NcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJpbmdzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcblxuXHRcdFx0Y29uc3QgciA9IHJhZGl1cyAtICggcmFkaXVzIC8gcmluZ3MgKiBpICk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGRpdmlzaW9uczsgaiArKyApIHtcblxuXHRcdFx0XHQvLyBmaXJzdCB2ZXJ0ZXhcblxuXHRcdFx0XHRsZXQgdiA9ICggaiAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRcdGxldCB4ID0gTWF0aC5zaW4oIHYgKSAqIHI7XG5cdFx0XHRcdGxldCB6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xuXHRcdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHRcdC8vIHNlY29uZCB2ZXJ0ZXhcblxuXHRcdFx0XHR2ID0gKCAoIGogKyAxICkgLyBkaXZpc2lvbnMgKSAqICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0XHR4ID0gTWF0aC5zaW4oIHYgKSAqIHI7XG5cdFx0XHRcdHogPSBNYXRoLmNvcyggdiApICogcjtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2xhckdyaWRIZWxwZXInO1xuXG5cdH1cblxuXHQvKipcblx0ICogRnJlZXMgdGhlIEdQVS1yZWxhdGVkIHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzXG5cdCAqIG1ldGhvZCB3aGVuZXZlciB0aGlzIGluc3RhbmNlIGlzIG5vIGxvbmdlciB1c2VkIGluIHlvdXIgYXBwLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFBvbGFyR3JpZEhlbHBlciB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4uL29iamVjdHMvTGluZS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEhlbHBlciBvYmplY3QgdG8gYXNzaXN0IHdpdGggdmlzdWFsaXppbmcgYSB7QGxpbmsgRGlyZWN0aW9uYWxMaWdodH0nc1xuICogZWZmZWN0IG9uIHRoZSBzY2VuZS4gVGhpcyBjb25zaXN0cyBvZiBwbGFuZSBhbmQgYSBsaW5lIHJlcHJlc2VudGluZyB0aGVcbiAqIGxpZ2h0J3MgcG9zaXRpb24gYW5kIGRpcmVjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggMHhGRkZGRkYgKTtcbiAqIHNjZW5lLmFkZCggbGlnaHQgKTtcbiAqXG4gKiBjb25zdCBoZWxwZXIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciggbGlnaHQsIDUgKTtcbiAqIHNjZW5lLmFkZCggaGVscGVyICk7XG4gKiBgYGBcbiAqXG4gKiBAYXVnbWVudHMgT2JqZWN0M0RcbiAqL1xuY2xhc3MgRGlyZWN0aW9uYWxMaWdodEhlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkaXJlY3Rpb25hbCBsaWdodCBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RGlyZWN0aW9uYWxMaWdodH0gbGlnaHQgLSBUaGUgbGlnaHQgdG8gYmUgdmlzdWFsaXplZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIC0gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBsYW5lLlxuXHQgKiBAcGFyYW0ge251bWJlcnxDb2xvcnxzdHJpbmd9IFtjb2xvcl0gLSBUaGUgaGVscGVyJ3MgY29sb3IuIElmIG5vdCBzZXQsIHRoZSBoZWxwZXIgd2lsbCB0YWtlXG5cdCAqIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaWdodCBiZWluZyB2aXN1YWxpemVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0RpcmVjdGlvbmFsTGlnaHR9XG5cdFx0ICovXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciBwYXJhbWV0ZXIgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cblx0XHQgKiBJZiBub3Qgc2V0LCB0aGUgaGVscGVyIHdpbGwgdGFrZSB0aGUgY29sb3Igb2YgdGhlIGxpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcnxDb2xvcnxzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHRIZWxwZXInO1xuXG5cdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTtcblxuXHRcdGxldCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFtcblx0XHRcdC0gc2l6ZSwgc2l6ZSwgMCxcblx0XHRcdHNpemUsIHNpemUsIDAsXG5cdFx0XHRzaXplLCAtIHNpemUsIDAsXG5cdFx0XHQtIHNpemUsIC0gc2l6ZSwgMCxcblx0XHRcdC0gc2l6ZSwgc2l6ZSwgMFxuXHRcdF0sIDMgKSApO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udGFpbnMgdGhlIGxpbmUgc2hvd2luZyB0aGUgbG9jYXRpb24gb2YgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0xpbmV9XG5cdFx0ICovXG5cdFx0dGhpcy5saWdodFBsYW5lID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcblxuXHRcdGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAwLCAxIF0sIDMgKSApO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVwcmVzZW50cyB0aGUgdGFyZ2V0IGxpbmUgb2YgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0xpbmV9XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRMaW5lID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhlbHBlciB0byBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiBvZiB0aGVcblx0ICogbGlnaHQgYmVpbmcgdmlzdWFsaXplZC5cblx0ICovXG5cdHVwZGF0ZSgpIHtcblxuXHRcdHRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cdFx0dGhpcy5saWdodC50YXJnZXQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0X3YyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRfdjMuc3ViVmVjdG9ycyggX3YyLCBfdjEgKTtcblxuXHRcdHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIF92MiApO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50YXJnZXRMaW5lLmxvb2tBdCggX3YyICk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLnNjYWxlLnogPSBfdjMubGVuZ3RoKCk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRGlyZWN0aW9uYWxMaWdodEhlbHBlciB9O1xuIiwiaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9DYW1lcmEuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2NhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IENhbWVyYSgpO1xuXG4vKipcbiAqIFRoaXMgaGVscHMgd2l0aCB2aXN1YWxpemluZyB3aGF0IGEgY2FtZXJhIGNvbnRhaW5zIGluIGl0cyBmcnVzdHVtLiBJdFxuICogdmlzdWFsaXplcyB0aGUgZnJ1c3R1bSBvZiBhIGNhbWVyYSB1c2luZyBhIGxpbmUgc2VnbWVudHMuXG4gKlxuICogQmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIFtsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbGlnaHRnbC5qcy9ibG9iL21hc3Rlci90ZXN0cy9zaGFkb3dtYXAuaHRtbH0uXG4gKlxuICogYENhbWVyYUhlbHBlcmAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBzY2VuZS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCA3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMCApO1xuICogY29uc3QgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2FtZXJhICk7XG4gKiBzY2VuZS5hZGQoIGhlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpbmVTZWdtZW50c1xuICovXG5jbGFzcyBDYW1lcmFIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFycm93IGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdG8gdmlzdWFsaXplLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIGNhbWVyYSApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgY29sb3JzID0gW107XG5cblx0XHRjb25zdCBwb2ludE1hcCA9IHt9O1xuXG5cdFx0Ly8gbmVhclxuXG5cdFx0YWRkTGluZSggJ24xJywgJ24yJyApO1xuXHRcdGFkZExpbmUoICduMicsICduNCcgKTtcblx0XHRhZGRMaW5lKCAnbjQnLCAnbjMnICk7XG5cdFx0YWRkTGluZSggJ24zJywgJ24xJyApO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRhZGRMaW5lKCAnZjEnLCAnZjInICk7XG5cdFx0YWRkTGluZSggJ2YyJywgJ2Y0JyApO1xuXHRcdGFkZExpbmUoICdmNCcsICdmMycgKTtcblx0XHRhZGRMaW5lKCAnZjMnLCAnZjEnICk7XG5cblx0XHQvLyBzaWRlc1xuXG5cdFx0YWRkTGluZSggJ24xJywgJ2YxJyApO1xuXHRcdGFkZExpbmUoICduMicsICdmMicgKTtcblx0XHRhZGRMaW5lKCAnbjMnLCAnZjMnICk7XG5cdFx0YWRkTGluZSggJ240JywgJ2Y0JyApO1xuXG5cdFx0Ly8gY29uZVxuXG5cdFx0YWRkTGluZSggJ3AnLCAnbjEnICk7XG5cdFx0YWRkTGluZSggJ3AnLCAnbjInICk7XG5cdFx0YWRkTGluZSggJ3AnLCAnbjMnICk7XG5cdFx0YWRkTGluZSggJ3AnLCAnbjQnICk7XG5cblx0XHQvLyB1cFxuXG5cdFx0YWRkTGluZSggJ3UxJywgJ3UyJyApO1xuXHRcdGFkZExpbmUoICd1MicsICd1MycgKTtcblx0XHRhZGRMaW5lKCAndTMnLCAndTEnICk7XG5cblx0XHQvLyB0YXJnZXRcblxuXHRcdGFkZExpbmUoICdjJywgJ3QnICk7XG5cdFx0YWRkTGluZSggJ3AnLCAnYycgKTtcblxuXHRcdC8vIGNyb3NzXG5cblx0XHRhZGRMaW5lKCAnY24xJywgJ2NuMicgKTtcblx0XHRhZGRMaW5lKCAnY24zJywgJ2NuNCcgKTtcblxuXHRcdGFkZExpbmUoICdjZjEnLCAnY2YyJyApO1xuXHRcdGFkZExpbmUoICdjZjMnLCAnY2Y0JyApO1xuXG5cdFx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiApIHtcblxuXHRcdFx0YWRkUG9pbnQoIGEgKTtcblx0XHRcdGFkZFBvaW50KCBiICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRQb2ludCggaWQgKSB7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRcdGNvbG9ycy5wdXNoKCAwLCAwLCAwICk7XG5cblx0XHRcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwb2ludE1hcFsgaWQgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBvaW50TWFwWyBpZCBdLnB1c2goICggdmVydGljZXMubGVuZ3RoIC8gMyApIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhSGVscGVyJztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW1lcmEgYmVpbmcgdmlzdWFsaXplZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtDYW1lcmF9XG5cdFx0ICovXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0aWYgKCB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ICkgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGNvbnRhaW5zIHRoZSBwb2ludHMgdXNlZCB0byB2aXN1YWxpemUgdGhlIGNhbWVyYS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLEFycmF5PG51bWJlcj4+fVxuXHRcdCAqL1xuXHRcdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHQvLyBjb2xvcnNcblxuXHRcdGNvbnN0IGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvciggMHhmZmFhMDAgKTtcblx0XHRjb25zdCBjb2xvckNvbmUgPSBuZXcgQ29sb3IoIDB4ZmYwMDAwICk7XG5cdFx0Y29uc3QgY29sb3JVcCA9IG5ldyBDb2xvciggMHgwMGFhZmYgKTtcblx0XHRjb25zdCBjb2xvclRhcmdldCA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblx0XHRjb25zdCBjb2xvckNyb3NzID0gbmV3IENvbG9yKCAweDMzMzMzMyApO1xuXG5cdFx0dGhpcy5zZXRDb2xvcnMoIGNvbG9yRnJ1c3R1bSwgY29sb3JDb25lLCBjb2xvclVwLCBjb2xvclRhcmdldCwgY29sb3JDcm9zcyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgY29sb3JzIG9mIHRoZSBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29sb3J9IGZydXN0dW0gLSBUaGUgZnJ1c3R1bSBsaW5lIGNvbG9yLlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjb25lIC0gVGhlIGNvbmUgbGluZSBjb2xvci5cblx0ICogQHBhcmFtIHtDb2xvcn0gdXAgLSBUaGUgdXAgbGluZSBjb2xvci5cblx0ICogQHBhcmFtIHtDb2xvcn0gdGFyZ2V0IC0gVGhlIHRhcmdldCBsaW5lIGNvbG9yLlxuXHQgKiBAcGFyYW0ge0NvbG9yfSBjcm9zcyAtIFRoZSBjcm9zcyBsaW5lIGNvbG9yLlxuXHQgKi9cblx0c2V0Q29sb3JzKCBmcnVzdHVtLCBjb25lLCB1cCwgdGFyZ2V0LCBjcm9zcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGNvbnN0IGNvbG9yQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4xLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMiwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIG40XG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgbjNcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA3LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBuMVxuXG5cdFx0Ly8gZmFyXG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDgsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA5LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYxLCBmMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxMSwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBmMiwgZjRcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDEyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjQsIGYzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE1LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIGYzLCBmMVxuXG5cdFx0Ly8gc2lkZXNcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxNywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuMSwgZjFcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE4LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTksIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIGYyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDIxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBmM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjIsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyMywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuNCwgZjRcblxuXHRcdC8vIGNvbmVcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjQsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMVxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjYsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNywgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMlxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjgsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyOSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuM1xuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzAsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuNFxuXG5cdFx0Ly8gdXBcblxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzIsIHVwLnIsIHVwLmcsIHVwLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMywgdXAuciwgdXAuZywgdXAuYiApOyAvLyB1MSwgdTJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM0LCB1cC5yLCB1cC5nLCB1cC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzUsIHVwLnIsIHVwLmcsIHVwLmIgKTsgLy8gdTIsIHUzXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzNiwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM3LCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUzLCB1MVxuXG5cdFx0Ly8gdGFyZ2V0XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM4LCB0YXJnZXQuciwgdGFyZ2V0LmcsIHRhcmdldC5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzksIHRhcmdldC5yLCB0YXJnZXQuZywgdGFyZ2V0LmIgKTsgLy8gYywgdFxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDAsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MSwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyAvLyBwLCBjXG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MiwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQzLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMSwgY24yXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0NCwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ1LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMywgY240XG5cblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ2LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDcsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YxLCBjZjJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ4LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDksIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YzLCBjZjRcblxuXHRcdGNvbG9yQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhlbHBlciBiYXNlZCBvbiB0aGUgcHJvamVjdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS5cblx0ICovXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cblx0XHRjb25zdCB3ID0gMSwgaCA9IDE7XG5cblx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4IGludmVyc2Vcblx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG5cdFx0X2NhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApO1xuXG5cdFx0Ly8gQWRqdXN0IHogdmFsdWVzIGJhc2VkIG9uIGNvb3JkaW5hdGUgc3lzdGVtXG5cdFx0Y29uc3QgbmVhclogPSB0aGlzLmNhbWVyYS5jb29yZGluYXRlU3lzdGVtID09PSBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gPyAtIDEgOiAwO1xuXG5cdFx0Ly8gY2VudGVyIC8gdGFyZ2V0XG5cdFx0c2V0UG9pbnQoICdjJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAndCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgMCwgMSApO1xuXG5cdFx0Ly8gbmVhclxuXG5cdFx0c2V0UG9pbnQoICduMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCAtIGgsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICduMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLSBoLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAnbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgaCwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ240JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCBuZWFyWiApO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRzZXRQb2ludCggJ2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgaCwgMSApO1xuXHRcdHNldFBvaW50KCAnZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIDEgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRzZXRQb2ludCggJ3UxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3ICogMC43LCBoICogMS4xLCBuZWFyWiApO1xuXHRcdHNldFBvaW50KCAndTInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdyAqIDAuNywgaCAqIDEuMSwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ3UzJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCBoICogMiwgbmVhclogKTtcblxuXHRcdC8vIGNyb3NzXG5cblx0XHRzZXRQb2ludCggJ2NmMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCAwLCAxICk7XG5cdFx0c2V0UG9pbnQoICdjZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIDEgKTtcblx0XHRzZXRQb2ludCggJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoICdjZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGgsIDEgKTtcblxuXHRcdHNldFBvaW50KCAnY24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIDAsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICdjbjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIG5lYXJaICk7XG5cdFx0c2V0UG9pbnQoICdjbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIC0gaCwgbmVhclogKTtcblx0XHRzZXRQb2ludCggJ2NuNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgbmVhclogKTtcblxuXHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEZyZWVzIHRoZSBHUFUtcmVsYXRlZCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpc1xuXHQgKiBtZXRob2Qgd2hlbmV2ZXIgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgdXNlZCBpbiB5b3VyIGFwcC5cblx0ICovXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuXG5mdW5jdGlvbiBzZXRQb2ludCggcG9pbnQsIHBvaW50TWFwLCBnZW9tZXRyeSwgY2FtZXJhLCB4LCB5LCB6ICkge1xuXG5cdF92ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHRjb25zdCBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuXHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwb3NpdGlvbi5zZXRYWVooIHBvaW50c1sgaSBdLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IENhbWVyYUhlbHBlciB9O1xuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4uL21hdGgvQm94My5qcyc7XG5pbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG4vKipcbiAqIEhlbHBlciBvYmplY3QgdG8gZ3JhcGhpY2FsbHkgc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveFxuICogYXJvdW5kIGFuIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3ggaXMgaGFuZGxlZCB3aXRoIHtAbGluayBCb3gzfSxcbiAqIHRoaXMgaXMganVzdCBhIHZpc3VhbCBoZWxwZXIgZm9yIGRlYnVnZ2luZy4gSXQgY2FuIGJlIGF1dG9tYXRpY2FsbHlcbiAqIHJlc2l6ZWQgd2l0aCB7QGxpbmsgQm94SGVscGVyI3VwZGF0ZX0gd2hlbiB0aGUgb2JqZWN0IGl0J3MgY3JlYXRlZCBmcm9tXG4gKiBpcyB0cmFuc2Zvcm1lZC4gTm90ZSB0aGF0IHRoZSBvYmplY3QgbXVzdCBoYXZlIGEgZ2VvbWV0cnkgZm9yIHRoaXMgdG8gd29yayxcbiAqIHNvIGl0IHdvbid0IHdvcmsgd2l0aCBzcHJpdGVzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoKTtcbiAqIGNvbnN0IG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBzcGhlcmUsIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggMHhmZjAwMDAgKSApO1xuICogY29uc3QgYm94ID0gbmV3IFRIUkVFLkJveEhlbHBlciggb2JqZWN0LCAweGZmZmYwMCApO1xuICogc2NlbmUuYWRkKCBib3ggKTtcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMaW5lU2VnbWVudHNcbiAqL1xuY2xhc3MgQm94SGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBib3ggaGVscGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBbb2JqZWN0XSAtIFRoZSAzRCBvYmplY3QgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveC5cblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSBbY29sb3I9MHhmZmZmMDBdIC0gVGhlIGJveCdzIGNvbG9yLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIG9iamVjdCwgY29sb3IgPSAweGZmZmYwMCApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgM0Qgb2JqZWN0IGJlaW5nIHZpc3VhbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0M0R9XG5cdFx0ICovXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dGhpcy50eXBlID0gJ0JveEhlbHBlcic7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBoZWxwZXIncyBnZW9tZXRyeSB0byBtYXRjaCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0LFxuXHQgKiBpbmNsdWRpbmcgYW55IGNoaWxkcmVuLlxuXHQgKi9cblx0dXBkYXRlKCkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfYm94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9ib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbWluID0gX2JveC5taW47XG5cdFx0Y29uc3QgbWF4ID0gX2JveC5tYXg7XG5cblx0XHQvKlxuXHRcdFx0NV9fX180XG5cdFx0MS9fX18wL3xcblx0XHR8IDZfX3xfN1xuXHRcdDIvX19fMy9cblxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0Ki9cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cblx0XHRhcnJheVsgMCBdID0gbWF4Lng7IGFycmF5WyAxIF0gPSBtYXgueTsgYXJyYXlbIDIgXSA9IG1heC56O1xuXHRcdGFycmF5WyAzIF0gPSBtaW4ueDsgYXJyYXlbIDQgXSA9IG1heC55OyBhcnJheVsgNSBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDYgXSA9IG1pbi54OyBhcnJheVsgNyBdID0gbWluLnk7IGFycmF5WyA4IF0gPSBtYXguejtcblx0XHRhcnJheVsgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XG5cdFx0YXJyYXlbIDEyIF0gPSBtYXgueDsgYXJyYXlbIDEzIF0gPSBtYXgueTsgYXJyYXlbIDE0IF0gPSBtaW4uejtcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xuXHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XG5cdFx0YXJyYXlbIDIxIF0gPSBtYXgueDsgYXJyYXlbIDIyIF0gPSBtaW4ueTsgYXJyYXlbIDIzIF0gPSBtaW4uejtcblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB3aXJlZnJhbWUgYm94IGZvciB0aGUgcGFzc2VkIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIDNEIG9iamVjdCB0byBjcmVhdGUgdGhlIGhlbHBlciBmb3IuXG5cdCAqIEByZXR1cm4ge0JveEhlbHBlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdHNldEZyb21PYmplY3QoIG9iamVjdCApIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0dGhpcy5vYmplY3QgPSBzb3VyY2Uub2JqZWN0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQm94SGVscGVyIH07XG4iLCJpbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIEEgaGVscGVyIG9iamVjdCB0byB2aXN1YWxpemUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEJveDN9LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuICogYm94LnNldEZyb21DZW50ZXJBbmRTaXplKCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMiwgMSwgMyApICk7XG4gKlxuICogY29uc3QgaGVscGVyID0gbmV3IFRIUkVFLkJveDNIZWxwZXIoIGJveCwgMHhmZmZmMDAgKTtcbiAqIHNjZW5lLmFkZCggaGVscGVyIClcbiAqIGBgYFxuICpcbiAqIEBhdWdtZW50cyBMaW5lU2VnbWVudHNcbiAqL1xuY2xhc3MgQm94M0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYm94MyBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm94M30gYm94IC0gVGhlIGJveCB0byB2aXN1YWxpemUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfENvbG9yfHN0cmluZ30gW2NvbG9yPTB4ZmZmZjAwXSAtIFRoZSBib3gncyBjb2xvci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCBib3gsIGNvbG9yID0gMHhmZmZmMDAgKSB7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xuXG5cdFx0Y29uc3QgcG9zaXRpb25zID0gWyAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDEsIC0gMSwgLSAxIF07XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYm94IGJlaW5nIHZpc3VhbGl6ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Qm94M31cblx0XHQgKi9cblx0XHR0aGlzLmJveCA9IGJveDtcblxuXHRcdHRoaXMudHlwZSA9ICdCb3gzSGVscGVyJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdGNvbnN0IGJveCA9IHRoaXMuYm94O1xuXG5cdFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG5cdFx0Ym94LmdldENlbnRlciggdGhpcy5wb3NpdGlvbiApO1xuXG5cdFx0Ym94LmdldFNpemUoIHRoaXMuc2NhbGUgKTtcblxuXHRcdHRoaXMuc2NhbGUubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJveDNIZWxwZXIgfTtcbiIsImltcG9ydCB7IExpbmUgfSBmcm9tICcuLi9vYmplY3RzL0xpbmUuanMnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcblxuLyoqXG4gKiBBIGhlbHBlciBvYmplY3QgdG8gdmlzdWFsaXplIGFuIGluc3RhbmNlIG9mIHtAbGluayBQbGFuZX0uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBsYW5lID0gbmV3IFRIUkVFLlBsYW5lKCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMC4yICksIDMgKTtcbiAqIGNvbnN0IGhlbHBlciA9IG5ldyBUSFJFRS5QbGFuZUhlbHBlciggcGxhbmUsIDEsIDB4ZmZmZjAwICk7XG4gKiBzY2VuZS5hZGQoIGhlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpbmVcbiAqL1xuY2xhc3MgUGxhbmVIZWxwZXIgZXh0ZW5kcyBMaW5lIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwbGFuZSBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIC0gVGhlIHBsYW5lIHRvIGJlIHZpc3VhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSAtIFRoZSBzaWRlIGxlbmd0aCBvZiBwbGFuZSBoZWxwZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfENvbG9yfHN0cmluZ30gW2hleD0weGZmZmYwMF0gLSBUaGUgaGVscGVyJ3MgY29sb3IuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggcGxhbmUsIHNpemUgPSAxLCBoZXggPSAweGZmZmYwMCApIHtcblxuXHRcdGNvbnN0IGNvbG9yID0gaGV4O1xuXG5cdFx0Y29uc3QgcG9zaXRpb25zID0gWyAxLCAtIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIC0gMSwgMCwgMSwgMSwgMCBdO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUhlbHBlcic7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGxhbmUgYmVpbmcgdmlzdWFsaXplZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtQbGFuZX1cblx0XHQgKi9cblx0XHR0aGlzLnBsYW5lID0gcGxhbmU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2lkZSBsZW5ndGggb2YgcGxhbmUgaGVscGVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uczIgPSBbIDEsIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAtIDEsIDAgXTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMyLCAzICkgKTtcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApICk7XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdHRoaXMucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHR0aGlzLnNjYWxlLnNldCggMC41ICogdGhpcy5zaXplLCAwLjUgKiB0aGlzLnNpemUsIDEgKTtcblxuXHRcdHRoaXMubG9va0F0KCB0aGlzLnBsYW5lLm5vcm1hbCApO1xuXG5cdFx0dGhpcy50cmFuc2xhdGVaKCAtIHRoaXMucGxhbmUuY29uc3RhbnQgKTtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgaGVscGVyIHRvIG1hdGNoIHRoZSBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIG9mIHRoZVxuXHQgKiBsaWdodCBiZWluZyB2aXN1YWxpemVkLlxuXHQgKi9cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUGxhbmVIZWxwZXIgfTtcbiIsImltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcbmltcG9ydCB7IENvbmVHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvQ29uZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7IE1lc2hCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzJztcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL01lc2guanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4uL29iamVjdHMvTGluZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY29uc3QgX2F4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5sZXQgX2xpbmVHZW9tZXRyeSwgX2NvbmVHZW9tZXRyeTtcblxuLyoqXG4gKiBBbiAzRCBhcnJvdyBvYmplY3QgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAyLCAwICk7XG4gKlxuICogLy9ub3JtYWxpemUgdGhlIGRpcmVjdGlvbiB2ZWN0b3IgKGNvbnZlcnQgdG8gdmVjdG9yIG9mIGxlbmd0aCAxKVxuICogZGlyLm5vcm1hbGl6ZSgpO1xuICpcbiAqIGNvbnN0IG9yaWdpbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG4gKiBjb25zdCBsZW5ndGggPSAxO1xuICogY29uc3QgaGV4ID0gMHhmZmZmMDA7XG4gKlxuICogY29uc3QgYXJyb3dIZWxwZXIgPSBuZXcgVEhSRUUuQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGhleCApO1xuICogc2NlbmUuYWRkKCBhcnJvd0hlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIEFycm93SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFycm93IGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBbZGlyPSgwLCAwLCAxKV0gLSBUaGUgKG5vcm1hbGl6ZWQpIGRpcmVjdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW29yaWdpbj0oMCwgMCwgMCldIC0gUG9pbnQgYXQgd2hpY2ggdGhlIGFycm93IHN0YXJ0cy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gLSBMZW5ndGggb2YgdGhlIGFycm93IGluIHdvcmxkIHVuaXRzLlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8Q29sb3J8c3RyaW5nKX0gW2NvbG9yPTB4ZmZmZjAwXSAtIENvbG9yIG9mIHRoZSBhcnJvdy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWFkTGVuZ3RoPWxlbmd0aCowLjJdIC0gVGhlIGxlbmd0aCBvZiB0aGUgaGVhZCBvZiB0aGUgYXJyb3cuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVhZFdpZHRoPWhlYWRMZW5ndGgqMC4yXSAtIFRoZSB3aWR0aCBvZiB0aGUgaGVhZCBvZiB0aGUgYXJyb3cuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciggZGlyID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSwgb3JpZ2luID0gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKSwgbGVuZ3RoID0gMSwgY29sb3IgPSAweGZmZmYwMCwgaGVhZExlbmd0aCA9IGxlbmd0aCAqIDAuMiwgaGVhZFdpZHRoID0gaGVhZExlbmd0aCAqIDAuMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQXJyb3dIZWxwZXInO1xuXG5cdFx0aWYgKCBfbGluZUdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdF9saW5lR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdF9saW5lR2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAxLCAwIF0sIDMgKSApO1xuXG5cdFx0XHRfY29uZUdlb21ldHJ5ID0gbmV3IENvbmVHZW9tZXRyeSggMC41LCAxLCA1LCAxICk7XG5cdFx0XHRfY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGluZSBwYXJ0IG9mIHRoZSBhcnJvdyBoZWxwZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TGluZX1cblx0XHQgKi9cblx0XHR0aGlzLmxpbmUgPSBuZXcgTGluZSggX2xpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY29uZSBwYXJ0IG9mIHRoZSBhcnJvdyBoZWxwZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TWVzaH1cblx0XHQgKi9cblx0XHR0aGlzLmNvbmUgPSBuZXcgTWVzaCggX2NvbmVHZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgdG9uZU1hcHBlZDogZmFsc2UgfSApICk7XG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XG5cdFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtWZWN0b3IzfSBkaXIgLSBUaGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9yLlxuXHQgKi9cblx0c2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9heGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Y29uc3QgcmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIF9heGlzLCByYWRpYW5zICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgYXJyb3cgaW4gd29ybGQgdW5pdHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVhZExlbmd0aD1sZW5ndGgqMC4yXSAtIFRoZSBsZW5ndGggb2YgdGhlIGhlYWQgb2YgdGhlIGFycm93LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlYWRXaWR0aD1oZWFkTGVuZ3RoKjAuMl0gLSBUaGUgd2lkdGggb2YgdGhlIGhlYWQgb2YgdGhlIGFycm93LlxuXHQgKi9cblx0c2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIgKSB7XG5cblx0XHR0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBNYXRoLm1heCggMC4wMDAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTsgLy8gc2VlICMxNzQ1OFxuXHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cdFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdFx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSBjb2xvciAtIFRoZSBjb2xvciB0byBzZXQuXG5cdCAqL1xuXHRzZXRDb2xvciggY29sb3IgKSB7XG5cblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubGluZS5jb3B5KCBzb3VyY2UubGluZSApO1xuXHRcdHRoaXMuY29uZS5jb3B5KCBzb3VyY2UuY29uZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5saW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQXJyb3dIZWxwZXIgfTtcbiIsImltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcblxuLyoqXG4gKiBBbiBheGlzIG9iamVjdCB0byB2aXN1YWxpemUgdGhlIDMgYXhlcyBpbiBhIHNpbXBsZSB3YXkuXG4gKiBUaGUgWCBheGlzIGlzIHJlZC4gVGhlIFkgYXhpcyBpcyBncmVlbi4gVGhlIFogYXhpcyBpcyBibHVlLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBheGVzSGVscGVyID0gbmV3IFRIUkVFLkF4ZXNIZWxwZXIoIDUgKTtcbiAqIHNjZW5lLmFkZCggYXhlc0hlbHBlciApO1xuICogYGBgXG4gKlxuICogQGF1Z21lbnRzIExpbmVTZWdtZW50c1xuICovXG5jbGFzcyBBeGVzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBheGVzIGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIC0gU2l6ZSBvZiB0aGUgbGluZXMgcmVwcmVzZW50aW5nIHRoZSBheGVzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHNpemUgPSAxICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQwLCAwLCAwLFx0c2l6ZSwgMCwgMCxcblx0XHRcdDAsIDAsIDAsXHQwLCBzaXplLCAwLFxuXHRcdFx0MCwgMCwgMCxcdDAsIDAsIHNpemVcblx0XHRdO1xuXG5cdFx0Y29uc3QgY29sb3JzID0gW1xuXHRcdFx0MSwgMCwgMCxcdDEsIDAuNiwgMCxcblx0XHRcdDAsIDEsIDAsXHQwLjYsIDEsIDAsXG5cdFx0XHQwLCAwLCAxLFx0MCwgMC42LCAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcblxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBeGVzSGVscGVyJztcblxuXHR9XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIGNvbG9ycyBvZiB0aGUgYXhlcyBoZWxwZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfENvbG9yfHN0cmluZ30geEF4aXNDb2xvciAtIFRoZSBjb2xvciBmb3IgdGhlIHggYXhpcy5cblx0ICogQHBhcmFtIHtudW1iZXJ8Q29sb3J8c3RyaW5nfSB5QXhpc0NvbG9yIC0gVGhlIGNvbG9yIGZvciB0aGUgeSBheGlzLlxuXHQgKiBAcGFyYW0ge251bWJlcnxDb2xvcnxzdHJpbmd9IHpBeGlzQ29sb3IgLSBUaGUgY29sb3IgZm9yIHRoZSB6IGF4aXMuXG5cdCAqIEByZXR1cm4ge0F4ZXNIZWxwZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgYXhlcyBoZWxwZXIuXG5cdCAqL1xuXHRzZXRDb2xvcnMoIHhBeGlzQ29sb3IsIHlBeGlzQ29sb3IsIHpBeGlzQ29sb3IgKSB7XG5cblx0XHRjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdGNvbnN0IGFycmF5ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuXG5cdFx0Y29sb3Iuc2V0KCB4QXhpc0NvbG9yICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDAgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMyApO1xuXG5cdFx0Y29sb3Iuc2V0KCB5QXhpc0NvbG9yICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDYgKTtcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgOSApO1xuXG5cdFx0Y29sb3Iuc2V0KCB6QXhpc0NvbG9yICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDEyICk7XG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDE1ICk7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGcmVlcyB0aGUgR1BVLXJlbGF0ZWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXNcblx0ICogbWV0aG9kIHdoZW5ldmVyIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzZWQgaW4geW91ciBhcHAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQXhlc0hlbHBlciB9O1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGguanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuL1NoYXBlLmpzJztcbmltcG9ydCB7IFNoYXBlVXRpbHMgfSBmcm9tICcuLi9TaGFwZVV0aWxzLmpzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY29udmVydCBhIHNlcmllcyBvZiBwYXRocyB0byBhbiBhcnJheSBvZlxuICogc2hhcGVzLiBJdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBpbiBjb250ZXh0IG9mIGZvbnRzIGFuZCBTVkcuXG4gKi9cbmNsYXNzIFNoYXBlUGF0aCB7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2hhcGUgcGF0aC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY29sb3Igb2YgdGhlIHNoYXBlLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0NvbG9yfVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwYXRocyB0aGF0IGhhdmUgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoaXMgc2hhcGUuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7QXJyYXk8UGF0aD59XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3ViUGF0aHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHBhdGggdGhhdCBpcyBiZWluZyBnZW5lcmF0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7P1BhdGh9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBwYXRoIGFuZCBtb3ZlcyBpdCBjdXJyZW50IHBvaW50IHRvIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHtTaGFwZVBhdGh9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc2hhcGUgcGF0aC5cblx0ICovXG5cdG1vdmVUbyggeCwgeSApIHtcblxuXHRcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdHRoaXMuc3ViUGF0aHMucHVzaCggdGhpcy5jdXJyZW50UGF0aCApO1xuXHRcdHRoaXMuY3VycmVudFBhdGgubW92ZVRvKCB4LCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIExpbmVDdXJ2ZX0gdG8gdGhlIHBhdGggYnkgY29ubmVjdGluZ1xuXHQgKiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cblx0ICogQHJldHVybiB7U2hhcGVQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHNoYXBlIHBhdGguXG5cdCAqL1xuXHRsaW5lVG8oIHgsIHkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIHtAbGluayBRdWFkcmF0aWNCZXppZXJDdXJ2ZX0gdG8gdGhlIHBhdGggYnkgY29ubmVjdGluZ1xuXHQgKiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRoZSBnaXZlbiBvbmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhQ1B4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cblx0ICogQHJldHVybiB7U2hhcGVQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHNoYXBlIHBhdGguXG5cdCAqL1xuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIHtAbGluayBDdWJpY0JlemllckN1cnZlfSB0byB0aGUgcGF0aCBieSBjb25uZWN0aW5nXG5cdCAqIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdGhlIGdpdmVuIG9uZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDF4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGFDUDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhQ1AyeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYVggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhWSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cblx0ICogQHJldHVybiB7U2hhcGVQYXRofSBBIHJlZmVyZW5jZSB0byB0aGlzIHNoYXBlIHBhdGguXG5cdCAqL1xuXHRiZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5iZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFNwbGluZUN1cnZlfSB0byB0aGUgcGF0aCBieSBjb25uZWN0aW5nXG5cdCAqIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgcG9pbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PFZlY3RvcjI+fSBwdHMgLSBBbiBhcnJheSBvZiBwb2ludHMgaW4gMkQgc3BhY2UuXG5cdCAqIEByZXR1cm4ge1NoYXBlUGF0aH0gQSByZWZlcmVuY2UgdG8gdGhpcyBzaGFwZSBwYXRoLlxuXHQgKi9cblx0c3BsaW5lVGhydSggcHRzICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5zcGxpbmVUaHJ1KCBwdHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIHBhdGhzIGludG8gYW4gYXJyYXkgb2Ygc2hhcGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ0NXIC0gQnkgZGVmYXVsdCBzb2xpZCBzaGFwZXMgYXJlICBkZWZpbmVkIGNsb2Nrd2lzZSAoQ1cpIGFuZCBob2xlcyBhcmUgZGVmaW5lZCBjb3VudGVyY2xvY2t3aXNlIChDQ1cpLlxuXHQgKiBJZiB0aGlzIGZsYWcgaXMgc2V0IHRvIGB0cnVlYCwgdGhlbiB0aG9zZSBhcmUgZmxpcHBlZC5cblx0ICogQHJldHVybiB7QXJyYXk8U2hhcGU+fSBBbiBhcnJheSBvZiBzaGFwZXMuXG5cdCAqL1xuXHR0b1NoYXBlcyggaXNDQ1cgKSB7XG5cblx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cblx0XHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuXHRcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcblxuXHRcdFx0Y29uc3QgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cblx0XHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG5cdFx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG5cdFx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG5cdFx0XHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuXHRcdFx0bGV0IGluc2lkZSA9IGZhbHNlO1xuXHRcdFx0Zm9yICggbGV0IHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcblxuXHRcdFx0XHRsZXQgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBwIF07XG5cdFx0XHRcdGxldCBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cblx0XHRcdFx0bGV0IGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuXHRcdFx0XHRsZXQgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxuXHRcdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcblxuXHRcdFx0XHRcdFx0ZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuXHRcdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaW5QdC54ID09PSBlZGdlTG93UHQueCApXHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cblx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG5cdFx0XHRcdFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXG5cdFx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG5cdFx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuXHRcdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG5cdFx0XHRcdFx0Ly8gY29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVyblx0aW5zaWRlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXG5cdFx0Y29uc3Qgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xuXHRcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG5cdFx0bGV0IHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZTtcblx0XHRjb25zdCBzaGFwZXMgPSBbXTtcblxuXHRcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcblx0XHRcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdH1cblxuXHRcdGxldCBob2xlc0ZpcnN0ID0gISBpc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xuXHRcdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG5cdFx0Y29uc3QgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuXHRcdGNvbnN0IG5ld1NoYXBlcyA9IFtdO1xuXHRcdGxldCBuZXdTaGFwZUhvbGVzID0gW107XG5cdFx0bGV0IG1haW5JZHggPSAwO1xuXHRcdGxldCB0bXBQb2ludHM7XG5cblx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcblx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuXHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xuXHRcdFx0c29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcblxuXHRcdFx0aWYgKCBzb2xpZCApIHtcblxuXHRcdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XG5cblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB7IHM6IG5ldyBTaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcblx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0bGV0IGFtYmlndW91cyA9IGZhbHNlO1xuXHRcdFx0bGV0IHRvQ2hhbmdlID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG5cblx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hvID0gbmV3U2hhcGVIb2xlc1sgc0lkeCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBobyA9IHNob1sgaElkeCBdO1xuXHRcdFx0XHRcdGxldCBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlICsrO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgczJJZHggXS5wdXNoKCBobyApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRhbWJpZ3VvdXMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cblx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRvQ2hhbmdlID4gMCAmJiBhbWJpZ3VvdXMgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsZXQgdG1wSG9sZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XG5cdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG5cdFx0cmV0dXJuIHNoYXBlcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBTaGFwZVBhdGggfTtcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjb250cm9scy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyBFdmVudERpc3BhdGNoZXJcbiAqL1xuY2xhc3MgQ29udHJvbHMgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnRyb2xzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgaXMgbWFuYWdlZCBieSB0aGUgY29udHJvbHMuXG5cdCAqIEBwYXJhbSB7P0hUTUxET01FbGVtZW50fSBkb21FbGVtZW50IC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGZvciBldmVudCBsaXN0ZW5lcnMuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCBkb21FbGVtZW50ID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgaXMgbWFuYWdlZCBieSB0aGUgY29udHJvbHMuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7T2JqZWN0M0R9XG5cdFx0ICovXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgSFRNTCBlbGVtZW50IHVzZWQgZm9yIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHs/SFRNTERPTUVsZW1lbnR9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBjb250cm9scyByZXNwb25kcyB0byB1c2VyIGlucHV0IG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb250cm9scy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHR0aGlzLnN0YXRlID0gLSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBvYmplY3QgZGVmaW5lcyB0aGUga2V5Ym9hcmQgaW5wdXQgb2YgdGhlIGNvbnRyb2xzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmtleXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgb2JqZWN0IGRlZmluZXMgd2hhdCB0eXBlIG9mIGFjdGlvbnMgYXJlIGFzc2lnbmVkIHRvIHRoZSBhdmFpbGFibGUgbW91c2UgYnV0dG9ucy5cblx0XHQgKiBJdCBkZXBlbmRzIG9uIHRoZSBjb250cm9sIGltcGxlbWVudGF0aW9uIHdoYXQga2luZCBvZiBtb3VzZSBidXR0b25zIGFuZCBhY3Rpb25zIGFyZSBzdXBwb3J0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7e0xFRlQ6ID9udW1iZXIsIE1JRERMRTogP251bWJlciwgUklHSFQ6ID9udW1iZXJ9fVxuXHRcdCAqL1xuXHRcdHRoaXMubW91c2VCdXR0b25zID0geyBMRUZUOiBudWxsLCBNSURETEU6IG51bGwsIFJJR0hUOiBudWxsIH07XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG9iamVjdCBkZWZpbmVzIHdoYXQgdHlwZSBvZiBhY3Rpb25zIGFyZSBhc3NpZ25lZCB0byB3aGF0IGtpbmQgb2YgdG91Y2ggaW50ZXJhY3Rpb24uXG5cdFx0ICogSXQgZGVwZW5kcyBvbiB0aGUgY29udHJvbCBpbXBsZW1lbnRhdGlvbiB3aGF0IGtpbmQgb2YgdG91Y2ggaW50ZXJhY3Rpb24gYW5kIGFjdGlvbnMgYXJlIHN1cHBvcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHt7T05FOiA/bnVtYmVyLCBUV086ID9udW1iZXJ9fVxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hlcyA9IHsgT05FOiBudWxsLCBUV086IG51bGwgfTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIHRoZSBjb250cm9scyB0byB0aGUgRE9NLiBUaGlzIG1ldGhvZCBoYXMgc28gY2FsbGVkIFwic2lkZSBlZmZlY3RzXCIgc2luY2Vcblx0ICogaXQgYWRkcyB0aGUgbW9kdWxlJ3MgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET00uXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTERPTUVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgRE9NIGVsZW1lbnQgdG8gY29ubmVjdCB0by5cblx0ICovXG5cdGNvbm5lY3QoIGVsZW1lbnQgKSB7XG5cblx0XHRpZiAoIGVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29udHJvbHM6IGNvbm5lY3QoKSBub3cgcmVxdWlyZXMgYW4gZWxlbWVudC4nICk7IC8vIEBkZXByZWNhdGVkLCB0aGUgd2FybmluZyBjYW4gYmUgcmVtb3ZlZCB3aXRoIHIxODVcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kb21FbGVtZW50ICE9PSBudWxsICkgdGhpcy5kaXNjb25uZWN0KCk7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuXG5cdH1cblxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIGNvbnRyb2xzIGZyb20gdGhlIERPTS5cblx0ICovXG5cdGRpc2Nvbm5lY3QoKSB7fVxuXG5cdC8qKlxuXHQgKiBDYWxsIHRoaXMgbWV0aG9kIGlmIHlvdSBubyBsb25nZXIgd2FudCB1c2UgdG8gdGhlIGNvbnRyb2xzLiBJdCBmcmVlcyBhbGwgaW50ZXJuYWxcblx0ICogcmVzb3VyY2VzIGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG5cdCAqL1xuXHRkaXNwb3NlKCkge31cblxuXHQvKipcblx0ICogQ29udHJvbHMgc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCBpZiB0aGV5IGhhdmUgdG8gdXBkYXRlIHRoZWlyIGludGVybmFsIHN0YXRlXG5cdCAqIHBlciBzaW11bGF0aW9uIHN0ZXAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGFdIC0gVGhlIHRpbWUgZGVsdGEgaW4gc2Vjb25kcy5cblx0ICovXG5cdHVwZGF0ZSggLyogZGVsdGEgKi8gKSB7fVxuXG59XG5cbmV4cG9ydCB7IENvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyBBbHBoYUZvcm1hdCwgUmVkRm9ybWF0LCBSZWRJbnRlZ2VyRm9ybWF0LCBSR0Zvcm1hdCwgUkdJbnRlZ2VyRm9ybWF0LCBSR0JGb3JtYXQsIFJHQkFGb3JtYXQsIFJHQkFJbnRlZ2VyRm9ybWF0LCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDFfRm9ybWF0LCBSR0JBX1MzVENfRFhUM19Gb3JtYXQsIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCwgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCwgUkdCX0VUQzFfRm9ybWF0LCBSR0JfRVRDMl9Gb3JtYXQsIFJHQkFfRVRDMl9FQUNfRm9ybWF0LCBSR0JBX0FTVENfNHg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDVfRm9ybWF0LCBSR0JBX0FTVENfNng1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDVfRm9ybWF0LCBSR0JBX0FTVENfOHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDZfRm9ybWF0LCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQsIFJHQkFfQlBUQ19Gb3JtYXQsIFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQsIFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdCwgUkVEX1JHVEMxX0Zvcm1hdCwgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQsIFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQsIFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlLCBCeXRlVHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIFNob3J0VHlwZSwgSGFsZkZsb2F0VHlwZSwgVW5zaWduZWRTaG9ydDQ0NDRUeXBlLCBVbnNpZ25lZFNob3J0NTU1MVR5cGUsIFVuc2lnbmVkSW50VHlwZSwgSW50VHlwZSwgRmxvYXRUeXBlLCBVbnNpZ25lZEludDU5OTlUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBTY2FsZXMgdGhlIHRleHR1cmUgYXMgbGFyZ2UgYXMgcG9zc2libGUgd2l0aGluIGl0cyBzdXJmYWNlIHdpdGhvdXQgY3JvcHBpbmdcbiAqIG9yIHN0cmV0Y2hpbmcgdGhlIHRleHR1cmUuIFRoZSBtZXRob2QgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8gb2ZcbiAqIHRoZSB0ZXh0dXJlLiBBa2luIHRvIENTUyBgb2JqZWN0LWZpdDogY29udGFpbmBcbiAqXG4gKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgLSBUaGUgdGV4dHVyZSdzIGFzcGVjdCByYXRpby5cbiAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB1cGRhdGVkIHRleHR1cmUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW4oIHRleHR1cmUsIGFzcGVjdCApIHtcblxuXHRjb25zdCBpbWFnZUFzcGVjdCA9ICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLndpZHRoICkgPyB0ZXh0dXJlLmltYWdlLndpZHRoIC8gdGV4dHVyZS5pbWFnZS5oZWlnaHQgOiAxO1xuXG5cdGlmICggaW1hZ2VBc3BlY3QgPiBhc3BlY3QgKSB7XG5cblx0XHR0ZXh0dXJlLnJlcGVhdC54ID0gMTtcblx0XHR0ZXh0dXJlLnJlcGVhdC55ID0gaW1hZ2VBc3BlY3QgLyBhc3BlY3Q7XG5cblx0XHR0ZXh0dXJlLm9mZnNldC54ID0gMDtcblx0XHR0ZXh0dXJlLm9mZnNldC55ID0gKCAxIC0gdGV4dHVyZS5yZXBlYXQueSApIC8gMjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGV4dHVyZS5yZXBlYXQueCA9IGFzcGVjdCAvIGltYWdlQXNwZWN0O1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSAxO1xuXG5cdFx0dGV4dHVyZS5vZmZzZXQueCA9ICggMSAtIHRleHR1cmUucmVwZWF0LnggKSAvIDI7XG5cdFx0dGV4dHVyZS5vZmZzZXQueSA9IDA7XG5cblx0fVxuXG5cdHJldHVybiB0ZXh0dXJlO1xuXG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSB0ZXh0dXJlIHRvIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBzaXplIHRvIGZpbGwgdGhlIHN1cmZhY2UsIGxlYXZpbmdcbiAqIG5vIGVtcHR5IHNwYWNlLiBUaGUgbWV0aG9kIHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvIG9mIHRoZSB0ZXh0dXJlLlxuICogQWtpbiB0byBDU1MgYG9iamVjdC1maXQ6IGNvdmVyYC5cbiAqXG4gKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgLSBUaGUgdGV4dHVyZSdzIGFzcGVjdCByYXRpby5cbiAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB1cGRhdGVkIHRleHR1cmUuXG4gKi9cbmZ1bmN0aW9uIGNvdmVyKCB0ZXh0dXJlLCBhc3BlY3QgKSB7XG5cblx0Y29uc3QgaW1hZ2VBc3BlY3QgPSAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS53aWR0aCApID8gdGV4dHVyZS5pbWFnZS53aWR0aCAvIHRleHR1cmUuaW1hZ2UuaGVpZ2h0IDogMTtcblxuXHRpZiAoIGltYWdlQXNwZWN0ID4gYXNwZWN0ICkge1xuXG5cdFx0dGV4dHVyZS5yZXBlYXQueCA9IGFzcGVjdCAvIGltYWdlQXNwZWN0O1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSAxO1xuXG5cdFx0dGV4dHVyZS5vZmZzZXQueCA9ICggMSAtIHRleHR1cmUucmVwZWF0LnggKSAvIDI7XG5cdFx0dGV4dHVyZS5vZmZzZXQueSA9IDA7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRleHR1cmUucmVwZWF0LnggPSAxO1xuXHRcdHRleHR1cmUucmVwZWF0LnkgPSBpbWFnZUFzcGVjdCAvIGFzcGVjdDtcblxuXHRcdHRleHR1cmUub2Zmc2V0LnggPSAwO1xuXHRcdHRleHR1cmUub2Zmc2V0LnkgPSAoIDEgLSB0ZXh0dXJlLnJlcGVhdC55ICkgLyAyO1xuXG5cdH1cblxuXHRyZXR1cm4gdGV4dHVyZTtcblxufVxuXG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIHRleHR1cmUgdG8gdGhlIGRlZmF1bHQgdHJhbnNmb3JtYXRpb24uIEFraW4gdG8gQ1NTIGBvYmplY3QtZml0OiBmaWxsYC5cbiAqXG4gKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZS5cbiAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB1cGRhdGVkIHRleHR1cmUuXG4gKi9cbmZ1bmN0aW9uIGZpbGwoIHRleHR1cmUgKSB7XG5cblx0dGV4dHVyZS5yZXBlYXQueCA9IDE7XG5cdHRleHR1cmUucmVwZWF0LnkgPSAxO1xuXG5cdHRleHR1cmUub2Zmc2V0LnggPSAwO1xuXHR0ZXh0dXJlLm9mZnNldC55ID0gMDtcblxuXHRyZXR1cm4gdGV4dHVyZTtcblxufVxuXG4vKipcbiAqIERldGVybWluZXMgaG93IG1hbnkgYnl0ZXMgbXVzdCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdGV4dHVyZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgLSBUaGUgdGV4dHVyZSdzIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIC0gVGhlIHRleHR1cmUncyB0eXBlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYnl0ZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVMZW5ndGgoIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSApIHtcblxuXHRjb25zdCB0eXBlQnl0ZUxlbmd0aCA9IGdldFRleHR1cmVUeXBlQnl0ZUxlbmd0aCggdHlwZSApO1xuXG5cdHN3aXRjaCAoIGZvcm1hdCApIHtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvT3BlbkdMLVJlZnBhZ2VzL2VzMy4wL2h0bWwvZ2xUZXhJbWFnZTJELnhodG1sXG5cdFx0Y2FzZSBBbHBoYUZvcm1hdDpcblx0XHRcdHJldHVybiB3aWR0aCAqIGhlaWdodDtcblx0XHRjYXNlIFJlZEZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKSAvIHR5cGVCeXRlTGVuZ3RoLmNvbXBvbmVudHMgKSAqIHR5cGVCeXRlTGVuZ3RoLmJ5dGVMZW5ndGg7XG5cdFx0Y2FzZSBSZWRJbnRlZ2VyRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggKCB3aWR0aCAqIGhlaWdodCApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblx0XHRjYXNlIFJHRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggKCB3aWR0aCAqIGhlaWdodCAqIDIgKSAvIHR5cGVCeXRlTGVuZ3RoLmNvbXBvbmVudHMgKSAqIHR5cGVCeXRlTGVuZ3RoLmJ5dGVMZW5ndGg7XG5cdFx0Y2FzZSBSR0ludGVnZXJGb3JtYXQ6XG5cdFx0XHRyZXR1cm4gKCAoIHdpZHRoICogaGVpZ2h0ICogMiApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblx0XHRjYXNlIFJHQkZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKiAzICkgLyB0eXBlQnl0ZUxlbmd0aC5jb21wb25lbnRzICkgKiB0eXBlQnl0ZUxlbmd0aC5ieXRlTGVuZ3RoO1xuXHRcdGNhc2UgUkdCQUZvcm1hdDpcblx0XHRcdHJldHVybiAoICggd2lkdGggKiBoZWlnaHQgKiA0ICkgLyB0eXBlQnl0ZUxlbmd0aC5jb21wb25lbnRzICkgKiB0eXBlQnl0ZUxlbmd0aC5ieXRlTGVuZ3RoO1xuXHRcdGNhc2UgUkdCQUludGVnZXJGb3JtYXQ6XG5cdFx0XHRyZXR1cm4gKCAoIHdpZHRoICogaGVpZ2h0ICogNCApIC8gdHlwZUJ5dGVMZW5ndGguY29tcG9uZW50cyApICogdHlwZUJ5dGVMZW5ndGguYnl0ZUxlbmd0aDtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiL1xuXHRcdGNhc2UgUkdCX1MzVENfRFhUMV9Gb3JtYXQ6XG5cdFx0Y2FzZSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDMgKSAvIDQgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgMyApIC8gNCApICogODtcblx0XHRjYXNlIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDpcblx0XHRjYXNlIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiAxNjtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMvXG5cdFx0Y2FzZSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDpcblx0XHRjYXNlIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDpcblx0XHRcdHJldHVybiAoIE1hdGgubWF4KCB3aWR0aCwgMTYgKSAqIE1hdGgubWF4KCBoZWlnaHQsIDggKSApIC8gNDtcblx0XHRjYXNlIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0OlxuXHRcdGNhc2UgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0OlxuXHRcdFx0cmV0dXJuICggTWF0aC5tYXgoIHdpZHRoLCA4ICkgKiBNYXRoLm1heCggaGVpZ2h0LCA4ICkgKSAvIDI7XG5cblx0XHQvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Yy9cblx0XHRjYXNlIFJHQl9FVEMxX0Zvcm1hdDpcblx0XHRjYXNlIFJHQl9FVEMyX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiA4O1xuXHRcdGNhc2UgUkdCQV9FVEMyX0VBQ19Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDMgKSAvIDQgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgMyApIC8gNCApICogMTY7XG5cblx0XHQvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMvXG5cdFx0Y2FzZSBSR0JBX0FTVENfNHg0X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMyApIC8gNCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAzICkgLyA0ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ181eDRfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA0ICkgLyA1ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDMgKSAvIDQgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzV4NV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDQgKSAvIDUgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNCApIC8gNSApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfNng1X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgNSApIC8gNiApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA0ICkgLyA1ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ182eDZfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA1ICkgLyA2ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDUgKSAvIDYgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzh4NV9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDcgKSAvIDggKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNCApIC8gNSApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfOHg2X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgNyApIC8gOCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA1ICkgLyA2ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ184eDhfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA3ICkgLyA4ICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDcgKSAvIDggKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEweDVfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoICggd2lkdGggKyA5ICkgLyAxMCApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyA0ICkgLyA1ICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgOSApIC8gMTAgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgNSApIC8gNiApICogMTY7XG5cdFx0Y2FzZSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDkgKSAvIDEwICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDcgKSAvIDggKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgOSApIC8gMTAgKSAqIE1hdGguZmxvb3IoICggaGVpZ2h0ICsgOSApIC8gMTAgKSAqIDE2O1xuXHRcdGNhc2UgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCAoIHdpZHRoICsgMTEgKSAvIDEyICkgKiBNYXRoLmZsb29yKCAoIGhlaWdodCArIDkgKSAvIDEwICkgKiAxNjtcblx0XHRjYXNlIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggKCB3aWR0aCArIDExICkgLyAxMiApICogTWF0aC5mbG9vciggKCBoZWlnaHQgKyAxMSApIC8gMTIgKSAqIDE2O1xuXG5cdFx0Ly8gaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy93ZWJnbC9leHRlbnNpb25zL0VYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMvXG5cdFx0Y2FzZSBSR0JBX0JQVENfRm9ybWF0OlxuXHRcdGNhc2UgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdDpcblx0XHRjYXNlIFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdDpcblx0XHRcdHJldHVybiBNYXRoLmNlaWwoIHdpZHRoIC8gNCApICogTWF0aC5jZWlsKCBoZWlnaHQgLyA0ICkgKiAxNjtcblxuXHRcdC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvd2ViZ2wvZXh0ZW5zaW9ucy9FWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjL1xuXHRcdGNhc2UgUkVEX1JHVEMxX0Zvcm1hdDpcblx0XHRjYXNlIFNJR05FRF9SRURfUkdUQzFfRm9ybWF0OlxuXHRcdFx0cmV0dXJuIE1hdGguY2VpbCggd2lkdGggLyA0ICkgKiBNYXRoLmNlaWwoIGhlaWdodCAvIDQgKSAqIDg7XG5cdFx0Y2FzZSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0OlxuXHRcdGNhc2UgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQ6XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKCB3aWR0aCAvIDQgKSAqIE1hdGguY2VpbCggaGVpZ2h0IC8gNCApICogMTY7XG5cblx0fVxuXG5cdHRocm93IG5ldyBFcnJvcihcblx0XHRgVW5hYmxlIHRvIGRldGVybWluZSB0ZXh0dXJlIGJ5dGUgbGVuZ3RoIGZvciAke2Zvcm1hdH0gZm9ybWF0LmAsXG5cdCk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGVCeXRlTGVuZ3RoKCB0eXBlICkge1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG5cdFx0Y2FzZSBCeXRlVHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDEsIGNvbXBvbmVudHM6IDEgfTtcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnRUeXBlOlxuXHRcdGNhc2UgU2hvcnRUeXBlOlxuXHRcdGNhc2UgSGFsZkZsb2F0VHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDIsIGNvbXBvbmVudHM6IDEgfTtcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTpcblx0XHRjYXNlIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTpcblx0XHRcdHJldHVybiB7IGJ5dGVMZW5ndGg6IDIsIGNvbXBvbmVudHM6IDQgfTtcblx0XHRjYXNlIFVuc2lnbmVkSW50VHlwZTpcblx0XHRjYXNlIEludFR5cGU6XG5cdFx0Y2FzZSBGbG9hdFR5cGU6XG5cdFx0XHRyZXR1cm4geyBieXRlTGVuZ3RoOiA0LCBjb21wb25lbnRzOiAxIH07XG5cdFx0Y2FzZSBVbnNpZ25lZEludDU5OTlUeXBlOlxuXHRcdFx0cmV0dXJuIHsgYnl0ZUxlbmd0aDogNCwgY29tcG9uZW50czogMyB9O1xuXG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoIGBVbmtub3duIHRleHR1cmUgdHlwZSAke3R5cGV9LmAgKTtcblxufVxuXG4vKipcbiAqIEEgY2xhc3MgY29udGFpbmluZyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgdGV4dHVyZXMuXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0dXJlVXRpbHMge1xuXG5cdC8qKlxuXHQgKiBTY2FsZXMgdGhlIHRleHR1cmUgYXMgbGFyZ2UgYXMgcG9zc2libGUgd2l0aGluIGl0cyBzdXJmYWNlIHdpdGhvdXQgY3JvcHBpbmdcblx0ICogb3Igc3RyZXRjaGluZyB0aGUgdGV4dHVyZS4gVGhlIG1ldGhvZCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIGFzcGVjdCByYXRpbyBvZlxuXHQgKiB0aGUgdGV4dHVyZS4gQWtpbiB0byBDU1MgYG9iamVjdC1maXQ6IGNvbnRhaW5gXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IC0gVGhlIHRleHR1cmUncyBhc3BlY3QgcmF0aW8uXG5cdCAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB1cGRhdGVkIHRleHR1cmUuXG5cdCAqL1xuXHRzdGF0aWMgY29udGFpbiggdGV4dHVyZSwgYXNwZWN0ICkge1xuXG5cdFx0cmV0dXJuIGNvbnRhaW4oIHRleHR1cmUsIGFzcGVjdCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2NhbGVzIHRoZSB0ZXh0dXJlIHRvIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBzaXplIHRvIGZpbGwgdGhlIHN1cmZhY2UsIGxlYXZpbmdcblx0ICogbm8gZW1wdHkgc3BhY2UuIFRoZSBtZXRob2QgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8gb2YgdGhlIHRleHR1cmUuXG5cdCAqIEFraW4gdG8gQ1NTIGBvYmplY3QtZml0OiBjb3ZlcmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IC0gVGhlIHRleHR1cmUncyBhc3BlY3QgcmF0aW8uXG5cdCAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB1cGRhdGVkIHRleHR1cmUuXG5cdCAqL1xuXHRzdGF0aWMgY292ZXIoIHRleHR1cmUsIGFzcGVjdCApIHtcblxuXHRcdHJldHVybiBjb3ZlciggdGV4dHVyZSwgYXNwZWN0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmVzIHRoZSB0ZXh0dXJlIHRvIHRoZSBkZWZhdWx0IHRyYW5zZm9ybWF0aW9uLiBBa2luIHRvIENTUyBgb2JqZWN0LWZpdDogZmlsbGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlLlxuXHQgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdXBkYXRlZCB0ZXh0dXJlLlxuXHQgKi9cblx0c3RhdGljIGZpbGwoIHRleHR1cmUgKSB7XG5cblx0XHRyZXR1cm4gZmlsbCggdGV4dHVyZSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBob3cgbWFueSBieXRlcyBtdXN0IGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZm9ybWF0IC0gVGhlIHRleHR1cmUncyBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIC0gVGhlIHRleHR1cmUncyB0eXBlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBieXRlIGxlbmd0aC5cblx0ICovXG5cdHN0YXRpYyBnZXRCeXRlTGVuZ3RoKCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUgKSB7XG5cblx0XHRyZXR1cm4gZ2V0Qnl0ZUxlbmd0aCggd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IGNvbnRhaW4sIGNvdmVyLCBmaWxsLCBnZXRCeXRlTGVuZ3RoLCBUZXh0dXJlVXRpbHMgfTtcbiIsImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG5leHBvcnQgeyBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0xBcnJheVJlbmRlclRhcmdldC5qcyc7XG5leHBvcnQgeyBXZWJHTDNEUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0wzRFJlbmRlclRhcmdldC5qcyc7XG5leHBvcnQgeyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmVycy9XZWJHTEN1YmVSZW5kZXJUYXJnZXQuanMnO1xuZXhwb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qcyc7XG5leHBvcnQgeyBXZWJYUkNvbnRyb2xsZXIgfSBmcm9tICcuL3JlbmRlcmVycy93ZWJ4ci9XZWJYUkNvbnRyb2xsZXIuanMnO1xuZXhwb3J0IHsgRm9nRXhwMiB9IGZyb20gJy4vc2NlbmVzL0ZvZ0V4cDIuanMnO1xuZXhwb3J0IHsgRm9nIH0gZnJvbSAnLi9zY2VuZXMvRm9nLmpzJztcbmV4cG9ydCB7IFNjZW5lIH0gZnJvbSAnLi9zY2VuZXMvU2NlbmUuanMnO1xuZXhwb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi9vYmplY3RzL1Nwcml0ZS5qcyc7XG5leHBvcnQgeyBMT0QgfSBmcm9tICcuL29iamVjdHMvTE9ELmpzJztcbmV4cG9ydCB7IFNraW5uZWRNZXNoIH0gZnJvbSAnLi9vYmplY3RzL1NraW5uZWRNZXNoLmpzJztcbmV4cG9ydCB7IFNrZWxldG9uIH0gZnJvbSAnLi9vYmplY3RzL1NrZWxldG9uLmpzJztcbmV4cG9ydCB7IEJvbmUgfSBmcm9tICcuL29iamVjdHMvQm9uZS5qcyc7XG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9vYmplY3RzL01lc2guanMnO1xuZXhwb3J0IHsgSW5zdGFuY2VkTWVzaCB9IGZyb20gJy4vb2JqZWN0cy9JbnN0YW5jZWRNZXNoLmpzJztcbmV4cG9ydCB7IEJhdGNoZWRNZXNoIH0gZnJvbSAnLi9vYmplY3RzL0JhdGNoZWRNZXNoLmpzJztcbmV4cG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4vb2JqZWN0cy9MaW5lU2VnbWVudHMuanMnO1xuZXhwb3J0IHsgTGluZUxvb3AgfSBmcm9tICcuL29iamVjdHMvTGluZUxvb3AuanMnO1xuZXhwb3J0IHsgTGluZSB9IGZyb20gJy4vb2JqZWN0cy9MaW5lLmpzJztcbmV4cG9ydCB7IFBvaW50cyB9IGZyb20gJy4vb2JqZWN0cy9Qb2ludHMuanMnO1xuZXhwb3J0IHsgR3JvdXAgfSBmcm9tICcuL29iamVjdHMvR3JvdXAuanMnO1xuZXhwb3J0IHsgVmlkZW9UZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanMnO1xuZXhwb3J0IHsgVmlkZW9GcmFtZVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL1ZpZGVvRnJhbWVUZXh0dXJlLmpzJztcbmV4cG9ydCB7IEZyYW1lYnVmZmVyVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvRnJhbWVidWZmZXJUZXh0dXJlLmpzJztcbmV4cG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvU291cmNlLmpzJztcbmV4cG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qcyc7XG5leHBvcnQgeyBEYXRhQXJyYXlUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9EYXRhQXJyYXlUZXh0dXJlLmpzJztcbmV4cG9ydCB7IERhdGEzRFRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0RhdGEzRFRleHR1cmUuanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzJztcbmV4cG9ydCB7IENvbXByZXNzZWRBcnJheVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0NvbXByZXNzZWRBcnJheVRleHR1cmUuanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZEN1YmVUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9Db21wcmVzc2VkQ3ViZVRleHR1cmUuanMnO1xuZXhwb3J0IHsgQ3ViZVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzJztcbmV4cG9ydCB7IENhbnZhc1RleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0NhbnZhc1RleHR1cmUuanMnO1xuZXhwb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xuZXhwb3J0IHsgRGVwdGhBcnJheVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0RlcHRoQXJyYXlUZXh0dXJlLmpzJztcbmV4cG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9nZW9tZXRyaWVzL0dlb21ldHJpZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tYXRlcmlhbHMvTWF0ZXJpYWxzLmpzJztcbmV4cG9ydCB7IEFuaW1hdGlvbkxvYWRlciB9IGZyb20gJy4vbG9hZGVycy9BbmltYXRpb25Mb2FkZXIuanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIuanMnO1xuZXhwb3J0IHsgQ3ViZVRleHR1cmVMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanMnO1xuZXhwb3J0IHsgRGF0YVRleHR1cmVMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvRGF0YVRleHR1cmVMb2FkZXIuanMnO1xuZXhwb3J0IHsgVGV4dHVyZUxvYWRlciB9IGZyb20gJy4vbG9hZGVycy9UZXh0dXJlTG9hZGVyLmpzJztcbmV4cG9ydCB7IE9iamVjdExvYWRlciB9IGZyb20gJy4vbG9hZGVycy9PYmplY3RMb2FkZXIuanMnO1xuZXhwb3J0IHsgTWF0ZXJpYWxMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanMnO1xuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnlMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanMnO1xuZXhwb3J0IHsgRGVmYXVsdExvYWRpbmdNYW5hZ2VyLCBMb2FkaW5nTWFuYWdlciB9IGZyb20gJy4vbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qcyc7XG5leHBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJy4vbG9hZGVycy9JbWFnZUxvYWRlci5qcyc7XG5leHBvcnQgeyBJbWFnZUJpdG1hcExvYWRlciB9IGZyb20gJy4vbG9hZGVycy9JbWFnZUJpdG1hcExvYWRlci5qcyc7XG5leHBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXJzL0ZpbGVMb2FkZXIuanMnO1xuZXhwb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXJzL0xvYWRlci5qcyc7XG5leHBvcnQgeyBMb2FkZXJVdGlscyB9IGZyb20gJy4vbG9hZGVycy9Mb2FkZXJVdGlscy5qcyc7XG5leHBvcnQgeyBDYWNoZSB9IGZyb20gJy4vbG9hZGVycy9DYWNoZS5qcyc7XG5leHBvcnQgeyBBdWRpb0xvYWRlciB9IGZyb20gJy4vbG9hZGVycy9BdWRpb0xvYWRlci5qcyc7XG5leHBvcnQgeyBTcG90TGlnaHQgfSBmcm9tICcuL2xpZ2h0cy9TcG90TGlnaHQuanMnO1xuZXhwb3J0IHsgUG9pbnRMaWdodCB9IGZyb20gJy4vbGlnaHRzL1BvaW50TGlnaHQuanMnO1xuZXhwb3J0IHsgUmVjdEFyZWFMaWdodCB9IGZyb20gJy4vbGlnaHRzL1JlY3RBcmVhTGlnaHQuanMnO1xuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH0gZnJvbSAnLi9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzJztcbmV4cG9ydCB7IERpcmVjdGlvbmFsTGlnaHQgfSBmcm9tICcuL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzJztcbmV4cG9ydCB7IEFtYmllbnRMaWdodCB9IGZyb20gJy4vbGlnaHRzL0FtYmllbnRMaWdodC5qcyc7XG5leHBvcnQgeyBMaWdodCB9IGZyb20gJy4vbGlnaHRzL0xpZ2h0LmpzJztcbmV4cG9ydCB7IExpZ2h0UHJvYmUgfSBmcm9tICcuL2xpZ2h0cy9MaWdodFByb2JlLmpzJztcbmV4cG9ydCB7IFN0ZXJlb0NhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9TdGVyZW9DYW1lcmEuanMnO1xuZXhwb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xuZXhwb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnLi9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qcyc7XG5leHBvcnQgeyBDdWJlQ2FtZXJhIH0gZnJvbSAnLi9jYW1lcmFzL0N1YmVDYW1lcmEuanMnO1xuZXhwb3J0IHsgQXJyYXlDYW1lcmEgfSBmcm9tICcuL2NhbWVyYXMvQXJyYXlDYW1lcmEuanMnO1xuZXhwb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi9jYW1lcmFzL0NhbWVyYS5qcyc7XG5leHBvcnQgeyBBdWRpb0xpc3RlbmVyIH0gZnJvbSAnLi9hdWRpby9BdWRpb0xpc3RlbmVyLmpzJztcbmV4cG9ydCB7IFBvc2l0aW9uYWxBdWRpbyB9IGZyb20gJy4vYXVkaW8vUG9zaXRpb25hbEF1ZGlvLmpzJztcbmV4cG9ydCB7IEF1ZGlvQ29udGV4dCB9IGZyb20gJy4vYXVkaW8vQXVkaW9Db250ZXh0LmpzJztcbmV4cG9ydCB7IEF1ZGlvQW5hbHlzZXIgfSBmcm9tICcuL2F1ZGlvL0F1ZGlvQW5hbHlzZXIuanMnO1xuZXhwb3J0IHsgQXVkaW8gfSBmcm9tICcuL2F1ZGlvL0F1ZGlvLmpzJztcbmV4cG9ydCB7IFZlY3RvcktleWZyYW1lVHJhY2sgfSBmcm9tICcuL2FuaW1hdGlvbi90cmFja3MvVmVjdG9yS2V5ZnJhbWVUcmFjay5qcyc7XG5leHBvcnQgeyBTdHJpbmdLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi9hbmltYXRpb24vdHJhY2tzL1N0cmluZ0tleWZyYW1lVHJhY2suanMnO1xuZXhwb3J0IHsgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgfSBmcm9tICcuL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanMnO1xuZXhwb3J0IHsgTnVtYmVyS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL3RyYWNrcy9OdW1iZXJLZXlmcmFtZVRyYWNrLmpzJztcbmV4cG9ydCB7IENvbG9yS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL3RyYWNrcy9Db2xvcktleWZyYW1lVHJhY2suanMnO1xuZXhwb3J0IHsgQm9vbGVhbktleWZyYW1lVHJhY2sgfSBmcm9tICcuL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanMnO1xuZXhwb3J0IHsgUHJvcGVydHlNaXhlciB9IGZyb20gJy4vYW5pbWF0aW9uL1Byb3BlcnR5TWl4ZXIuanMnO1xuZXhwb3J0IHsgUHJvcGVydHlCaW5kaW5nIH0gZnJvbSAnLi9hbmltYXRpb24vUHJvcGVydHlCaW5kaW5nLmpzJztcbmV4cG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuL2FuaW1hdGlvbi9LZXlmcmFtZVRyYWNrLmpzJztcbmV4cG9ydCB7IEFuaW1hdGlvblV0aWxzIH0gZnJvbSAnLi9hbmltYXRpb24vQW5pbWF0aW9uVXRpbHMuanMnO1xuZXhwb3J0IHsgQW5pbWF0aW9uT2JqZWN0R3JvdXAgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRpb25PYmplY3RHcm91cC5qcyc7XG5leHBvcnQgeyBBbmltYXRpb25NaXhlciB9IGZyb20gJy4vYW5pbWF0aW9uL0FuaW1hdGlvbk1peGVyLmpzJztcbmV4cG9ydCB7IEFuaW1hdGlvbkNsaXAgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRpb25DbGlwLmpzJztcbmV4cG9ydCB7IEFuaW1hdGlvbkFjdGlvbiB9IGZyb20gJy4vYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvbi5qcyc7XG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldDNEIH0gZnJvbSAnLi9jb3JlL1JlbmRlclRhcmdldDNELmpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldEFycmF5IH0gZnJvbSAnLi9jb3JlL1JlbmRlclRhcmdldEFycmF5LmpzJztcbmV4cG9ydCB7IFVuaWZvcm0gfSBmcm9tICcuL2NvcmUvVW5pZm9ybS5qcyc7XG5leHBvcnQgeyBVbmlmb3Jtc0dyb3VwIH0gZnJvbSAnLi9jb3JlL1VuaWZvcm1zR3JvdXAuanMnO1xuZXhwb3J0IHsgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanMnO1xuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xuZXhwb3J0IHsgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuL2NvcmUvSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xuZXhwb3J0IHsgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XG5leHBvcnQgeyBHTEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vY29yZS9HTEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmV4cG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi9jb3JlL09iamVjdDNELmpzJztcbmV4cG9ydCB7IFJheWNhc3RlciB9IGZyb20gJy4vY29yZS9SYXljYXN0ZXIuanMnO1xuZXhwb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9jb3JlL0xheWVycy5qcyc7XG5leHBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcbmV4cG9ydCB7IENsb2NrIH0gZnJvbSAnLi9jb3JlL0Nsb2NrLmpzJztcbmV4cG9ydCB7IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCB9IGZyb20gJy4vbWF0aC9pbnRlcnBvbGFudHMvUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LmpzJztcbmV4cG9ydCB7IExpbmVhckludGVycG9sYW50IH0gZnJvbSAnLi9tYXRoL2ludGVycG9sYW50cy9MaW5lYXJJbnRlcnBvbGFudC5qcyc7XG5leHBvcnQgeyBEaXNjcmV0ZUludGVycG9sYW50IH0gZnJvbSAnLi9tYXRoL2ludGVycG9sYW50cy9EaXNjcmV0ZUludGVycG9sYW50LmpzJztcbmV4cG9ydCB7IEN1YmljSW50ZXJwb2xhbnQgfSBmcm9tICcuL21hdGgvaW50ZXJwb2xhbnRzL0N1YmljSW50ZXJwb2xhbnQuanMnO1xuZXhwb3J0IHsgSW50ZXJwb2xhbnQgfSBmcm9tICcuL21hdGgvSW50ZXJwb2xhbnQuanMnO1xuZXhwb3J0IHsgVHJpYW5nbGUgfSBmcm9tICcuL21hdGgvVHJpYW5nbGUuanMnO1xuZXhwb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnLi9tYXRoL01hdGhVdGlscy5qcyc7XG5leHBvcnQgeyBTcGhlcmljYWwgfSBmcm9tICcuL21hdGgvU3BoZXJpY2FsLmpzJztcbmV4cG9ydCB7IEN5bGluZHJpY2FsIH0gZnJvbSAnLi9tYXRoL0N5bGluZHJpY2FsLmpzJztcbmV4cG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9tYXRoL1BsYW5lLmpzJztcbmV4cG9ydCB7IEZydXN0dW0gfSBmcm9tICcuL21hdGgvRnJ1c3R1bS5qcyc7XG5leHBvcnQgeyBGcnVzdHVtQXJyYXkgfSBmcm9tICcuL21hdGgvRnJ1c3R1bUFycmF5LmpzJztcbmV4cG9ydCB7IFNwaGVyZSB9IGZyb20gJy4vbWF0aC9TcGhlcmUuanMnO1xuZXhwb3J0IHsgUmF5IH0gZnJvbSAnLi9tYXRoL1JheS5qcyc7XG5leHBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9tYXRoL01hdHJpeDQuanMnO1xuZXhwb3J0IHsgTWF0cml4MyB9IGZyb20gJy4vbWF0aC9NYXRyaXgzLmpzJztcbmV4cG9ydCB7IE1hdHJpeDIgfSBmcm9tICcuL21hdGgvTWF0cml4Mi5qcyc7XG5leHBvcnQgeyBCb3gzIH0gZnJvbSAnLi9tYXRoL0JveDMuanMnO1xuZXhwb3J0IHsgQm94MiB9IGZyb20gJy4vbWF0aC9Cb3gyLmpzJztcbmV4cG9ydCB7IExpbmUzIH0gZnJvbSAnLi9tYXRoL0xpbmUzLmpzJztcbmV4cG9ydCB7IEV1bGVyIH0gZnJvbSAnLi9tYXRoL0V1bGVyLmpzJztcbmV4cG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuL21hdGgvVmVjdG9yNC5qcyc7XG5leHBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9tYXRoL1ZlY3RvcjMuanMnO1xuZXhwb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4vbWF0aC9WZWN0b3IyLmpzJztcbmV4cG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL21hdGgvUXVhdGVybmlvbi5qcyc7XG5leHBvcnQgeyBDb2xvciB9IGZyb20gJy4vbWF0aC9Db2xvci5qcyc7XG5leHBvcnQgeyBDb2xvck1hbmFnZW1lbnQgfSBmcm9tICcuL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcbmV4cG9ydCB7IFNwaGVyaWNhbEhhcm1vbmljczMgfSBmcm9tICcuL21hdGgvU3BoZXJpY2FsSGFybW9uaWNzMy5qcyc7XG5leHBvcnQgeyBTcG90TGlnaHRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzJztcbmV4cG9ydCB7IFNrZWxldG9uSGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzJztcbmV4cG9ydCB7IFBvaW50TGlnaHRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qcyc7XG5leHBvcnQgeyBIZW1pc3BoZXJlTGlnaHRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzJztcbmV4cG9ydCB7IEdyaWRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvR3JpZEhlbHBlci5qcyc7XG5leHBvcnQgeyBQb2xhckdyaWRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvUG9sYXJHcmlkSGVscGVyLmpzJztcbmV4cG9ydCB7IERpcmVjdGlvbmFsTGlnaHRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qcyc7XG5leHBvcnQgeyBDYW1lcmFIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzJztcbmV4cG9ydCB7IEJveEhlbHBlciB9IGZyb20gJy4vaGVscGVycy9Cb3hIZWxwZXIuanMnO1xuZXhwb3J0IHsgQm94M0hlbHBlciB9IGZyb20gJy4vaGVscGVycy9Cb3gzSGVscGVyLmpzJztcbmV4cG9ydCB7IFBsYW5lSGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL1BsYW5lSGVscGVyLmpzJztcbmV4cG9ydCB7IEFycm93SGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL0Fycm93SGVscGVyLmpzJztcbmV4cG9ydCB7IEF4ZXNIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvQXhlc0hlbHBlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2V4dHJhcy9jdXJ2ZXMvQ3VydmVzLmpzJztcbmV4cG9ydCB7IFNoYXBlIH0gZnJvbSAnLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5leHBvcnQgeyBQYXRoIH0gZnJvbSAnLi9leHRyYXMvY29yZS9QYXRoLmpzJztcbmV4cG9ydCB7IFNoYXBlUGF0aCB9IGZyb20gJy4vZXh0cmFzL2NvcmUvU2hhcGVQYXRoLmpzJztcbmV4cG9ydCB7IEN1cnZlUGF0aCB9IGZyb20gJy4vZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzJztcbmV4cG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9leHRyYXMvY29yZS9DdXJ2ZS5qcyc7XG5leHBvcnQgeyBDb250cm9scyB9IGZyb20gJy4vZXh0cmFzL0NvbnRyb2xzLmpzJztcbmV4cG9ydCB7IERhdGFVdGlscyB9IGZyb20gJy4vZXh0cmFzL0RhdGFVdGlscy5qcyc7XG5leHBvcnQgeyBJbWFnZVV0aWxzIH0gZnJvbSAnLi9leHRyYXMvSW1hZ2VVdGlscy5qcyc7XG5leHBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi9leHRyYXMvU2hhcGVVdGlscy5qcyc7XG5leHBvcnQgeyBUZXh0dXJlVXRpbHMgfSBmcm9tICcuL2V4dHJhcy9UZXh0dXJlVXRpbHMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ2FudmFzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9UaHJlZS5MZWdhY3kuanMnO1xuXG5pZiAoIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICkge1xuXG5cdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoICdyZWdpc3RlcicsIHsgZGV0YWlsOiB7XG5cdFx0cmV2aXNpb246IFJFVklTSU9OLFxuXHR9IH0gKSApO1xuXG59XG5cbmlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0aWYgKCB3aW5kb3cuX19USFJFRV9fICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogTXVsdGlwbGUgaW5zdGFuY2VzIG9mIFRocmVlLmpzIGJlaW5nIGltcG9ydGVkLicgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0d2luZG93Ll9fVEhSRUVfXyA9IFJFVklTSU9OO1xuXG5cdH1cblxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNBOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNBOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDQTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDQTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvSEE7O0FBRUE7OztBQUdBO0FBQ0s7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0s7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDLzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNsa0JBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVZOztBQUVMOztBQUVQOztBQUVBOztBQUVPOztBQUVQOztBQUVBOztBQzFMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbklBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakxBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDOWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ3g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDeHVDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbndCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdm9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenZDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzVHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3BoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTdCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbCtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwUEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzNNQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3gvQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMzNUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDck5BOztBQUVPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVLOztBQzVHTDs7QUNBQTs7QUNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDNUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaFpBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDNVJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM3aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0hBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FDck9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM1VEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDM0VBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3pEQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNyWUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN2V0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3JRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM1T0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOW1EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUNqVUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaElBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN2VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDakNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuVUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaktBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdjNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ2ptQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0s7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0s7O0FDdlJMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDeERBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQ25LQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQy9VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDdERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ2pMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDekZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDbHdCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzdYQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQ2x4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4NUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ2gxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN4SkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDekhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUN2WEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FDdk1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDM0lBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDM0hBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQ25IQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDcElBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDL1NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbkZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQzlIQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OyJ9
